(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("numeric"), require("numeral"), require("jStat"));
	else if(typeof define === 'function' && define.amd)
		define(["numeric", "numeral", "jStat"], factory);
	else if(typeof exports === 'object')
		exports["formulajs"] = factory(require("numeric"), require("numeral"), require("jStat"));
	else
		root["formulajs"] = factory(root["numeric"], root["numeral"], root["jStat"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var categories = [
	  __webpack_require__(1),
	  __webpack_require__(15),
	  __webpack_require__(12),
	  __webpack_require__(16),
	  __webpack_require__(2),
	  __webpack_require__(7),
	  __webpack_require__(14),
	  __webpack_require__(17),
	  __webpack_require__(11),
	  __webpack_require__(18),
	  __webpack_require__(6),
	  __webpack_require__(10)
	];

	for (var c in categories) {
	  var category = categories[c];
	  for (var f in category) {
	    exports[f] = exports[f] || category[f];
	  }
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var mathTrig = __webpack_require__(2);
	var statistical = __webpack_require__(6);
	var engineering = __webpack_require__(12);
	var dateTime = __webpack_require__(14);

	function set(fn, root) {
	  if (root) {
	    for (var i in root) {
	      fn[i] = root[i];
	    }
	  }
	  return fn;
	}

	exports.BETADIST = statistical.BETA.DIST;
	exports.BETAINV = statistical.BETA.INV;
	exports.BINOMDIST = statistical.BINOM.DIST;
	exports.CEILING = exports.ISOCEILING = set(mathTrig.CEILING.MATH, mathTrig.CEILING);
	exports.CEILINGMATH = mathTrig.CEILING.MATH;
	exports.CEILINGPRECISE = mathTrig.CEILING.PRECISE;
	exports.CHIDIST = statistical.CHISQ.DIST;
	exports.CHIDISTRT = statistical.CHISQ.DIST.RT;
	exports.CHIINV = statistical.CHISQ.INV;
	exports.CHIINVRT = statistical.CHISQ.INV.RT;
	exports.CHITEST = statistical.CHISQ.TEST;
	exports.CONFIDENCE = set(statistical.CONFIDENCE.NORM, statistical.CONFIDENCE);
	exports.COVAR = statistical.COVARIANCE.P;
	exports.COVARIANCEP = statistical.COVARIANCE.P;
	exports.COVARIANCES = statistical.COVARIANCE.S;
	exports.CRITBINOM = statistical.BINOM.INV;
	exports.EXPONDIST = statistical.EXPON.DIST;
	exports.ERFCPRECISE = engineering.ERFC.PRECISE;
	exports.ERFPRECISE = engineering.ERF.PRECISE;
	exports.FDIST = statistical.F.DIST;
	exports.FDISTRT = statistical.F.DIST.RT;
	exports.FINVRT = statistical.F.INV.RT;
	exports.FINV = statistical.F.INV;
	exports.FLOOR = set(mathTrig.FLOOR.MATH, mathTrig.FLOOR);
	exports.FLOORMATH = mathTrig.FLOOR.MATH;
	exports.FLOORPRECISE = mathTrig.FLOOR.PRECISE;
	exports.FTEST = statistical.F.TEST;
	exports.GAMMADIST = statistical.GAMMA.DIST;
	exports.GAMMAINV = statistical.GAMMA.INV;
	exports.GAMMALNPRECISE = statistical.GAMMALN.PRECISE;
	exports.HYPGEOMDIST = statistical.HYPGEOM.DIST;
	exports.LOGINV = statistical.LOGNORM.INV;
	exports.LOGNORMINV = statistical.LOGNORM.INV;
	exports.LOGNORMDIST = statistical.LOGNORM.DIST;
	exports.MODE = set(statistical.MODE.SNGL, statistical.MODE);
	exports.MODEMULT = statistical.MODE.MULT;
	exports.MODESNGL = statistical.MODE.SNGL;
	exports.NEGBINOMDIST = statistical.NEGBINOM.DIST;
	exports.NETWORKDAYSINTL = dateTime.NETWORKDAYS.INTL;
	exports.NORMDIST = statistical.NORM.DIST;
	exports.NORMINV = statistical.NORM.INV;
	exports.NORMSDIST = statistical.NORM.S.DIST;
	exports.NORMSINV = statistical.NORM.S.INV;
	exports.PERCENTILE = set(statistical.PERCENTILE.EXC, statistical.PERCENTILE);
	exports.PERCENTILEEXC = statistical.PERCENTILE.EXC;
	exports.PERCENTILEINC = statistical.PERCENTILE.INC;
	exports.PERCENTRANK = set(statistical.PERCENTRANK.INC, statistical.PERCENTRANK);
	exports.PERCENTRANKEXC = statistical.PERCENTRANK.EXC;
	exports.PERCENTRANKINC = statistical.PERCENTRANK.INC;
	exports.POISSON = set(statistical.POISSON.DIST, statistical.POISSON);
	exports.POISSONDIST = statistical.POISSON.DIST;
	exports.QUARTILE = set(statistical.QUARTILE.INC, statistical.QUARTILE);
	exports.QUARTILEEXC = statistical.QUARTILE.EXC;
	exports.QUARTILEINC = statistical.QUARTILE.INC;
	exports.RANK = set(statistical.RANK.EQ, statistical.RANK);
	exports.RANKAVG = statistical.RANK.AVG;
	exports.RANKEQ = statistical.RANK.EQ;
	exports.SKEWP = statistical.SKEW.P;
	exports.STDEV = set(statistical.STDEV.S, statistical.STDEV);
	exports.STDEVP = statistical.STDEV.P;
	exports.STDEVS = statistical.STDEV.S;
	exports.TDIST = statistical.T.DIST;
	exports.TDISTRT = statistical.T.DIST.RT;
	exports.TINV = statistical.T.INV;
	exports.TTEST = statistical.T.TEST;
	exports.VAR = set(statistical.VAR.S, statistical.VAR);
	exports.VARP = statistical.VAR.P;
	exports.VARS = statistical.VAR.S;
	exports.WEIBULL = set(statistical.WEIBULL.DIST, statistical.WEIBULL);
	exports.WEIBULLDIST = statistical.WEIBULL.DIST;
	exports.WORKDAYINTL = dateTime.WORKDAY.INTL;
	exports.ZTEST = statistical.Z.TEST;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var numeric = __webpack_require__(3);
	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var statistical = __webpack_require__(6);
	var information = __webpack_require__(11);

	exports.ABS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.abs(utils.parseNumber(number));
	};

	exports.ACOS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.acos(number);
	};

	exports.ACOSH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number + Math.sqrt(number * number - 1));
	};

	exports.ACOT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.atan(1 / number);
	};

	exports.ACOTH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 0.5 * Math.log((number + 1) / (number - 1));
	};

	//TODO: use options
	exports.AGGREGATE = function(function_num, options, ref1, ref2) {
	  function_num = utils.parseNumber(function_num);
	  options = utils.parseNumber(function_num);
	  if (utils.anyIsError(function_num, options)) {
	    return error.value;
	  }
	  switch (function_num) {
	    case 1:
	      return statistical.AVERAGE(ref1);
	    case 2:
	      return statistical.COUNT(ref1);
	    case 3:
	      return statistical.COUNTA(ref1);
	    case 4:
	      return statistical.MAX(ref1);
	    case 5:
	      return statistical.MIN(ref1);
	    case 6:
	      return exports.PRODUCT(ref1);
	    case 7:
	      return statistical.STDEV.S(ref1);
	    case 8:
	      return statistical.STDEV.P(ref1);
	    case 9:
	      return exports.SUM(ref1);
	    case 10:
	      return statistical.VAR.S(ref1);
	    case 11:
	      return statistical.VAR.P(ref1);
	    case 12:
	      return statistical.MEDIAN(ref1);
	    case 13:
	      return statistical.MODE.SNGL(ref1);
	    case 14:
	      return statistical.LARGE(ref1, ref2);
	    case 15:
	      return statistical.SMALL(ref1, ref2);
	    case 16:
	      return statistical.PERCENTILE.INC(ref1, ref2);
	    case 17:
	      return statistical.QUARTILE.INC(ref1, ref2);
	    case 18:
	      return statistical.PERCENTILE.EXC(ref1, ref2);
	    case 19:
	      return statistical.QUARTILE.EXC(ref1, ref2);
	  }
	};

	exports.ARABIC = function(text) {
	  // Credits: Rafa? Kukawski
	  if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {
	    return error.value;
	  }
	  var r = 0;
	  text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i) {
	    r += {
	      M: 1000,
	      CM: 900,
	      D: 500,
	      CD: 400,
	      C: 100,
	      XC: 90,
	      L: 50,
	      XL: 40,
	      X: 10,
	      IX: 9,
	      V: 5,
	      IV: 4,
	      I: 1
	    }[i];
	  });
	  return r;
	};

	exports.ASIN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.asin(number);
	};

	exports.ASINH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number + Math.sqrt(number * number + 1));
	};

	exports.ATAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.atan(number);
	};

	exports.ATAN2 = function(number_x, number_y) {
	  number_x = utils.parseNumber(number_x);
	  number_y = utils.parseNumber(number_y);
	  if (utils.anyIsError(number_x, number_y)) {
	    return error.value;
	  }
	  return Math.atan2(number_x, number_y);
	};

	exports.ATANH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log((1 + number) / (1 - number)) / 2;
	};

	exports.BASE = function(number, radix, min_length) {
	  min_length = min_length || 0;

	  number = utils.parseNumber(number);
	  radix = utils.parseNumber(radix);
	  min_length = utils.parseNumber(min_length);
	  if (utils.anyIsError(number, radix, min_length)) {
	    return error.value;
	  }
	  min_length = (min_length === undefined) ? 0 : min_length;
	  var result = number.toString(radix);
	  return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result;
	};

	exports.CEILING = function(number, significance, mode) {
	  significance = (significance === undefined) ? 1 : Math.abs(significance);
	  mode = mode || 0;

	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  mode = utils.parseNumber(mode);
	  if (utils.anyIsError(number, significance, mode)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.ceil(number / significance) * significance, precision);
	  } else {
	    if (mode === 0) {
	      return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
	    } else {
	      return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
	    }
	  }
	};

	exports.CEILING.MATH = exports.CEILING;

	exports.CEILING.PRECISE = exports.CEILING;

	exports.COMBIN = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return exports.FACT(number) / (exports.FACT(number_chosen) * exports.FACT(number - number_chosen));
	};

	exports.COMBINA = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return (number === 0 && number_chosen === 0) ? 1 : exports.COMBIN(number + number_chosen - 1, number - 1);
	};

	exports.COS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.cos(number);
	};

	exports.COSH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return (Math.exp(number) + Math.exp(-number)) / 2;
	};

	exports.COT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.tan(number);
	};

	exports.COTH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var e2 = Math.exp(2 * number);
	  return (e2 + 1) / (e2 - 1);
	};

	exports.CSC = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.sin(number);
	};

	exports.CSCH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 2 / (Math.exp(number) - Math.exp(-number));
	};

	exports.DECIMAL = function(number, radix) {
	  if (arguments.length < 1) {
	    return error.value;
	  }


	  return parseInt(number, radix);
	};

	exports.DEGREES = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return number * 180 / Math.PI;
	};

	exports.EVEN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return exports.CEILING(number, -2, -1);
	};

	exports.EXP = Math.exp;

	var MEMOIZED_FACT = [];
	exports.FACT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var n = Math.floor(number);
	  if (n === 0 || n === 1) {
	    return 1;
	  } else if (MEMOIZED_FACT[n] > 0) {
	    return MEMOIZED_FACT[n];
	  } else {
	    MEMOIZED_FACT[n] = exports.FACT(n - 1) * n;
	    return MEMOIZED_FACT[n];
	  }
	};

	exports.FACTDOUBLE = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var n = Math.floor(number);
	  if (n <= 0) {
	    return 1;
	  } else {
	    return n * exports.FACTDOUBLE(n - 2);
	  }
	};

	exports.FLOOR = function(number, significance) {
	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(number, significance)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }

	  if (!(number > 0 && significance > 0) && !(number < 0 && significance < 0)) {
	    return error.num;
	  }

	  significance = Math.abs(significance);
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.floor(number / significance) * significance, precision);
	  } else {
	    return -exports.ROUND(Math.ceil(Math.abs(number) / significance), precision);
	  }
	};

	//TODO: Verify
	exports.FLOOR.MATH = function(number, significance, mode) {
	  significance = (significance === undefined) ? 1 : significance;
	  mode = (mode === undefined) ? 0 : mode;

	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  mode = utils.parseNumber(mode);
	  if (utils.anyIsError(number, significance, mode)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }

	  significance = significance ? Math.abs(significance) : 1;
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.floor(number / significance) * significance, precision);
	  } else if (mode === 0 || mode === undefined) {
	    return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
	  }
	  return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
	};

	// Deprecated
	exports.FLOOR.PRECISE = exports.FLOOR.MATH;

	// adapted http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
	exports.GCD = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var r0 = range[0];
	  var x = r0 < 0 ? -r0 : r0;
	  for (var i = 1; i < n; i++) {
	    var ri = range[i];
	    var y = ri < 0 ? -ri : ri;
	    while (x && y) {
	      if (x > y) {
	        x %= y;
	      } else {
	        y %= x;
	      }
	    }
	    x += y;
	  }
	  return x;
	};


	exports.INT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.floor(number);
	};

	//TODO: verify
	exports.ISO = {
	  CEILING: exports.CEILING
	};

	exports.LCM = function() {
	  // Credits: Jonas Raoni Soares Silva
	  var o = utils.parseNumberArray(utils.flatten(arguments));
	  if (o instanceof Error) {
	    return o;
	  }
	  for (var i, j, n, d, r = 1;
	    (n = o.pop()) !== undefined;) {
	    while (n > 1) {
	      if (n % 2) {
	        for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
	          //empty
	        }
	        d = (i <= j) ? i : n;
	      } else {
	        d = 2;
	      }
	      for (n /= d, r *= d, i = o.length; i;
	        (o[--i] % d) === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {
	        //empty
	      }
	    }
	  }
	  return r;
	};

	exports.LN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number);
	};

	exports.LOG = function(number, base) {
	  number = utils.parseNumber(number);
	  base = utils.parseNumber(base);
	  if (utils.anyIsError(number, base)) {
	    return error.value;
	  }
	  base = (base === undefined) ? 10 : base;
	  return Math.log(number) / Math.log(base);
	};

	exports.LOG10 = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number) / Math.log(10);
	};

	exports.MDETERM = function(matrix) {
	  matrix = utils.parseMatrix(matrix);
	  if (matrix instanceof Error) {
	    return matrix;
	  }
	  return numeric.det(matrix);
	};

	exports.MINVERSE = function(matrix) {
	  matrix = utils.parseMatrix(matrix);
	  if (matrix instanceof Error) {
	    return matrix;
	  }
	  return numeric.inv(matrix);
	};

	exports.MMULT = function(matrix1, matrix2) {
	  matrix1 = utils.parseMatrix(matrix1);
	  matrix2 = utils.parseMatrix(matrix2);
	  if (utils.anyIsError(matrix1, matrix2)) {
	    return error.value;
	  }
	  return numeric.dot(matrix1, matrix2);
	};

	exports.MOD = function(dividend, divisor) {
	  dividend = utils.parseNumber(dividend);
	  divisor = utils.parseNumber(divisor);
	  if (utils.anyIsError(dividend, divisor)) {
	    return error.value;
	  }
	  if (divisor === 0) {
	    return error.div0;
	  }
	  var modulus = Math.abs(dividend % divisor);
	  return (divisor > 0) ? modulus : -modulus;
	};

	  exports.MROUND = function(number, multiple) {
	  number = utils.parseNumber(number);
	  multiple = utils.parseNumber(multiple);
	  if (utils.anyIsError(number, multiple)) {
	    return error.value;
	  }
	  if (number * multiple < 0) {
	    return error.num;
	  }

	  return Math.round(number / multiple) * multiple;
	};

	exports.MULTINOMIAL = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  var sum = 0;
	  var divisor = 1;
	  for (var i = 0; i < args.length; i++) {
	    sum += args[i];
	    divisor *= exports.FACT(args[i]);
	  }
	  return exports.FACT(sum) / divisor;
	};

	exports.MUNIT = function(dimension) {
	  dimension = utils.parseNumber(dimension);
	  if (dimension instanceof Error) {
	    return dimension;
	  }
	  return numeric.identity(dimension);
	};

	exports.ODD = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var temp = Math.ceil(Math.abs(number));
	  temp = (temp & 1) ? temp : temp + 1;
	  return (number > 0) ? temp : -temp;
	};

	exports.PI = function() {
	  return Math.PI;
	};

	exports.POWER = function(number, power) {
	  number = utils.parseNumber(number);
	  power = utils.parseNumber(power);
	  if (utils.anyIsError(number, power)) {
	    return error.value;
	  }
	  var result = Math.pow(number, power);
	  if (isNaN(result)) {
	    return error.num;
	  }

	  return result;
	};

	exports.PRODUCT = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  var result = 1;
	  for (var i = 0; i < args.length; i++) {
	    result *= args[i];
	  }
	  return result;
	};

	exports.QUOTIENT = function(numerator, denominator) {
	  numerator = utils.parseNumber(numerator);
	  denominator = utils.parseNumber(denominator);
	  if (utils.anyIsError(numerator, denominator)) {
	    return error.value;
	  }
	  return parseInt(numerator / denominator, 10);
	};

	exports.RADIANS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return number * Math.PI / 180;
	};

	exports.RAND = function() {
	  return Math.random();
	};

	exports.RANDBETWEEN = function(bottom, top) {
	  bottom = utils.parseNumber(bottom);
	  top = utils.parseNumber(top);
	  if (utils.anyIsError(bottom, top)) {
	    return error.value;
	  }
	  // Creative Commons Attribution 3.0 License
	  // Copyright (c) 2012 eqcode
	  return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
	};

	// TODO
	exports.ROMAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  // The MIT License
	  // Copyright (c) 2008 Steven Levithan
	  var digits = String(number).split('');
	  var key = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
	  var roman = '';
	  var i = 3;
	  while (i--) {
	    roman = (key[+digits.pop() + (i * 10)] || '') + roman;
	  }
	  return new Array(+digits.join('') + 1).join('M') + roman;
	};

	exports.ROUND = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
	};

	exports.ROUNDDOWN = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

	exports.ROUNDUP = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.ceil(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

	exports.SEC = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.cos(number);
	};

	exports.SECH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 2 / (Math.exp(number) + Math.exp(-number));
	};

	exports.SERIESSUM = function(x, n, m, coefficients) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  m = utils.parseNumber(m);
	  coefficients = utils.parseNumberArray(coefficients);
	  if (utils.anyIsError(x, n, m, coefficients)) {
	    return error.value;
	  }
	  var result = coefficients[0] * Math.pow(x, n);
	  for (var i = 1; i < coefficients.length; i++) {
	    result += coefficients[i] * Math.pow(x, n + i * m);
	  }
	  return result;
	};

	exports.SIGN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  if (number < 0) {
	    return -1;
	  } else if (number === 0) {
	    return 0;
	  } else {
	    return 1;
	  }
	};

	exports.SIN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.sin(number);
	};

	  exports.SINH = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    return (Math.exp(number) - Math.exp(-number)) / 2;
	  };

	  exports.SQRT = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    if (number < 0) {
	      return error.num;
	    }
	    return Math.sqrt(number);
	  };

	  exports.SQRTPI = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    return Math.sqrt(number * Math.PI);
	  };

	exports.SUBTOTAL = function(function_code, ref1) {
	  function_code = utils.parseNumber(function_code);
	  if (function_code instanceof Error) {
	    return function_code;
	  }
	  switch (function_code) {
	    case 1:
	      return statistical.AVERAGE(ref1);
	    case 2:
	      return statistical.COUNT(ref1);
	    case 3:
	      return statistical.COUNTA(ref1);
	    case 4:
	      return statistical.MAX(ref1);
	    case 5:
	      return statistical.MIN(ref1);
	    case 6:
	      return exports.PRODUCT(ref1);
	    case 7:
	      return statistical.STDEV.S(ref1);
	    case 8:
	      return statistical.STDEV.P(ref1);
	    case 9:
	      return exports.SUM(ref1);
	    case 10:
	      return statistical.VAR.S(ref1);
	    case 11:
	      return statistical.VAR.P(ref1);
	      // no hidden values for us
	    case 101:
	      return statistical.AVERAGE(ref1);
	    case 102:
	      return statistical.COUNT(ref1);
	    case 103:
	      return statistical.COUNTA(ref1);
	    case 104:
	      return statistical.MAX(ref1);
	    case 105:
	      return statistical.MIN(ref1);
	    case 106:
	      return exports.PRODUCT(ref1);
	    case 107:
	      return statistical.STDEV.S(ref1);
	    case 108:
	      return statistical.STDEV.P(ref1);
	    case 109:
	      return exports.SUM(ref1);
	    case 110:
	      return statistical.VAR.S(ref1);
	    case 111:
	      return statistical.VAR.P(ref1);

	  }
	};

	exports.ADD = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.value;
	  }

	  return num1 + num2;
	};

	exports.MINUS = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.value;
	  }

	  return num1 - num2;
	};

	exports.DIVIDE = function (dividend, divisor) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  dividend = utils.parseNumber(dividend);
	  divisor = utils.parseNumber(divisor);
	  if (utils.anyIsError(dividend, divisor)) {
	    return error.value;
	  }

	  if (divisor === 0) {
	    return error.div0;
	  }

	  return dividend / divisor;
	};

	exports.MULTIPLY = function (factor1, factor2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  factor1 = utils.parseNumber(factor1);
	  factor2 = utils.parseNumber(factor2);
	  if (utils.anyIsError(factor1, factor2)) {
	    return error.value;
	  }

	  return factor1 * factor2;
	};

	exports.GTE = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 >= num2;
	};

	exports.LT = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 < num2;
	};


	exports.LTE = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 <= num2;
	};

	exports.EQ = function (value1, value2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  return value1 === value2;
	};

	exports.NE = function (value1, value2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  return value1 !== value2;
	};

	exports.POW = function (base, exponent) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  base = utils.parseNumber(base);
	  exponent = utils.parseNumber(exponent);
	  if (utils.anyIsError(base, exponent)) {
	    return error.error;
	  }

	  return exports.POWER(base, exponent);
	};

	exports.SUM = function() {
	  var result = 0;
	  var argsKeys = Object.keys(arguments);
	  for (var i = 0; i < argsKeys.length; ++i) {
	    var elt = arguments[argsKeys[i]];
	    if (typeof elt === 'number') {
	      result += elt;
	    } else if (typeof elt === 'string') {
	      var parsed = parseFloat(elt);
	      !isNaN(parsed) && (result += parsed);
	    } else if (Array.isArray(elt)) {
	      result += exports.SUM.apply(null, elt);
	    }
	  }
	  return result;
	};

	exports.SUMIF = function(range, criteria) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (range instanceof Error) {
	    return range;
	  }
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    result += (eval(range[i] + criteria)) ? range[i] : 0; // jshint ignore:line
	  }
	  return result;
	};

	exports.SUMIFS = function() {
	  var args = utils.argsToArray(arguments);
	  var range = utils.parseNumberArray(utils.flatten(args.shift()));
	  if (range instanceof Error) {
	    return range;
	  }
	  var criteria = args;

	  var n_range_elements = range.length;
	  var n_criterias = criteria.length;

	  var result = 0;
	  for (var i = 0; i < n_range_elements; i++) {
	    var el = range[i];
	    var condition = '';
	    for (var c = 0; c < n_criterias; c++) {
	      condition += el + criteria[c];
	      if (c !== n_criterias - 1) {
	        condition += '&&';
	      }
	    }
	    if (eval(condition)) { // jshint ignore:line
	      result += el;
	    }
	  }
	  return result;
	};

	exports.SUMPRODUCT = function() {
	  if (!arguments || arguments.length === 0) {
	    return error.value;
	  }
	  var arrays = arguments.length + 1;
	  var result = 0;
	  var product;
	  var k;
	  var _i;
	  var _ij;
	  for (var i = 0; i < arguments[0].length; i++) {
	    if (!(arguments[0][i] instanceof Array)) {
	      product = 1;
	      for (k = 1; k < arrays; k++) {
	        _i = utils.parseNumber(arguments[k - 1][i]);
	        if (_i instanceof Error) {
	          return _i;
	        }
	        product *= _i;
	      }
	      result += product;
	    } else {
	      for (var j = 0; j < arguments[0][i].length; j++) {
	        product = 1;
	        for (k = 1; k < arrays; k++) {
	          _ij = utils.parseNumber(arguments[k - 1][i][j]);
	          if (_ij instanceof Error) {
	            return _ij;
	          }
	          product *= _ij;
	        }
	        result += product;
	      }
	    }
	  }
	  return result;
	};

	exports.SUMSQ = function() {
	  var numbers = utils.parseNumberArray(utils.flatten(arguments));
	  if (numbers instanceof Error) {
	    return numbers;
	  }
	  var result = 0;
	  var length = numbers.length;
	  for (var i = 0; i < length; i++) {
	    result += (information.ISNUMBER(numbers[i])) ? numbers[i] * numbers[i] : 0;
	  }
	  return result;
	};

	exports.SUMX2MY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  for (var i = 0; i < array_x.length; i++) {
	    result += array_x[i] * array_x[i] - array_y[i] * array_y[i];
	  }
	  return result;
	};

	exports.SUMX2PY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  for (var i = 0; i < array_x.length; i++) {
	    result += array_x[i] * array_x[i] + array_y[i] * array_y[i];
	  }
	  return result;
	};

	exports.SUMXMY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  array_x = utils.flatten(array_x);
	  array_y = utils.flatten(array_y);
	  for (var i = 0; i < array_x.length; i++) {
	    result += Math.pow(array_x[i] - array_y[i], 2);
	  }
	  return result;
	};

	exports.TAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.tan(number);
	};

	exports.TANH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var e2 = Math.exp(2 * number);
	  return (e2 - 1) / (e2 + 1);
	};

	exports.TRUNC = function(number, digits) {
	  digits = (digits === undefined) ? 0 : digits;
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	function flattenShallow(array) {
	  if (!array || !array.reduce) { return array; }
	  return array.reduce(function(a, b) {
	    var aIsArray = Array.isArray(a);
	    var bIsArray = Array.isArray(b);
	    if (aIsArray && bIsArray ) {
	      return a.concat(b);
	    }
	    if (aIsArray) {
	      a.push(b);
	      return a;
	    }
	    if (bIsArray) {
	      return [a].concat(b);
	    }
	    return [a, b];
	  });
	}

	function isFlat(array) {
	  if (!array) { return false; }
	  for (var i = 0; i < array.length; ++i) {
	    if (Array.isArray(array[i])) {
	      return false;
	    }
	  }
	  return true;
	}

	exports.flatten = function() {
	  var result = exports.argsToArray.apply(null, arguments);
	  while (!isFlat(result)) {
	    result = flattenShallow(result);
	  }
	  return result;
	};

	exports.argsToArray = function(args) {
	  return Array.prototype.slice.call(args, 0);
	};

	exports.numbers = function() {
	  var possibleNumbers = this.flatten.apply(null, arguments);
	  return possibleNumbers.filter(function(el) {
	    return typeof el === 'number';
	  });
	};

	exports.cleanFloat = function(number) {
	  var power = 1e14;
	  return Math.round(number * power) / power;
	};

	exports.parseBool = function(bool) {
	  if (typeof bool === 'boolean') {
	    return bool;
	  }

	  if (bool instanceof Error) {
	    return bool;
	  }

	  if (typeof bool === 'number') {
	    return bool !== 0;
	  }

	  if (typeof bool === 'string') {
	    var up = bool.toUpperCase();
	    if (up === 'TRUE') {
	      return true;
	    }

	    if (up === 'FALSE') {
	      return false;
	    }
	  }

	  if (bool instanceof Date && !isNaN(bool)) {
	    return true;
	  }

	  return error.value;
	};

	exports.parseNumber = function(string) {
	  if (string === undefined || string === '') {
	    return error.value;
	  }
	  if (!isNaN(string)) {
	    return parseFloat(string);
	  }
	  return error.value;
	};

	exports.parseNumberArray = function(arr) {
	  var len;
	  if (!arr || (len = arr.length) === 0) {
	    return error.value;
	  }
	  var parsed;
	  while (len--) {
	    parsed = exports.parseNumber(arr[len]);
	    if (parsed === error.value) {
	      return parsed;
	    }
	    arr[len] = parsed;
	  }
	  return arr;
	};

	exports.parseMatrix = function(matrix) {
	  var n;
	  if (!matrix || (n = matrix.length) === 0) {
	    return error.value;
	  }
	  var pnarr;
	  for (var i = 0; i < matrix.length; i++) {
	    pnarr = exports.parseNumberArray(matrix[i]);
	    matrix[i] = pnarr;
	    if (pnarr instanceof Error) {
	      return pnarr;
	    }
	  }
	  return matrix;
	};

	var d1900 = new Date(1900, 0, 1);
	exports.parseDate = function(date) {
	  if (!isNaN(date)) {
	    if (date instanceof Date) {
	      return new Date(date);
	    }
	    var d = parseInt(date, 10);
	    if (d < 0) {
	      return error.num;
	    }
	    if (d <= 60) {
	      return new Date(d1900.getTime() + (d - 1) * 86400000);
	    }
	    return new Date(d1900.getTime() + (d - 2) * 86400000);
	  }
	  if (typeof date === 'string') {
	    date = new Date(date);
	    if (!isNaN(date)) {
	      return date;
	    }
	  }
	  return error.value;
	};

	exports.parseDateArray = function(arr) {
	  var len = arr.length;
	  var parsed;
	  while (len--) {
	    parsed = this.parseDate(arr[len]);
	    if (parsed === error.value) {
	      return parsed;
	    }
	    arr[len] = parsed;
	  }
	  return arr;
	};

	exports.anyIsError = function() {
	  var n = arguments.length;
	  while (n--) {
	    if (arguments[n] instanceof Error) {
	      return true;
	    }
	  }
	  return false;
	};

	exports.arrayValuesToNumbers = function(arr) {
	  var n = arr.length;
	  var el;
	  while (n--) {
	    el = arr[n];
	    if (typeof el === 'number') {
	      continue;
	    }
	    if (el === true) {
	      arr[n] = 1;
	      continue;
	    }
	    if (el === false) {
	      arr[n] = 0;
	      continue;
	    }
	    if (typeof el === 'string') {
	      var number = this.parseNumber(el);
	      if (number instanceof Error) {
	        arr[n] = 0;
	      } else {
	        arr[n] = number;
	      }
	    }
	  }
	  return arr;
	};

	exports.rest = function(array, idx) {
	  idx = idx || 1;
	  if (!array || typeof array.slice !== 'function') {
	    return array;
	  }
	  return array.slice(idx);
	};

	exports.initial = function(array, idx) {
	  idx = idx || 1;
	  if (!array || typeof array.slice !== 'function') {
	    return array;
	  }
	  return array.slice(0, array.length - idx);
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	exports.nil = new Error('#NULL!');
	exports.div0 = new Error('#DIV/0!');
	exports.value = new Error('#VALUE?');
	exports.ref = new Error('#REF!');
	exports.name = new Error('#NAME?');
	exports.num = new Error('#NUM!');
	exports.na = new Error('#N/A');
	exports.error = new Error('#ERROR!');
	exports.data = new Error('#GETTING_DATA');


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var mathTrig = __webpack_require__(2);
	var text = __webpack_require__(7);
	var jStat = __webpack_require__(9).jStat;
	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var misc = __webpack_require__(10);

	var SQRT2PI = 2.5066282746310002;

	exports.AVEDEV = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  return jStat.sum(jStat(range).subtract(jStat.mean(range)).abs()[0]) / range.length;
	};

	exports.AVERAGE = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sum = 0;
	  var count = 0;
	  for (var i = 0; i < n; i++) {
	    sum += range[i];
	    count += 1;
	  }
	  return sum / count;
	};

	exports.AVERAGEA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sum = 0;
	  var count = 0;
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sum += el;
	    }
	    if (el === true) {
	      sum++;
	    }
	    if (el !== null) {
	      count++;
	    }
	  }
	  return sum / count;
	};

	exports.AVERAGEIF = function(range, criteria, average_range) {
	  average_range = average_range || range;
	  range = utils.flatten(range);
	  average_range = utils.parseNumberArray(utils.flatten(average_range));
	  if (average_range instanceof Error) {
	    return average_range;
	  }
	  var average_count = 0;
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (eval(range[i] + criteria)) { // jshint ignore:line
	      result += average_range[i];
	      average_count++;
	    }
	  }
	  return result / average_count;
	};

	exports.AVERAGEIFS = function() {
	  // Does not work with multi dimensional ranges yet!
	  //http://office.microsoft.com/en-001/excel-help/averageifs-function-HA010047493.aspx
	  var args = utils.argsToArray(arguments);
	  var criteria = (args.length - 1) / 2;
	  var range = utils.flatten(args[0]);
	  var count = 0;
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    var condition = '';
	    for (var j = 0; j < criteria; j++) {
	      condition += args[2 * j + 1][i] + args[2 * j + 2];
	      if (j !== criteria - 1) {
	        condition += '&&';
	      }
	    }
	    if (eval(condition)) { // jshint ignore:line
	      result += range[i];
	      count++;
	    }
	  }

	  var average = result / count;
	  if (isNaN(average)) {
	    return 0;
	  } else {
	    return average;
	  }
	};

	exports.BETA = {};

	exports.BETA.DIST = function(x, alpha, beta, cumulative, A, B) {
	  if (arguments.length < 4) {
	    return error.value;
	  }

	  A = (A === undefined) ? 0 : A;
	  B = (B === undefined) ? 1 : B;

	  x = utils.parseNumber(x);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  A = utils.parseNumber(A);
	  B = utils.parseNumber(B);
	  if (utils.anyIsError(x, alpha, beta, A, B)) {
	    return error.value;
	  }

	  x = (x - A) / (B - A);
	  return (cumulative) ? jStat.beta.cdf(x, alpha, beta) : jStat.beta.pdf(x, alpha, beta);
	};

	exports.BETA.INV = function(probability, alpha, beta, A, B) {
	  A = (A === undefined) ? 0 : A;
	  B = (B === undefined) ? 1 : B;

	  probability = utils.parseNumber(probability);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  A = utils.parseNumber(A);
	  B = utils.parseNumber(B);
	  if (utils.anyIsError(probability, alpha, beta, A, B)) {
	    return error.value;
	  }

	  return jStat.beta.inv(probability, alpha, beta) * (B - A) + A;
	};

	exports.BINOM = {};

	exports.BINOM.DIST = function(successes, trials, probability, cumulative) {
	  successes = utils.parseNumber(successes);
	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  cumulative = utils.parseNumber(cumulative);
	  if (utils.anyIsError(successes, trials, probability, cumulative)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.binomial.cdf(successes, trials, probability) : jStat.binomial.pdf(successes, trials, probability);
	};

	exports.BINOM.DIST.RANGE = function(trials, probability, successes, successes2) {
	  successes2 = (successes2 === undefined) ? successes : successes2;

	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  successes = utils.parseNumber(successes);
	  successes2 = utils.parseNumber(successes2);
	  if (utils.anyIsError(trials, probability, successes, successes2)) {
	    return error.value;
	  }

	  var result = 0;
	  for (var i = successes; i <= successes2; i++) {
	    result += mathTrig.COMBIN(trials, i) * Math.pow(probability, i) * Math.pow(1 - probability, trials - i);
	  }
	  return result;
	};

	exports.BINOM.INV = function(trials, probability, alpha) {
	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  alpha = utils.parseNumber(alpha);
	  if (utils.anyIsError(trials, probability, alpha)) {
	    return error.value;
	  }

	  var x = 0;
	  while (x <= trials) {
	    if (jStat.binomial.cdf(x, trials, probability) >= alpha) {
	      return x;
	    }
	    x++;
	  }
	};

	exports.CHISQ = {};

	exports.CHISQ.DIST = function(x, k, cumulative) {
	  x = utils.parseNumber(x);
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(x, k)) {
	    return error.value;
	  }

	  return (cumulative) ? jStat.chisquare.cdf(x, k) : jStat.chisquare.pdf(x, k);
	};

	exports.CHISQ.DIST.RT = function(x, k) {
	  if (!x | !k) {
	    return error.na;
	  }

	  if (x < 1 || k > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof k !== 'number')) {
	    return error.value;
	  }

	  return 1 -  jStat.chisquare.cdf(x, k);
	};

	exports.CHISQ.INV = function(probability, k) {
	  probability = utils.parseNumber(probability);
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(probability, k)) {
	    return error.value;
	  }
	  return jStat.chisquare.inv(probability, k);
	};

	exports.CHISQ.INV.RT = function(p, k) {
	  if (!p | !k) {
	    return error.na;
	  }

	  if (p < 0 || p > 1 || k < 1 || k > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof p !== 'number') || (typeof k !== 'number')) {
	    return error.value;
	  }

	  return jStat.chisquare.inv(1.0 - p, k);
	};

	exports.CHISQ.TEST = function(observed, expected) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if ((!(observed instanceof Array)) || (!(expected instanceof Array))) {
	    return error.value;
	  }

	  if (observed.length !== expected.length) {
	    return error.value;
	  }

	  if (observed[0] && expected[0] &&
	      observed[0].length !== expected[0].length) {
	    return error.value;
	  }

	  var row = observed.length;
	  var tmp, i, j;

	  // Convert single-dimension array into two-dimension array
	  for (i = 0; i < row; i ++) {
	    if (!(observed[i] instanceof Array)) {
	      tmp = observed[i];
	      observed[i] = [];
	      observed[i].push(tmp);
	    }
	    if (!(expected[i] instanceof Array)) {
	      tmp = expected[i];
	      expected[i] = [];
	      expected[i].push(tmp);
	    }
	  }

	  var col = observed[0].length;
	  var dof = (col === 1) ? row-1 : (row-1)*(col-1);
	  var xsqr = 0;
	  var Pi =Math.PI;

	  for (i = 0; i < row; i ++) {
	    for (j = 0; j < col; j ++) {
	      xsqr += Math.pow((observed[i][j] - expected[i][j]), 2) / expected[i][j];
	    }
	  }

	  // Get independency by X square and its degree of freedom
	  function ChiSq(xsqr, dof) {
	    var p = Math.exp(-0.5 * xsqr);
	    if((dof%2) === 1) {
	      p = p * Math.sqrt(2 * xsqr/Pi);
	    }
	    var k = dof;
	    while(k >= 2) {
	      p = p * xsqr/k;
	      k = k - 2;
	    }
	    var t = p;
	    var a = dof;
	    while (t > 0.0000000001*p) {
	      a = a + 2;
	      t = t * xsqr/a;
	      p = p + t;
	    }
	    return 1-p;
	  }

	  return Math.round(ChiSq(xsqr, dof) * 1000000) / 1000000;
	};

	exports.COLUMN = function(matrix, index) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (index < 0) {
	    return error.num;
	  }

	  if (!(matrix instanceof Array) || (typeof index !== 'number')) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return undefined;
	  }

	  return jStat.col(matrix, index);
	};

	exports.COLUMNS = function(matrix) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (!(matrix instanceof Array)) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return 0;
	  }

	  return jStat.cols(matrix);
	};

	exports.CONFIDENCE = {};

	exports.CONFIDENCE.NORM = function(alpha, sd, n) {
	  alpha = utils.parseNumber(alpha);
	  sd = utils.parseNumber(sd);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(alpha, sd, n)) {
	    return error.value;
	  }
	  return jStat.normalci(1, alpha, sd, n)[1] - 1;
	};

	exports.CONFIDENCE.T = function(alpha, sd, n) {
	  alpha = utils.parseNumber(alpha);
	  sd = utils.parseNumber(sd);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(alpha, sd, n)) {
	    return error.value;
	  }
	  return jStat.tci(1, alpha, sd, n)[1] - 1;
	};

	exports.CORREL = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  return jStat.corrcoeff(array1, array2);
	};

	exports.COUNT = function() {
	  return utils.numbers(utils.flatten(arguments)).length;
	};

	exports.COUNTA = function() {
	  var range = utils.flatten(arguments);
	  return range.length - exports.COUNTBLANK(range);
	};

	exports.COUNTIN = function (range, value) {
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (range[i] === value) {
	      result++;
	    }
	  }
	  return result;
	};


	exports.COUNTBLANK = function() {
	  var range = utils.flatten(arguments);
	  var blanks = 0;
	  var element;
	  for (var i = 0; i < range.length; i++) {
	    element = range[i];
	    if (element === null || element === '') {
	      blanks++;
	    }
	  }
	  return blanks;
	};

	exports.COUNTIF = function(range, criteria) {
	  range = utils.flatten(range);
	  if (!/[<>=!]/.test(criteria)) {
	    criteria = '=="' + criteria + '"';
	  }
	  var matches = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (typeof range[i] !== 'string') {
	      if (eval(range[i] + criteria)) { // jshint ignore:line
	        matches++;
	      }
	    } else {
	      if (eval('"' + range[i] + '"' + criteria)) { // jshint ignore:line
	        matches++;
	      }
	    }
	  }
	  return matches;
	};

	exports.COUNTIFS = function() {
	  var args = utils.argsToArray(arguments);
	  var results = new Array(utils.flatten(args[0]).length);
	  for (var i = 0; i < results.length; i++) {
	    results[i] = true;
	  }
	  for (i = 0; i < args.length; i += 2) {
	    var range = utils.flatten(args[i]);
	    var criteria = args[i + 1];
	    if (!/[<>=!]/.test(criteria)) {
	      criteria = '=="' + criteria + '"';
	    }
	    for (var j = 0; j < range.length; j++) {
	      if (typeof range[j] !== 'string') {
	        results[j] = results[j] && eval(range[j] + criteria); // jshint ignore:line
	      } else {
	        results[j] = results[j] && eval('"' + range[j] + '"' + criteria); // jshint ignore:line
	      }
	    }
	  }
	  var result = 0;
	  for (i = 0; i < results.length; i++) {
	    if (results[i]) {
	      result++;
	    }
	  }
	  return result;
	};

	exports.COUNTUNIQUE = function () {
	  return misc.UNIQUE.apply(null, utils.flatten(arguments)).length;
	};

	exports.COVARIANCE = {};

	exports.COVARIANCE.P = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  var mean1 = jStat.mean(array1);
	  var mean2 = jStat.mean(array2);
	  var result = 0;
	  var n = array1.length;
	  for (var i = 0; i < n; i++) {
	    result += (array1[i] - mean1) * (array2[i] - mean2);
	  }
	  return result / n;
	};

	exports.COVARIANCE.S = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  return jStat.covariance(array1, array2);
	};

	exports.DEVSQ = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    result += Math.pow((range[i] - mean), 2);
	  }
	  return result;
	};

	exports.EXPON = {};

	exports.EXPON.DIST = function(x, lambda, cumulative) {
	  x = utils.parseNumber(x);
	  lambda = utils.parseNumber(lambda);
	  if (utils.anyIsError(x, lambda)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.exponential.cdf(x, lambda) : jStat.exponential.pdf(x, lambda);
	};

	exports.F = {};

	exports.F.DIST = function(x, d1, d2, cumulative) {
	  x = utils.parseNumber(x);
	  d1 = utils.parseNumber(d1);
	  d2 = utils.parseNumber(d2);
	  if (utils.anyIsError(x, d1, d2)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.centralF.cdf(x, d1, d2) : jStat.centralF.pdf(x, d1, d2);
	};

	exports.F.DIST.RT = function(x, d1, d2) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (x < 0 || d1 < 1 || d2 < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {
	    return error.value;
	  }

	  return 1 - jStat.centralF.cdf(x, d1, d2);
	};

	exports.F.INV = function(probability, d1, d2) {
	  probability = utils.parseNumber(probability);
	  d1 = utils.parseNumber(d1);
	  d2 = utils.parseNumber(d2);
	  if (utils.anyIsError(probability, d1, d2)) {
	    return error.value;
	  }
	  if (probability <= 0.0 || probability > 1.0) {
	    return error.num;
	  }

	  return jStat.centralF.inv(probability, d1, d2);
	};

	exports.F.INV.RT = function(p, d1, d2) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (p < 0 || p > 1 || d1 < 1 || d1 > Math.pow(10, 10) || d2 < 1 || d2 > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof p !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {
	    return error.value;
	  }

	  return jStat.centralF.inv(1.0 - p, d1, d2);
	};

	exports.F.TEST = function(array1, array2) {
	  if (!array1 || !array2) {
	    return error.na;
	  }

	  if (!(array1 instanceof Array) || !(array2 instanceof Array)) {
	    return error.na;
	  }

	  if (array1.length < 2 || array2.length < 2) {
	    return error.div0;
	  }

	  var sumOfSquares = function(values, x1) {
	    var sum = 0;
	    for (var i = 0; i < values.length; i++) {
	      sum +=Math.pow((values[i] - x1), 2);
	    }
	    return sum;
	  };

	  var x1 = mathTrig.SUM(array1) / array1.length;
	  var x2 = mathTrig.SUM(array2) / array2.length;
	  var sum1 = sumOfSquares(array1, x1) / (array1.length - 1);
	  var sum2 = sumOfSquares(array2, x2) / (array2.length - 1);

	  return sum1 / sum2;
	};

	exports.FISHER = function(x) {
	  x = utils.parseNumber(x);
	  if (x instanceof Error) {
	    return x;
	  }
	  return Math.log((1 + x) / (1 - x)) / 2;
	};

	exports.FISHERINV = function(y) {
	  y = utils.parseNumber(y);
	  if (y instanceof Error) {
	    return y;
	  }
	  var e2y = Math.exp(2 * y);
	  return (e2y - 1) / (e2y + 1);
	};

	exports.FORECAST = function(x, data_y, data_x) {
	  x = utils.parseNumber(x);
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(x, data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  var b = num / den;
	  var a = ymean - b * xmean;
	  return a + b * x;
	};

	exports.FREQUENCY = function(data, bins) {
	  data = utils.parseNumberArray(utils.flatten(data));
	  bins = utils.parseNumberArray(utils.flatten(bins));
	  if (utils.anyIsError(data, bins)) {
	    return error.value;
	  }
	  var n = data.length;
	  var b = bins.length;
	  var r = [];
	  for (var i = 0; i <= b; i++) {
	    r[i] = 0;
	    for (var j = 0; j < n; j++) {
	      if (i === 0) {
	        if (data[j] <= bins[0]) {
	          r[0] += 1;
	        }
	      } else if (i < b) {
	        if (data[j] > bins[i - 1] && data[j] <= bins[i]) {
	          r[i] += 1;
	        }
	      } else if (i === b) {
	        if (data[j] > bins[b - 1]) {
	          r[b] += 1;
	        }
	      }
	    }
	  }
	  return r;
	};


	exports.GAMMA = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  if (number === 0) {
	    return error.num;
	  }

	  if (parseInt(number, 10) === number && number < 0) {
	    return error.num;
	  }

	  return jStat.gammafn(number);
	};

	exports.GAMMA.DIST = function(value, alpha, beta, cumulative) {
	  if (arguments.length !== 4) {
	    return error.na;
	  }

	  if (value < 0 || alpha <= 0 || beta <= 0) {
	    return error.value;
	  }

	  if ((typeof value !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {
	    return error.value;
	  }

	  return cumulative ? jStat.gamma.cdf(value, alpha, beta, true) : jStat.gamma.pdf(value, alpha, beta, false);
	};

	exports.GAMMA.INV = function(probability, alpha, beta) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {
	    return error.num;
	  }

	  if ((typeof probability !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {
	    return error.value;
	  }

	  return jStat.gamma.inv(probability, alpha, beta);
	};

	exports.GAMMALN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return jStat.gammaln(number);
	};

	exports.GAMMALN.PRECISE = function(x) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (x <= 0) {
	    return error.num;
	  }

	  if (typeof x !== 'number') {
	    return error.value;
	  }

	  return jStat.gammaln(x);
	};

	exports.GAUSS = function(z) {
	  z = utils.parseNumber(z);
	  if (z instanceof Error) {
	    return z;
	  }
	  return jStat.normal.cdf(z, 0, 1) - 0.5;
	};

	exports.GEOMEAN = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  return jStat.geomean(args);
	};

	exports.GROWTH = function(known_y, known_x, new_x, use_const) {
	  // Credits: Ilmari Karonen (http://stackoverflow.com/questions/14161990/how-to-implement-growth-function-in-javascript)

	  known_y = utils.parseNumberArray(known_y);
	  if (known_y instanceof Error) {
	    return known_y;
	  }

	  // Default values for optional parameters:
	  var i;
	  if (known_x === undefined) {
	    known_x = [];
	    for (i = 1; i <= known_y.length; i++) {
	      known_x.push(i);
	    }
	  }
	  if (new_x === undefined) {
	    new_x = [];
	    for (i = 1; i <= known_y.length; i++) {
	      new_x.push(i);
	    }
	  }

	  known_x = utils.parseNumberArray(known_x);
	  new_x = utils.parseNumberArray(new_x);
	  if (utils.anyIsError(known_x, new_x)) {
	    return error.value;
	  }


	  if (use_const === undefined) {
	    use_const = true;
	  }

	  // Calculate sums over the data:
	  var n = known_y.length;
	  var avg_x = 0;
	  var avg_y = 0;
	  var avg_xy = 0;
	  var avg_xx = 0;
	  for (i = 0; i < n; i++) {
	    var x = known_x[i];
	    var y = Math.log(known_y[i]);
	    avg_x += x;
	    avg_y += y;
	    avg_xy += x * y;
	    avg_xx += x * x;
	  }
	  avg_x /= n;
	  avg_y /= n;
	  avg_xy /= n;
	  avg_xx /= n;

	  // Compute linear regression coefficients:
	  var beta;
	  var alpha;
	  if (use_const) {
	    beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);
	    alpha = avg_y - beta * avg_x;
	  } else {
	    beta = avg_xy / avg_xx;
	    alpha = 0;
	  }

	  // Compute and return result array:
	  var new_y = [];
	  for (i = 0; i < new_x.length; i++) {
	    new_y.push(Math.exp(alpha + beta * new_x[i]));
	  }
	  return new_y;
	};

	exports.HARMEAN = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    den += 1 / range[i];
	  }
	  return n / den;
	};

	exports.HYPGEOM = {};

	exports.HYPGEOM.DIST = function(x, n, M, N, cumulative) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  M = utils.parseNumber(M);
	  N = utils.parseNumber(N);
	  if (utils.anyIsError(x, n, M, N)) {
	    return error.value;
	  }

	  function pdf(x, n, M, N) {
	    return mathTrig.COMBIN(M, x) * mathTrig.COMBIN(N - M, n - x) / mathTrig.COMBIN(N, n);
	  }

	  function cdf(x, n, M, N) {
	    var result = 0;
	    for (var i = 0; i <= x; i++) {
	      result += pdf(i, n, M, N);
	    }
	    return result;
	  }

	  return (cumulative) ? cdf(x, n, M, N) : pdf(x, n, M, N);
	};

	exports.INTERCEPT = function(known_y, known_x) {
	  known_y = utils.parseNumberArray(known_y);
	  known_x = utils.parseNumberArray(known_x);
	  if (utils.anyIsError(known_y, known_x)) {
	    return error.value;
	  }
	  if (known_y.length !== known_x.length) {
	    return error.na;
	  }
	  return exports.FORECAST(0, known_y, known_x);
	};

	exports.KURT = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var sigma = 0;
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 4);
	  }
	  sigma = sigma / Math.pow(jStat.stdev(range, true), 4);
	  return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sigma - 3 * (n - 1) * (n - 1) / ((n - 2) * (n - 3));
	};

	exports.LARGE = function(range, k) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(range, k)) {
	    return range;
	  }
	  return range.sort(function(a, b) {
	    return b - a;
	  })[k - 1];
	};

	exports.LINEST = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var ymean = jStat.mean(data_y);
	  var xmean = jStat.mean(data_x);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  var m = num / den;
	  var b = ymean - m * xmean;
	  return [m, b];
	};

	// According to Microsoft:
	// http://office.microsoft.com/en-us/starter-help/logest-function-HP010342665.aspx
	// LOGEST returns are based on the following linear model:
	// ln y = x1 ln m1 + ... + xn ln mn + ln b
	exports.LOGEST = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  for (var i = 0; i < data_y.length; i ++) {
	    data_y[i] = Math.log(data_y[i]);
	  }

	  var result = exports.LINEST(data_y, data_x);
	  result[0] = Math.round(Math.exp(result[0])*1000000)/1000000;
	  result[1] = Math.round(Math.exp(result[1])*1000000)/1000000;
	  return result;
	};

	exports.LOGNORM = {};

	exports.LOGNORM.DIST = function(x, mean, sd, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.lognormal.cdf(x, mean, sd) : jStat.lognormal.pdf(x, mean, sd);
	};

	exports.LOGNORM.INV = function(probability, mean, sd) {
	  probability = utils.parseNumber(probability);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(probability, mean, sd)) {
	    return error.value;
	  }
	  return jStat.lognormal.inv(probability, mean, sd);
	};

	exports.MAX = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.max.apply(Math, range);
	};

	exports.MAXA = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.max.apply(Math, range);
	};

	exports.MEDIAN = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return jStat.median(range);
	};

	exports.MIN = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.min.apply(Math, range);
	};

	exports.MINA = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.min.apply(Math, range);
	};

	exports.MODE = {};

	exports.MODE.MULT = function() {
	  // Credits: Roönaän
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var count = {};
	  var maxItems = [];
	  var max = 0;
	  var currentItem;

	  for (var i = 0; i < n; i++) {
	    currentItem = range[i];
	    count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;
	    if (count[currentItem] > max) {
	      max = count[currentItem];
	      maxItems = [];
	    }
	    if (count[currentItem] === max) {
	      maxItems[maxItems.length] = currentItem;
	    }
	  }
	  return maxItems;
	};

	exports.MODE.SNGL = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  return exports.MODE.MULT(range).sort(function(a, b) {
	    return a - b;
	  })[0];
	};

	exports.NEGBINOM = {};

	exports.NEGBINOM.DIST = function(k, r, p, cumulative) {
	  k = utils.parseNumber(k);
	  r = utils.parseNumber(r);
	  p = utils.parseNumber(p);
	  if (utils.anyIsError(k, r, p)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.negbin.cdf(k, r, p) : jStat.negbin.pdf(k, r, p);
	};

	exports.NORM = {};

	exports.NORM.DIST = function(x, mean, sd, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  if (sd <= 0) {
	    return error.num;
	  }

	  // Return normal distribution computed by jStat [http://jstat.org]
	  return (cumulative) ? jStat.normal.cdf(x, mean, sd) : jStat.normal.pdf(x, mean, sd);
	};

	exports.NORM.INV = function(probability, mean, sd) {
	  probability = utils.parseNumber(probability);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(probability, mean, sd)) {
	    return error.value;
	  }
	  return jStat.normal.inv(probability, mean, sd);
	};

	exports.NORM.S = {};

	exports.NORM.S.DIST = function(z, cumulative) {
	  z = utils.parseNumber(z);
	  if (z instanceof Error) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.normal.cdf(z, 0, 1) : jStat.normal.pdf(z, 0, 1);
	};

	exports.NORM.S.INV = function(probability) {
	  probability = utils.parseNumber(probability);
	  if (probability instanceof Error) {
	    return error.value;
	  }
	  return jStat.normal.inv(probability, 0, 1);
	};

	exports.PEARSON = function(data_x, data_y) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den1 = 0;
	  var den2 = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den1 += Math.pow(data_x[i] - xmean, 2);
	    den2 += Math.pow(data_y[i] - ymean, 2);
	  }
	  return num / Math.sqrt(den1 * den2);
	};

	exports.PERCENTILE = {};

	exports.PERCENTILE.EXC = function(array, k) {
	  array = utils.parseNumberArray(utils.flatten(array));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(array, k)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    {
	      return a - b;
	    }
	  });
	  var n = array.length;
	  if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {
	    return error.num;
	  }
	  var l = k * (n + 1) - 1;
	  var fl = Math.floor(l);
	  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
	};

	exports.PERCENTILE.INC = function(array, k) {
	  array = utils.parseNumberArray(utils.flatten(array));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(array, k)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var n = array.length;
	  var l = k * (n - 1);
	  var fl = Math.floor(l);
	  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
	};

	exports.PERCENTRANK = {};

	exports.PERCENTRANK.EXC = function(array, x, significance) {
	  significance = (significance === undefined) ? 3 : significance;
	  array = utils.parseNumberArray(utils.flatten(array));
	  x = utils.parseNumber(x);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(array, x, significance)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var uniques = misc.UNIQUE.apply(null, array);
	  var n = array.length;
	  var m = uniques.length;
	  var power = Math.pow(10, significance);
	  var result = 0;
	  var match = false;
	  var i = 0;
	  while (!match && i < m) {
	    if (x === uniques[i]) {
	      result = (array.indexOf(uniques[i]) + 1) / (n + 1);
	      match = true;
	    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
	      result = (array.indexOf(uniques[i]) + 1 + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n + 1);
	      match = true;
	    }
	    i++;
	  }
	  return Math.floor(result * power) / power;
	};

	exports.PERCENTRANK.INC = function(array, x, significance) {
	  significance = (significance === undefined) ? 3 : significance;
	  array = utils.parseNumberArray(utils.flatten(array));
	  x = utils.parseNumber(x);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(array, x, significance)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var uniques = misc.UNIQUE.apply(null, array);
	  var n = array.length;
	  var m = uniques.length;
	  var power = Math.pow(10, significance);
	  var result = 0;
	  var match = false;
	  var i = 0;
	  while (!match && i < m) {
	    if (x === uniques[i]) {
	      result = array.indexOf(uniques[i]) / (n - 1);
	      match = true;
	    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
	      result = (array.indexOf(uniques[i]) + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n - 1);
	      match = true;
	    }
	    i++;
	  }
	  return Math.floor(result * power) / power;
	};

	exports.PERMUT = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return mathTrig.FACT(number) / mathTrig.FACT(number - number_chosen);
	};

	exports.PERMUTATIONA = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return Math.pow(number, number_chosen);
	};

	exports.PHI = function(x) {
	  x = utils.parseNumber(x);
	  if (x instanceof Error) {
	    return error.value;
	  }
	  return Math.exp(-0.5 * x * x) / SQRT2PI;
	};

	exports.POISSON = {};

	exports.POISSON.DIST = function(x, mean, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  if (utils.anyIsError(x, mean)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.poisson.cdf(x, mean) : jStat.poisson.pdf(x, mean);
	};

	exports.PROB = function(range, probability, lower, upper) {
	  if (lower === undefined) {
	    return 0;
	  }
	  upper = (upper === undefined) ? lower : upper;

	  range = utils.parseNumberArray(utils.flatten(range));
	  probability = utils.parseNumberArray(utils.flatten(probability));
	  lower = utils.parseNumber(lower);
	  upper = utils.parseNumber(upper);
	  if (utils.anyIsError(range, probability, lower, upper)) {
	    return error.value;
	  }

	  if (lower === upper) {
	    return (range.indexOf(lower) >= 0) ? probability[range.indexOf(lower)] : 0;
	  }

	  var sorted = range.sort(function(a, b) {
	    return a - b;
	  });
	  var n = sorted.length;
	  var result = 0;
	  for (var i = 0; i < n; i++) {
	    if (sorted[i] >= lower && sorted[i] <= upper) {
	      result += probability[range.indexOf(sorted[i])];
	    }
	  }
	  return result;
	};

	exports.QUARTILE = {};

	exports.QUARTILE.EXC = function(range, quart) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  quart = utils.parseNumber(quart);
	  if (utils.anyIsError(range, quart)) {
	    return error.value;
	  }
	  switch (quart) {
	    case 1:
	      return exports.PERCENTILE.EXC(range, 0.25);
	    case 2:
	      return exports.PERCENTILE.EXC(range, 0.5);
	    case 3:
	      return exports.PERCENTILE.EXC(range, 0.75);
	    default:
	      return error.num;
	  }
	};

	exports.QUARTILE.INC = function(range, quart) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  quart = utils.parseNumber(quart);
	  if (utils.anyIsError(range, quart)) {
	    return error.value;
	  }
	  switch (quart) {
	    case 1:
	      return exports.PERCENTILE.INC(range, 0.25);
	    case 2:
	      return exports.PERCENTILE.INC(range, 0.5);
	    case 3:
	      return exports.PERCENTILE.INC(range, 0.75);
	    default:
	      return error.num;
	  }
	};

	exports.RANK = {};

	exports.RANK.AVG = function(number, range, order) {
	  number = utils.parseNumber(number);
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (utils.anyIsError(number, range)) {
	    return error.value;
	  }
	  range = utils.flatten(range);
	  order = order || false;
	  var sort = (order) ? function(a, b) {
	    return a - b;
	  } : function(a, b) {
	    return b - a;
	  };
	  range = range.sort(sort);

	  var length = range.length;
	  var count = 0;
	  for (var i = 0; i < length; i++) {
	    if (range[i] === number) {
	      count++;
	    }
	  }

	  return (count > 1) ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1;
	};

	exports.RANK.EQ = function(number, range, order) {
	  number = utils.parseNumber(number);
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (utils.anyIsError(number, range)) {
	    return error.value;
	  }
	  order = order || false;
	  var sort = (order) ? function(a, b) {
	    return a - b;
	  } : function(a, b) {
	    return b - a;
	  };
	  range = range.sort(sort);
	  return range.indexOf(number) + 1;
	};

	exports.ROW = function(matrix, index) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (index < 0) {
	    return error.num;
	  }

	  if (!(matrix instanceof Array) || (typeof index !== 'number')) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return undefined;
	  }

	  return jStat.row(matrix, index);
	};

	exports.ROWS = function(matrix) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (!(matrix instanceof Array)) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return 0;
	  }

	  return jStat.rows(matrix);
	};

	exports.RSQ = function(data_x, data_y) { // no need to flatten here, PEARSON will take care of that
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  if (utils.anyIsError(data_x, data_y)) {
	    return error.value;
	  }
	  return Math.pow(exports.PEARSON(data_x, data_y), 2);
	};

	exports.SKEW = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var sigma = 0;
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 3);
	  }
	  return n * sigma / ((n - 1) * (n - 2) * Math.pow(jStat.stdev(range, true), 3));
	};

	exports.SKEW.P = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var m2 = 0;
	  var m3 = 0;
	  for (var i = 0; i < n; i++) {
	    m3 += Math.pow(range[i] - mean, 3);
	    m2 += Math.pow(range[i] - mean, 2);
	  }
	  m3 = m3 / n;
	  m2 = m2 / n;
	  return m3 / Math.pow(m2, 3 / 2);
	};

	exports.SLOPE = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  return num / den;
	};

	exports.SMALL = function(range, k) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(range, k)) {
	    return range;
	  }
	  return range.sort(function(a, b) {
	    return a - b;
	  })[k - 1];
	};

	exports.STANDARDIZE = function(x, mean, sd) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  return (x - mean) / sd;
	};

	exports.STDEV = {};

	exports.STDEV.P = function() {
	  var v = exports.VAR.P.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEV.S = function() {
	  var v = exports.VAR.S.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEVA = function() {
	  var v = exports.VARA.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEVPA = function() {
	  var v = exports.VARPA.apply(this, arguments);
	  return Math.sqrt(v);
	};


	exports.STEYX = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var lft = 0;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    lft += Math.pow(data_y[i] - ymean, 2);
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  return Math.sqrt((lft - num * num / den) / (n - 2));
	};

	exports.TRANSPOSE = function(matrix) {
	  if (!matrix) {
	    return error.na;
	  }
	  return jStat.transpose(matrix);
	};

	exports.T = text.T;

	exports.T.DIST = function(x, df, cumulative) {
	  x = utils.parseNumber(x);
	  df = utils.parseNumber(df);
	  if (utils.anyIsError(x, df)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.studentt.cdf(x, df) : jStat.studentt.pdf(x, df);
	};

	exports.T.DIST['2T'] = function(x, df) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (x < 0 || df < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof df !== 'number')) {
	    return error.value;
	  }

	  return (1 - jStat.studentt.cdf(x , df)) * 2;
	};

	exports.T.DIST.RT = function(x, df) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (x < 0 || df < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof df !== 'number')) {
	    return error.value;
	  }

	  return 1 - jStat.studentt.cdf(x , df);
	};

	exports.T.INV = function(probability, df) {
	  probability = utils.parseNumber(probability);
	  df = utils.parseNumber(df);
	  if (utils.anyIsError(probability, df)) {
	    return error.value;
	  }
	  return jStat.studentt.inv(probability, df);
	};

	exports.T.INV['2T'] = function(probability, df) {
	  probability = utils.parseNumber(probability);
	  df = utils.parseNumber(df);
	  if (probability <= 0 || probability > 1 || df < 1) {
	    return error.num;
	  }
	  if (utils.anyIsError(probability, df)) {
	    return error.value;
	  }
	  return Math.abs(jStat.studentt.inv(probability/2, df));
	};

	// The algorithm can be found here:
	// http://www.chem.uoa.gr/applets/AppletTtest/Appl_Ttest2.html
	exports.T.TEST = function(data_x, data_y) {
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  if (utils.anyIsError(data_x, data_y)) {
	    return error.value;
	  }

	  var mean_x = jStat.mean(data_x);
	  var mean_y = jStat.mean(data_y);
	  var s_x = 0;
	  var s_y = 0;
	  var i;

	  for (i = 0; i < data_x.length; i++) {
	    s_x += Math.pow(data_x[i] - mean_x, 2);
	  }
	  for (i = 0; i < data_y.length; i++) {
	    s_y += Math.pow(data_y[i] - mean_y, 2);
	  }

	  s_x = s_x / (data_x.length-1);
	  s_y = s_y / (data_y.length-1);

	  var t = Math.abs(mean_x - mean_y) / Math.sqrt(s_x/data_x.length + s_y/data_y.length);

	  return exports.T.DIST['2T'](t, data_x.length+data_y.length-2);
	};

	exports.TREND = function(data_y, data_x, new_data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  new_data_x = utils.parseNumberArray(utils.flatten(new_data_x));
	  if (utils.anyIsError(data_y, data_x, new_data_x)) {
	    return error.value;
	  }
	  var linest = exports.LINEST(data_y, data_x);
	  var m = linest[0];
	  var b = linest[1];
	  var result = [];

	  new_data_x.forEach(function(x) {
	    result.push(m * x + b);
	  });

	  return result;
	};

	exports.TRIMMEAN = function(range, percent) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  percent = utils.parseNumber(percent);
	  if (utils.anyIsError(range, percent)) {
	    return error.value;
	  }
	  var trim = mathTrig.FLOOR(range.length * percent, 2) / 2;
	  return jStat.mean(utils.initial(utils.rest(range.sort(function(a, b) {
	    return a - b;
	  }), trim), trim));
	};

	exports.VAR = {};

	exports.VAR.P = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sigma = 0;
	  var mean = exports.AVERAGE(range);
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 2);
	  }
	  return sigma / n;
	};

	exports.VAR.S = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sigma = 0;
	  var mean = exports.AVERAGE(range);
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 2);
	  }
	  return sigma / (n - 1);
	};

	exports.VARA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sigma = 0;
	  var count = 0;
	  var mean = exports.AVERAGEA(range);
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sigma += Math.pow(el - mean, 2);
	    } else if (el === true) {
	      sigma += Math.pow(1 - mean, 2);
	    } else {
	      sigma += Math.pow(0 - mean, 2);
	    }

	    if (el !== null) {
	      count++;
	    }
	  }
	  return sigma / (count - 1);
	};

	exports.VARPA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sigma = 0;
	  var count = 0;
	  var mean = exports.AVERAGEA(range);
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sigma += Math.pow(el - mean, 2);
	    } else if (el === true) {
	      sigma += Math.pow(1 - mean, 2);
	    } else {
	      sigma += Math.pow(0 - mean, 2);
	    }

	    if (el !== null) {
	      count++;
	    }
	  }
	  return sigma / count;
	};

	exports.WEIBULL = {};

	exports.WEIBULL.DIST = function(x, alpha, beta, cumulative) {
	  x = utils.parseNumber(x);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  if (utils.anyIsError(x, alpha, beta)) {
	    return error.value;
	  }
	  return (cumulative) ? 1 - Math.exp(-Math.pow(x / beta, alpha)) : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);
	};

	exports.Z = {};

	exports.Z.TEST = function(range, x, sd) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  x = utils.parseNumber(x);
	  if (utils.anyIsError(range, x)) {
	    return error.value;
	  }

	  sd = sd || exports.STDEV.S(range);
	  var n = range.length;
	  return 1 - exports.NORM.S.DIST((exports.AVERAGE(range) - x) / (sd / Math.sqrt(n)), true);
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var numeral = __webpack_require__(8);

	//TODO
	exports.ASC = function() {
	 throw new Error('ASC is not implemented');
	};

	//TODO
	exports.BAHTTEXT = function() {
	 throw new Error('BAHTTEXT is not implemented');
	};

	exports.CHAR = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return String.fromCharCode(number);
	};

	exports.CLEAN = function(text) {
	  text = text || '';
	  var re = /[\0-\x1F]/g;
	  return text.replace(re, "");
	};

	exports.CODE = function(text) {
	  text = text || '';
	  return text.charCodeAt(0);
	};

	exports.CONCATENATE = function() {
	  var args = utils.flatten(arguments);

	  var trueFound = 0;
	  while ((trueFound = args.indexOf(true)) > -1) {
	    args[trueFound] = 'TRUE';
	  }

	  var falseFound = 0;
	  while ((falseFound = args.indexOf(false)) > -1) {
	    args[falseFound] = 'FALSE';
	  }

	  return args.join('');
	};

	//TODO
	exports.DBCS = function() {
	 throw new Error('DBCS is not implemented');
	};

	exports.DOLLAR = function(number, decimals) {
	  decimals = (decimals === undefined) ? 2 : decimals;

	  number = utils.parseNumber(number);
	  decimals = utils.parseNumber(decimals);
	  if (utils.anyIsError(number, decimals)) {
	    return error.value;
	  }
	  var format = '';
	  if (decimals <= 0) {
	    number = Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    format = '($0,0)';
	  } else if (decimals > 0) {
	    format = '($0,0.' + new Array(decimals + 1).join('0') + ')';
	  }
	  return numeral(number).format(format);
	};

	exports.EXACT = function(text1, text2) {
	  return text1 === text2;
	};

	exports.FIND = function(find_text, within_text, position) {
	  position = (position === undefined) ? 0 : position;
	  return within_text ? within_text.indexOf(find_text, position - 1) + 1 : null;
	};

	exports.FIXED = function(number, decimals, no_commas) {
	  decimals = (decimals === undefined) ? 2 : decimals;
	  no_commas = (no_commas === undefined) ? false : no_commas;

	  number = utils.parseNumber(number);
	  decimals = utils.parseNumber(decimals);
	  if (utils.anyIsError(number, decimals)) {
	    return error.value;
	  }

	  var format = no_commas ? '0' : '0,0';
	  if (decimals <= 0) {
	    number = Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	  } else if (decimals > 0) {
	    format += '.' + new Array(decimals + 1).join('0');
	  }
	  return numeral(number).format(format);
	};

	exports.HTML2TEXT = function (value) {
	  var result = '';

	  if (value) {
	    if (value instanceof Array) {
	      value.forEach(function (line) {
	        if (result !== '') {
	          result += '\n';
	        }
	        result += (line.replace(/<(?:.|\n)*?>/gm, ''));
	      });
	    } else {
	      result = value.replace(/<(?:.|\n)*?>/gm, '');
	    }
	  }

	  return result;
	};

	exports.LEFT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = utils.parseNumber(number);
	  if (number instanceof Error || typeof text !== 'string') {
	    return error.value;
	  }
	  return text ? text.substring(0, number) : null;
	};

	exports.LEN = function(text) {
	  if (arguments.length === 0) {
	    return error.error;
	  }

	  if (typeof text === 'string') {
	    return text ? text.length : 0;
	  }

	  if (text.length) {
	    return text.length;
	  }

	  return error.value;
	};

	exports.LOWER = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text ? text.toLowerCase() : text;
	};

	exports.MID = function(text, start, number) {
	  start = utils.parseNumber(start);
	  number = utils.parseNumber(number);
	  if (utils.anyIsError(start, number) || typeof text !== 'string') {
	    return number;
	  }

	  var begin = start - 1;
	  var end = begin + number;

	  return text.substring(begin, end);
	};

	// TODO
	exports.NUMBERVALUE = function (text, decimal_separator, group_separator)  {
	  decimal_separator = (typeof decimal_separator === 'undefined') ? '.' : decimal_separator;
	  group_separator = (typeof group_separator === 'undefined') ? ',' : group_separator;
	  return Number(text.replace(decimal_separator, '.').replace(group_separator, ''));
	};

	// TODO
	exports.PRONETIC = function() {
	 throw new Error('PRONETIC is not implemented');
	};

	exports.PROPER = function(text) {
	  if (text === undefined || text.length === 0) {
	    return error.value;
	  }
	  if (text === true) {
	    text = 'TRUE';
	  }
	  if (text === false) {
	    text = 'FALSE';
	  }
	  if (isNaN(text) && typeof text === 'number') {
	    return error.value;
	  }
	  if (typeof text === 'number') {
	    text = '' + text;
	  }

	  return text.replace(/\w\S*/g, function(txt) {
	    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
	  });
	};

	exports.REGEXEXTRACT = function (text, regular_expression) {
	  var match = text.match(new RegExp(regular_expression));
	  return match ? (match[match.length > 1 ? match.length - 1 : 0]) : null;
	};

	exports.REGEXMATCH = function (text, regular_expression, full) {
	  var match = text.match(new RegExp(regular_expression));
	  return full ? match : !!match;
	};

	exports.REGEXREPLACE = function (text, regular_expression, replacement) {
	  return text.replace(new RegExp(regular_expression), replacement);
	};

	exports.REPLACE = function(text, position, length, new_text) {
	  position = utils.parseNumber(position);
	  length = utils.parseNumber(length);
	  if (utils.anyIsError(position, length) ||
	    typeof text !== 'string' ||
	    typeof new_text !== 'string') {
	    return error.value;
	  }
	  return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
	};

	exports.REPT = function(text, number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return new Array(number + 1).join(text);
	};

	exports.RIGHT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return text ? text.substring(text.length - number) : null;
	};

	exports.SEARCH = function(find_text, within_text, position) {
	  var foundAt;
	  if (typeof find_text !== 'string' || typeof within_text !== 'string') {
	    return error.value;
	  }
	  position = (position === undefined) ? 0 : position;
	  foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1)+1;
	  return (foundAt === 0)?error.value:foundAt;
	};

	exports.SPLIT = function (text, separator) {
	  return text.split(separator);
	};

	exports.SUBSTITUTE = function(text, old_text, new_text, occurrence) {
	  if (!text || !old_text || !new_text) {
	    return text;
	  } else if (occurrence === undefined) {
	    return text.replace(new RegExp(old_text, 'g'), new_text);
	  } else {
	    var index = 0;
	    var i = 0;
	    while (text.indexOf(old_text, index) > 0) {
	      index = text.indexOf(old_text, index + 1);
	      i++;
	      if (i === occurrence) {
	        return text.substring(0, index) + new_text + text.substring(index + old_text.length);
	      }
	    }
	  }
	};

	exports.T = function(value) {
	  return (typeof value === "string") ? value : '';
	};

	// TODO incomplete implementation
	exports.TEXT = function(value, format) {
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(value)) {
	    return error.na;
	  }

	  return numeral(value).format(format);
	};

	exports.TRIM = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text.replace(/ +/g, ' ').trim();
	};

	exports.UNICHAR = this.CHAR;

	exports.UNICODE = this.CODE;

	exports.UPPER = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text.toUpperCase();
	};

	exports.VALUE = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return numeral().unformat(text);
	};


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var utils   = __webpack_require__(4);
	var numeral = __webpack_require__(8);

	exports.UNIQUE = function () {
	  var result = [];
	  for (var i = 0; i < arguments.length; ++i) {
	    var hasElement = false;
	    var element    = arguments[i];

	    // Check if we've already seen this element.
	    for (var j = 0; j < result.length; ++j) {
	      hasElement = result[j] === element;
	      if (hasElement) { break; }
	    }

	    // If we did not find it, add it to the result.
	    if (!hasElement) {
	      result.push(element);
	    }
	  }
	  return result;
	};

	exports.FLATTEN = utils.flatten;

	exports.ARGS2ARRAY = function () {
	  return Array.prototype.slice.call(arguments, 0);
	};

	exports.REFERENCE = function (context, reference) {
	  try {
	    var path = reference.split('.');
	    var result = context;
	    for (var i = 0; i < path.length; ++i) {
	      var step = path[i];
	      if (step[step.length - 1] === ']') {
	        var opening = step.indexOf('[');
	        var index = step.substring(opening + 1, step.length - 1);
	        result = result[step.substring(0, opening)][index];
	      } else {
	        result = result[step];
	      }
	    }
	    return result;
	  } catch (error) {}
	};

	exports.JOIN = function (array, separator) {
	  return array.join(separator);
	};

	exports.NUMBERS = function () {
	  var possibleNumbers = utils.flatten(arguments);
	  return possibleNumbers.filter(function (el) {
	    return typeof el === 'number';
	  });
	};

	exports.NUMERAL = function (number, format) {
	  return numeral(number).format(format);
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	// TODO
	exports.CELL = function() {
	 throw new Error('CELL is not implemented');
	};

	exports.ERROR = {};
	exports.ERROR.TYPE = function(error_val) {
	  switch (error_val) {
	    case error.nil: return 1;
	    case error.div0: return 2;
	    case error.value: return 3;
	    case error.ref: return 4;
	    case error.name: return 5;
	    case error.num: return 6;
	    case error.na: return 7;
	    case error.data: return 8;
	  }
	  return error.na;
	};

	// TODO
	exports.INFO = function() {
	 throw new Error('INFO is not implemented');
	};

	exports.ISBLANK = function(value) {
	  return value === null;
	};

	exports.ISBINARY = function (number) {
	  return (/^[01]{1,10}$/).test(number);
	};

	exports.ISERR = function(value) {
	  return ([error.value, error.ref, error.div0, error.num, error.name, error.nil]).indexOf(value) >= 0 ||
	    (typeof value === 'number' && (isNaN(value) || !isFinite(value)));
	};

	exports.ISERROR = function(value) {
	  return exports.ISERR(value) || value === error.na;
	};

	exports.ISEVEN = function(number) {
	  return (Math.floor(Math.abs(number)) & 1) ? false : true;
	};

	// TODO
	exports.ISFORMULA = function() {
	  throw new Error('ISFORMULA is not implemented');
	};

	exports.ISLOGICAL = function(value) {
	  return value === true || value === false;
	};

	exports.ISNA = function(value) {
	  return value === error.na;
	};

	exports.ISNONTEXT = function(value) {
	  return typeof(value) !== 'string';
	};

	exports.ISNUMBER = function(value) {
	  return typeof(value) === 'number' && !isNaN(value) && isFinite(value);
	};

	exports.ISODD = function(number) {
	  return (Math.floor(Math.abs(number)) & 1) ? true : false;
	};

	// TODO
	exports.ISREF = function() {
	  throw new Error('ISREF is not implemented');
	};

	exports.ISTEXT = function(value) {
	  return typeof(value) === 'string';
	};

	exports.N = function(value) {
	  if (this.ISNUMBER(value)) {
	    return value;
	  }
	  if (value instanceof Date) {
	    return value.getTime();
	  }
	  if (value === true) {
	    return 1;
	  }
	  if (value === false) {
	    return 0;
	  }
	  if (this.ISERROR(value)) {
	    return value;
	  }
	  return 0;
	};

	exports.NA = function() {
	  return error.na;
	};


	// TODO
	exports.SHEET = function() {
	  throw new Error('SHEET is not implemented');
	};

	// TODO
	exports.SHEETS = function() {
	  throw new Error('SHEETS is not implemented');
	};

	exports.TYPE = function(value) {
	  if (this.ISNUMBER(value)) {
	    return 1;
	  }
	  if (this.ISTEXT(value)) {
	    return 2;
	  }
	  if (this.ISLOGICAL(value)) {
	    return 4;
	  }
	  if (this.ISERROR(value)) {
	    return 16;
	  }
	  if (Array.isArray(value)) {
	    return 64;
	  }
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var jStat = __webpack_require__(9).jStat;
	var text = __webpack_require__(7);
	var utils = __webpack_require__(4);
	var bessel = __webpack_require__(13);

	function isValidBinaryNumber(number) {
	  return (/^[01]{1,10}$/).test(number);
	}

	exports.BESSELI = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besseli(x, n);
	};

	exports.BESSELJ = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besselj(x, n);
	};

	exports.BESSELK = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besselk(x, n);
	};

	exports.BESSELY = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.bessely(x, n);
	};

	exports.BIN2DEC = function(number) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Convert binary number to decimal
	  var result = parseInt(number, 2);

	  // Handle negative numbers
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return parseInt(stringified.substring(1), 2) - 512;
	  } else {
	    return result;
	  }
	};


	exports.BIN2HEX = function(number, places) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character hexadecimal number if number is negative
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);
	  }

	  // Convert binary number to hexadecimal
	  var result = parseInt(number, 2).toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.BIN2OCT = function(number, places) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
	  }

	  // Convert binary number to octal
	  var result = parseInt(number, 2).toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.BITAND = function(number1, number2) {
	  // Return error if either number is a non-numeric value
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise AND of two numbers
	  return number1 & number2;
	};

	exports.BITLSHIFT = function(number, shift) {
	  number = utils.parseNumber(number);
	  shift = utils.parseNumber(shift);
	  if (utils.anyIsError(number, shift)) {
	    return error.value;
	  }

	  // Return error if number is less than 0
	  if (number < 0) {
	    return error.num;
	  }

	  // Return error if number is a non-integer
	  if (Math.floor(number) !== number) {
	    return error.num;
	  }

	  // Return error if number is greater than (2^48)-1
	  if (number > 281474976710655) {
	    return error.num;
	  }

	  // Return error if the absolute value of shift is greater than 53
	  if (Math.abs(shift) > 53) {
	    return error.num;
	  }

	  // Return number shifted by shift bits to the left or to the right if shift is negative
	  return (shift >= 0) ? number << shift : number >> -shift;
	};

	exports.BITOR = function(number1, number2) {
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise OR of two numbers
	  return number1 | number2;
	};

	exports.BITRSHIFT = function(number, shift) {
	  number = utils.parseNumber(number);
	  shift = utils.parseNumber(shift);
	  if (utils.anyIsError(number, shift)) {
	    return error.value;
	  }

	  // Return error if number is less than 0
	  if (number < 0) {
	    return error.num;
	  }

	  // Return error if number is a non-integer
	  if (Math.floor(number) !== number) {
	    return error.num;
	  }

	  // Return error if number is greater than (2^48)-1
	  if (number > 281474976710655) {
	    return error.num;
	  }

	  // Return error if the absolute value of shift is greater than 53
	  if (Math.abs(shift) > 53) {
	    return error.num;
	  }

	  // Return number shifted by shift bits to the right or to the left if shift is negative
	  return (shift >= 0) ? number >> shift : number << -shift;
	};

	exports.BITXOR = function(number1, number2) {
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise XOR of two numbers
	  return number1 ^ number2;
	};

	exports.COMPLEX = function(real, imaginary, suffix) {
	  real = utils.parseNumber(real);
	  imaginary = utils.parseNumber(imaginary);
	  if (utils.anyIsError(real, imaginary)) {
	    return real;
	  }

	  // Set suffix
	  suffix = (suffix === undefined) ? 'i' : suffix;

	  // Return error if suffix is neither "i" nor "j"
	  if (suffix !== 'i' && suffix !== 'j') {
	    return error.value;
	  }

	  // Return complex number
	  if (real === 0 && imaginary === 0) {
	    return 0;
	  } else if (real === 0) {
	    return (imaginary === 1) ? suffix : imaginary.toString() + suffix;
	  } else if (imaginary === 0) {
	    return real.toString();
	  } else {
	    var sign = (imaginary > 0) ? '+' : '';
	    return real.toString() + sign + ((imaginary === 1) ? suffix : imaginary.toString() + suffix);
	  }
	};

	exports.CONVERT = function(number, from_unit, to_unit) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // List of units supported by CONVERT and units defined by the International System of Units
	  // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion ratio]
	  var units = [
	    ["a.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
	    ["a.u. of charge", "e", null, "electric_charge", false, false, 1.60217653141414e-19],
	    ["a.u. of energy", "Eh", null, "energy", false, false, 4.35974417757576e-18],
	    ["a.u. of length", "a?", null, "length", false, false, 5.29177210818182e-11],
	    ["a.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
	    ["a.u. of time", "?/Eh", null, "time", false, false, 2.41888432650516e-17],
	    ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
	    ["ampere", "A", null, "electric_current", true, false, 1],
	    ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
	    ["ångström", "Å", ["ang"], "length", false, true, 1e-10],
	    ["are", "ar", null, "area", false, true, 100],
	    ["astronomical unit", "ua", null, "length", false, false, 1.49597870691667e-11],
	    ["bar", "bar", null, "pressure", false, false, 100000],
	    ["barn", "b", null, "area", false, false, 1e-28],
	    ["becquerel", "Bq", null, "radioactivity", true, false, 1],
	    ["bit", "bit", ["b"], "information", false, true, 1],
	    ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
	    ["byte", "byte", null, "information", false, true, 8],
	    ["candela", "cd", null, "luminous_intensity", true, false, 1],
	    ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
	    ["coulomb", "C", null, "electric_charge", true, false, 1],
	    ["cubic ångström", "ang3", ["ang^3"], "volume", false, true, 1e-30],
	    ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
	    ["cubic inch", "in3", ["in^3"], "volume", false, true, 0.000016387064],
	    ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 8.46786664623715e-47],
	    ["cubic metre", "m?", null, "volume", true, true, 1],
	    ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 4168181825.44058],
	    ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
	    ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 7.58660370370369e-8],
	    ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
	    ["cup", "cup", null, "volume", false, true, 0.0002365882365],
	    ["dalton", "Da", ["u"], "mass", false, false, 1.66053886282828e-27],
	    ["day", "d", ["day"], "time", false, true, 86400],
	    ["degree", "°", null, "angle", false, false, 0.0174532925199433],
	    ["degrees Rankine", "Rank", null, "temperature", false, true, 0.555555555555556],
	    ["dyne", "dyn", ["dy"], "force", false, true, 0.00001],
	    ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
	    ["ell", "ell", null, "length", false, true, 1.143],
	    ["erg", "erg", ["e"], "energy", false, true, 1e-7],
	    ["farad", "F", null, "electric_capacitance", true, false, 1],
	    ["fluid ounce", "oz", null, "volume", false, true, 0.0000295735295625],
	    ["foot", "ft", null, "length", false, true, 0.3048],
	    ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
	    ["gal", "Gal", null, "acceleration", false, false, 0.01],
	    ["gallon", "gal", null, "volume", false, true, 0.003785411784],
	    ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
	    ["grain", "grain", null, "mass", false, true, 0.0000647989],
	    ["gram", "g", null, "mass", false, true, 0.001],
	    ["gray", "Gy", null, "absorbed_dose", true, false, 1],
	    ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
	    ["hectare", "ha", null, "area", false, true, 10000],
	    ["henry", "H", null, "inductance", true, false, 1],
	    ["hertz", "Hz", null, "frequency", true, false, 1],
	    ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
	    ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519.538],
	    ["hour", "h", ["hr"], "time", false, true, 3600],
	    ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 0.00454609],
	    ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
	    ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
	    ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
	    ["inch", "in", null, "length", false, true, 0.0254],
	    ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
	    ["IT calorie", "cal", null, "energy", false, true, 4.1868],
	    ["joule", "J", null, "energy", true, true, 1],
	    ["katal", "kat", null, "catalytic_activity", true, false, 1],
	    ["kelvin", "K", ["kel"], "temperature", true, true, 1],
	    ["kilogram", "kg", null, "mass", true, true, 1],
	    ["knot", "kn", null, "speed", false, true, 0.514444444444444],
	    ["light-year", "ly", null, "length", false, true, 9460730472580800],
	    ["litre", "L", ["l", "lt"], "volume", false, true, 0.001],
	    ["lumen", "lm", null, "luminous_flux", true, false, 1],
	    ["lux", "lx", null, "illuminance", true, false, 1],
	    ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
	    ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
	    ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 0.00027777777777778],
	    ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
	    ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
	    ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
	    ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
	    ["metre", "m", null, "length", true, true, 1],
	    ["miles per hour", "mph", null, "speed", false, true, 0.44704],
	    ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
	    ["minute", "?", null, "angle", false, false, 0.000290888208665722],
	    ["minute", "min", ["mn"], "time", false, true, 60],
	    ["modern teaspoon", "tspm", null, "volume", false, true, 0.000005],
	    ["mole", "mol", null, "amount_of_substance", true, false, 1],
	    ["morgen", "Morgen", null, "area", false, true, 2500],
	    ["n.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
	    ["n.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
	    ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
	    ["n.u. of time", "?/(me?c??)", null, "time", false, false, 1.28808866778687e-21],
	    ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
	    ["newton", "N", null, "force", true, true, 1],
	    ["œrsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
	    ["ohm", "Ω", null, "electric_resistance", true, false, 1],
	    ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
	    ["pascal", "Pa", null, "pressure", true, false, 1],
	    ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
	    ["pferdestärke", "PS", null, "power", false, true, 735.49875],
	    ["phot", "ph", null, "illuminance", false, false, 0.0001],
	    ["pica (1/6 inch)", "pica", null, "length", false, true, 0.00035277777777778],
	    ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
	    ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
	    ["pond", "pond", null, "force", false, true, 0.00980665],
	    ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
	    ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
	    ["quart", "qt", null, "volume", false, true, 0.000946352946],
	    ["radian", "rad", null, "angle", true, false, 1],
	    ["second", "?", null, "angle", false, false, 0.00000484813681109536],
	    ["second", "s", ["sec"], "time", true, true, 1],
	    ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
	    ["siemens", "S", null, "electrical_conductance", true, false, 1],
	    ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
	    ["slug", "sg", null, "mass", false, true, 14.59390294],
	    ["square ångström", "ang2", ["ang^2"], "area", false, true, 1e-20],
	    ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
	    ["square inch", "in2", ["in^2"], "area", false, true, 0.00064516],
	    ["square light-year", "ly2", ["ly^2"], "area", false, true, 8.95054210748189e+31],
	    ["square meter", "m?", null, "area", true, true, 1],
	    ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988.110336],
	    ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
	    ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 0.00001792111111111],
	    ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
	    ["statute mile", "mi", null, "length", false, true, 1609.344],
	    ["steradian", "sr", null, "solid_angle", true, false, 1],
	    ["stilb", "sb", null, "luminance", false, false, 0.0001],
	    ["stokes", "St", null, "kinematic_viscosity", false, false, 0.0001],
	    ["stone", "stone", null, "mass", false, true, 6.35029318],
	    ["tablespoon", "tbs", null, "volume", false, true, 0.0000147868],
	    ["teaspoon", "tsp", null, "volume", false, true, 0.00000492892],
	    ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
	    ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
	    ["ton", "ton", null, "mass", false, true, 907.18474],
	    ["tonne", "t", null, "mass", false, false, 1000],
	    ["U.K. pint", "uk_pt", null, "volume", false, true, 0.00056826125],
	    ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
	    ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
	    ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 0.000473176473],
	    ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
	    ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
	    ["volt", "V", null, "voltage", true, false, 1],
	    ["watt", "W", null, "power", true, true, 1],
	    ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
	    ["weber", "Wb", null, "magnetic_flux", true, false, 1],
	    ["yard", "yd", null, "length", false, true, 0.9144],
	    ["year", "yr", null, "time", false, true, 31557600]
	  ];

	  // Binary prefixes
	  // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived from]
	  var binary_prefixes = {
	    Yi: ["yobi", 80, 1208925819614629174706176, "Yi", "yotta"],
	    Zi: ["zebi", 70, 1180591620717411303424, "Zi", "zetta"],
	    Ei: ["exbi", 60, 1152921504606846976, "Ei", "exa"],
	    Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
	    Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
	    Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
	    Mi: ["mebi", 20, 1048576, "Mi", "mega"],
	    ki: ["kibi", 10, 1024, "ki", "kilo"]
	  };

	  // Unit prefixes
	  // [Name, Multiplier, Abbreviation]
	  var unit_prefixes = {
	    Y: ["yotta", 1e+24, "Y"],
	    Z: ["zetta", 1e+21, "Z"],
	    E: ["exa", 1e+18, "E"],
	    P: ["peta", 1e+15, "P"],
	    T: ["tera", 1e+12, "T"],
	    G: ["giga", 1e+09, "G"],
	    M: ["mega", 1e+06, "M"],
	    k: ["kilo", 1e+03, "k"],
	    h: ["hecto", 1e+02, "h"],
	    e: ["dekao", 1e+01, "e"],
	    d: ["deci", 1e-01, "d"],
	    c: ["centi", 1e-02, "c"],
	    m: ["milli", 1e-03, "m"],
	    u: ["micro", 1e-06, "u"],
	    n: ["nano", 1e-09, "n"],
	    p: ["pico", 1e-12, "p"],
	    f: ["femto", 1e-15, "f"],
	    a: ["atto", 1e-18, "a"],
	    z: ["zepto", 1e-21, "z"],
	    y: ["yocto", 1e-24, "y"]
	  };

	  // Initialize units and multipliers
	  var from = null;
	  var to = null;
	  var base_from_unit = from_unit;
	  var base_to_unit = to_unit;
	  var from_multiplier = 1;
	  var to_multiplier = 1;
	  var alt;

	  // Lookup from and to units
	  for (var i = 0; i < units.length; i++) {
	    alt = (units[i][2] === null) ? [] : units[i][2];
	    if (units[i][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
	      from = units[i];
	    }
	    if (units[i][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
	      to = units[i];
	    }
	  }

	  // Lookup from prefix
	  if (from === null) {
	    var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
	    var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];

	    // Handle dekao unit prefix (only unit prefix with two characters)
	    if (from_unit.substring(0, 2) === 'da') {
	      from_unit_prefix = ["dekao", 1e+01, "da"];
	    }

	    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
	    if (from_binary_prefix) {
	      from_multiplier = from_binary_prefix[2];
	      base_from_unit = from_unit.substring(2);
	    } else if (from_unit_prefix) {
	      from_multiplier = from_unit_prefix[1];
	      base_from_unit = from_unit.substring(from_unit_prefix[2].length);
	    }

	    // Lookup from unit
	    for (var j = 0; j < units.length; j++) {
	      alt = (units[j][2] === null) ? [] : units[j][2];
	      if (units[j][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
	        from = units[j];
	      }
	    }
	  }

	  // Lookup to prefix
	  if (to === null) {
	    var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
	    var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];

	    // Handle dekao unit prefix (only unit prefix with two characters)
	    if (to_unit.substring(0, 2) === 'da') {
	      to_unit_prefix = ["dekao", 1e+01, "da"];
	    }

	    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
	    if (to_binary_prefix) {
	      to_multiplier = to_binary_prefix[2];
	      base_to_unit = to_unit.substring(2);
	    } else if (to_unit_prefix) {
	      to_multiplier = to_unit_prefix[1];
	      base_to_unit = to_unit.substring(to_unit_prefix[2].length);
	    }

	    // Lookup to unit
	    for (var k = 0; k < units.length; k++) {
	      alt = (units[k][2] === null) ? [] : units[k][2];
	      if (units[k][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
	        to = units[k];
	      }
	    }
	  }

	  // Return error if a unit does not exist
	  if (from === null || to === null) {
	    return error.na;
	  }

	  // Return error if units represent different quantities
	  if (from[3] !== to[3]) {
	    return error.na;
	  }

	  // Return converted number
	  return number * from[6] * from_multiplier / (to[6] * to_multiplier);
	};

	exports.DEC2BIN = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -512, or is greater than 511
	  if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (number < 0) {
	    return '1' + text.REPT('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = parseInt(number, 10).toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DEC2HEX = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
	  if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character hexadecimal number if number is negative
	  if (number < 0) {
	    return (1099511627776 + number).toString(16);
	  }

	  // Convert decimal number to hexadecimal
	  var result = parseInt(number, 10).toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DEC2OCT = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
	  if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  if (number < 0) {
	    return (1073741824 + number).toString(8);
	  }

	  // Convert decimal number to octal
	  var result = parseInt(number, 10).toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DELTA = function(number1, number2) {
	  // Set number2 to zero if undefined
	  number2 = (number2 === undefined) ? 0 : number2;
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return delta
	  return (number1 === number2) ? 1 : 0;
	};

	// TODO: why is upper_bound not used ? The excel documentation has no examples with upper_bound
	exports.ERF = function(lower_bound, upper_bound) {
	  // Set number2 to zero if undefined
	  upper_bound = (upper_bound === undefined) ? 0 : upper_bound;

	  lower_bound = utils.parseNumber(lower_bound);
	  upper_bound = utils.parseNumber(upper_bound);
	  if (utils.anyIsError(lower_bound, upper_bound)) {
	    return error.value;
	  }

	  return jStat.erf(lower_bound);
	};

	// TODO
	exports.ERF.PRECISE = function() {
	 throw new Error('ERF.PRECISE is not implemented');
	};

	exports.ERFC = function(x) {
	  // Return error if x is not a number
	  if (isNaN(x)) {
	    return error.value;
	  }

	  return jStat.erfc(x);
	};

	// TODO
	exports.ERFC.PRECISE = function() {
	 throw new Error('ERFC.PRECISE is not implemented');
	};

	exports.GESTEP = function(number, step) {
	  step = step || 0;
	  number = utils.parseNumber(number);
	  if (utils.anyIsError(step, number)) {
	    return number;
	  }

	  // Return delta
	  return (number >= step) ? 1 : 0;
	};

	exports.HEX2BIN = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Check if number is negative
	  var negative = (number.length === 10 && number.substring(0, 1).toLowerCase() === 'f') ? true : false;

	  // Convert hexadecimal number to decimal
	  var decimal = (negative) ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);

	  // Return error if number is lower than -512 or greater than 511
	  if (decimal < -512 || decimal > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (negative) {
	    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = decimal.toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.HEX2DEC = function(number) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert hexadecimal number to decimal
	  var decimal = parseInt(number, 16);

	  // Return decimal number
	  return (decimal >= 549755813888) ? decimal - 1099511627776 : decimal;
	};

	exports.HEX2OCT = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert hexadecimal number to decimal
	  var decimal = parseInt(number, 16);

	  // Return error if number is positive and greater than 0x1fffffff (536870911)
	  if (decimal > 536870911 && decimal < 1098974756864) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  if (decimal >= 1098974756864) {
	    return (decimal - 1098437885952).toString(8);
	  }

	  // Convert decimal number to octal
	  var result = decimal.toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.IMABS = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return absolute value of complex number
	  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
	};

	exports.IMAGINARY = function(inumber) {
	  if (inumber === undefined || inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Return 0 if inumber is equal to 0
	  if (inumber === 0 || inumber === '0') {
	    return 0;
	  }

	  // Handle special cases
	  if (['i', 'j'].indexOf(inumber) >= 0) {
	    return 1;
	  }

	  // Normalize imaginary coefficient
	  inumber = inumber.replace('+i', '+1i').replace('-i', '-1i').replace('+j', '+1j').replace('-j', '-1j');

	  // Lookup sign
	  var plus = inumber.indexOf('+');
	  var minus = inumber.indexOf('-');
	  if (plus === 0) {
	    plus = inumber.indexOf('+', 1);
	  }

	  if (minus === 0) {
	    minus = inumber.indexOf('-', 1);
	  }

	  // Lookup imaginary unit
	  var last = inumber.substring(inumber.length - 1, inumber.length);
	  var unit = (last === 'i' || last === 'j');

	  if (plus >= 0 || minus >= 0) {
	    // Return error if imaginary unit is neither i nor j
	    if (!unit) {
	      return error.num;
	    }

	    // Return imaginary coefficient of complex number
	    if (plus >= 0) {
	      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(plus + 1, inumber.length - 1));
	    } else {
	      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
	        error.num :
	        -Number(inumber.substring(minus + 1, inumber.length - 1));
	    }
	  } else {
	    if (unit) {
	      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : inumber.substring(0, inumber.length - 1);
	    } else {
	      return (isNaN(inumber)) ? error.num : 0;
	    }
	  }
	};

	exports.IMARGUMENT = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return error if inumber is equal to zero
	  if (x === 0 && y === 0) {
	    return error.div0;
	  }

	  // Return PI/2 if x is equal to zero and y is positive
	  if (x === 0 && y > 0) {
	    return Math.PI / 2;
	  }

	  // Return -PI/2 if x is equal to zero and y is negative
	  if (x === 0 && y < 0) {
	    return -Math.PI / 2;
	  }

	  // Return zero if x is negative and y is equal to zero
	  if (y === 0 && x > 0) {
	    return 0;
	  }

	  // Return zero if x is negative and y is equal to zero
	  if (y === 0 && x < 0) {
	    return -Math.PI;
	  }

	  // Return argument of complex number
	  if (x > 0) {
	    return Math.atan(y / x);
	  } else if (x < 0 && y >= 0) {
	    return Math.atan(y / x) + Math.PI;
	  } else {
	    return Math.atan(y / x) - Math.PI;
	  }
	};

	exports.IMCONJUGATE = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return conjugate of complex number
	  return (y !== 0) ? exports.COMPLEX(x, -y, unit) : inumber;
	};

	exports.IMCOS = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return cosine of complex number
	  return exports.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
	};

	exports.IMCOSH = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return hyperbolic cosine of complex number
	  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
	};

	exports.IMCOT = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return cotangent of complex number
	  return exports.IMDIV(exports.IMCOS(inumber), exports.IMSIN(inumber));
	};

	exports.IMDIV = function(inumber1, inumber2) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var a = exports.IMREAL(inumber1);
	  var b = exports.IMAGINARY(inumber1);
	  var c = exports.IMREAL(inumber2);
	  var d = exports.IMAGINARY(inumber2);

	  if (utils.anyIsError(a, b, c, d)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit1 = inumber1.substring(inumber1.length - 1);
	  var unit2 = inumber2.substring(inumber2.length - 1);
	  var unit = 'i';
	  if (unit1 === 'j') {
	    unit = 'j';
	  } else if (unit2 === 'j') {
	    unit = 'j';
	  }

	  // Return error if inumber2 is null
	  if (c === 0 && d === 0) {
	    return error.num;
	  }

	  // Return exponential of complex number
	  var den = c * c + d * d;
	  return exports.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);
	};

	exports.IMEXP = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  var e = Math.exp(x);
	  return exports.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);
	};

	exports.IMLN = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);
	};

	exports.IMLOG10 = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);
	};

	exports.IMLOG2 = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);
	};

	exports.IMPOWER = function(inumber, number) {
	  number = utils.parseNumber(number);
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);
	  if (utils.anyIsError(number, x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Calculate power of modulus
	  var p = Math.pow(exports.IMABS(inumber), number);

	  // Calculate argument
	  var t = exports.IMARGUMENT(inumber);

	  // Return exponential of complex number
	  return exports.COMPLEX(p * Math.cos(number * t), p * Math.sin(number * t), unit);
	};

	exports.IMPRODUCT = function() {
	  // Initialize result
	  var result = arguments[0];

	  // Loop on all numbers
	  for (var i = 1; i < arguments.length; i++) {
	    // Lookup coefficients of two complex numbers
	    var a = exports.IMREAL(result);
	    var b = exports.IMAGINARY(result);
	    var c = exports.IMREAL(arguments[i]);
	    var d = exports.IMAGINARY(arguments[i]);

	    if (utils.anyIsError(a, b, c, d)) {
	      return error.value;
	    }

	    // Complute product of two complex numbers
	    result = exports.COMPLEX(a * c - b * d, a * d + b * c);
	  }

	  // Return product of complex numbers
	  return result;
	};

	exports.IMREAL = function(inumber) {
	  if (inumber === undefined || inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Return 0 if inumber is equal to 0
	  if (inumber === 0 || inumber === '0') {
	    return 0;
	  }

	  // Handle special cases
	  if (['i', '+i', '1i', '+1i', '-i', '-1i', 'j', '+j', '1j', '+1j', '-j', '-1j'].indexOf(inumber) >= 0) {
	    return 0;
	  }

	  // Lookup sign
	  var plus = inumber.indexOf('+');
	  var minus = inumber.indexOf('-');
	  if (plus === 0) {
	    plus = inumber.indexOf('+', 1);
	  }
	  if (minus === 0) {
	    minus = inumber.indexOf('-', 1);
	  }

	  // Lookup imaginary unit
	  var last = inumber.substring(inumber.length - 1, inumber.length);
	  var unit = (last === 'i' || last === 'j');

	  if (plus >= 0 || minus >= 0) {
	    // Return error if imaginary unit is neither i nor j
	    if (!unit) {
	      return error.num;
	    }

	    // Return real coefficient of complex number
	    if (plus >= 0) {
	      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(0, plus));
	    } else {
	      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(0, minus));
	    }
	  } else {
	    if (unit) {
	      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : 0;
	    } else {
	      return (isNaN(inumber)) ? error.num : inumber;
	    }
	  }
	};

	exports.IMSEC = function(inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return secant of complex number
	  return exports.IMDIV('1', exports.IMCOS(inumber));
	};

	exports.IMSECH = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return hyperbolic secant of complex number
	  return exports.IMDIV('1', exports.IMCOSH(inumber));
	};

	exports.IMSIN = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return sine of complex number
	  return exports.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
	};

	exports.IMSINH = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return hyperbolic sine of complex number
	  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
	};

	exports.IMSQRT = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Calculate power of modulus
	  var s = Math.sqrt(exports.IMABS(inumber));

	  // Calculate argument
	  var t = exports.IMARGUMENT(inumber);

	  // Return exponential of complex number
	  return exports.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
	};

	exports.IMCSC = function (inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.num;
	  }

	  // Return cosecant of complex number
	  return exports.IMDIV('1', exports.IMSIN(inumber));
	};

	exports.IMCSCH = function (inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.num;
	  }

	  // Return hyperbolic cosecant of complex number
	  return exports.IMDIV('1', exports.IMSINH(inumber));
	};

	exports.IMSUB = function(inumber1, inumber2) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var a = this.IMREAL(inumber1);
	  var b = this.IMAGINARY(inumber1);
	  var c = this.IMREAL(inumber2);
	  var d = this.IMAGINARY(inumber2);

	  if (utils.anyIsError(a, b, c, d)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit1 = inumber1.substring(inumber1.length - 1);
	  var unit2 = inumber2.substring(inumber2.length - 1);
	  var unit = 'i';
	  if (unit1 === 'j') {
	    unit = 'j';
	  } else if (unit2 === 'j') {
	    unit = 'j';
	  }

	  // Return _ of two complex numbers
	  return this.COMPLEX(a - c, b - d, unit);
	};

	exports.IMSUM = function() {
	  var args = utils.flatten(arguments);

	  // Initialize result
	  var result = args[0];

	  // Loop on all numbers
	  for (var i = 1; i < args.length; i++) {
	    // Lookup coefficients of two complex numbers
	    var a = this.IMREAL(result);
	    var b = this.IMAGINARY(result);
	    var c = this.IMREAL(args[i]);
	    var d = this.IMAGINARY(args[i]);

	    if (utils.anyIsError(a, b, c, d)) {
	      return error.value;
	    }

	    // Complute product of two complex numbers
	    result = this.COMPLEX(a + c, b + d);
	  }

	  // Return sum of complex numbers
	  return result;
	};

	exports.IMTAN = function(inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return tangent of complex number
	  return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));
	};

	exports.OCT2BIN = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Check if number is negative
	  var negative = (number.length === 10 && number.substring(0, 1) === '7') ? true : false;

	  // Convert octal number to decimal
	  var decimal = (negative) ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);

	  // Return error if number is lower than -512 or greater than 511
	  if (decimal < -512 || decimal > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (negative) {
	    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = decimal.toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.OCT2DEC = function(number) {
	  // Return error if number is not octal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert octal number to decimal
	  var decimal = parseInt(number, 8);

	  // Return decimal number
	  return (decimal >= 536870912) ? decimal - 1073741824 : decimal;
	};

	exports.OCT2HEX = function(number, places) {
	  // Return error if number is not octal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert octal number to decimal
	  var decimal = parseInt(number, 8);

	  // Ignore places and return a 10-character octal number if number is negative
	  if (decimal >= 536870912) {
	    return 'ff' + (decimal + 3221225472).toString(16);
	  }

	  // Convert decimal number to hexadecimal
	  var result = decimal.toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var M = Math;
	function _horner(arr, v) { return arr.reduce(function(z,w){return v * z + w;},0); };
	function _bessel_iter(x, n, f0, f1, sign) {
	  if(!sign) sign = -1;
	  var tdx = 2 / x, f2;
	  if(n === 0) return f0;
	  if(n === 1) return f1;
	  for(var o = 1; o != n; ++o) {
	    f2 = f1 * o * tdx + sign * f0;
	    f0 = f1; f1 = f2;
	  }
	  return f1;
	}
	function _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {
	  return function bessel(x,n) {
	    if(n === 0) return bessel0(x);
	    if(n === 1) return bessel1(x);
	    if(n < 0) throw name + ': Order (' + n + ') must be nonnegative';
	    if(nonzero == 1 && x === 0) throw name + ': Undefined when x == 0';
	    if(nonzero == 2 && x <= 0) throw name + ': Undefined when x <= 0';
	    var b0 = bessel0(x), b1 = bessel1(x);
	    return _bessel_iter(x, n, b0, b1, sign);
	  };
	}
	var besselj = (function() {
	  var b0_a1a = [57568490574.0,-13362590354.0,651619640.7,-11214424.18,77392.33017,-184.9052456].reverse();
	  var b0_a2a = [57568490411.0,1029532985.0,9494680.718,59272.64853,267.8532712,1.0].reverse();
	  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
	  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934935152e-7].reverse();
	  var W = 0.636619772; // 2 / Math.PI

	  function bessel0(x) {
	    var a, a1, a2, y = x * x, xx = M.abs(x) - 0.785398164;
	    if(M.abs(x) < 8) {
	      a1 = _horner(b0_a1a, y);
	      a2 = _horner(b0_a2a, y);
	      a = a1/a2;
	    }
	    else {
	      y = 64 / y;
	      a1 = _horner(b0_a1b, y);
	      a2 = _horner(b0_a2b, y);
	      a = M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));
	    }
	    return a;
	  }
	  var b1_a1a = [72362614232.0,-7895059235.0,242396853.1,-2972611.439, 15704.48260, -30.16036606].reverse();
	  var b1_a2a = [144725228442.0, 2300535178.0, 18583304.74, 99447.43394, 376.9991397, 1.0].reverse();
	  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
	  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
	  function bessel1(x) {
	    var a, a1, a2, y = x*x, xx = M.abs(x) - 2.356194491;
	    if(Math.abs(x)< 8) {
	      a1 = x*_horner(b1_a1a, y);
	      a2 = _horner(b1_a2a, y);
	      a = a1 / a2;
	    } else {
	      y = 64 / y;
	      a1=_horner(b1_a1b, y);
	      a2=_horner(b1_a2b, y);
	      a=M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));
	      if(x < 0) a = -a;
	    }
	    return a;
	  }
	  return function besselj(x, n) {
	    n = Math.round(n);
	    if(n === 0) return bessel0(M.abs(x));
	    if(n === 1) return bessel1(M.abs(x));
	    if(n < 0) throw 'BESSELJ: Order (' + n + ') must be nonnegative';
	    if(M.abs(x) === 0) return 0;

	    var ret, j, tox = 2 / M.abs(x), m, jsum, sum, bjp, bj, bjm;
	    if(M.abs(x) > n) {
	      ret = _bessel_iter(x, n, bessel0(M.abs(x)), bessel1(M.abs(x)),-1);
	    } else {
	      m=2*M.floor((n+M.floor(M.sqrt(40*n)))/2);
	      jsum=0;
	      bjp=ret=sum=0.0;
	      bj=1.0;
	      for (j=m;j>0;j--) {
	        bjm=j*tox*bj-bjp;
	        bjp=bj;
	        bj=bjm;
	        if (M.abs(bj) > 1E10) {
	          bj *= 1E-10;
	          bjp *= 1E-10;
	          ret *= 1E-10;
	          sum *= 1E-10;
	        }
	        if (jsum) sum += bj;
	        jsum=!jsum;
	        if (j == n) ret=bjp;
	      }
	      sum=2.0*sum-bj;
	      ret /= sum;
	    }
	    return x < 0 && (n%2) ? -ret : ret;
	  };
	})();
	var bessely = (function() {
	  var b0_a1a = [-2957821389.0, 7062834065.0, -512359803.6, 10879881.29, -86327.92757, 228.4622733].reverse();
	  var b0_a2a = [40076544269.0, 745249964.8, 7189466.438, 47447.26470, 226.1030244, 1.0].reverse();
	  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
	  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934945152e-7].reverse();

	  var W = 0.636619772;
	  function bessel0(x) {
	    var a, a1, a2, y = x * x, xx = x - 0.785398164;
	    if(x < 8) {
	      a1 = _horner(b0_a1a, y);
	      a2 = _horner(b0_a2a, y);
	      a = a1/a2 + W * besselj(x,0) * M.log(x);
	    } else {
	      y = 64 / y;
	      a1 = _horner(b0_a1b, y);
	      a2 = _horner(b0_a2b, y);
	      a = M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);
	    }
	    return a;
	  }

	  var b1_a1a = [-0.4900604943e13, 0.1275274390e13, -0.5153438139e11, 0.7349264551e9, -0.4237922726e7, 0.8511937935e4].reverse();
	  var b1_a2a = [0.2499580570e14, 0.4244419664e12, 0.3733650367e10, 0.2245904002e8, 0.1020426050e6, 0.3549632885e3, 1].reverse();
	  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
	  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
	  function bessel1(x) {
	    var a, a1, a2, y = x*x, xx = x - 2.356194491;
	    if(x < 8) {
	      a1 = x*_horner(b1_a1a, y);
	      a2 = _horner(b1_a2a, y);
	      a = a1/a2 + W * (besselj(x,1) * M.log(x) - 1 / x);
	    } else {
	      y = 64 / y;
	      a1=_horner(b1_a1b, y);
	      a2=_horner(b1_a2b, y);
	      a=M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);
	    }
	    return a;
	  }

	  return _bessel_wrap(bessel0, bessel1, 'BESSELY', 1, -1);
	})();
	var besseli = (function() {
	  var b0_a = [1.0, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.360768e-1, 0.45813e-2].reverse();
	  var b0_b = [0.39894228, 0.1328592e-1, 0.225319e-2, -0.157565e-2, 0.916281e-2, -0.2057706e-1, 0.2635537e-1, -0.1647633e-1, 0.392377e-2].reverse();
	  function bessel0(x) {
	    if(x <= 3.75) return _horner(b0_a, x*x/(3.75*3.75));
	    return M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b0_b, 3.75/M.abs(x));
	  }

	  var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.2658733e-1, 0.301532e-2, 0.32411e-3].reverse();
	  var b1_b = [0.39894228, -0.3988024e-1, -0.362018e-2, 0.163801e-2, -0.1031555e-1, 0.2282967e-1, -0.2895312e-1, 0.1787654e-1, -0.420059e-2].reverse();
	  function bessel1(x) {
	    if(x < 3.75) return x * _horner(b1_a, x*x/(3.75*3.75));
	    return (x < 0 ? -1 : 1) * M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b1_b, 3.75/M.abs(x));
	  }

	  return function besseli(x, n) {
	    n = Math.round(n);
	    if(n === 0) return bessel0(x);
	    if(n == 1) return bessel1(x);
	    if(n < 0) throw 'BESSELI Order (' + n + ') must be nonnegative';
	    if(M.abs(x) === 0) return 0;

	    var ret, j, tox = 2 / M.abs(x), m, bip, bi, bim;
	    m=2*M.round((n+M.round(M.sqrt(40*n)))/2);
	    bip=ret=0.0;
	    bi=1.0;
	    for (j=m;j>0;j--) {
	      bim=j*tox*bi + bip;
	      bip=bi; bi=bim;
	      if (M.abs(bi) > 1E10) {
	        bi *= 1E-10;
	        bip *= 1E-10;
	        ret *= 1E-10;
	      }
	      if(j == n) ret = bip;
	    }
	    ret *= besseli(x, 0) / bi;
	    return x < 0 && (n%2) ? -ret : ret;
	  };

	})();

	var besselk = (function() {
	  var b0_a = [-0.57721566, 0.42278420, 0.23069756, 0.3488590e-1, 0.262698e-2, 0.10750e-3, 0.74e-5].reverse();
	  var b0_b = [1.25331414, -0.7832358e-1, 0.2189568e-1, -0.1062446e-1, 0.587872e-2, -0.251540e-2, 0.53208e-3].reverse();
	  function bessel0(x) {
	    if(x <= 2) return -M.log(x/2)*besseli(x,0) + _horner(b0_a, x*x/4);
	    return M.exp(-x)/M.sqrt(x)*_horner(b0_b, 2/x);
	  }

	  var b1_a = [1.0, 0.15443144, -0.67278579, -0.18156897, -0.1919402e-1, -0.110404e-2, -0.4686e-4].reverse();
	  var b1_b = [1.25331414, 0.23498619, -0.3655620e-1, 0.1504268e-1, -0.780353e-2, 0.325614e-2, -0.68245e-3].reverse();
	  function bessel1(x) {
	    if(x <= 2) return M.log(x/2)*besseli(x,1) + (1/x)*_horner(b1_a, x*x/4);
	    return M.exp(-x)/M.sqrt(x)*_horner(b1_b, 2/x);
	  }

	  return _bessel_wrap(bessel0, bessel1, 'BESSELK', 2, 1);
	})();
	if(true) {
	  exports.besselj = besselj;
	  exports.bessely = bessely;
	  exports.besseli = besseli;
	  exports.besselk = besselk;
	}



/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var utils = __webpack_require__(4);

	var d1900 = new Date(1900, 0, 1);
	var WEEK_STARTS = [
	  undefined,
	  0,
	  1,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  1,
	  2,
	  3,
	  4,
	  5,
	  6,
	  0
	];
	var WEEK_TYPES = [
	  [],
	  [1, 2, 3, 4, 5, 6, 7],
	  [7, 1, 2, 3, 4, 5, 6],
	  [6, 0, 1, 2, 3, 4, 5],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [7, 1, 2, 3, 4, 5, 6],
	  [6, 7, 1, 2, 3, 4, 5],
	  [5, 6, 7, 1, 2, 3, 4],
	  [4, 5, 6, 7, 1, 2, 3],
	  [3, 4, 5, 6, 7, 1, 2],
	  [2, 3, 4, 5, 6, 7, 1],
	  [1, 2, 3, 4, 5, 6, 7]
	];
	var WEEKEND_TYPES = [
	  [],
	  [6, 0],
	  [0, 1],
	  [1, 2],
	  [2, 3],
	  [3, 4],
	  [4, 5],
	  [5, 6],
	  undefined,
	  undefined,
	  undefined, [0, 0],
	  [1, 1],
	  [2, 2],
	  [3, 3],
	  [4, 4],
	  [5, 5],
	  [6, 6]
	];

	exports.DATE = function(year, month, day) {
	  year = utils.parseNumber(year);
	  month = utils.parseNumber(month);
	  day = utils.parseNumber(day);
	  if (utils.anyIsError(year, month, day)) {
	    return error.value;
	  }
	  if (year < 0 || month < 0 || day < 0) {
	    return error.num;
	  }
	  var date = new Date(year, month - 1, day);
	  return date;
	};

	exports.DATEVALUE = function(date_text) {
	  if (typeof date_text !== 'string') {
	    return error.value;
	  }
	  var date = Date.parse(date_text);
	  if (isNaN(date)) {
	    return error.value;
	  }
	  if (date <= -2203891200000) {
	    return (date - d1900) / 86400000 + 1;
	  }
	  return (date - d1900) / 86400000 + 2;
	};

	exports.DAY = function(serial_number) {
	  var date = utils.parseDate(serial_number);
	  if (date instanceof Error) {
	    return date;
	  }
	  return date.getDate();
	};

	exports.DAYS = function(end_date, start_date) {
	  end_date = utils.parseDate(end_date);
	  start_date = utils.parseDate(start_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  return serial(end_date) - serial(start_date);
	};

	exports.DAYS360 = function(start_date, end_date, method) {
	  method = utils.parseBool(method);
	  start_date = utils.parseDate(start_date);
	  end_date = utils.parseDate(end_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (method instanceof Error) {
	    return method;
	  }
	  var sm = start_date.getMonth();
	  var em = end_date.getMonth();
	  var sd, ed;
	  if (method) {
	    sd = start_date.getDate() === 31 ? 30 : start_date.getDate();
	    ed = end_date.getDate() === 31 ? 30 : end_date.getDate();
	  } else {
	    var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
	    var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
	    sd = start_date.getDate() === smd ? 30 : start_date.getDate();
	    if (end_date.getDate() === emd) {
	      if (sd < 30) {
	        em++;
	        ed = 1;
	      } else {
	        ed = 30;
	      }
	    } else {
	      ed = end_date.getDate();
	    }
	  }
	  return 360 * (end_date.getFullYear() - start_date.getFullYear()) +
	    30 * (em - sm) + (ed - sd);
	};

	exports.EDATE = function(start_date, months) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (isNaN(months)) {
	    return error.value;
	  }
	  months = parseInt(months, 10);
	  start_date.setMonth(start_date.getMonth() + months);
	  return serial(start_date);
	};

	exports.EOMONTH = function(start_date, months) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (isNaN(months)) {
	    return error.value;
	  }
	  months = parseInt(months, 10);
	  return serial(new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0));
	};

	exports.HOUR = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getHours();
	};

	exports.INTERVAL = function (second) {
	  if (typeof second !== 'number' && typeof second !== 'string') {
	    return error.value;
	  } else {
	    second = parseInt(second, 10);
	  }

	  var year  = Math.floor(second/946080000);
	  second    = second%946080000;
	  var month = Math.floor(second/2592000);
	  second    = second%2592000;
	  var day   = Math.floor(second/86400);
	  second    = second%86400;

	  var hour  = Math.floor(second/3600);
	  second    = second%3600;
	  var min   = Math.floor(second/60);
	  second    = second%60;
	  var sec   = second;

	  year  = (year  > 0) ? year  + 'Y' : '';
	  month = (month > 0) ? month + 'M' : '';
	  day   = (day   > 0) ? day   + 'D' : '';
	  hour  = (hour  > 0) ? hour  + 'H' : '';
	  min   = (min   > 0) ? min   + 'M' : '';
	  sec   = (sec   > 0) ? sec   + 'S' : '';

	  return 'P' + year + month + day +
	  'T' + hour + min + sec;
	};

	exports.ISOWEEKNUM = function(date) {
	  date = utils.parseDate(date);
	  if (date instanceof Error) {
	    return date;
	  }

	  date.setHours(0, 0, 0);
	  date.setDate(date.getDate() + 4 - (date.getDay() || 7));
	  var yearStart = new Date(date.getFullYear(), 0, 1);
	  return Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
	};

	exports.MINUTE = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getMinutes();
	};

	exports.MONTH = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getMonth() + 1;
	};

	exports.NETWORKDAYS = function(start_date, end_date, holidays) {
	  return this.NETWORKDAYS.INTL(start_date, end_date, 1, holidays);
	};

	exports.NETWORKDAYS.INTL = function(start_date, end_date, weekend, holidays) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  end_date = utils.parseDate(end_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (weekend === undefined) {
	    weekend = WEEKEND_TYPES[1];
	  } else {
	    weekend = WEEKEND_TYPES[weekend];
	  }
	  if (!(weekend instanceof Array)) {
	    return error.value;
	  }
	  if (holidays === undefined) {
	    holidays = [];
	  } else if (!(holidays instanceof Array)) {
	    holidays = [holidays];
	  }
	  for (var i = 0; i < holidays.length; i++) {
	    var h = utils.parseDate(holidays[i]);
	    if (h instanceof Error) {
	      return h;
	    }
	    holidays[i] = h;
	  }
	  var days = (end_date - start_date) / (1000 * 60 * 60 * 24) + 1;
	  var total = days;
	  var day = start_date;
	  for (i = 0; i < days; i++) {
	    var d = (new Date().getTimezoneOffset() > 0) ? day.getUTCDay() : day.getDay();
	    var dec = false;
	    if (d === weekend[0] || d === weekend[1]) {
	      dec = true;
	    }
	    for (var j = 0; j < holidays.length; j++) {
	      var holiday = holidays[j];
	      if (holiday.getDate() === day.getDate() &&
	        holiday.getMonth() === day.getMonth() &&
	        holiday.getFullYear() === day.getFullYear()) {
	        dec = true;
	        break;
	      }
	    }
	    if (dec) {
	      total--;
	    }
	    day.setDate(day.getDate() + 1);
	  }
	  return total;
	};

	exports.NOW = function() {
	  return new Date();
	};

	exports.SECOND = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getSeconds();
	};

	exports.TIME = function(hour, minute, second) {
	  hour = utils.parseNumber(hour);
	  minute = utils.parseNumber(minute);
	  second = utils.parseNumber(second);
	  if (utils.anyIsError(hour, minute, second)) {
	    return error.value;
	  }
	  if (hour < 0 || minute < 0 || second < 0) {
	    return error.num;
	  }
	  return (3600 * hour + 60 * minute + second) / 86400;
	};

	exports.TIMEVALUE = function(time_text) {
	  time_text = utils.parseDate(time_text);
	  if (time_text instanceof Error) {
	    return time_text;
	  }
	  return (3600 * time_text.getHours() +
	    60 * time_text.getMinutes() +
	    time_text.getSeconds()) / 86400;
	};

	exports.TODAY = function() {
	  return new Date();
	};

	exports.WEEKDAY = function(serial_number, return_type) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  if (return_type === undefined) {
	    return_type = 1;
	  }
	  var day = serial_number.getDay();
	  return WEEK_TYPES[return_type][day];
	};

	exports.WEEKNUM = function(serial_number, return_type) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  if (return_type === undefined) {
	    return_type = 1;
	  }
	  if (return_type === 21) {
	    return this.ISOWEEKNUM(serial_number);
	  }
	  var week_start = WEEK_STARTS[return_type];
	  var jan = new Date(serial_number.getFullYear(), 0, 1);
	  var inc = jan.getDay() < week_start ? 1 : 0;
	  jan -= Math.abs(jan.getDay() - week_start) * 24 * 60 * 60 * 1000;
	  return Math.floor(((serial_number - jan) / (1000 * 60 * 60 * 24)) / 7 + 1) + inc;
	};

	exports.WORKDAY = function(start_date, days, holidays) {
	  return this.WORKDAY.INTL(start_date, days, 1, holidays);
	};

	exports.WORKDAY.INTL = function(start_date, days, weekend, holidays) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  days = utils.parseNumber(days);
	  if (days instanceof Error) {
	    return days;
	  }
	  if (days < 0) {
	    return error.num;
	  }
	  if (weekend === undefined) {
	    weekend = WEEKEND_TYPES[1];
	  } else {
	    weekend = WEEKEND_TYPES[weekend];
	  }
	  if (!(weekend instanceof Array)) {
	    return error.value;
	  }
	  if (holidays === undefined) {
	    holidays = [];
	  } else if (!(holidays instanceof Array)) {
	    holidays = [holidays];
	  }
	  for (var i = 0; i < holidays.length; i++) {
	    var h = utils.parseDate(holidays[i]);
	    if (h instanceof Error) {
	      return h;
	    }
	    holidays[i] = h;
	  }
	  var d = 0;
	  while (d < days) {
	    start_date.setDate(start_date.getDate() + 1);
	    var day = start_date.getDay();
	    if (day === weekend[0] || day === weekend[1]) {
	      continue;
	    }
	    for (var j = 0; j < holidays.length; j++) {
	      var holiday = holidays[j];
	      if (holiday.getDate() === start_date.getDate() &&
	        holiday.getMonth() === start_date.getMonth() &&
	        holiday.getFullYear() === start_date.getFullYear()) {
	        d--;
	        break;
	      }
	    }
	    d++;
	  }
	  return start_date;
	};

	exports.YEAR = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getFullYear();
	};

	function isLeapYear(year) {
	  return new Date(year, 1, 29).getMonth() === 1;
	}

	// TODO : Use DAYS ?
	function daysBetween(start_date, end_date) {
	  return Math.ceil((end_date - start_date) / 1000 / 60 / 60 / 24);
	}

	exports.YEARFRAC = function(start_date, end_date, basis) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  end_date = utils.parseDate(end_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }

	  basis = basis || 0;
	  var sd = start_date.getDate();
	  var sm = start_date.getMonth() + 1;
	  var sy = start_date.getFullYear();
	  var ed = end_date.getDate();
	  var em = end_date.getMonth() + 1;
	  var ey = end_date.getFullYear();

	  switch (basis) {
	    case 0:
	      // US (NASD) 30/360
	      if (sd === 31 && ed === 31) {
	        sd = 30;
	        ed = 30;
	      } else if (sd === 31) {
	        sd = 30;
	      } else if (sd === 30 && ed === 31) {
	        ed = 30;
	      }
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	    case 1:
	      // Actual/actual
	      var feb29Between = function(date1, date2) {
	        var year1 = date1.getFullYear();
	        var mar1year1 = new Date(year1, 2, 1);
	        if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
	          return true;
	        }
	        var year2 = date2.getFullYear();
	        var mar1year2 = new Date(year2, 2, 1);
	        return (isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2);
	      };
	      var ylength = 365;
	      if (sy === ey || ((sy + 1) === ey) && ((sm > em) || ((sm === em) && (sd >= ed)))) {
	        if ((sy === ey && isLeapYear(sy)) ||
	            feb29Between(start_date, end_date) ||
	            (em === 1 && ed === 29)) {
	          ylength = 366;
	        }
	        return daysBetween(start_date, end_date) / ylength;
	      }
	      var years = (ey - sy) + 1;
	      var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;
	      var average = days / years;
	      return daysBetween(start_date, end_date) / average;
	    case 2:
	      // Actual/360
	      return daysBetween(start_date, end_date) / 360;
	    case 3:
	      // Actual/365
	      return daysBetween(start_date, end_date) / 365;
	    case 4:
	      // European 30/360
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	  }
	};

	function serial(date) {
	  var addOn = (date > -2203891200000)?2:1;
	  return (date - d1900) / 86400000 + addOn;
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var stats = __webpack_require__(6);
	var maths = __webpack_require__(2);
	var utils = __webpack_require__(4);

	function compact(array) {
	  if (!array) { return array; }
	  var result = [];
	  for (var i = 0; i < array.length; ++i) {
	    if (!array[i]) { continue; }
	    result.push(array[i]);
	  }
	  return result;
	}

	exports.FINDFIELD = function(database, title) {
	  var index = null;
	  for (var i = 0; i < database.length; i++) {
	    if (database[i][0] === title) {
	      index = i;
	      break;
	    }
	  }

	  // Return error if the input field title is incorrect
	  if (index == null) {
	    return error.value;
	  }
	  return index;
	};

	function findResultIndex(database, criterias) {
	  var matches = {};
	  for (var i = 1; i < database[0].length; ++i) {
	    matches[i] = true;
	  }
	  var maxCriteriaLength = criterias[0].length;
	  for (i = 1; i < criterias.length; ++i) {
	    if (criterias[i].length > maxCriteriaLength) {
	      maxCriteriaLength = criterias[i].length;
	    }
	  }

	  for (var k = 1; k < database.length; ++k) {
	    for (var l = 1; l < database[k].length; ++l) {
	      var currentCriteriaResult = false;
	      var hasMatchingCriteria   = false;
	      for (var j = 0; j < criterias.length; ++j) {
	        var criteria = criterias[j];
	        if (criteria.length < maxCriteriaLength) {
	          continue;
	        }

	        var criteriaField = criteria[0];
	        if (database[k][0] !== criteriaField) {
	          continue;
	        }
	        hasMatchingCriteria = true;
	        for (var p = 1; p < criteria.length; ++p) {
	          currentCriteriaResult = currentCriteriaResult || eval(database[k][l] + criteria[p]);  // jshint ignore:line
	        }
	      }
	      if (hasMatchingCriteria) {
	        matches[l] = matches[l] && currentCriteriaResult;
	      }
	    }
	  }

	  var result = [];
	  for (var n = 0; n < database[0].length; ++n) {
	    if (matches[n]) {
	      result.push(n - 1);
	    }
	  }
	  return result;
	}

	// Database functions
	exports.DAVERAGE = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var sum = 0;
	  for (var i = 0; i < resultIndexes.length; i++) {
	    sum += targetFields[resultIndexes[i]];
	  }
	  return resultIndexes.length === 0 ? error.div0 : sum / resultIndexes.length;
	};

	exports.DCOUNT = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.COUNT(targetValues);
	};

	exports.DCOUNTA = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.COUNTA(targetValues);
	};

	exports.DGET = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  // Return error if no record meets the criteria
	  if (resultIndexes.length === 0) {
	    return error.value;
	  }
	  // Returns the #NUM! error value because more than one record meets the
	  // criteria
	  if (resultIndexes.length > 1) {
	    return error.num;
	  }

	  return targetFields[resultIndexes[0]];
	};

	exports.DMAX = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var maxValue = targetFields[resultIndexes[0]];
	  for (var i = 1; i < resultIndexes.length; i++) {
	    if (maxValue < targetFields[resultIndexes[i]]) {
	      maxValue = targetFields[resultIndexes[i]];
	    }
	  }
	  return maxValue;
	};

	exports.DMIN = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var minValue = targetFields[resultIndexes[0]];
	  for (var i = 1; i < resultIndexes.length; i++) {
	    if (minValue > targetFields[resultIndexes[i]]) {
	      minValue = targetFields[resultIndexes[i]];
	    }
	  }
	  return minValue;
	};

	exports.DPRODUCT = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  var result = 1;
	  for (i = 0; i < targetValues.length; i++) {
	    result *= targetValues[i];
	  }
	  return result;
	};

	exports.DSTDEV = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  return stats.STDEV.S(targetValues);
	};

	exports.DSTDEVP = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  return stats.STDEV.P(targetValues);
	};

	exports.DSUM = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return maths.SUM(targetValues);
	};

	exports.DVAR = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.VAR.S(targetValues);
	};

	exports.DVARP = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.VAR.P(targetValues);
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var utils = __webpack_require__(4);
	var information = __webpack_require__(11);

	exports.AND = function() {
	  var args = utils.flatten(arguments);
	  var result = true;
	  for (var i = 0; i < args.length; i++) {
	    if (!args[i]) {
	      result = false;
	    }
	  }
	  return result;
	};

	exports.CHOOSE = function() {
	  if (arguments.length < 2) {
	    return error.na;
	  }

	  var index = arguments[0];
	  if (index < 1 || index > 254) {
	    return error.value;
	  }

	  if (arguments.length < index + 1) {
	    return error.value;
	  }

	  return arguments[index];
	};

	exports.FALSE = function() {
	  return false;
	};

	exports.IF = function(test, then_value, otherwise_value) {
	  return test ? then_value : otherwise_value;
	};

	exports.IFERROR = function(value, valueIfError) {
	  if (information.ISERROR(value)) {
	    return valueIfError;
	  }
	  return value;
	};

	exports.IFNA = function(value, value_if_na) {
	  return value === error.na ? value_if_na : value;
	};

	exports.NOT = function(logical) {
	  return !logical;
	};

	exports.OR = function() {
	  var args = utils.flatten(arguments);
	  var result = false;
	  for (var i = 0; i < args.length; i++) {
	    if (args[i]) {
	      result = true;
	    }
	  }
	  return result;
	};

	exports.TRUE = function() {
	  return true;
	};

	exports.XOR = function() {
	  var args = utils.flatten(arguments);
	  var result = 0;
	  for (var i = 0; i < args.length; i++) {
	    if (args[i]) {
	      result++;
	    }
	  }
	  return (Math.floor(Math.abs(result)) & 1) ? true : false;
	};

	exports.SWITCH = function () {
	  var result;
	  if (arguments.length > 0)  {
	    var targetValue = arguments[0];
	    var argc = arguments.length - 1;
	    var switchCount = Math.floor(argc / 2);
	    var switchSatisfied = false;
	    var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];

	    if (switchCount) {
	      for (var index = 0; index < switchCount; index++) {
	        if (targetValue === arguments[index * 2 + 1]) {
	          result = arguments[index * 2 + 2];
	          switchSatisfied = true;
	          break;
	        }
	      }
	    }

	    if (!switchSatisfied && defaultClause) {
	      result = defaultClause;
	    }
	  }

	  return result;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var dateTime = __webpack_require__(14);
	var utils = __webpack_require__(4);

	function validDate(d) {
	  return d && d.getTime && !isNaN(d.getTime());
	}

	function ensureDate(d) {
	  return (d instanceof Date)?d:new Date(d);
	}

	exports.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
	  // Return error if either date is invalid
	  issue      = ensureDate(issue);
	  first      = ensureDate(first);
	  settlement = ensureDate(settlement);
	  if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {
	    return '#VALUE!';
	  }

	  // Return error if either rate or par are lower than or equal to zero
	  if (rate <= 0 || par <= 0) {
	    return '#NUM!';
	  }

	  // Return error if frequency is neither 1, 2, or 4
	  if ([1, 2, 4].indexOf(frequency) === -1) {
	    return '#NUM!';
	  }

	  // Return error if basis is neither 0, 1, 2, 3, or 4
	  if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
	    return '#NUM!';
	  }

	  // Return error if settlement is before or equal to issue
	  if (settlement <= issue) {
	    return '#NUM!';
	  }

	  // Set default values
	  par   = par   || 0;
	  basis = basis || 0;

	  // Compute accrued interest
	  return par * rate * dateTime.YEARFRAC(issue, settlement, basis);
	};

	// TODO
	exports.ACCRINTM = function() {
	 throw new Error('ACCRINTM is not implemented');
	};

	// TODO
	exports.AMORDEGRC = function() {
	 throw new Error('AMORDEGRC is not implemented');
	};

	// TODO
	exports.AMORLINC = function() {
	 throw new Error('AMORLINC is not implemented');
	};

	// TODO
	exports.COUPDAYBS = function() {
	 throw new Error('COUPDAYBS is not implemented');
	};

	// TODO
	exports.COUPDAYS = function() {
	 throw new Error('COUPDAYS is not implemented');
	};

	// TODO
	exports.COUPDAYSNC = function() {
	 throw new Error('COUPDAYSNC is not implemented');
	};

	// TODO
	exports.COUPNCD = function() {
	 throw new Error('COUPNCD is not implemented');
	};

	// TODO
	exports.COUPNUM = function() {
	 throw new Error('COUPNUM is not implemented');
	};

	// TODO
	exports.COUPPCD = function() {
	 throw new Error('COUPPCD is not implemented');
	};

	exports.CUMIPMT = function(rate, periods, value, start, end, type) {
	  // Credits: algorithm inspired by Apache OpenOffice
	  // Credits: Hannes Stiebitzhofer for the translations of function and variable names
	  // Requires exports.FV() and exports.PMT() from exports.js [http://stoic.com/exports/]

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, periods, value)) {
	    return error.value;
	  }

	  // Return error if either rate, periods, or value are lower than or equal to zero
	  if (rate <= 0 || periods <= 0 || value <= 0) {
	    return error.num;
	  }

	  // Return error if start < 1, end < 1, or start > end
	  if (start < 1 || end < 1 || start > end) {
	    return error.num;
	  }

	  // Return error if type is neither 0 nor 1
	  if (type !== 0 && type !== 1) {
	    return error.num;
	  }

	  // Compute cumulative interest
	  var payment = exports.PMT(rate, periods, value, 0, type);
	  var interest = 0;

	  if (start === 1) {
	    if (type === 0) {
	      interest = -value;
	      start++;
	    }
	  }

	  for (var i = start; i <= end; i++) {
	    if (type === 1) {
	      interest += exports.FV(rate, i - 2, payment, value, 1) - payment;
	    } else {
	      interest += exports.FV(rate, i - 1, payment, value, 0);
	    }
	  }
	  interest *= rate;

	  // Return cumulative interest
	  return interest;
	};

	exports.CUMPRINC = function(rate, periods, value, start, end, type) {
	  // Credits: algorithm inspired by Apache OpenOffice
	  // Credits: Hannes Stiebitzhofer for the translations of function and variable names

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, periods, value)) {
	    return error.value;
	  }

	  // Return error if either rate, periods, or value are lower than or equal to zero
	  if (rate <= 0 || periods <= 0 || value <= 0) {
	    return error.num;
	  }

	  // Return error if start < 1, end < 1, or start > end
	  if (start < 1 || end < 1 || start > end) {
	    return error.num;
	  }

	  // Return error if type is neither 0 nor 1
	  if (type !== 0 && type !== 1) {
	    return error.num;
	  }

	  // Compute cumulative principal
	  var payment = exports.PMT(rate, periods, value, 0, type);
	  var principal = 0;
	  if (start === 1) {
	    if (type === 0) {
	      principal = payment + value * rate;
	    } else {
	      principal = payment;
	    }
	    start++;
	  }
	  for (var i = start; i <= end; i++) {
	    if (type > 0) {
	      principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;
	    } else {
	      principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;
	    }
	  }

	  // Return cumulative principal
	  return principal;
	};

	exports.DB = function(cost, salvage, life, period, month) {
	  // Initialize month
	  month = (month === undefined) ? 12 : month;

	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  month = utils.parseNumber(month);
	  if (utils.anyIsError(cost, salvage, life, period, month)) {
	    return error.value;
	  }

	  // Return error if any of the parameters is negative
	  if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
	    return error.num;
	  }

	  // Return error if month is not an integer between 1 and 12
	  if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
	    return error.num;
	  }

	  // Return error if period is greater than life
	  if (period > life) {
	    return error.num;
	  }

	  // Return 0 (zero) if salvage is greater than or equal to cost
	  if (salvage >= cost) {
	    return 0;
	  }

	  // Rate is rounded to three decimals places
	  var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);

	  // Compute initial depreciation
	  var initial = cost * rate * month / 12;

	  // Compute total depreciation
	  var total = initial;
	  var current = 0;
	  var ceiling = (period === life) ? life - 1 : period;
	  for (var i = 2; i <= ceiling; i++) {
	    current = (cost - total) * rate;
	    total += current;
	  }

	  // Depreciation for the first and last periods are special cases
	  if (period === 1) {
	    // First period
	    return initial;
	  } else if (period === life) {
	    // Last period
	    return (cost - total) * rate;
	  } else {
	    return current;
	  }
	};

	exports.DDB = function(cost, salvage, life, period, factor) {
	  // Initialize factor
	  factor = (factor === undefined) ? 2 : factor;

	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  factor = utils.parseNumber(factor);
	  if (utils.anyIsError(cost, salvage, life, period, factor)) {
	    return error.value;
	  }

	  // Return error if any of the parameters is negative or if factor is null
	  if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
	    return error.num;
	  }

	  // Return error if period is greater than life
	  if (period > life) {
	    return error.num;
	  }

	  // Return 0 (zero) if salvage is greater than or equal to cost
	  if (salvage >= cost) {
	    return 0;
	  }

	  // Compute depreciation
	  var total = 0;
	  var current = 0;
	  for (var i = 1; i <= period; i++) {
	    current = Math.min((cost - total) * (factor / life), (cost - salvage - total));
	    total += current;
	  }

	  // Return depreciation
	  return current;
	};

	// TODO
	exports.DISC = function() {
	 throw new Error('DISC is not implemented');
	};

	exports.DOLLARDE = function(dollar, fraction) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  dollar = utils.parseNumber(dollar);
	  fraction = utils.parseNumber(fraction);
	  if (utils.anyIsError(dollar, fraction)) {
	    return error.value;
	  }

	  // Return error if fraction is negative
	  if (fraction < 0) {
	    return error.num;
	  }

	  // Return error if fraction is greater than or equal to 0 and less than 1
	  if (fraction >= 0 && fraction < 1) {
	    return error.div0;
	  }

	  // Truncate fraction if it is not an integer
	  fraction = parseInt(fraction, 10);

	  // Compute integer part
	  var result = parseInt(dollar, 10);

	  // Add decimal part
	  result += (dollar % 1) * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;

	  // Round result
	  var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
	  result = Math.round(result * power) / power;

	  // Return converted dollar price
	  return result;
	};

	exports.DOLLARFR = function(dollar, fraction) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  dollar = utils.parseNumber(dollar);
	  fraction = utils.parseNumber(fraction);
	  if (utils.anyIsError(dollar, fraction)) {
	    return error.value;
	  }

	  // Return error if fraction is negative
	  if (fraction < 0) {
	    return error.num;
	  }

	  // Return error if fraction is greater than or equal to 0 and less than 1
	  if (fraction >= 0 && fraction < 1) {
	    return error.div0;
	  }

	  // Truncate fraction if it is not an integer
	  fraction = parseInt(fraction, 10);

	  // Compute integer part
	  var result = parseInt(dollar, 10);

	  // Add decimal part
	  result += (dollar % 1) * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;

	  // Return converted dollar price
	  return result;
	};

	// TODO
	exports.DURATION = function() {
	 throw new Error('DURATION is not implemented');
	};

	exports.EFFECT = function(rate, periods) {
	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  if (utils.anyIsError(rate, periods)) {
	    return error.value;
	  }

	  // Return error if rate <=0 or periods < 1
	  if (rate <= 0 || periods < 1) {
	    return error.num;
	  }

	  // Truncate periods if it is not an integer
	  periods = parseInt(periods, 10);

	  // Return effective annual interest rate
	  return Math.pow(1 + rate / periods, periods) - 1;
	};

	exports.FV = function(rate, periods, payment, value, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  value = value || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  value = utils.parseNumber(value);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, payment, value, type)) {
	    return error.value;
	  }

	  // Return future value
	  var result;
	  if (rate === 0) {
	    result = value + payment * periods;
	  } else {
	    var term = Math.pow(1 + rate, periods);
	    if (type === 1) {
	      result = value * term + payment * (1 + rate) * (term - 1) / rate;
	    } else {
	      result = value * term + payment * (term - 1) / rate;
	    }
	  }
	  return -result;
	};

	exports.FVSCHEDULE = function(principal, schedule) {
	  principal = utils.parseNumber(principal);
	  schedule = utils.parseNumberArray(utils.flatten(schedule));
	  if (utils.anyIsError(principal, schedule)) {
	    return error.value;
	  }

	  var n = schedule.length;
	  var future = principal;

	  // Apply all interests in schedule
	  for (var i = 0; i < n; i++) {
	    // Apply scheduled interest
	    future *= 1 + schedule[i];
	  }

	  // Return future value
	  return future;
	};

	// TODO
	exports.INTRATE = function() {
	 throw new Error('INTRATE is not implemented');
	};

	exports.IPMT = function(rate, period, periods, present, future, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  period = utils.parseNumber(period);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, period, periods, present, future, type)) {
	    return error.value;
	  }

	  // Compute payment
	  var payment = exports.PMT(rate, periods, present, future, type);

	  // Compute interest
	  var interest;
	  if (period === 1) {
	    if (type === 1) {
	      interest = 0;
	    } else {
	      interest = -present;
	    }
	  } else {
	    if (type === 1) {
	      interest = exports.FV(rate, period - 2, payment, present, 1) - payment;
	    } else {
	      interest = exports.FV(rate, period - 1, payment, present, 0);
	    }
	  }

	  // Return interest
	  return interest * rate;
	};

	exports.IRR = function(values, guess) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  guess = guess || 0;

	  values = utils.parseNumberArray(utils.flatten(values));
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(values, guess)) {
	    return error.value;
	  }

	  // Calculates the resulting amount
	  var irrResult = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = values[0];
	    for (var i = 1; i < values.length; i++) {
	      result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);
	    }
	    return result;
	  };

	  // Calculates the first derivation
	  var irrResultDeriv = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = 0;
	    for (var i = 1; i < values.length; i++) {
	      var frac = (dates[i] - dates[0]) / 365;
	      result -= frac * values[i] / Math.pow(r, frac + 1);
	    }
	    return result;
	  };

	  // Initialize dates and check that values contains at least one positive value and one negative value
	  var dates = [];
	  var positive = false;
	  var negative = false;
	  for (var i = 0; i < values.length; i++) {
	    dates[i] = (i === 0) ? 0 : dates[i - 1] + 365;
	    if (values[i] > 0) {
	      positive = true;
	    }
	    if (values[i] < 0) {
	      negative = true;
	    }
	  }

	  // Return error if values does not contain at least one positive value and one negative value
	  if (!positive || !negative) {
	    return error.num;
	  }

	  // Initialize guess and resultRate
	  guess = (guess === undefined) ? 0.1 : guess;
	  var resultRate = guess;

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-10;

	  // Implement Newton's method
	  var newRate, epsRate, resultValue;
	  var contLoop = true;
	  do {
	    resultValue = irrResult(values, dates, resultRate);
	    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
	    epsRate = Math.abs(newRate - resultRate);
	    resultRate = newRate;
	    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
	  } while (contLoop);

	  // Return internal rate of return
	  return resultRate;
	};

	exports.ISPMT = function(rate, period, periods, value) {
	  rate = utils.parseNumber(rate);
	  period = utils.parseNumber(period);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, period, periods, value)) {
	    return error.value;
	  }

	  // Return interest
	  return value * rate * (period / periods - 1);
	};

	// TODO
	exports.MDURATION = function() {
	 throw new Error('MDURATION is not implemented');
	};

	exports.MIRR = function(values, finance_rate, reinvest_rate) {
	  values = utils.parseNumberArray(utils.flatten(values));
	  finance_rate = utils.parseNumber(finance_rate);
	  reinvest_rate = utils.parseNumber(reinvest_rate);
	  if (utils.anyIsError(values, finance_rate, reinvest_rate)) {
	    return error.value;
	  }

	  // Initialize number of values
	  var n = values.length;

	  // Lookup payments (negative values) and incomes (positive values)
	  var payments = [];
	  var incomes = [];
	  for (var i = 0; i < n; i++) {
	    if (values[i] < 0) {
	      payments.push(values[i]);
	    } else {
	      incomes.push(values[i]);
	    }
	  }

	  // Return modified internal rate of return
	  var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);
	  var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);
	  return Math.pow(num / den, 1 / (n - 1)) - 1;
	};

	exports.NOMINAL = function(rate, periods) {
	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  if (utils.anyIsError(rate, periods)) {
	    return error.value;
	  }

	  // Return error if rate <=0 or periods < 1
	  if (rate <= 0 || periods < 1) {
	    return error.num;
	  }

	  // Truncate periods if it is not an integer
	  periods = parseInt(periods, 10);

	  // Return nominal annual interest rate
	  return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
	};

	exports.NPER = function(rate, payment, present, future, type) {
	  type = (type === undefined) ? 0 : type;
	  future = (future === undefined) ? 0 : future;

	  rate = utils.parseNumber(rate);
	  payment = utils.parseNumber(payment);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, payment, present, future, type)) {
	    return error.value;
	  }

	  // Return number of periods
	  var num = payment * (1 + rate * type) - future * rate;
	  var den = (present * rate + payment * (1 + rate * type));
	  return Math.log(num / den) / Math.log(1 + rate);
	};

	exports.NPV = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }

	  // Lookup rate
	  var rate = args[0];

	  // Initialize net present value
	  var value = 0;

	  // Loop on all values
	  for (var j = 1; j < args.length; j++) {
	    value += args[j] / Math.pow(1 + rate, j);
	  }

	  // Return net present value
	  return value;
	};

	// TODO
	exports.ODDFPRICE = function() {
	 throw new Error('ODDFPRICE is not implemented');
	};

	// TODO
	exports.ODDFYIELD = function() {
	 throw new Error('ODDFYIELD is not implemented');
	};

	// TODO
	exports.ODDLPRICE = function() {
	 throw new Error('ODDLPRICE is not implemented');
	};

	// TODO
	exports.ODDLYIELD = function() {
	 throw new Error('ODDLYIELD is not implemented');
	};

	exports.PDURATION = function(rate, present, future) {
	  rate = utils.parseNumber(rate);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  if (utils.anyIsError(rate, present, future)) {
	    return error.value;
	  }

	  // Return error if rate <=0
	  if (rate <= 0) {
	    return error.num;
	  }

	  // Return number of periods
	  return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
	};

	exports.PMT = function(rate, periods, present, future, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, present, future, type)) {
	    return error.value;
	  }

	  // Return payment
	  var result;
	  if (rate === 0) {
	    result = (present + future) / periods;
	  } else {
	    var term = Math.pow(1 + rate, periods);
	    if (type === 1) {
	      result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
	    } else {
	      result = future * rate / (term - 1) + present * rate / (1 - 1 / term);
	    }
	  }
	  return -result;
	};

	exports.PPMT = function(rate, period, periods, present, future, type) {
	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, present, future, type)) {
	    return error.value;
	  }

	  return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);
	};

	// TODO
	exports.PRICE = function() {
	 throw new Error('PRICE is not implemented');
	};

	// TODO
	exports.PRICEDISC = function() {
	 throw new Error('PRICEDISC is not implemented');
	};

	// TODO
	exports.PRICEMAT = function() {
	 throw new Error('PRICEMAT is not implemented');
	};

	exports.PV = function(rate, periods, payment, future, type) {
	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, payment, future, type)) {
	    return error.value;
	  }

	  // Return present value
	  if (rate === 0) {
	    return -payment * periods - future;
	  } else {
	    return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
	  }
	};

	exports.RATE = function(periods, payment, present, future, type, guess) {
	  // Credits: rabugento

	  guess = (guess === undefined) ? 0.01 : guess;
	  future = (future === undefined) ? 0 : future;
	  type = (type === undefined) ? 0 : type;

	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(periods, payment, present, future, type, guess)) {
	    return error.value;
	  }

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-6;

	  // Set maximum number of iterations
	  var iterMax = 100;
	  var iter = 0;
	  var close = false;
	  var rate = guess;

	  while (iter < iterMax && !close) {
	    var t1 = Math.pow(rate + 1, periods);
	    var t2 = Math.pow(rate + 1, periods - 1);

	    var f1 = future + t1 * present + payment * (t1 - 1) * (rate * type + 1) / rate;
	    var f2 = periods * t2 * present - payment * (t1 - 1) *(rate * type + 1) / Math.pow(rate,2);
	    var f3 = periods * payment * t2 * (rate * type + 1) / rate + payment * (t1 - 1) * type / rate;

	    var newRate = rate - f1 / (f2 + f3);

	    if (Math.abs(newRate - rate) < epsMax) close = true;
	    iter++
	    rate = newRate;
	  }

	  if (!close) return Number.NaN + rate;
	  return rate;
	};

	// TODO
	exports.RECEIVED = function() {
	 throw new Error('RECEIVED is not implemented');
	};

	exports.RRI = function(periods, present, future) {
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  if (utils.anyIsError(periods, present, future)) {
	    return error.value;
	  }

	  // Return error if periods or present is equal to 0 (zero)
	  if (periods === 0 || present === 0) {
	    return error.num;
	  }

	  // Return equivalent interest rate
	  return Math.pow(future / present, 1 / periods) - 1;
	};

	exports.SLN = function(cost, salvage, life) {
	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  if (utils.anyIsError(cost, salvage, life)) {
	    return error.value;
	  }

	  // Return error if life equal to 0 (zero)
	  if (life === 0) {
	    return error.num;
	  }

	  // Return straight-line depreciation
	  return (cost - salvage) / life;
	};

	exports.SYD = function(cost, salvage, life, period) {
	  // Return error if any of the parameters is not a number
	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  if (utils.anyIsError(cost, salvage, life, period)) {
	    return error.value;
	  }

	  // Return error if life equal to 0 (zero)
	  if (life === 0) {
	    return error.num;
	  }

	  // Return error if period is lower than 1 or greater than life
	  if (period < 1 || period > life) {
	    return error.num;
	  }

	  // Truncate period if it is not an integer
	  period = parseInt(period, 10);

	  // Return straight-line depreciation
	  return ((cost - salvage) * (life - period + 1) * 2) / (life * (life + 1));
	};

	exports.TBILLEQ = function(settlement, maturity, discount) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  discount = utils.parseNumber(discount);
	  if (utils.anyIsError(settlement, maturity, discount)) {
	    return error.value;
	  }

	  // Return error if discount is lower than or equal to zero
	  if (discount <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return (365 * discount) / (360 - discount * dateTime.DAYS360(settlement, maturity, false));
	};

	exports.TBILLPRICE = function(settlement, maturity, discount) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  discount = utils.parseNumber(discount);
	  if (utils.anyIsError(settlement, maturity, discount)) {
	    return error.value;
	  }

	  // Return error if discount is lower than or equal to zero
	  if (discount <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return 100 * (1 - discount * dateTime.DAYS360(settlement, maturity, false) / 360);
	};

	exports.TBILLYIELD = function(settlement, maturity, price) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  price = utils.parseNumber(price);
	  if (utils.anyIsError(settlement, maturity, price)) {
	    return error.value;
	  }

	  // Return error if price is lower than or equal to zero
	  if (price <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return (100 - price) * 360 / (price * dateTime.DAYS360(settlement, maturity, false));
	};

	// TODO
	exports.VDB = function() {
	 throw new Error('VDB is not implemented');
	};


	exports.XIRR = function(values, dates, guess) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  values = utils.parseNumberArray(utils.flatten(values));
	  dates = utils.parseDateArray(utils.flatten(dates));
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(values, dates, guess)) {
	    return error.value;
	  }

	  // Calculates the resulting amount
	  var irrResult = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = values[0];
	    for (var i = 1; i < values.length; i++) {
	      result += values[i] / Math.pow(r, dateTime.DAYS(dates[i], dates[0]) / 365);
	    }
	    return result;
	  };

	  // Calculates the first derivation
	  var irrResultDeriv = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = 0;
	    for (var i = 1; i < values.length; i++) {
	      var frac = dateTime.DAYS(dates[i], dates[0]) / 365;
	      result -= frac * values[i] / Math.pow(r, frac + 1);
	    }
	    return result;
	  };

	  // Check that values contains at least one positive value and one negative value
	  var positive = false;
	  var negative = false;
	  for (var i = 0; i < values.length; i++) {
	    if (values[i] > 0) {
	      positive = true;
	    }
	    if (values[i] < 0) {
	      negative = true;
	    }
	  }

	  // Return error if values does not contain at least one positive value and one negative value
	  if (!positive || !negative) {
	    return error.num;
	  }

	  // Initialize guess and resultRate
	  guess = guess || 0.1;
	  var resultRate = guess;

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-10;

	  // Implement Newton's method
	  var newRate, epsRate, resultValue;
	  var contLoop = true;
	  do {
	    resultValue = irrResult(values, dates, resultRate);
	    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
	    epsRate = Math.abs(newRate - resultRate);
	    resultRate = newRate;
	    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
	  } while (contLoop);

	  // Return internal rate of return
	  return resultRate;
	};

	exports.XNPV = function(rate, values, dates) {
	  rate = utils.parseNumber(rate);
	  values = utils.parseNumberArray(utils.flatten(values));
	  dates = utils.parseDateArray(utils.flatten(dates));
	  if (utils.anyIsError(rate, values, dates)) {
	    return error.value;
	  }

	  var result = 0;
	  for (var i = 0; i < values.length; i++) {
	    result += values[i] / Math.pow(1 + rate, dateTime.DAYS(dates[i], dates[0]) / 365);
	  }
	  return result;
	};

	// TODO
	exports.YIELD = function() {
	 throw new Error('YIELD is not implemented');
	};

	// TODO
	exports.YIELDDISC = function() {
	 throw new Error('YIELDDISC is not implemented');
	};

	// TODO
	exports.YIELDMAT = function() {
	 throw new Error('YIELDMAT is not implemented');
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	exports.MATCH = function(lookupValue, lookupArray, matchType) {
	  if (!lookupValue && !lookupArray) {
	    return error.na;
	  }

	  if (arguments.length === 2) {
	    matchType = 1;
	  }
	  if (!(lookupArray instanceof Array)) {
	    return error.na;
	  }

	  if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
	    return error.na;
	  }
	  var index;
	  var indexValue;
	  for (var idx = 0; idx < lookupArray.length; idx++) {
	    if (matchType === 1) {
	      if (lookupArray[idx] === lookupValue) {
	        return idx + 1;
	      } else if (lookupArray[idx] < lookupValue) {
	        if (!indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        } else if (lookupArray[idx] > indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        }
	      }
	    } else if (matchType === 0) {
	      if (typeof lookupValue === 'string') {
	        lookupValue = lookupValue.replace(/\?/g, '.');
	        if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
	          return idx + 1;
	        }
	      } else {
	        if (lookupArray[idx] === lookupValue) {
	          return idx + 1;
	        }
	      }
	    } else if (matchType === -1) {
	      if (lookupArray[idx] === lookupValue) {
	        return idx + 1;
	      } else if (lookupArray[idx] > lookupValue) {
	        if (!indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        } else if (lookupArray[idx] < indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        }
	      }
	    }
	  }

	  return index ? index : error.na;
	};

/***/ }
/******/ ])
});
;
},{"jStat":2,"numeral":3,"numeric":4}],2:[function(require,module,exports){
this.j$ = this.jStat = (function(Math, undefined) {

// For quick reference.
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

// Calculate correction for IEEE error
// TODO: This calculation can be improved.
function calcRdx(n, m) {
  var val = n > m ? n : m;
  return Math.pow(10,
                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));
}


var isArray = Array.isArray || function isArray(arg) {
  return toString.call(arg) === '[object Array]';
};


function isFunction(arg) {
  return toString.call(arg) === '[object Function]';
}


function isNumber(arg) {
  return typeof arg === 'number' && arg === arg;
}


// Converts the jStat matrix to vector.
function toVector(arr) {
  return concat.apply([], arr);
}


// The one and only jStat constructor.
function jStat() {
  return new jStat._init(arguments);
}


// TODO: Remove after all references in src files have been removed.
jStat.fn = jStat.prototype;


// By separating the initializer from the constructor it's easier to handle
// always returning a new instance whether "new" was used or not.
jStat._init = function _init(args) {
  var i;

  // If first argument is an array, must be vector or matrix.
  if (isArray(args[0])) {
    // Check if matrix.
    if (isArray(args[0][0])) {
      // See if a mapping function was also passed.
      if (isFunction(args[1]))
        args[0] = jStat.map(args[0], args[1]);
      // Iterate over each is faster than this.push.apply(this, args[0].
      for (i = 0; i < args[0].length; i++)
        this[i] = args[0][i];
      this.length = args[0].length;

    // Otherwise must be a vector.
    } else {
      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];
      this.length = 1;
    }

  // If first argument is number, assume creation of sequence.
  } else if (isNumber(args[0])) {
    this[0] = jStat.seq.apply(null, args);
    this.length = 1;

  // Handle case when jStat object is passed to jStat.
  } else if (args[0] instanceof jStat) {
    // Duplicate the object and pass it back.
    return jStat(args[0].toArray());

  // Unexpected argument value, return empty jStat object.
  // TODO: This is strange behavior. Shouldn't this throw or some such to let
  // the user know they had bad arguments?
  } else {
    this[0] = [];
    this.length = 1;
  }

  return this;
};
jStat._init.prototype = jStat.prototype;
jStat._init.constructor = jStat;


// Utility functions.
// TODO: for internal use only?
jStat.utils = {
  calcRdx: calcRdx,
  isArray: isArray,
  isFunction: isFunction,
  isNumber: isNumber,
  toVector: toVector
};


// Easily extend the jStat object.
// TODO: is this seriously necessary?
jStat.extend = function extend(obj) {
  var i, j;

  if (arguments.length === 1) {
    for (j in obj)
      jStat[j] = obj[j];
    return this;
  }

  for (i = 1; i < arguments.length; i++) {
    for (j in arguments[i])
      obj[j] = arguments[i][j];
  }

  return obj;
};


// Returns the number of rows in the matrix.
jStat.rows = function rows(arr) {
  return arr.length || 1;
};


// Returns the number of columns in the matrix.
jStat.cols = function cols(arr) {
  return arr[0].length || 1;
};


// Returns the dimensions of the object { rows: i, cols: j }
jStat.dimensions = function dimensions(arr) {
  return {
    rows: jStat.rows(arr),
    cols: jStat.cols(arr)
  };
};


// Returns a specified row as a vector
jStat.row = function row(arr, index) {
  return arr[index];
};


// Returns the specified column as a vector
jStat.col = function cols(arr, index) {
  var column = new Array(arr.length);
  for (var i = 0; i < arr.length; i++)
    column[i] = [arr[i][index]];
  return column;
};


// Returns the diagonal of the matrix
jStat.diag = function diag(arr) {
  var nrow = jStat.rows(arr);
  var res = new Array(nrow);
  for (var row = 0; row < nrow; row++)
    res[row] = [arr[row][row]];
  return res;
};


// Returns the anti-diagonal of the matrix
jStat.antidiag = function antidiag(arr) {
  var nrow = jStat.rows(arr) - 1;
  var res = new Array(nrow);
  for (var i = 0; nrow >= 0; nrow--, i++)
    res[i] = [arr[i][nrow]];
  return res;
};

// Transpose a matrix or array.
jStat.transpose = function transpose(arr) {
  var obj = [];
  var objArr, rows, cols, j, i;

  // Make sure arr is in matrix format.
  if (!isArray(arr[0]))
    arr = [arr];

  rows = arr.length;
  cols = arr[0].length;

  for (i = 0; i < cols; i++) {
    objArr = new Array(rows);
    for (j = 0; j < rows; j++)
      objArr[j] = arr[j][i];
    obj.push(objArr);
  }

  // If obj is vector, return only single array.
  return obj.length === 1 ? obj[0] : obj;
};


// Map a function to an array or array of arrays.
// "toAlter" is an internal variable.
jStat.map = function map(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    for (col = 0; col < ncol; col++)
      res[row][col] = func(arr[row][col], row, col);
  }

  return res.length === 1 ? res[0] : res;
};


// Destructively alter an array.
jStat.alter = function alter(arr, func) {
  return jStat.map(arr, func, true);
};


// Generate a rows x cols matrix according to the supplied function.
jStat.create = function  create(rows, cols, func) {
  var res = new Array(rows);
  var i, j;

  if (isFunction(cols)) {
    func = cols;
    cols = rows;
  }

  for (i = 0; i < rows; i++) {
    res[i] = new Array(cols);
    for (j = 0; j < cols; j++)
      res[i][j] = func(i, j);
  }

  return res;
};


function retZero() { return 0; }


// Generate a rows x cols matrix of zeros.
jStat.zeros = function zeros(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retZero);
};


function retOne() { return 1; }


// Generate a rows x cols matrix of ones.
jStat.ones = function ones(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retOne);
};


// Generate a rows x cols matrix of uniformly random numbers.
jStat.rand = function rand(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, Math.random);
};


function retIdent(i, j) { return i === j ? 1 : 0; }


// Generate an identity matrix of size row x cols.
jStat.identity = function identity(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retIdent);
};


// Tests whether a matrix is symmetric
jStat.symmetric = function symmetric(arr) {
  var issymmetric = true;
  var size = arr.length;
  var row, col;

  if (arr.length !== arr[0].length)
    return false;

  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++)
      if (arr[col][row] !== arr[row][col])
        return false;
  }

  return true;
};


// Set all values to zero.
jStat.clear = function clear(arr) {
  return jStat.alter(arr, retZero);
};


// Generate sequence.
jStat.seq = function seq(min, max, length, func) {
  if (!isFunction(func))
    func = false;

  var arr = [];
  var hival = calcRdx(min, max);
  var step = (max * hival - min * hival) / ((length - 1) * hival);
  var current = min;
  var cnt;

  // Current is assigned using a technique to compensate for IEEE error.
  // TODO: Needs better implementation.
  for (cnt = 0;
       current <= max;
       cnt++, current = (min * hival + step * hival * cnt) / hival) {
    arr.push((func ? func(current, cnt) : current));
  }

  return arr;
};


// TODO: Go over this entire implementation. Seems a tragic waste of resources
// doing all this work. Instead, and while ugly, use new Function() to generate
// a custom function for each static method.

// Quick reference.
var jProto = jStat.prototype;

// Default length.
jProto.length = 0;

// For internal use only.
// TODO: Check if they're actually used, and if they are then rename them
// to _*
jProto.push = Array.prototype.push;
jProto.sort = Array.prototype.sort;
jProto.splice = Array.prototype.splice;
jProto.slice = Array.prototype.slice;


// Return a clean array.
jProto.toArray = function toArray() {
  return this.length > 1 ? slice.call(this) : slice.call(this)[0];
};


// Map a function to a matrix or vector.
jProto.map = function map(func, toAlter) {
  return jStat(jStat.map(this, func, toAlter));
};


// Destructively alter an array.
jProto.alter = function alter(func) {
  jStat.alter(this, func);
  return this;
};


// Extend prototype with methods that have no argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(func) {
      var self = this,
      results;
      // Check for callback.
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self));
        });
        return this;
      }
      results = jStat[passfunc](this);
      return isArray(results) ? jStat(results) : results;
    };
  })(funcs[i]);
})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));


// Extend prototype with methods that have one argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(index, func) {
      var self = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self, index));
        });
        return this;
      }
      return jStat(jStat[passfunc](this, index));
    };
  })(funcs[i]);
})('row col'.split(' '));


// Extend prototype with simple shortcut methods.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = new Function(
        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');
  })(funcs[i]);
})('create zeros ones rand identity'.split(' '));


// Exposing jStat.
return jStat;

}(Math));
(function(jStat, Math) {

var isFunction = jStat.utils.isFunction;

// Ascending functions for sort
function ascNum(a, b) { return a - b; }

function clip(arg, min, max) {
  return Math.max(min, Math.min(arg, max));
}


// sum of an array
jStat.sum = function sum(arr) {
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};


// sum squared
jStat.sumsqrd = function sumsqrd(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i] * arr[i];
  return sum;
};


// sum of squared errors of prediction (SSE)
jStat.sumsqerr = function sumsqerr(arr) {
  var mean = jStat.mean(arr);
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0) {
    tmp = arr[i] - mean;
    sum += tmp * tmp;
  }
  return sum;
};


// product of an array
jStat.product = function product(arr) {
  var prod = 1;
  var i = arr.length;
  while (--i >= 0)
    prod *= arr[i];
  return prod;
};


// minimum value of an array
jStat.min = function min(arr) {
  var low = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] < low)
      low = arr[i];
  return low;
};


// maximum value of an array
jStat.max = function max(arr) {
  var high = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] > high)
      high = arr[i];
  return high;
};


// mean value of an array
jStat.mean = function mean(arr) {
  return jStat.sum(arr) / arr.length;
};


// mean squared error (MSE)
jStat.meansqerr = function meansqerr(arr) {
  return jStat.sumsqerr(arr) / arr.length;
};


// geometric mean of an array
jStat.geomean = function geomean(arr) {
  return Math.pow(jStat.product(arr), 1 / arr.length);
};


// median of an array
jStat.median = function median(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  // check if array is even or odd, then return the appropriate
  return !(arrlen & 1)
    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2
    : _arr[(arrlen / 2) | 0 ];
};


// cumulative sum of an array
jStat.cumsum = function cumsum(arr) {
  var len = arr.length;
  var sums = new Array(len);
  var i;
  sums[0] = arr[0];
  for (i = 1; i < len; i++)
    sums[i] = sums[i - 1] + arr[i];
  return sums;
};


// successive differences of a sequence
jStat.diff = function diff(arr) {
  var diffs = [];
  var arrLen = arr.length;
  var i;
  for (i = 1; i < arrLen; i++)
    diffs.push(arr[i] - arr[i - 1]);
  return diffs;
};


// mode of an array
// if there are multiple modes of an array, return all of them
// is this the appropriate way of handling it?
jStat.mode = function mode(arr) {
  var arrLen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  var count = 1;
  var maxCount = 0;
  var numMaxCount = 0;
  var mode_arr = [];
  var i;

  for (i = 0; i < arrLen; i++) {
    if (_arr[i] === _arr[i + 1]) {
      count++;
    } else {
      if (count > maxCount) {
        mode_arr = [_arr[i]];
        maxCount = count;
        numMaxCount = 0;
      }
      // are there multiple max counts
      else if (count === maxCount) {
        mode_arr.push(_arr[i]);
        numMaxCount++;
      }
      // resetting count for new value in array
      count = 1;
    }
  }

  return numMaxCount === 0 ? mode_arr[0] : mode_arr;
};


// range of an array
jStat.range = function range(arr) {
  return jStat.max(arr) - jStat.min(arr);
};

// variance of an array
// flag indicates population vs sample
jStat.variance = function variance(arr, flag) {
  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
};


// standard deviation of an array
// flag indicates population vs sample
jStat.stdev = function stdev(arr, flag) {
  return Math.sqrt(jStat.variance(arr, flag));
};


// mean deviation (mean absolute deviation) of an array
jStat.meandev = function meandev(arr) {
  var devSum = 0;
  var mean = jStat.mean(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - mean);
  return devSum / arr.length;
};


// median deviation (median absolute deviation) of an array
jStat.meddev = function meddev(arr) {
  var devSum = 0;
  var median = jStat.median(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - median);
  return devSum / arr.length;
};


// coefficient of variation
jStat.coeffvar = function coeffvar(arr) {
  return jStat.stdev(arr) / jStat.mean(arr);
};


// quartiles of an array
jStat.quartiles = function quartiles(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  return [
    _arr[ Math.round((arrlen) / 4) - 1 ],
    _arr[ Math.round((arrlen) / 2) - 1 ],
    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]
  ];
};


// Arbitary quantiles of an array. Direct port of the scipy.stats
// implementation by Pierre GF Gerard-Marchant.
jStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
  var sortedArray = arr.slice().sort(ascNum);
  var quantileVals = [quantilesArray.length];
  var n = arr.length;
  var i, p, m, aleph, k, gamma;

  if (typeof alphap === 'undefined')
    alphap = 3 / 8;
  if (typeof betap === 'undefined')
    betap = 3 / 8;

  for (i = 0; i < quantilesArray.length; i++) {
    p = quantilesArray[i];
    m = alphap + p * (1 - alphap - betap);
    aleph = n * p + m;
    k = Math.floor(clip(aleph, 1, n - 1));
    gamma = clip(aleph - k, 0, 1);
    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
  }

  return quantileVals;
};

// The percentile rank of score in a given array. Returns the percentage
// of all values in the input array that are less than (kind='strict') or
// less or equal than (kind='weak') score. Default is weak.
jStat.percentileOfScore = function percentileOfScore(arr, score, kind) {
  var counter = 0;
  var len = arr.length;
  var strict = false;
  var value, i;

  if (kind === 'strict')
    strict = true;

  for (i = 0; i < len; i++) {
    value = arr[i];
    if ((strict && value < score) ||
        (!strict && value <= score)) {
      counter++;
    }
  }

  return counter / len;
};

// covariance of two arrays
jStat.covariance = function covariance(arr1, arr2) {
  var u = jStat.mean(arr1);
  var v = jStat.mean(arr2);
  var arr1Len = arr1.length;
  var sq_dev = new Array(arr1Len);
  var i;

  for (i = 0; i < arr1Len; i++)
    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);

  return jStat.sum(sq_dev) / (arr1Len - 1);
};


// (pearson's) population correlation coefficient, rho
jStat.corrcoeff = function corrcoeff(arr1, arr2) {
  return jStat.covariance(arr1, arr2) /
      jStat.stdev(arr1, 1) /
      jStat.stdev(arr2, 1);
};


var jProto = jStat.prototype;


// Extend jProto with method for calculating cumulative sums, as it does not
// run again in case of true.
// If a matrix is passed, automatically assume operation should be done on the
// columns.
jProto.cumsum = function(fullbool, func) {
  var arr = [];
  var i = 0;
  var tmpthis = this;

  // Assignment reassignation depending on how parameters were passed in.
  if (isFunction(fullbool)) {
    func = fullbool;
    fullbool = false;
  }

  // Check if a callback was passed with the function.
  if (func) {
    setTimeout(function() {
      func.call(tmpthis, jProto.cumsum.call(tmpthis, fullbool));
    });
    return this;
  }

  // Check if matrix and run calculations.
  if (this.length > 1) {
    tmpthis = fullbool === true ? this : this.transpose();
    for (; i < tmpthis.length; i++)
      arr[i] = jStat.cumsum(tmpthis[i]);
    return arr;
  }

  return jStat.cumsum(this[0], fullbool);
};


// Extend jProto with methods which don't require arguments and work on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return fullbool === true
            ? jStat[passfunc](jStat.utils.toVector(arr))
            : arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('sum sumsqrd sumsqerr product min max mean meansqerr geomean median diff ' +
    'mode range variance stdev meandev meddev coeffvar quartiles').split(' '));


// Extend jProto with functions that take arguments. Operations on matrices are
// done on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function() {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      var args = Array.prototype.slice.call(arguments);

      // If the last argument is a function, we assume it's a callback; we
      // strip the callback out and call the function again.
      if (isFunction(args[args.length - 1])) {
        var callbackFunction = args[args.length - 1];
        var argsToPass = args.slice(0, args.length - 1);

        setTimeout(function() {
          callbackFunction.call(tmpthis,
                                jProto[passfunc].apply(tmpthis, argsToPass));
        });
        return this;

      // Otherwise we curry the function args and call normally.
      } else {
        var callbackFunction = undefined;
        var curriedFunction = function curriedFunction(vector) {
          return jStat[passfunc].apply(tmpthis, [vector].concat(args));
        }
      }

      // If this is a matrix, run column-by-column.
      if (this.length > 1) {
        tmpthis = tmpthis.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = curriedFunction(tmpthis[i]);
        return arr;
      }

      // Otherwise run on the vector.
      return curriedFunction(this[0]);
    };
  })(funcs[i]);
})('quantiles percentileOfScore'.split(' '));

}(this.jStat, Math));
// Special functions //
(function(jStat, Math) {

// Log-gamma function
jStat.gammaln = function gammaln(x) {
  var j = 0;
  var cof = [
    76.18009172947146, -86.50532032941677, 24.01409824083091,
    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
  ];
  var ser = 1.000000000190015;
  var xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++)
    ser += cof[j] / ++y;
  return Math.log(2.5066282746310005 * ser / xx) - tmp;
};


// gamma of x
jStat.gammafn = function gammafn(x) {
  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,
           629.3311553128184, 866.9662027904133, -31451.272968848367,
           -36144.413418691176, 66456.14382024054
  ];
  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,
           -3107.771671572311, 22538.118420980151, 4755.8462775278811,
           -134659.9598649693, -115132.2596755535];
  var fact = false;
  var n = 0;
  var xden = 0;
  var xnum = 0;
  var y = x;
  var i, z, yi, res, sum, ysq;
  if (y <= 0) {
    res = y % 1 + 3.6e-16;
    if (res) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  yi = y;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  for (i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
};


// lower incomplete gamma function P(a,x)
jStat.gammap = function gammap(a, x) {
  var aln = jStat.gammaln(a);
  var ap = a;
  var sum = 1 / a;
  var del = sum;
  var b = x + 1 - a;
  var c = 1 / 1.0e-30;
  var d = 1 / b;
  var h = d;
  var i = 1;
  // calculate maximum number of itterations required for a
  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  var an, endval;

  if (x < 0 || a <= 0) {
    return NaN;
  } else if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      sum += del *= x / ++ap;
    }
    return sum * Math.exp(-x + a * Math.log(x) - (aln));
  }

  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= d * c;
  }

  return 1 - h * Math.exp(-x + a * Math.log(x) - (aln));
};


// natural log factorial of n
jStat.factorialln = function factorialln(n) {
  return n < 0 ? NaN : jStat.gammaln(n + 1);
};

// factorial of n
jStat.factorial = function factorial(n) {
  return n < 0 ? NaN : jStat.gammafn(n + 1);
};

// combinations of n, m
jStat.combination = function combination(n, m) {
  // make sure n or m don't exceed the upper limit of usable values
  return (n > 170 || m > 170)
      ? Math.exp(jStat.combinationln(n, m))
      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);
};


jStat.combinationln = function combinationln(n, m){
  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);
};


// permutations of n, m
jStat.permutation = function permutation(n, m) {
  return jStat.factorial(n) / jStat.factorial(n - m);
};


// beta function
jStat.betafn = function betafn(x, y) {
  // ensure arguments are positive
  if (x <= 0 || y <= 0)
    return undefined;
  // make sure x + y doesn't exceed the upper limit of usable values
  return (x + y > 170)
      ? Math.exp(jStat.betaln(x, y))
      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);
};


// natural logarithm of beta function
jStat.betaln = function betaln(x, y) {
  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);
};


// Evaluates the continued fraction for incomplete beta function by modified
// Lentz's method.
jStat.betacf = function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;

  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h = d;

  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7)
      break;
  }

  return h;
};


// Returns the inverse incomplte gamma function
jStat.gammapinv = function gammapinv(p, a) {
  var j = 0;
  var a1 = a - 1;
  var EPS = 1e-8;
  var gln = jStat.gammaln(a);
  var x, err, t, u, pp, lna1, afac;

  if (p >= 1)
    return Math.max(100, a + 100 * Math.sqrt(a));
  if (p <= 0)
    return 0;
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    x = Math.max(1e-3,
                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t)
      x = Math.pow(p / t, 1 / a);
    else
      x = 1 - Math.log(1 - (p - t) / (1 - t));
  }

  for(; j < 12; j++) {
    if (x <= 0)
      return 0;
    err = jStat.gammap(a, x) - p;
    if (a > 1)
      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    else
      t = Math.exp(-x + a1 * Math.log(x) - gln);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (Math.abs(t) < EPS * x)
      break;
  }

  return x;
};


// Returns the error function erf(x)
jStat.erf = function erf(x) {
  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,
             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,
             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,
             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,
             -6.886027e-12, 8.94487e-13, 3.13092e-13,
             -1.12708e-13, 3.81e-16, 7.106e-15,
             -1.523e-15, -9.4e-17, 1.21e-16,
             -2.8e-17];
  var j = cof.length - 1;
  var isneg = false;
  var d = 0;
  var dd = 0;
  var t, ty, tmp, res;

  if (x < 0) {
    x = -x;
    isneg = true;
  }

  t = 2 / (2 + x);
  ty = 4 * t - 2;

  for(; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }

  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
  return isneg ? res - 1 : 1 - res;
};


// Returns the complmentary error function erfc(x)
jStat.erfc = function erfc(x) {
  return 1 - jStat.erf(x);
};


// Returns the inverse of the complementary error function
jStat.erfcinv = function erfcinv(p) {
  var j = 0;
  var x, err, t, pp;
  if (p >= 2)
    return -100;
  if (p <= 0)
    return 100;
  pp = (p < 1) ? p : 2 - p;
  t = Math.sqrt(-2 * Math.log(pp / 2));
  x = -0.70711 * ((2.30753 + t * 0.27061) /
                  (1 + t * (0.99229 + t * 0.04481)) - t);
  for (; j < 2; j++) {
    err = jStat.erfc(x) - pp;
    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
  }
  return (p < 1) ? x : -x;
};


// Returns the inverse of the incomplete beta function
jStat.ibetainv = function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0)
    return 0;
  if (p >= 1)
    return 1;
  if (a >= 1 && b >= 1) {
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));
    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *
        (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w)
      x = Math.pow(a * w * p, 1 / a);
    else
      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
  }
  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);
  for(; j < 10; j++) {
    if (x === 0 || x === 1)
      return x;
    err = jStat.ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (x >= 1)
      x = 0.5 * (x + t + 1);
    if (Math.abs(t) < EPS * x && j > 0)
      break;
  }
  return x;
};


// Returns the incomplete beta function I_x(a,b)
jStat.ibeta = function ibeta(x, a, b) {
  // Factors in front of the continued fraction.
  var bt = (x === 0 || x === 1) ?  0 :
    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -
             jStat.gammaln(b) + a * Math.log(x) + b *
             Math.log(1 - x));
  if (x < 0 || x > 1)
    return false;
  if (x < (a + 1) / (a + b + 2))
    // Use continued fraction directly.
    return bt * jStat.betacf(x, a, b) / a;
  // else use continued fraction after making the symmetry transformation.
  return 1 - bt * jStat.betacf(1 - x, b, a) / b;
};


// Returns a normal deviate (mu=0, sigma=1).
// If n and m are specified it returns a object of normal deviates.
jStat.randn = function randn(n, m) {
  var u, v, x, y, q, mat;
  if (!m)
    m = n;
  if (n)
    return jStat.create(n, m, function() { return jStat.randn(); });
  do {
    u = Math.random();
    v = 1.7156 * (Math.random() - 0.5);
    x = u - 0.449871;
    y = Math.abs(v) + 0.386595;
    q = x * x + y * (0.19600 * y - 0.25472 * x);
  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));
  return v / u;
};


// Returns a gamma deviate by the method of Marsaglia and Tsang.
jStat.randg = function randg(shape, n, m) {
  var oalph = shape;
  var a1, a2, u, v, x, mat;
  if (!m)
    m = n;
  if (!shape)
    shape = 1;
  if (n) {
    mat = jStat.zeros(n,m);
    mat.alter(function() { return jStat.randg(shape); });
    return mat;
  }
  if (shape < 1)
    shape += 1;
  a1 = shape - 1 / 3;
  a2 = 1 / Math.sqrt(9 * a1);
  do {
    do {
      x = jStat.randn();
      v = 1 + a2 * x;
    } while(v <= 0);
    v = v * v * v;
    u = Math.random();
  } while(u > 1 - 0.331 * Math.pow(x, 4) &&
          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));
  // alpha > 1
  if (shape == oalph)
    return a1 * v;
  // alpha < 1
  do {
    u = Math.random();
  } while(u === 0);
  return Math.pow(u, 1 / oalph) * a1 * v;
};


// making use of static methods on the instance
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(
          jStat.map(this, function(value) { return jStat[passfunc](value); }));
    }
  })(funcs[i]);
})('gammaln gammafn factorial factorialln'.split(' '));


(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(jStat[passfunc].apply(null, arguments));
    };
  })(funcs[i]);
})('randn'.split(' '));

}(this.jStat, Math));
(function(jStat, Math) {

// generate all distribution instance methods
(function(list) {
  for (var i = 0; i < list.length; i++) (function(func) {
    // distribution instance method
    jStat[func] = function(a, b, c) {
      if (!(this instanceof arguments.callee))
        return new arguments.callee(a, b, c);
      this._a = a;
      this._b = b;
      this._c = c;
      return this;
    };
    // distribution method to be used on a jStat instance
    jStat.fn[func] = function(a, b, c) {
      var newthis = jStat[func](a, b, c);
      newthis.data = this;
      return newthis;
    };
    // sample instance method
    jStat[func].prototype.sample = function(arr) {
      var a = this._a;
      var b = this._b;
      var c = this._c;
      if (arr)
        return jStat.alter(arr, function() {
          return jStat[func].sample(a, b, c);
        });
      else
        return jStat[func].sample(a, b, c);
    };
    // generate the pdf, cdf and inv instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function(x) {
          var a = this._a;
          var b = this._b;
          var c = this._c;
          if (!x && x !== 0)
            x = this.data;
          if (typeof x !== 'number') {
            return jStat.fn.map.call(x, function(x) {
              return jStat[func][fnfunc](x, a, b, c);
            });
          }
          return jStat[func][fnfunc](x, a, b, c);
        };
      })(vals[i]);
    })('pdf cdf inv'.split(' '));
    // generate the mean, median, mode and variance instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function() {
          return jStat[func][fnfunc](this._a, this._b, this._c);
        };
      })(vals[i]);
    })('mean median mode variance'.split(' '));
  })(list[i]);
})((
  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +
  'lognormal normal pareto studentt weibull uniform  binomial negbin hypgeom ' +
  'poisson triangular'
).split(' '));



// extend beta function with static methods
jStat.extend(jStat.beta, {
  pdf: function pdf(x, alpha, beta) {
    // PDF is zero outside the support
    if (x > 1 || x < 0)
      return 0;
    // PDF is one for the uniform case
    if (alpha == 1 && beta == 1)
      return 1;

    if (alpha < 512 || beta < 512) {
      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /
          jStat.betafn(alpha, beta);
    } else {
      return Math.exp((alpha - 1) * Math.log(x) +
                      (beta - 1) * Math.log(1 - x) -
                      jStat.betaln(alpha, beta));
    }
  },

  cdf: function cdf(x, alpha, beta) {
    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);
  },

  inv: function inv(x, alpha, beta) {
    return jStat.ibetainv(x, alpha, beta);
  },

  mean: function mean(alpha, beta) {
    return alpha / (alpha + beta);
  },

  median: function median(alpha, beta) {
    throw new Error('median not yet implemented');
  },

  mode: function mode(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  },

  // return a random sample
  sample: function sample(alpha, beta) {
    var u = jStat.randg(alpha);
    return u / (u + jStat.randg(beta));
  },

  variance: function variance(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  }
});

// extend F function with static methods
jStat.extend(jStat.centralF, {
  pdf: function pdf(x, df1, df2) {
    if (x < 0)
      return undefined;
    return Math.sqrt((Math.pow(df1 * x, df1) * Math.pow(df2, df2)) /
                     (Math.pow(df1 * x + df2, df1 + df2))) /
                     (x * jStat.betafn(df1/2, df2/2));

  },

  cdf: function cdf(x, df1, df2) {
    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);
  },

  inv: function inv(x, df1, df2) {
    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));
  },

  mean: function mean(df1, df2) {
    return (df2 > 2) ? df2 / (df2 - 2) : undefined;
  },

  mode: function mode(df1, df2) {
    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;
  },

  // return a random sample
  sample: function sample(df1, df2) {
    var x1 = jStat.randg(df1 / 2) * 2;
    var x2 = jStat.randg(df2 / 2) * 2;
    return (x1 / df1) / (x2 / df2);
  },

  variance: function variance(df1, df2) {
    if (df2 <= 4)
      return undefined;
    return 2 * df2 * df2 * (df1 + df2 - 2) /
        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
  }
});


// extend cauchy function with static methods
jStat.extend(jStat.cauchy, {
  pdf: function pdf(x, local, scale) {
    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;
  },

  cdf: function cdf(x, local, scale) {
    return Math.atan((x - local) / scale) / Math.PI + 0.5;
  },

  inv: function(p, local, scale) {
    return local + scale * Math.tan(Math.PI * (p - 0.5));
  },

  median: function median(local, scale) {
    return local;
  },

  mode: function mode(local, scale) {
    return local;
  },

  sample: function sample(local, scale) {
    return jStat.randn() *
        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;
  }
});



// extend chisquare function with static methods
jStat.extend(jStat.chisquare, {
  pdf: function pdf(x, dof) {
    return Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *
                    Math.log(2) - jStat.gammaln(dof / 2));
  },

  cdf: function cdf(x, dof) {
    return jStat.gammap(dof / 2, x / 2);
  },

  inv: function(p, dof) {
    return 2 * jStat.gammapinv(p, 0.5 * dof);
  },

  mean : function(dof) {
    return dof;
  },

  // TODO: this is an approximation (is there a better way?)
  median: function median(dof) {
    return dof * Math.pow(1 - (2 / (9 * dof)), 3);
  },

  mode: function mode(dof) {
    return (dof - 2 > 0) ? dof - 2 : 0;
  },

  sample: function sample(dof) {
    return jStat.randg(dof / 2) * 2;
  },

  variance: function variance(dof) {
    return 2 * dof;
  }
});



// extend exponential function with static methods
jStat.extend(jStat.exponential, {
  pdf: function pdf(x, rate) {
    return x < 0 ? 0 : rate * Math.exp(-rate * x);
  },

  cdf: function cdf(x, rate) {
    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
  },

  inv: function(p, rate) {
    return -Math.log(1 - p) / rate;
  },

  mean : function(rate) {
    return 1 / rate;
  },

  median: function (rate) {
    return (1 / rate) * Math.log(2);
  },

  mode: function mode(rate) {
    return 0;
  },

  sample: function sample(rate) {
    return -1 / rate * Math.log(Math.random());
  },

  variance : function(rate) {
    return Math.pow(rate, -2);
  }
});



// extend gamma function with static methods
jStat.extend(jStat.gamma, {
  pdf: function pdf(x, shape, scale) {
    return Math.exp((shape - 1) * Math.log(x) - x / scale -
                    jStat.gammaln(shape) - shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    return jStat.gammap(shape, x / scale);
  },

  inv: function(p, shape, scale) {
    return jStat.gammapinv(p, shape) * scale;
  },

  mean : function(shape, scale) {
    return shape * scale;
  },

  mode: function mode(shape, scale) {
    if(shape > 1) return (shape - 1) * scale;
    return undefined;
  },

  sample: function sample(shape, scale) {
    return jStat.randg(shape) * scale;
  },

  variance: function variance(shape, scale) {
    return shape * scale * scale;
  }
});

// extend inverse gamma function with static methods
jStat.extend(jStat.invgamma, {
  pdf: function pdf(x, shape, scale) {
    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -
                    jStat.gammaln(shape) + shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    return 1 - jStat.gammap(shape, scale / x);
  },

  inv: function(p, shape, scale) {
    return scale / jStat.gammapinv(1 - p, shape);
  },

  mean : function(shape, scale) {
    return (shape > 1) ? scale / (shape - 1) : undefined;
  },

  mode: function mode(shape, scale) {
    return scale / (shape + 1);
  },

  sample: function sample(shape, scale) {
    return scale / jStat.randg(shape);
  },

  variance: function variance(shape, scale) {
    if (shape <= 2)
      return undefined;
    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
  }
});


// extend kumaraswamy function with static methods
jStat.extend(jStat.kumaraswamy, {
  pdf: function pdf(x, alpha, beta) {
    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *
                    Math.log(x) + (beta - 1) *
                    Math.log(1 - Math.pow(x, alpha)));
  },

  cdf: function cdf(x, alpha, beta) {
    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));
  },

  mean : function(alpha, beta) {
    return (beta * jStat.gammafn(1 + 1 / alpha) *
            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));
  },

  median: function median(alpha, beta) {
    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);
  },

  mode: function mode(alpha, beta) {
    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
      return undefined;
    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
  },

  variance: function variance(alpha, beta) {
    throw new Error('variance not yet implemented');
    // TODO: complete this
  }
});



// extend lognormal function with static methods
jStat.extend(jStat.lognormal, {
  pdf: function pdf(x, mu, sigma) {
    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -
                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /
                    (2 * sigma * sigma));
  },

  cdf: function cdf(x, mu, sigma) {
    return 0.5 +
        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));
  },

  inv: function(p, mu, sigma) {
    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);
  },

  mean: function mean(mu, sigma) {
    return Math.exp(mu + sigma * sigma / 2);
  },

  median: function median(mu, sigma) {
    return Math.exp(mu);
  },

  mode: function mode(mu, sigma) {
    return Math.exp(mu - sigma * sigma);
  },

  sample: function sample(mu, sigma) {
    return Math.exp(jStat.randn() * sigma + mu);
  },

  variance: function variance(mu, sigma) {
    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);
  }
});



// extend normal function with static methods
jStat.extend(jStat.normal, {
  pdf: function pdf(x, mean, std) {
    return Math.exp(-0.5 * Math.log(2 * Math.PI) -
                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
  },

  cdf: function cdf(x, mean, std) {
    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));
  },

  inv: function(p, mean, std) {
    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;
  },

  mean : function(mean, std) {
    return mean;
  },

  median: function median(mean, std) {
    return mean;
  },

  mode: function (mean, std) {
    return mean;
  },

  sample: function sample(mean, std) {
    return jStat.randn() * std + mean;
  },

  variance : function(mean, std) {
    return std * std;
  }
});



// extend pareto function with static methods
jStat.extend(jStat.pareto, {
  pdf: function pdf(x, scale, shape) {
    if (x <= scale)
      return undefined;
    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);
  },

  cdf: function cdf(x, scale, shape) {
    return 1 - Math.pow(scale / x, shape);
  },

  mean: function mean(scale, shape) {
    if (shape <= 1)
      return undefined;
    return (shape * Math.pow(scale, shape)) / (shape - 1);
  },

  median: function median(scale, shape) {
    return scale * (shape * Math.SQRT2);
  },

  mode: function mode(scale, shape) {
    return scale;
  },

  variance : function(scale, shape) {
    if (shape <= 2)
      return undefined;
    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));
  }
});



// extend studentt function with static methods
jStat.extend(jStat.studentt, {
  pdf: function pdf(x, dof) {
    return (jStat.gammafn((dof + 1) / 2) / (Math.sqrt(dof * Math.PI) *
        jStat.gammafn(dof / 2))) *
        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));
  },

  cdf: function cdf(x, dof) {
    var dof2 = dof / 2;
    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /
                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);
  },

  inv: function(p, dof) {
    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
    x = Math.sqrt(dof * (1 - x) / x);
    return (p > 0.5) ? x : -x;
  },

  mean: function mean(dof) {
    return (dof > 1) ? 0 : undefined;
  },

  median: function median(dof) {
    return 0;
  },

  mode: function mode(dof) {
    return 0;
  },

  sample: function sample(dof) {
    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));
  },

  variance: function variance(dof) {
    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;
  }
});



// extend weibull function with static methods
jStat.extend(jStat.weibull, {
  pdf: function pdf(x, scale, shape) {
    if (x < 0)
      return 0;
    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *
        Math.exp(-(Math.pow((x / scale), shape)));
  },

  cdf: function cdf(x, scale, shape) {
    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));
  },

  inv: function(p, scale, shape) {
    return scale * Math.pow(-Math.log(1 - p), 1 / shape);
  },

  mean : function(scale, shape) {
    return scale * jStat.gammafn(1 + 1 / shape);
  },

  median: function median(scale, shape) {
    return scale * Math.pow(Math.log(2), 1 / shape);
  },

  mode: function mode(scale, shape) {
    if (shape <= 1)
      return undefined;
    return scale * Math.pow((shape - 1) / shape, 1 / shape);
  },

  sample: function sample(scale, shape) {
    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);
  },

  variance: function variance(scale, shape) {
    return scale * scale * jStat.gammafn(1 + 2 / shape) -
        Math.pow(this.mean(scale, shape), 2);
  }
});



// extend uniform function with static methods
jStat.extend(jStat.uniform, {
  pdf: function pdf(x, a, b) {
    return (x < a || x > b) ? 0 : 1 / (b - a);
  },

  cdf: function cdf(x, a, b) {
    if (x < a)
      return 0;
    else if (x < b)
      return (x - a) / (b - a);
    return 1;
  },

  mean: function mean(a, b) {
    return 0.5 * (a + b);
  },

  median: function median(a, b) {
    return jStat.mean(a, b);
  },

  mode: function mode(a, b) {
    throw new Error('mode is not yet implemented');
  },

  sample: function sample(a, b) {
    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);
  },

  variance: function variance(a, b) {
    return Math.pow(b - a, 2) / 12;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.binomial, {
  pdf: function pdf(k, n, p) {
    return (p === 0 || p === 1) ?
      ((n * p) === k ? 1 : 0) :
      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  },

  cdf: function cdf(x, n, p) {
    var binomarr = [],
    k = 0;
    if (x < 0) {
      return 0;
    }
    if (x < n) {
      for (; k <= x; k++) {
        binomarr[ k ] = jStat.binomial.pdf(k, n, p);
      }
      return jStat.sum(binomarr);
    }
    return 1;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.negbin, {
  pdf: function pdf(k, r, p) {
    return k !== k | 0
      ? false
      : k < 0
        ? 0
        : jStat.combination(k + r - 1, r - 1) * Math.pow(1 - p, k) * Math.pow(p, r);
  },

  cdf: function cdf(x, r, p) {
    var sum = 0,
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sum += jStat.negbin.pdf(k, r, p);
    }
    return sum;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.hypgeom, {
  pdf: function pdf(k, N, m, n) {
    // Hypergeometric PDF.

    // A simplification of the CDF algorithm below.

    // k = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(k !== k | 0) {
      return false;
    } else if(k < 0 || k < m - (N - n)) {
      // It's impossible to have this few successes drawn.
      return 0;
    } else if(k > n || k > m) {
      // It's impossible to have this many successes drawn.
      return 0;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return jStat.hypgeom.pdf(n - k, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return jStat.hypgeom.pdf(m - k, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.pdf(k, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate product to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < k; i++) {
        // For every possible number of successes up to that observed...

        while(scaledPDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          scaledPDF *= 1 - (m / (N - samplesDone));

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledPDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledPDF));
    }
  },

  cdf: function cdf(x, N, m, n) {
    // Hypergeometric CDF.

    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
    // and comes from his hypergeometric test calculator at
    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.

    // x = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(x < 0 || x < m - (N - n)) {
      // It's impossible to have this few successes drawn or fewer.
      return 0;
    } else if(x >= n || x >= m) {
      // We will always have this many successes or fewer.
      return 1;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.cdf(x, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate sum to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // Holds the intermediate, scaled total CDF.
      var scaledCDF = 1;

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < x; i++) {
        // For every possible number of successes up to that observed...

        while(scaledCDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          var factor = 1 - (m / (N - samplesDone));

          scaledPDF *= factor;
          scaledCDF *= factor;

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));

        // Add to the CDF answer.
        scaledCDF += scaledPDF;
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledCDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledCDF));
    }
  }
});



// extend uniform function with static methods
jStat.extend(jStat.poisson, {
  pdf: function pdf(k, l) {
    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);
  },

  cdf: function cdf(x, l) {
    var sumarr = [],
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sumarr.push(jStat.poisson.pdf(k, l));
    }
    return jStat.sum(sumarr);
  },

  mean : function(l) {
    return l;
  },

  variance : function(l) {
    return l;
  },

  sample: function sample(l) {
    var p = 1, k = 0, L = Math.exp(-l);
    do {
      k++;
      p *= Math.random();
    } while (p > L);
    return k - 1;
  }
});

// extend triangular function with static methods
jStat.extend(jStat.triangular, {
  pdf: function pdf(x, a, b, c) {
    return (b <= a || c < a || c > b)
      ? undefined
      : (x < a || x > b)
        ? 0
        : (x <= c)
          ? (2 * (x - a)) / ((b - a) * (c - a))
          : (2 * (b - x)) / ((b - a) * (b - c));
  },

  cdf: function cdf(x, a, b, c) {
    if (b <= a || c < a || c > b)
      return undefined;
    if (x < a) {
      return 0;
    } else {
      if (x <= c)
        return Math.pow(x - a, 2) / ((b - a) * (c - a));
      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));
    }
    // never reach this
    return 1;
  },

  mean: function mean(a, b, c) {
    return (a + b + c) / 3;
  },

  median: function median(a, b, c) {
    if (c <= (a + b) / 2) {
      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);
    } else if (c > (a + b) / 2) {
      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);
    }
  },

  mode: function mode(a, b, c) {
    return c;
  },

  sample: function sample(a, b, c) {
    var u = Math.random();
    if (u < ((c - a) / (b - a)))
      return a + Math.sqrt(u * (b - a) * (c - a))
    return b - Math.sqrt((1 - u) * (b - a) * (b - c));
  },

  variance: function variance(a, b, c) {
    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
  }
});

}(this.jStat, Math));
/* Provides functions for the solution of linear system of equations, integration, extrapolation,
 * interpolation, eigenvalue problems, differential equations and PCA analysis. */

(function(jStat, Math) {

var push = Array.prototype.push;
var isArray = jStat.utils.isArray;

jStat.extend({

  // add a vector/matrix to a vector/matrix or scalar
  add: function add(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value + arg[row][col];
      });
    }
    return jStat.map(arr, function(value) { return value + arg; });
  },

  // subtract a vector or scalar from the vector
  subtract: function subtract(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value - arg[row][col] || 0;
      });
    }
    return jStat.map(arr, function(value) { return value - arg; });
  },

  // matrix division
  divide: function divide(arr, arg) {
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.multiply(arr, jStat.inv(arg));
    }
    return jStat.map(arr, function(value) { return value / arg; });
  },

  // matrix multiplication
  multiply: function multiply(arr, arg) {
    var row, col, nrescols, sum,
    nrow = arr.length,
    ncol = arr[0].length,
    res = jStat.zeros(nrow, nrescols = (isArray(arg)) ? arg[0].length : ncol),
    rescols = 0;
    if (isArray(arg)) {
      for (; rescols < nrescols; rescols++) {
        for (row = 0; row < nrow; row++) {
          sum = 0;
          for (col = 0; col < ncol; col++)
          sum += arr[row][col] * arg[col][rescols];
          res[row][rescols] = sum;
        }
      }
      return (nrow === 1 && rescols === 1) ? res[0][0] : res;
    }
    return jStat.map(arr, function(value) { return value * arg; });
  },

  // Returns the dot product of two matricies
  dot: function dot(arr, arg) {
    if (!isArray(arr[0])) arr = [ arr ];
    if (!isArray(arg[0])) arg = [ arg ];
    // convert column to row vector
    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,
    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,
    res = [],
    row = 0,
    nrow = left.length,
    ncol = left[0].length,
    sum, col;
    for (; row < nrow; row++) {
      res[row] = [];
      sum = 0;
      for (col = 0; col < ncol; col++)
      sum += left[row][col] * right[row][col];
      res[row] = sum;
    }
    return (res.length === 1) ? res[0] : res;
  },

  // raise every element by a scalar
  pow: function pow(arr, arg) {
    return jStat.map(arr, function(value) { return Math.pow(value, arg); });
  },

  // generate the absolute values of the vector
  abs: function abs(arr) {
    return jStat.map(arr, function(value) { return Math.abs(value); });
  },

  // computes the p-norm of the vector
  // In the case that a matrix is passed, uses the first row as the vector
  norm: function norm(arr, p) {
    var nnorm = 0,
    i = 0;
    // check the p-value of the norm, and set for most common case
    if (isNaN(p)) p = 2;
    // check if multi-dimensional array, and make vector correction
    if (isArray(arr[0])) arr = arr[0];
    // vector norm
    for (; i < arr.length; i++) {
      nnorm += Math.pow(Math.abs(arr[i]), p);
    }
    return Math.pow(nnorm, 1 / p);
  },

  // TODO: make compatible with matrices
  // computes the angle between two vectors in rads
  angle: function angle(arr, arg) {
    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));
  },

  // augment one matrix by another
  aug: function aug(a, b) {
    var newarr = a.slice(),
    i = 0;
    for (; i < newarr.length; i++) {
      push.apply(newarr[i], b[i]);
    }
    return newarr;
  },

  inv: function inv(a) {
    var rows = a.length,
    cols = a[0].length,
    b = jStat.identity(rows, cols),
    c = jStat.gauss_jordan(a, b),
    obj = [],
    i = 0,
    j;
    for (; i < rows; i++) {
      obj[i] = [];
      for (j = cols - 1; j < c[0].length; j++)
      obj[i][j - cols] = c[i][j];
    }
    return obj;
  },

  // calculate the determinant of a matrix
  det: function det(a) {
    var alen = a.length,
    alend = alen * 2,
    vals = new Array(alend),
    rowshift = alen - 1,
    colshift = alend - 1,
    mrow = rowshift - alen + 1,
    mcol = colshift,
    i = 0,
    result = 0,
    j;
    // check for special 2x2 case
    if (alen === 2) {
      return a[0][0] * a[1][1] - a[0][1] * a[1][0];
    }
    for (; i < alend; i++) {
      vals[i] = 1;
    }
    for (i = 0; i < alen; i++) {
      for (j = 0; j < alen; j++) {
        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];
        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];
        mrow++;
        mcol--;
      }
      mrow = --rowshift - alen + 1;
      mcol = --colshift;
    }
    for (i = 0; i < alen; i++) {
      result += vals[i];
    }
    for (; i < alend; i++) {
      result -= vals[i];
    }
    return result;
  },

  gauss_elimination: function gauss_elimination(a, b) {
    var i = 0,
    j = 0,
    n = a.length,
    m = a[0].length,
    factor = 1,
    sum = 0,
    x = [],
    maug, pivot, temp, k;
    a = jStat.aug(a, b);
    maug = a[0].length;
    for(; i < n; i++) {
      pivot = a[i][i];
      j = i;
      for (k = i + 1; k < m; k++) {
        if (pivot < Math.abs(a[k][i])) {
          pivot = a[k][i];
          j = k;
        }
      }
      if (j != i) {
        for(k = 0; k < maug; k++) {
          temp = a[i][k];
          a[i][k] = a[j][k];
          a[j][k] = temp;
        }
      }
      for (j = i + 1; j < n; j++) {
        factor = a[j][i] / a[i][i];
        for(k = i; k < maug; k++) {
          a[j][k] = a[j][k] - factor * a[i][k];
        }
      }
    }
    for (i = n - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j<= n - 1; j++) {
        sum = x[j] * a[i][j];
      }
      x[i] =(a[i][maug - 1] - sum) / a[i][i];
    }
    return x;
  },

  gauss_jordan: function gauss_jordan(a, b) {
    var m = jStat.aug(a, b),
    h = m.length,
    w = m[0].length;
    // find max pivot
    for (var y = 0; y < h; y++) {
      var maxrow = y;
      for (var y2 = y+1; y2 < h; y2++) {
        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
          maxrow = y2;
      }
      var tmp = m[y];
      m[y] = m[maxrow];
      m[maxrow] = tmp
      for (var y2 = y+1; y2 < h; y2++) {
        c = m[y2][y] / m[y][y];
        for (var x = y; x < w; x++) {
          m[y2][x] -= m[y][x] * c;
        }
      }
    }
    // backsubstitute
    for (var y = h-1; y >= 0; y--) {
      c = m[y][y];
      for (var y2 = 0; y2 < y; y2++) {
        for (var x = w-1; x > y-1; x--) {
          m[y2][x] -= m[y][x] * m[y2][y] / c;
        }
      }
      m[y][y] /= c;
      for (var x = h; x < w; x++) {
        m[y][x] /= c;
      }
    }
    return m;
  },

  lu: function lu(a, b) {
    throw new Error('lu not yet implemented');
  },

  cholesky: function cholesky(a, b) {
    throw new Error('cholesky not yet implemented');
  },

  gauss_jacobi: function gauss_jacobi(a, b, x, r) {
    var i = 0;
    var j = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);
    c = jStat.multiply(jStat.inv(d), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  gauss_seidel: function gauss_seidel(a, b, x, r) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);
    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i = i + 1;
    }
    return xk;
  },

  SOR: function SOR(a, b, x, r, w) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),
                       jStat.subtract(jStat.multiply(d, 1 - w),
                                      jStat.multiply(u, w)));
    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,
        jStat.multiply(l, w))), b), w);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  householder: function householder(a) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var alpha, r, k, j, factor;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
      alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, jStat.multiply(a, p));
    }
    return a;
  },

  // TODO: not working properly.
  QR: function QR(a, b) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var x = [];
    var j, alpha, r, k, factor, sum;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
        alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++)
        w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, a);
      b = jStat.multiply(p, b);
    }
    for (i = m - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j <= n - 1; j++)
      sum = x[j] * a[i][j];
      x[i] = b[i][0] / a[i][i];
    }
    return x;
  },

  jacobi: function jacobi(a) {
    var condition = 1;
    var count = 0;
    var n = a.length;
    var e = jStat.identity(n, n);
    var ev = [];
    var b, i, j, p, q, maxim, theta, s;
    // condition === 1 only if tolerance is not reached
    while (condition === 1) {
      count++;
      maxim = a[0][1];
      p = 0;
      q = 1;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (i != j) {
            if (maxim < Math.abs(a[i][j])) {
              maxim = Math.abs(a[i][j]);
              p = i;
              q = j;
            }
          }
        }
      }
      if (a[p][p] === a[q][q])
        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;
      else
        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
      s = jStat.identity(n, n);
      s[p][p] = Math.cos(theta);
      s[p][q] = -Math.sin(theta);
      s[q][p] = Math.sin(theta);
      s[q][q] = Math.cos(theta);
      // eigen vector matrix
      e = jStat.multiply(e, s);
      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);
      a = b;
      condition = 0;
      for (i = 1; i < n; i++) {
        for (j = 1; j < n; j++) {
          if (i != j && Math.abs(a[i][j]) > 0.001) {
            condition = 1;
          }
        }
      }
    }
    for (i = 0; i < n; i++) ev.push(a[i][i]);
    //returns both the eigenvalue and eigenmatrix
    return [e, ev];
  },

  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
    var k1, k2, u_j1, k3, k4;
    if (order === 2) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h, u_j + k1);
        u_j1 = u_j + (k1 + k2) / 2;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    if (order === 4) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h / 2, u_j + k1 / 2);
        k3 = h * f(t_j + h / 2, u_j + k2 / 2);
        k4 = h * f(t_j +h, u_j + k3);
        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    return u_j;
  },

  romberg: function romberg(f, a, b, order) {
    var i = 0;
    var h = (b - a) / 2;
    var x = [];
    var h1 = [];
    var g = [];
    var m, a1, j, k, I, d;
    while (i < order / 2) {
      I = f(a);
      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
      m = x.length;
      for (j = 1; j < m - 1; j++) {
        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);
      }
      I = (h / 3) * (I + f(b));
      g[i] = I;
      h /= 2;
      i++;
    }
    a1 = g.length;
    m = 1;
    while (a1 !== 1) {
      for (j = 0; j < a1 - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a1 = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  richardson: function richardson(X, f, x, h) {
    function pos(X, x) {
      var i = 0;
      var n = X.length;
      var p;
      for (; i < n; i++)
        if (X[i] === x) p = i;
      return p;
    }
    var n = X.length,
    h_min = Math.abs(x - X[pos(X, x) + 1]),
    i = 0,
    g = [],
    h1 = [],
    y1, y2, m, a, j;
    while (h >= h_min) {
      y1 = pos(X, x + h);
      y2 = pos(X, x);
      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
      h /= 2;
      i++;
    }
    a = g.length;
    m = 1;
    while (a != 1) {
      for (j = 0; j < a - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  simpson: function simpson(f, a, b, n) {
    var h = (b - a) / n;
    var I = f(a);
    var x = [];
    var j = a;
    var k = 0;
    var i = 1;
    var m;
    for (; j <= b; j = j + h, k++)
      x[k] = j;
    m = x.length;
    for (; i < m - 1; i++) {
      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);
    }
    return (h / 3) * (I + f(b));
  },

  hermite: function hermite(X, F, dF, value) {
    var n = X.length;
    var p = 0;
    var i = 0;
    var l = [];
    var dl = [];
    var A = [];
    var B = [];
    var j;
    for (; i < n; i++) {
      l[i] = 1;
      for (j = 0; j < n; j++) {
        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
      }
      dl[i] = 0;
      for (j = 0; j < n; j++) {
        if (i != j) dl[i] += 1 / (X [i] - X[j]);
      }
      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
      B[i] = (value - X[i]) * (l[i] * l[i]);
      p += (A[i] * F[i] + B[i] * dF[i]);
    }
    return p;
  },

  lagrange: function lagrange(X, F, value) {
    var p = 0;
    var i = 0;
    var j, l;
    var n = X.length;
    for (; i < n; i++) {
      l = F[i];
      for (j = 0; j < n; j++) {
        // calculating the lagrange polynomial L_i
        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
      }
      // adding the lagrange polynomials found above
      p += l;
    }
    return p;
  },

  cubic_spline: function cubic_spline(X, F, value) {
    var n = X.length;
    var i = 0, j;
    var A = [];
    var B = [];
    var alpha = [];
    var c = [];
    var h = [];
    var b = [];
    var d = [];
    for (; i < n - 1; i++)
      h[i] = X[i + 1] - X[i];
    alpha[0] = 0;
    for (i = 1; i < n - 1; i++) {
      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -
          (3 / h[i-1]) * (F[i] - F[i-1]);
    }
    for (i = 1; i < n - 1; i++) {
      A[i] = [];
      B[i] = [];
      A[i][i-1] = h[i-1];
      A[i][i] = 2 * (h[i - 1] + h[i]);
      A[i][i+1] = h[i];
      B[i][0] = alpha[i];
    }
    c = jStat.multiply(jStat.inv(A), B);
    for (j = 0; j < n - 1; j++) {
      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
    }
    for (j = 0; j < n; j++) {
      if (X[j] > value) break;
    }
    j -= 1;
    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *
        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];
  },

  gauss_quadrature: function gauss_quadrature() {
    throw new Error('gauss_quadrature not yet implemented');
  },

  PCA: function PCA(X) {
    var m = X.length;
    var n = X[0].length;
    var flag = false;
    var i = 0;
    var j, temp1;
    var u = [];
    var D = [];
    var result = [];
    var temp2 = [];
    var Y = [];
    var Bt = [];
    var B = [];
    var C = [];
    var V = [];
    var Vt = [];
    for (i = 0; i < m; i++) {
      u[i] = jStat.sum(X[i]) / n;
    }
    for (i = 0; i < n; i++) {
      B[i] = [];
      for(j = 0; j < m; j++) {
        B[i][j] = X[j][i] - u[j];
      }
    }
    B = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      C[i] = [];
      for (j = 0; j < m; j++) {
        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);
      }
    }
    result = jStat.jacobi(C);
    V = result[0];
    D = result[1];
    Vt = jStat.transpose(V);
    for (i = 0; i < D.length; i++) {
      for (j = i; j < D.length; j++) {
        if(D[i] < D[j])  {
          temp1 = D[i];
          D[i] = D[j];
          D[j] = temp1;
          temp2 = Vt[i];
          Vt[i] = Vt[j];
          Vt[j] = temp2;
        }
      }
    }
    Bt = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      Y[i] = [];
      for (j = 0; j < Bt.length; j++) {
        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);
      }
    }
    return [X, D, Vt, Y];
  }
});

// extend jStat.fn with methods that require one argument
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function(arg, func) {
      var tmpthis = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));
        }, 15);
        return this;
      }
      if (typeof jStat[passfunc](this, arg) === 'number')
        return jStat[passfunc](this, arg);
      else
        return jStat(jStat[passfunc](this, arg));
    };
  }(funcs[i]));
}('add divide multiply subtract dot pow abs norm angle'.split(' ')));

}(this.jStat, Math));
(function(jStat, Math) {

var slice = [].slice;
var isNumber = jStat.utils.isNumber;

// flag==true denotes use of sample standard deviation
// Z Statistics
jStat.extend({
  // 2 different parameter lists:
  // (value, mean, sd)
  // (value, array, flag)
  zscore: function zscore() {
    var args = slice.call(arguments);
    if (isNumber(args[1])) {
      return (args[0] - args[1]) / args[2];
    }
    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);
  },

  // 3 different paramter lists:
  // (value, mean, sd, sides)
  // (zscore, sides)
  // (value, array, sides, flag)
  ztest: function ztest() {
    var args = slice.call(arguments);
    if (args.length === 4) {
      if(isNumber(args[1])) {
        var z = jStat.zscore(args[0],args[1],args[2])
        return (args[3] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);
      }
      var z = args[0]
      return (args[2] === 1) ?
        (jStat.normal.cdf(-Math.abs(z),0,1)) :
        (jStat.normal.cdf(-Math.abs(z),0,1)*2);
    }
    var z = jStat.zscore(args[0],args[1],args[3])
    return (args[1] === 1) ?
      (jStat.normal.cdf(-Math.abs(z), 0, 1)) :
      (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);
  }
});

jStat.extend(jStat.fn, {
  zscore: function zscore(value, flag) {
    return (value - this.mean()) / this.stdev(flag);
  },

  ztest: function ztest(value, sides, flag) {
    var zscore = Math.abs(this.zscore(value, flag));
    return (sides === 1) ?
      (jStat.normal.cdf(-zscore, 0, 1)) :
      (jStat.normal.cdf(-zscore, 0, 1) * 2);
  }
});

// T Statistics
jStat.extend({
  // 2 parameter lists
  // (value, mean, sd, n)
  // (value, array)
  tscore: function tscore() {
    var args = slice.call(arguments);
    return (args.length === 4) ?
      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :
      ((args[0] - jStat.mean(args[1])) /
       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));
  },

  // 3 different paramter lists:
  // (value, mean, sd, n, sides)
  // (tscore, n, sides)
  // (value, array, sides)
  ttest: function ttest() {
    var args = slice.call(arguments);
    var tscore;
    if (args.length === 5) {
      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));
      return (args[4] === 1) ?
        (jStat.studentt.cdf(-tscore, args[3]-1)) :
        (jStat.studentt.cdf(-tscore, args[3]-1)*2);
    }
    if (isNumber(args[1])) {
      tscore = Math.abs(args[0])
      return (args[2] == 1) ?
        (jStat.studentt.cdf(-tscore, args[1]-1)) :
        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);
    }
    tscore = Math.abs(jStat.tscore(args[0], args[1]))
    return (args[2] == 1) ?
      (jStat.studentt.cdf(-tscore, args[1].length-1)) :
      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);
  }
});

jStat.extend(jStat.fn, {
  tscore: function tscore(value) {
    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));
  },

  ttest: function ttest(value, sides) {
    return (sides === 1) ?
      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :
      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);
  }
});

// F Statistics
jStat.extend({
  // Paramter list is as follows:
  // (array1, array2, array3, ...)
  // or it is an array of arrays
  // array of arrays conversion
  anovafscore: function anovafscore() {
    var args = slice.call(arguments),
    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
    if (args.length === 1) {
      tmpargs = new Array(args[0].length);
      for (i = 0; i < args[0].length; i++) {
        tmpargs[i] = args[0][i];
      }
      args = tmpargs;
    }
    // 2 sample case
    if (args.length === 2) {
      return jStat.variance(args[0]) / jStat.variance(args[1]);
    }
    // Builds sample array
    sample = new Array();
    for (i = 0; i < args.length; i++) {
      sample = sample.concat(args[i]);
    }
    sampMean = jStat.mean(sample);
    // Computes the explained variance
    expVar = 0;
    for (i = 0; i < args.length; i++) {
      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);
    }
    expVar /= (args.length - 1);
    // Computes unexplained variance
    unexpVar = 0;
    for (i = 0; i < args.length; i++) {
      sampSampMean = jStat.mean(args[i]);
      for (j = 0; j < args[i].length; j++) {
        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);
      }
    }
    unexpVar /= (sample.length - args.length);
    return expVar / unexpVar;
  },

  // 2 different paramter setups
  // (array1, array2, array3, ...)
  // (anovafscore, df1, df2)
  anovaftest: function anovaftest() {
    var args = slice.call(arguments),
    df1, df2, n, i;
    if (isNumber(args[0])) {
      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);
    }
    anovafscore = jStat.anovafscore(args);
    df1 = args.length - 1;
    n = 0;
    for (i = 0; i < args.length; i++) {
      n = n + args[i].length;
    }
    df2 = n - df1 - 1;
    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);
  },

  ftest: function ftest(fscore, df1, df2) {
    return 1 - jStat.centralF.cdf(fscore, df1, df2);
  }
});

jStat.extend(jStat.fn, {
  anovafscore: function anovafscore() {
    return jStat.anovafscore(this.toArray());
  },

  anovaftes: function anovaftes() {
    var n = 0;
    var i;
    for (i = 0; i < this.length; i++) {
      n = n + this[i].length;
    }
    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);
  }
});

// Error Bounds
jStat.extend({
  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  normalci: function normalci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  tci: function tci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *
                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  significant: function significant(pvalue, alpha) {
    return pvalue < alpha;
  }
});

jStat.extend(jStat.fn, {
  normalci: function normalci(value, alpha) {
    return jStat.normalci(value, alpha, this.toArray());
  },

  tci: function tci(value, alpha) {
    return jStat.tci(value, alpha, this.toArray());
  }
});

}(this.jStat, Math));

},{}],3:[function(require,module,exports){
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;
            
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);
        
        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };
    
    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }
        
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        
        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';
            
            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            
            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }        


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this, 
                  inputString ? inputString : defaultFormat, 
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
                return inputString; 
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);            
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(this);

},{}],4:[function(require,module,exports){
(function (global){
"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sébastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
	var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
	var tolerance= 1.e-64/prec;
	var itmax= 50;
	var c=0;
	var i=0;
	var j=0;
	var k=0;
	var l=0;
	
	var u= numeric.clone(A);
	var m= u.length;
	
	var n= u[0].length;
	
	if (m < n) throw "Need more rows than columns"
	
	var e = new Array(n);
	var q = new Array(n);
	for (i=0; i<n; i++) e[i] = q[i] = 0.0;
	var v = numeric.rep([n,n],0);
//	v.zero();
	
 	function pythag(a,b)
 	{
		a = Math.abs(a)
		b = Math.abs(b)
		if (a > b)
			return a*Math.sqrt(1.0+(b*b/a/a))
		else if (b == 0.0) 
			return a
		return b*Math.sqrt(1.0+(a*a/b/b))
	}

	//Householder's reduction to bidiagonal form

	var f= 0.0;
	var g= 0.0;
	var h= 0.0;
	var x= 0.0;
	var y= 0.0;
	var z= 0.0;
	var s= 0.0;
	
	for (i=0; i < n; i++)
	{	
		e[i]= g;
		s= 0.0;
		l= i+1;
		for (j=i; j < m; j++) 
			s += (u[j][i]*u[j][i]);
		if (s <= tolerance)
			g= 0.0;
		else
		{	
			f= u[i][i];
			g= Math.sqrt(s);
			if (f >= 0.0) g= -g;
			h= f*g-s
			u[i][i]=f-g;
			for (j=l; j < n; j++)
			{
				s= 0.0
				for (k=i; k < m; k++) 
					s += u[k][i]*u[k][j]
				f= s/h
				for (k=i; k < m; k++) 
					u[k][j]+=f*u[k][i]
			}
		}
		q[i]= g
		s= 0.0
		for (j=l; j < n; j++) 
			s= s + u[i][j]*u[i][j]
		if (s <= tolerance)
			g= 0.0
		else
		{	
			f= u[i][i+1]
			g= Math.sqrt(s)
			if (f >= 0.0) g= -g
			h= f*g - s
			u[i][i+1] = f-g;
			for (j=l; j < n; j++) e[j]= u[i][j]/h
			for (j=l; j < m; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += (u[j][k]*u[i][k])
				for (k=l; k < n; k++) 
					u[j][k]+=s*e[k]
			}	
		}
		y= Math.abs(q[i])+Math.abs(e[i])
		if (y>x) 
			x=y
	}
	
	// accumulation of right hand gtransformations
	for (i=n-1; i != -1; i+= -1)
	{	
		if (g != 0.0)
		{
		 	h= g*u[i][i+1]
			for (j=l; j < n; j++) 
				v[j][i]=u[i][j]/h
			for (j=l; j < n; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += u[i][k]*v[k][j]
				for (k=l; k < n; k++) 
					v[k][j]+=(s*v[k][i])
			}	
		}
		for (j=l; j < n; j++)
		{
			v[i][j] = 0;
			v[j][i] = 0;
		}
		v[i][i] = 1;
		g= e[i]
		l= i
	}
	
	// accumulation of left hand transformations
	for (i=n-1; i != -1; i+= -1)
	{	
		l= i+1
		g= q[i]
		for (j=l; j < n; j++) 
			u[i][j] = 0;
		if (g != 0.0)
		{
			h= u[i][i]*g
			for (j=l; j < n; j++)
			{
				s=0.0
				for (k=l; k < m; k++) s += u[k][i]*u[k][j];
				f= s/h
				for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
			}
			for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
		}
		else
			for (j=i; j < m; j++) u[j][i] = 0;
		u[i][i] += 1;
	}
	
	// diagonalization of the bidiagonal form
	prec= prec*x
	for (k=n-1; k != -1; k+= -1)
	{
		for (var iteration=0; iteration < itmax; iteration++)
		{	// test f splitting
			var test_convergence = false
			for (l=k; l != -1; l+= -1)
			{	
				if (Math.abs(e[l]) <= prec)
				{	test_convergence= true
					break 
				}
				if (Math.abs(q[l-1]) <= prec)
					break 
			}
			if (!test_convergence)
			{	// cancellation of e[l] if l>0
				c= 0.0
				s= 1.0
				var l1= l-1
				for (i =l; i<k+1; i++)
				{	
					f= s*e[i]
					e[i]= c*e[i]
					if (Math.abs(f) <= prec)
						break
					g= q[i]
					h= pythag(f,g)
					q[i]= h
					c= g/h
					s= -f/h
					for (j=0; j < m; j++)
					{	
						y= u[j][l1]
						z= u[j][i]
						u[j][l1] =  y*c+(z*s)
						u[j][i] = -y*s+(z*c)
					} 
				}	
			}
			// test f convergence
			z= q[k]
			if (l== k)
			{	//convergence
				if (z<0.0)
				{	//q[k] is made non-negative
					q[k]= -z
					for (j=0; j < n; j++)
						v[j][k] = -v[j][k]
				}
				break  //break out of iteration loop and move on to next k value
			}
			if (iteration >= itmax-1)
				throw 'Error: no convergence.'
			// shift from bottom 2x2 minor
			x= q[l]
			y= q[k-1]
			g= e[k-1]
			h= e[k]
			f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
			g= pythag(f,1.0)
			if (f < 0.0)
				f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
			else
				f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
			// next QR transformation
			c= 1.0
			s= 1.0
			for (i=l+1; i< k+1; i++)
			{	
				g= e[i]
				y= q[i]
				h= s*g
				g= c*g
				z= pythag(f,h)
				e[i-1]= z
				c= f/z
				s= h/z
				f= x*c+g*s
				g= -x*s+g*c
				h= y*s
				y= y*c
				for (j=0; j < n; j++)
				{	
					x= v[j][i-1]
					z= v[j][i]
					v[j][i-1] = x*c+z*s
					v[j][i] = -x*s+z*c
				}
				z= pythag(f,h)
				q[i-1]= z
				c= f/z
				s= h/z
				f= c*g+s*y
				x= -s*g+c*y
				for (j=0; j < m; j++)
				{
					y= u[j][i-1]
					z= u[j][i]
					u[j][i-1] = y*c+z*s
					u[j][i] = -y*s+z*c
				}
			}
			e[l]= 0.0
			e[k]= f
			q[k]= x
		} 
	}
		
	//vt= transpose(v)
	//return (u,q,vt)
	for (i=0;i<q.length; i++) 
	  if (q[i] < prec) q[i] = 0
	  
	//sort eigenvalues	
	for (i=0; i< n; i++)
	{	 
	//writeln(q)
	 for (j=i-1; j >= 0; j--)
	 {
	  if (q[j] < q[i])
	  {
	//  writeln(i,'-',j)
	   c = q[j]
	   q[j] = q[i]
	   q[i] = c
	   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
	   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
	   i = j	   
	  }
	 }	
	}
	
	return {U:u,S:q,V:v}
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
function SpreadSheetError() {
    this.name = 'SpreadSheetError';
    this.message = '发生了错误';
}

SpreadSheetError.prototype = new Error();
SpreadSheetError.prototype.constructor = SpreadSheetError;
SpreadSheetError.prototype.toString = function () {
    return this.name + ' => ' + this.message;
};

exports.SpreadSheetError = SpreadSheetError;

},{}],6:[function(require,module,exports){
'use strict';

var _settings = require('./settings');

var _core = require('./core');

var _core2 = _interopRequireDefault(_core);

var _polyfill = require('./polyfill');

var _polyfill2 = _interopRequireDefault(_polyfill);

var _XFormulas = require('./plugins/xformulas/XFormulas');

var _Plugin = require('./plugins/Plugin');

var _Persistent = require('./plugins/persistent/Persistent');

var _Persistent2 = _interopRequireDefault(_Persistent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_core2.default.globalSettings = _settings.globalSettings;
_core2.default.defaultSettings = _settings.defaultSettings;
_core2.default.version = '@@_version_@@';

_core2.default.plugins = {
    Plugin: _Plugin.Plugin,
    registerPlugin: _Plugin.registerPlugin
};

// 内置插件
(0, _Plugin.registerPlugin)('persistent', _Persistent2.default);

// 浏览器环境下的全局变量名。
window.BrickSpreadSheet = _core2.default;
(0, _polyfill2.default)(window);

// TODO 提供更改全局变量名的方法，以防止全局变量冲突。

},{"./core":7,"./plugins/Plugin":20,"./plugins/persistent/Persistent":22,"./plugins/xformulas/XFormulas":32,"./polyfill":54,"./settings":55}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Frame = require('./designer/Frame');

var _Frame2 = _interopRequireDefault(_Frame);

var _Workbook = require('./designer/Workbook');

var _Workbook2 = _interopRequireDefault(_Workbook);

var _common = require('./utils/common');

var _Plugin = require('./plugins/Plugin');

var _Emitter2 = require('./utils/Emitter');

var _Emitter3 = _interopRequireDefault(_Emitter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AUTO_ID = 1;

var SpreadSheet = function (_Emitter) {
    _inherits(SpreadSheet, _Emitter);

    /**
     * 类似 Excel 的电子表格。
     *
     * @constructor
     * @param rootElement
     * @param {object} userSettings - 电子表格的用户配置信息
     * @param {object} userSettings.workbook - Workbook 的配置
     * @param {object[]} userSettings.sheets - 配置所有初始 Sheet 页的数组
     * @param {boolean=} [displayMode=false] - 展示模式，不可编辑。
     */
    function SpreadSheet(rootElement, userSettings) {
        var displayMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        _classCallCheck(this, SpreadSheet);

        var _this = _possibleConstructorReturn(this, (SpreadSheet.__proto__ || Object.getPrototypeOf(SpreadSheet)).call(this));

        _this.rootElement = rootElement;
        _this.getUserSettings(userSettings);

        _this.settings = {};
        (0, _common.extend)(_this.settings, SpreadSheet.defaultSettings);
        (0, _common.extend)(_this.settings, _this.userSettings);

        _this.id = _this.settings.id || _this.getId();
        _this.displayMode = displayMode;

        _this._initPlugin();
        _this.frame = new _Frame2.default(_this, _this.settings.frame);
        _this.workbook = new _Workbook2.default(_this, _this.settings.workbook);
        _this._enablePlugin();
        return _this;
    }

    _createClass(SpreadSheet, [{
        key: 'getId',
        value: function getId() {
            // 不指定 id 时，尽量生成不可重复的 id（使用当前 iframe 自增变量配合随机字符串的方式）
            return this.id || SpreadSheet.globalSettings.idPrefix + AUTO_ID++ + '-' + (0, _common.randomString)();
        }
    }, {
        key: 'getRootElement',
        value: function getRootElement() {
            return this.rootElement;
        }
    }, {
        key: 'getDisplayMode',
        value: function getDisplayMode() {
            return this.displayMode;
        }

        /**
         * 获取用户传入的初始配置。
         * @param {string=} s - 表示用户配置的 JSON 字符串
         * @returns {Object}
         */

    }, {
        key: 'getUserSettings',
        value: function getUserSettings(s) {
            if (this.userSettings) {
                return this.userSettings;
            }
            if (s && typeof s === 'string') {
                this.userSettings = JSON.parse(s);
            } else {
                this.userSettings = s;
            }
            return this.userSettings;
        }

        /**
         * 获取 SpreadSheet 实际生效的配置信息。
         * @returns {Object}
         */

    }, {
        key: 'getSettings',
        value: function getSettings() {
            return this.settings;
        }

        /**
         * 获取可交换的中间数据，用于数据提交、解析转换等。
         * @param {boolean} [oragin=false] - 为 `true` 时获取原始 JavaScript 对象
         * @returns
         */

    }, {
        key: 'getExchangeData',
        value: function getExchangeData() {
            var oragin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            var w = this.workbook._getExchange();
            var f = this.frame._getExchange(); // TODO frame
            var o = {
                workbook: w,
                frame: f,
                id: this.getId()
            };
            return oragin ? o : JSON.stringify(o);
        }

        /**
         * 获取当前 SpreadSheet 对应的 Workbook 实例。
         * @returns {Workbook}
         */

    }, {
        key: 'getWorkbookInstance',
        value: function getWorkbookInstance() {
            return this.workbook;
        }

        /**
         * 获取当前 SpreadSheet 对应的 Frame 实例。
         * @returns {Frame}
         */

    }, {
        key: 'getFrameInstance',
        value: function getFrameInstance() {
            return this.frame;
        }
    }, {
        key: '_initPlugin',
        value: function _initPlugin() {
            var _this2 = this;

            this.plugins = new Map();
            (0, _Plugin.getAllPlugins)().forEach(function (P) {
                var p = new P(_this2);
                (0, _Plugin.validatePlugin)(p);
                _this2.plugins.set(p.__name__, p);
            });
        }
    }, {
        key: '_enablePlugin',
        value: function _enablePlugin() {
            this.plugins.forEach(function (p) {
                if (p.isEnable()) {
                    p.enable();
                }
            });
        }
    }]);

    return SpreadSheet;
}(_Emitter3.default);

exports.default = SpreadSheet;

},{"./designer/Frame":9,"./designer/Workbook":13,"./plugins/Plugin":20,"./utils/Emitter":56,"./utils/common":57}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _common = require('../utils/common');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 配置翻译类。
 * 框架内部使用，用户代码不应该调用它。
 *
 * @private
 */
var ConfigTranslator = function () {

    /**
     *
     * @param {object} config
     * @param {Sheet} sheet
     */
    function ConfigTranslator(config, sheet) {
        _classCallCheck(this, ConfigTranslator);

        this.initialConfig = config;
        this.sheet = sheet;
    }

    /**
     * 中间数据格式的设计会尽量同时保证在 Excel 及 Web 页面中均便于处理，
     * 但不免存在一些 Web 中难以直接使用的数据格式，该方法即是完成此类数据格式
     * 的适配转换工作。
     * @returns {object}
     */


    _createClass(ConfigTranslator, [{
        key: 'translate',
        value: function translate() {
            var settings = {};
            var proto = Object.getPrototypeOf(this);
            var property = Object.getOwnPropertyNames(proto);

            for (var i = 0; i < property.length; ++i) {
                if (property[i].startsWith('_trans')) {
                    this[property[i]].call(this, settings);
                }
            }
            // console.info(this.sheet.getName() + '[ConfigTranslator.translate] settings ->', settings);
            return settings;
        }

        /**
         * handsontable 中的一些状态无法通过初始配置参数控制，
         * 只能在实例化之后调用相应的方法来恢复相应的状态，此方法
         * 即是完成该功能。
         */

    }, {
        key: 'initSheetState',
        value: function initSheetState() {
            var proto = Object.getPrototypeOf(this);
            var property = Object.getOwnPropertyNames(proto);

            for (var i = 0; i < property.length; ++i) {
                if (property[i].startsWith('_init')) {
                    this[property[i]].call(this);
                }
            }
        }

        // ------------------------ translate ------------------------------

    }, {
        key: '_transCell',
        value: function _transCell(settings) {
            var m = this.initialConfig.cellMetas;
            if (m) {
                settings.cell = [];
                for (var i = 0; i < m.length; ++i) {
                    var row = m[i];
                    for (var j = 0; j < row.length; ++j) {
                        var cellMeta = row[j];
                        if (cellMeta) {
                            var cell = {};
                            cell.row = cellMeta.row;
                            cell.col = cellMeta.col;

                            // dataType
                            if (cellMeta.dataType) {
                                for (var dt in cellMeta.dataType) {
                                    if (cellMeta.dataType.hasOwnProperty(dt)) {
                                        cell[dt] = cellMeta.dataType[dt];
                                    }
                                }
                                cell.type = cellMeta.dataType.typeName;
                                delete cell.typeName;
                            }

                            // styles
                            if (cellMeta.styles) {
                                if (cellMeta.styles.alignments) {
                                    var c = cellMeta.styles.alignments.join(' ht');
                                    cell.className = cell.className ? cell.className += ' ht' + c : 'ht' + c;
                                }
                                if (cellMeta.styles.fontFamily) {
                                    cell._style_fontFamily = cellMeta.styles.fontFamily;
                                }
                                if (cellMeta.styles.fontSize) {
                                    cell._style_fontSize = cellMeta.styles.fontSize;
                                }
                                if (cellMeta.styles.color) {
                                    cell._style_color = cellMeta.styles.color;
                                }
                                if (cellMeta.styles.backgroundColor) {
                                    cell._style_backgroundColor = cellMeta.styles.backgroundColor;
                                }
                                if (cellMeta.styles.fontStyle) {
                                    cell.className = cell.className ? cell.className += ' ssd-font-' + cellMeta.styles.fontStyle : 'ssd-font-' + cellMeta.styles.fontStyle;
                                }
                                if (cellMeta.styles.fontWeight) {
                                    cell.className = cell.className ? cell.className += ' ssd-font-bold' : 'ssd-font-bold';
                                }
                                if (cellMeta.styles.textDecoration) {
                                    cell.className = cell.className ? cell.className += ' ssd-font-underline' : 'ssd-font-underline';
                                }
                            }
                            settings.cell.push(cell);
                        }
                    }
                }
            }
        }
    }, {
        key: '_transData',
        value: function _transData(settings) {
            var s = this.initialConfig.data;
            if (s) {
                // hotTable 在有 data 的情况下只能显示有数据的行列，这对于设计器来说并不方便使用，
                // 故填充空数据以撑起表格至 initRows * initCols 的大小。
                //    if (s.length < this.sheet.initRows) {
                //        let formerCol = s.length;
                //        s.length = this.sheet.initRows;
                //        s.fill([], formerCol);
                //    }
                //    for (let i = 0; i < s.length; ++i) {
                //        let row = s[i];
                //        if (row.length < this.sheet.initCols) {
                //            let formerRow = row.length;
                //            row.length = this.sheet.initCols;
                //            row.fill('', formerRow);
                //        }
                //    }
                settings.minRows = this.sheet.initRows;
                settings.minCols = this.sheet.initCols;

                settings.data = s;
            }
        }

        // 列宽

    }, {
        key: '_transColWidths',
        value: function _transColWidths(settings) {
            var w = this.initialConfig.colWidths;
            if (w) {
                settings.colWidths = w;
            }
        }

        // 行高

    }, {
        key: '_transRowHeights',
        value: function _transRowHeights(settings) {
            var h = this.initialConfig.rowHeights;
            if (h) {
                settings.rowHeights = h;
            }
        }

        // 边框

    }, {
        key: '_transBorders',
        value: function _transBorders(settings) {
            var s = this.initialConfig.borders;
            if (s) {
                settings.customBorders = s;
            }
        }

        // 合并单元格

    }, {
        key: '_transMergeCells',
        value: function _transMergeCells(settings) {
            var s = this.initialConfig.mergeCells;
            if (s) {
                settings.mergeCells = s;
            }
        }

        // ------------------------ initState ------------------------------

        // 选区

    }, {
        key: '_initSelection',
        value: function _initSelection() {
            var s = this.initialConfig.selection;
            if (s) {
                this.sheet.select(s.row, s.col, s.endRow, s.endCol);
            } else {
                this.sheet.select(0, 0);
            }
        }
    }]);

    return ConfigTranslator;
}();

exports.default = ConfigTranslator;

},{"../utils/common":57}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextMenu = require('./frame/ContextMenu');

var _ContextMenu2 = _interopRequireDefault(_ContextMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 电子表格设计器中，除了 Workbook 外的组件管理器，
 * 包含菜单栏、工具栏、侧边栏、右键菜单等等。
 */
var Frame = function () {
  function Frame(instance, config) {
    _classCallCheck(this, Frame);

    this.spreadSheet = instance;
    /**
     *
     * @type {ContextMenu}
     */
    this.contextMenu = new _ContextMenu2.default(instance);
  }

  _createClass(Frame, [{
    key: '_getExchange',
    value: function _getExchange() {}
  }]);

  return Frame;
}();

exports.default = Frame;

},{"./frame/ContextMenu":16}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _common = require('../utils/common.js');

var _ConfigTranslator = require('./ConfigTranslator.js');

var _ConfigTranslator2 = _interopRequireDefault(_ConfigTranslator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Handsontable 组件的适配类
 */
var HotTableAdaptor = function (_Handsontable) {
    _inherits(HotTableAdaptor, _Handsontable);

    /**
     *
     * @param {HTMLElement} rootElement
     * @param {object} config - 原始配置信息
     * @param {object} extConfig - 附加的配置信息
     * @param {Sheet} sheet - 对应的 sheet 实例
     */
    function HotTableAdaptor(rootElement, config, extConfig, sheet) {
        _classCallCheck(this, HotTableAdaptor);

        var hotSettings = {};
        var translator = new _ConfigTranslator2.default(config, sheet);
        var settings = translator.translate();

        var frame = sheet.workbook.spreadSheet.getFrameInstance();
        var menuItems = frame.contextMenu.menuItems;
        var contextMenu = {};
        contextMenu.items = frame.contextMenu.getMenuItems4HotTable();
        contextMenu.callback = function (sheet) {
            return function (key, options) {
                if (menuItems.has(key)) {
                    var item = menuItems.get(key);
                    if (item.handler) {
                        item.handler.call(this, sheet, options.start, options.end, options);
                    }
                }
            };
        }(sheet);
        HotTableAdaptor._preference.contextMenu = contextMenu;

        (0, _common.extend)(hotSettings, HotTableAdaptor._preference);
        (0, _common.extend)(hotSettings, settings);
        (0, _common.extend)(hotSettings, extConfig);

        var _this = _possibleConstructorReturn(this, (HotTableAdaptor.__proto__ || Object.getPrototypeOf(HotTableAdaptor)).call(this, rootElement, hotSettings));

        _this._translator = translator;

        // handontable 每次 render 的时候，不保留 td 的状态，因此通过该事件重建一些样式。
        Handsontable.hooks.add('beforeRenderer', function (TD, row, col, prop, value, cellProperties) {
            TD.style.color = cellProperties._style_color || '';
            TD.style.fontFamily = cellProperties._style_fontFamily || '';
            TD.style.fontSize = cellProperties._style_fontSize || '';
            TD.style.backgroundColor = cellProperties._style_backgroundColor || '';
        }, _this);

        /*
         * 将 Handsontable 的所有事件都委托给 SpreadSheet 后会有些卡。
         * 只好将 Handsontable.hooks.getRegistered() 换成 ECP 项目需要的。
         */
        ['afterSelectionEnd'].forEach(function (hook) {
            Handsontable.hooks.add(hook, function () {
                var args = [];
                args.push(hook);
                args.push(sheet);
                args.push.apply(args, [].slice.call(arguments));
                var cxt = sheet.workbook.spreadSheet;
                cxt.emit.apply(cxt, args);
            }, _this);
        });
        return _this;
    }

    _createClass(HotTableAdaptor, [{
        key: 'destroy',
        value: function destroy() {
            _get(HotTableAdaptor.prototype.__proto__ || Object.getPrototypeOf(HotTableAdaptor.prototype), 'destroy', this).call(this);
            delete this._translator;
        }
    }]);

    return HotTableAdaptor;
}(Handsontable);

/**
 * 预设配置。
 * @private
 */


HotTableAdaptor._preference = {
    outsideClickDeselects: false,
    contextMenu: true,

    rowHeaders: true,
    colHeaders: true,

    manualColumnResize: true,
    manualRowResize: true,

    tableClassName: 'ssd-handsontable',

    xFormulas: true
};

exports.default = HotTableAdaptor;

},{"../utils/common.js":57,"./ConfigTranslator.js":8}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tabs = require('./views/Tabs');

var _Tabs2 = _interopRequireDefault(_Tabs);

var _HotTableAdaptor = require('./HotTableAdaptor');

var _HotTableAdaptor2 = _interopRequireDefault(_HotTableAdaptor);

var _SheetError = require('./SheetError');

var _Sheet_exchange = require('./ext/Sheet_exchange');

var _Sheet_helper = require('./ext/Sheet_helper');

var _common = require('../utils/common');

var _Emitter = require('../utils/Emitter');

var _Emitter2 = _interopRequireDefault(_Emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var INIT_ROWS = 150; // Sheet 初始可显示的行数
var INIT_COLS = 50; // Sheet 初始可显示的列数

// Webstorm IDE 的语法检查或 souremap 解析时不支持直接写到类的 extends 后。
var Mixin = (0, _Sheet_helper.SheetHelper)((0, _Sheet_exchange.Exchange)(_Emitter2.default));

/**
 * 工作表
 *
 * @fires Sheet#afterRename
 * @fires Sheet#afterRenameCancel
 */

var Sheet = function (_Mixin) {
    _inherits(Sheet, _Mixin);

    /**
     * 构造 Sheet 实例，用户代码不应该直接调用它，
     * 而是使用 Workbook.createSheet() 方法构造。
     *
     * @param {Workbook} workbook
     * @param {object} config
     * @private
     */
    function Sheet(workbook, config) {
        _classCallCheck(this, Sheet);

        /**
         * sheet 所在的工作表
         * @type {Workbook}
         */
        var _this = _possibleConstructorReturn(this, (Sheet.__proto__ || Object.getPrototypeOf(Sheet)).call(this));

        _this.workbook = workbook;
        _this.$$view = workbook.$$view;
        _this.settings = config;
        _this.sheetName = config.name;

        _this.initRows = INIT_ROWS;
        _this.initCols = INIT_COLS;

        _this.fx = {}; // TODO

        _this._render();
        return _this;
    }

    /**
     * @private
     */


    _createClass(Sheet, [{
        key: '_render',
        value: function _render() {
            this.$$view.appendTab(this.sheetName);

            var _$$view$_hotTables$ge = this.$$view._hotTables.get(this.sheetName),
                container = _$$view$_hotTables$ge.container,
                width = _$$view$_hotTables$ge.width,
                height = _$$view$_hotTables$ge.height;

            /**
             * @type {Handsontable}
             */

            this.handsontable = new _HotTableAdaptor2.default(container, this.settings, {
                width: width,
                height: height,
                readOnly: this.workbook.spreadSheet.getDisplayMode(),
                startRows: this.initRows,
                startCols: this.initCols,
                _isHotTableAdaptor: true,
                _sheet: this
            }, this);
            this.handsontable._translator.initSheetState();
            this.$$view.hideContent(this.getName());
        }

        /**
         * 获取当前 sheet 的名字
         * @returns {string}
         */

    }, {
        key: 'getName',
        value: function getName() {
            return this.sheetName;
        }

        /**
         * 激活当前 sheet 页
         */

    }, {
        key: 'active',
        value: function active() {
            this.workbook.activeSheet = this.getName();
            this.$$view.activeTab(this.getName());
            this.handsontable.render();
        }

        /**
         * 检测当前 sheet 是否被激活
         * @returns {boolean}
         */

    }, {
        key: 'isActive',
        value: function isActive() {
            return this.workbook.activeSheet === this.getName();
        }

        /**
         * 关闭 sheet 页
         */

    }, {
        key: 'close',
        value: function close() {
            this.workbook.closeSheet(this.getName());
        }

        /**
         * 销毁当前 sheet
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.handsontable.destroy();
            this.workbook.sheets.delete(this.getName());
            delete this.workbook;
            delete this.$$view;
        }

        /**
         * 给 sheet 页重命名
         * @param name - 新名字
         */

    }, {
        key: 'rename',
        value: function rename(name) {
            this.workbook.renameSheet(this.getName(), name);
        }

        /**
         * 选中 sheet 中的某区域。
         * 不指定 toRow 、toCol 时则选中对应的单元格。
         * @param {int} fromRow - 起始行
         * @param {int} fromCol - 起始列
         * @param {int} [toRow] - 终止行
         * @param {int} [toCol] - 终止列
         */

    }, {
        key: 'select',
        value: function select(fromRow, fromCol, toRow, toCol) {
            toRow = toRow || fromRow;
            toCol = toCol || fromCol;
            this.handsontable.selectCell(fromRow, fromCol, toRow, toCol, false);
        }

        /**
         * 获得当前 sheet 的选区
         * @returns {{row, col, endRow, endCol}}
         */

    }, {
        key: 'getSelection',
        value: function getSelection() {
            var selection = this.handsontable.getSelected();
            return {
                row: selection[0],
                col: selection[1],
                endRow: selection[2],
                endCol: selection[3]
            };
        }

        /**
         * 合并单元格
         * TIP: handsontable 官方合并功能不能正确处理已有的合并区域，故做重新计算。
         * @param {int} row - 起始行
         * @param {int} col - 起始列
         * @param {int} rowspan - 待合并的行数
         * @param {int} colspan - 待合并的列数
         */
        // TODO 最大行列数限制

    }, {
        key: 'mergeCells',
        value: function mergeCells(row, col, rowspan, colspan) {
            var r = 0;
            var cover = [];
            var mergeCells = this.handsontable.getSettings().mergeCells;

            var r1 = [row, col, row + rowspan - 1, col + colspan - 1];

            for (var i = mergeCells.length; i; --i) {
                var f = mergeCells[i - 1];
                var r2 = [f.row, f.col, f.row + f.rowspan - 1, f.col + f.colspan - 1];

                // 与原区域存在完全重叠
                if (_common.Coordinate.isEqual(r1, r2)) {
                    r = 1;
                    break;
                }
                // 是原区域的子集
                if (_common.Coordinate.isSubset(r1, r2)) {
                    r = 2;
                    break;
                }
                // 覆盖原区域（此时可能与另一个原区域交集或完全覆盖）
                if (_common.Coordinate.isSuperset(r1, r2)) {
                    cover.push(i - 1);
                    r = 3;
                    continue;
                }
                // 与原区域存在交集(不含子集、超集情况)
                if (_common.Coordinate.intersection(r1, r2)) {
                    r = 4;
                }
            }

            if (r === 0 || r === 3) {
                if (r === 3) {
                    // 这种情况下一定存在已经合并过的单元格
                    for (var _i = 0; _i < cover.length; ++_i) {
                        mergeCells.splice(cover[_i], 1);
                    }
                }
                mergeCells = mergeCells || [];
                mergeCells.push({
                    row: row,
                    col: col,
                    rowspan: rowspan,
                    colspan: colspan
                });
                this.handsontable.updateSettings({
                    mergeCells: mergeCells
                });
            } else if (r === 2 || r === 4) {
                throw new _SheetError.SheetError('\u7ED9\u5B9A\u7684\u5408\u5E76\u533A\u57DF\u4E0D\u5408\u6CD5: [' + row + ', ' + col + ', ' + rowspan + ', ' + colspan + ']');
            }
        }

        /**
         * 取消单元格合并
         * @param {int} row - 起始行
         * @param {int} col - 起始列
         * @param {int} rowspan - 待合并的行数
         * @param {int} colspan - 待合并的列数
         */

    }, {
        key: 'unMergeCells',
        value: function unMergeCells(row, col, rowspan, colspan) {
            var merged = this.handsontable.getSettings().mergeCells;
            var mergeCells = [];
            if (merged && merged.length) {
                for (var i = 0; i < merged.length; ++i) {
                    if (_common.Coordinate.isSubset([merged[i].row, merged[i].col, merged[i].row + merged[i].rowspan - 1, merged[i].col + merged[i].colspan - 1], [row, col, row + rowspan - 1, col + colspan - 1])) {
                        continue;
                    }
                    mergeCells.push(merged[i]);
                }
            }
            this.handsontable.updateSettings({
                mergeCells: mergeCells.length === 0 ? false : mergeCells
            });
        }
    }, {
        key: 'spliceClass',
        value: function spliceClass(selection, newClassName) {
            for (var _len = arguments.length, classNames = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                classNames[_key - 2] = arguments[_key];
            }

            var _this2 = this;

            this._walkonCellMetas(selection, function (row, col, cellMeta) {
                return {
                    className: (_this2._removeFormerClass(cellMeta.className, classNames) + ' ' + newClassName).trim()
                };
            }, { className: newClassName });
        }

        /**
         * 设置字体加粗
         * @param {boolean} [value=true] `true` 为加粗，`false` 取消加粗
         * @param {object} selection - 待设置的选区
         * @param {int} selection.row
         * @param {int} selection.col
         * @param {int} [selection.endRow]
         * @param {int} [selection.endCol]
         */

    }, {
        key: 'setFontBold',
        value: function setFontBold() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            if (value) {
                this.spliceClass(selection, 'ssd-font-bold', 'ssd-font-bold');
            } else {
                this.spliceClass(selection, '', 'ssd-font-bold');
            }
            this.handsontable.render();
        }

        /**
         * 设置斜体字
         * @param {boolean} [value=true]
         * @param {object} selection - 待设置的选区
         * @param {int} selection.row
         * @param {int} selection.col
         * @param {int} [selection.endRow]
         * @param {int} [selection.endCol]
         */

    }, {
        key: 'setFontItalic',
        value: function setFontItalic() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            if (value) {
                this.spliceClass(selection, 'ssd-font-italic', 'ssd-font-italic');
            } else {
                this.spliceClass(selection, '', 'ssd-font-italic');
            }
            this.handsontable.render();
        }

        /**
         * 设置字体下划线
         * @param {boolean} [value=true]
         * @param selection - 待设置的选区
         * @param {int} selection.row
         * @param {int} selection.col
         * @param {int} [selection.endRow]
         * @param {int} [selection.endCol]
         */

    }, {
        key: 'setFontUnderline',
        value: function setFontUnderline() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            if (value) {
                this.spliceClass(selection, 'ssd-font-underline', 'ssd-font-underline');
            } else {
                this.spliceClass(selection, '', 'ssd-font-underline');
            }
            this.handsontable.render();
        }

        /**
         * 设置字体颜色
         * TIP 如果 “handontable 直接通过 getCell 获得 TD 后设置样式”，当再次 render 时会失效。
         * @param value
         * @param selection
         */

    }, {
        key: 'setFontColor',
        value: function setFontColor() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_color: value
                };
            }, { _style_color: value });
            this.handsontable.render();
        }

        /**
         * 字体类型
         * @param value
         * @param selection
         */

    }, {
        key: 'setFontFamily',
        value: function setFontFamily() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_fontFamily: value
                };
            }, { _style_fontFamily: value });
            this.handsontable.render();
        }

        /**
         * 字体大小
         * @param value - 需要指定单位，如 12px
         * @param selection
         */

    }, {
        key: 'setFontSize',
        value: function setFontSize(value) {
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_fontSize: value
                };
            }, { _style_fontSize: value });
            this.handsontable.render();
        }

        /**
         * 设置背景色
         * @param value
         * @param selection
         */

    }, {
        key: 'setBackgroundColor',
        value: function setBackgroundColor() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_backgroundColor: value
                };
            }, { _style_backgroundColor: value });
            this.handsontable.render();
        }

        /**
         * FIXME handsontable 的 BUG 尚未处理，源码复杂，一时也不好扩展。
         * 设置边框
         * @param range - 边框范围，形如 `{form: {row: 1, col: 1}, to: {row: 3, col: 4}}` 的对象
         * @param top - 上边框，形如 `{width: 2, color: '#5292F7'}` 的对象
         * @param [right]
         * @param [bottom]
         * @param [left]
         */

    }, {
        key: 'setBorder',
        value: function setBorder(range, top, right, bottom, left) {
            var config = {
                range: range,
                top: top
            };
            config.right = right || top;
            config.bottom = bottom || top;
            config.left = left || config.right;

            var formerBorders = this.handsontable.getSettings().customBorders || [];
            formerBorders.push(config);

            // TODO customBorders cannot be updated via updateSettings
            // @see {@link https://github.com/handsontable/handsontable/issues/2002}
            this.handsontable.updateSettings({
                customBorders: formerBorders
            });
        }
    }]);

    return Sheet;
}(Mixin);

exports.default = Sheet;

/**
 * afterRename 事件。
 *
 * @event Sheet#afterRename
 * @type {Sheet}
 * @type {string}
 * @type {string}
 */

/**
 * afterRenameCancel 事件。
 *
 * @event Sheet#afterRenameCancel
 * @type {Sheet}
 * @type {string}
 * @type {string}
 */

},{"../utils/Emitter":56,"../utils/common":57,"./HotTableAdaptor":10,"./SheetError":12,"./ext/Sheet_exchange":14,"./ext/Sheet_helper":15,"./views/Tabs":18}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SheetError = SheetError;

var _SpreadSheetError = require('../SpreadSheetError');

function SheetError(value) {
    this.name = 'SheetError';
    this.message = value;
}
SheetError.prototype = new _SpreadSheetError.SpreadSheetError();
SheetError.prototype.constructor = SheetError;

},{"../SpreadSheetError":5}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tabs = require('./views/Tabs');

var _Tabs2 = _interopRequireDefault(_Tabs);

var _Sheet = require('./Sheet');

var _Sheet2 = _interopRequireDefault(_Sheet);

var _SheetError = require('./SheetError');

var _dataStructure = require('../utils/dataStructure');

var _common = require('../utils/common');

var _settings = require('../settings');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var regExp = _settings.globalSettings.sheet.sheetName;

/**
 * 工作簿。一个 Workbook 包含一个或多个 Sheet .
 */

var Workbook = function () {

    /**
     * Workbook 构造器
     * @param {SpreadSheet} instance
     * @param {object} config
     */
    function Workbook(instance, config) {
        var _this = this;

        _classCallCheck(this, Workbook);

        /**
         * @type {SpreadSheet}
         */
        this.spreadSheet = instance;
        /**
         * @type {CaseInsensitiveMap}
         */
        this.sheets = new _dataStructure.CaseInsensitiveMap();
        this.settings = config;

        this._initSettings(config);
        this.$$view = new _Tabs2.default(this);

        config.sheets.forEach(function (v) {
            return _this.createSheet(v);
        });

        // 根据初始化数据激活 sheet 页
        var toActive = this.getSheet(this.activeSheet);
        if (!toActive) {
            throw new _SheetError.SheetError('\u6307\u5B9A\u7684 activeSheet \u4E0D\u5B58\u5728: ' + this.activeSheet);
        }
        toActive.active();
    }

    /**
     *
     * @param settings
     * @private
     */


    _createClass(Workbook, [{
        key: '_initSettings',
        value: function _initSettings(settings) {
            var keys = Object.keys(settings);
            for (var i = 0, len = keys.length; i < len; ++i) {
                if (keys[i] === 'sheets') {
                    continue;
                }
                this[keys[i]] = settings[keys[i]];
            }
        }

        /**
         * 获取 Workbook 所属的电子表格的用户初始配置。
         * @returns {Object}
         */

    }, {
        key: 'getSettings',
        value: function getSettings() {
            return this.spreadSheet.getSettings();
        }

        /**
         * 获取当前 Workbook 的 id
         * @returns {string}
         */

    }, {
        key: 'getId',
        value: function getId() {
            return this.id || (this.id = this.spreadSheet.getId() + _settings.globalSettings.idSuffix4Workbook);
        }

        /**
         * 根据指定 sheet 名获取 sheet 实例
         * @param name
         * @returns {Sheet}
         */

    }, {
        key: 'getSheet',
        value: function getSheet(name) {
            return this.sheets.get(name);
        }

        /**
         * 获取当前 Workbook 下的所有 sheet 实例
         * @returns {CaseInsensitiveMap}
         */

    }, {
        key: 'getSheets',
        value: function getSheets() {
            return this.sheets;
        }

        /**
         * 获取所有 sheet 的名字
         * @returns {Iterator.<string>}
         */

    }, {
        key: 'getSheetNames',
        value: function getSheetNames() {
            return this.sheets.keys();
        }

        /**
         * 检验 sheet 是否已存在
         * @param name
         * @param {boolean} [exactly=false] - 是否使用精确大小写的 name
         * @returns {boolean}
         */

    }, {
        key: 'isSheetExist',
        value: function isSheetExist(name, exactly) {
            if (exactly) {
                return this.sheets.hasExact(name);
            }
            // return !!this.getSheet(name);
            return this.sheets.has(name);
        }

        /**
         * 生成 sheet 索引
         * @private
         * @returns {number}
         */

    }, {
        key: '_getAutoSheetIndex',
        value: function _getAutoSheetIndex() {
            if (!this.$$autoSheetIndex) {
                this.$$autoSheetIndex = 0;
            }
            return ++this.$$autoSheetIndex; // 从 1 开始
        }

        /**
         * 自动生成 sheet 名
         * @returns {string}
         * @private
         */

    }, {
        key: '_getAutoSheetName',
        value: function _getAutoSheetName() {
            var prefix = _settings.globalSettings.sheet.autoPrefix + ''; // 防止出现数字相加
            var name = prefix + this._getAutoSheetIndex();
            if (this.isSheetExist(name)) {
                return this._getAutoSheetName();
            }
            return name;
        }

        /**
         * 获取当前激活的 sheet 页
         * @returns {Sheet}
         */

    }, {
        key: 'getActiveSheet',
        value: function getActiveSheet() {
            return this.sheets.get(this.activeSheet);
        }

        /**
         * 创建新的 sheet 页
         * @param {object} [config] - sheet 页的配置信息
         * @returns {Sheet} 新创建的工作表
         */

    }, {
        key: 'createSheet',
        value: function createSheet(config) {

            if (config) {
                // 根据初始配置创建，name 不能为空
                this._validateSheetName(config.name);
            } else {
                // 用户操作创建，动态生成 name
                config = {};
                config.name = this._getAutoSheetName();
            }
            var newOne = new _Sheet2.default(this, config);
            this.sheets.set(config.name, newOne);
            return newOne;
        }

        /**
         * 销毁指定 sheet 页
         * @param {string | Sheet} sheet - sheet 名称或实例
         */

    }, {
        key: 'destroySheet',
        value: function destroySheet(sheet) {
            if (typeof sheet === 'string') {
                sheet = this.getSheet(sheet);
            }
            sheet.destroy();
        }

        /**
         * 给指定的 sheet 页重命名
         * @param {string} name1 - 待重命名的 sheet 页名字
         * @param {string} name2 - 新名字
         */
        // FIXME 编辑错位：
        // handsontable 在选中某单元格但没进入编辑时，会监听 document 上的 keydown 事件，
        // 造成修改 sheet 名时的文本框无法正确处理（会输入到表格中）
        // 暂时使用 input 的 select 代替 focus，迫使用户再次点击sheet名时才能修改。

    }, {
        key: 'renameSheet',
        value: function renameSheet(name1, name2) {
            var sheet = this.getSheet(name1);
            if (!sheet) {
                throw new _SheetError.SheetError('\u5DE5\u4F5C\u8868 "' + name1 + '" \u4E0D\u5B58\u5728');
            }
            if (name1 !== name2) {
                this._validateSheetName(name2, (0, _common.upperCase)(name1) === (0, _common.upperCase)(name2));
                sheet.sheetName = name2;
                if (this.activeSheet === name1) {
                    this.activeSheet = name2;
                }
                this.getSheets().delete(name1);
                this.getSheets().set(name2, sheet);
                this.$$view.tabRename(name1, name2);
            } else {
                this.$$view.tabRenameCancel(name1, name2);
            }
        }

        /**
         * 关闭指定 sheet 页
         */

    }, {
        key: 'closeSheet',
        value: function closeSheet(name) {
            var sheet = this.getSheet(name);
            if (!sheet) {
                throw new _SheetError.SheetError('\u65E0\u6CD5\u5173\u95ED\u4E0D\u5B58\u5728\u7684\u5DE5\u4F5C\u8868 "' + name + '" \u3002');
            }
            if (this.sheets.size() === 1) {
                throw new _SheetError.SheetError('\u65E0\u6CD5\u5173\u95ED\u4EC5\u6709\u7684\u4E00\u4E2A\u5DE5\u4F5C\u8868 "' + name + '" \u3002');
            }
            if (sheet.isActive()) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.sheets.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var k = _step.value;

                        if (k && k !== name) {
                            this.activeSheet = k;
                            this.getSheet(k).active();
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            this.sheets.delete(name);
            this.$$view.removeTab(name);
            this.destroySheet(sheet);
        }

        /**
         * 激活当前 workbook
         */

    }, {
        key: 'active',
        value: function active() {
            this.getActiveSheet().active();
        }

        /**
         * 激活指定 sheet
         * @param {string} sheetName
         */

    }, {
        key: 'activeSheet',
        value: function activeSheet(sheetName) {
            var sheet = this.getSheet(sheetName);
            if (sheet) {
                sheet.active();
            }
        }

        /**
         * 验证 sheet 名是否合法
         * @param {string} name
         * @param {boolean} exactly
         * @private
         */

    }, {
        key: '_validateSheetName',
        value: function _validateSheetName(name, exactly) {
            if (!name) {
                throw new _SheetError.SheetError('工作表的名称不能为空');
            }
            //  禁止一些特殊字符
            if (regExp.test(name)) {
                throw new _SheetError.SheetError('\u5DE5\u4F5C\u8868 "' + name + '" \u5305\u542B\u975E\u6CD5\u5B57\u7B26');
            }
            if (this.isSheetExist(name, exactly)) {
                throw new _SheetError.SheetError('\u5DE5\u4F5C\u8868 "' + name + '" \u5DF2\u5B58\u5728');
            }
        }
    }, {
        key: '_getExchange',
        value: function _getExchange() {
            var sheets = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.getSheets().toMap()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _step2$value = _slicedToArray(_step2.value, 2),
                        sheet = _step2$value[1];

                    sheet && sheets.push(sheet._getExchange());
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return {
                activeSheet: this.activeSheet,
                sheets: sheets
            };
        }
    }]);

    return Workbook;
}();

exports.default = Workbook;

},{"../settings":55,"../utils/common":57,"../utils/dataStructure":58,"./Sheet":11,"./SheetError":12,"./views/Tabs":18}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Exchange = exports.Exchange = function Exchange(Sup) {
    return function (_Sup) {
        _inherits(_class, _Sup);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: '_getExchange',
            value: function _getExchange() {
                var _getDataMeta2 = this._getDataMeta(),
                    data = _getDataMeta2.data,
                    cells = _getDataMeta2.cells;

                var _getSizeEx2 = this._getSizeEx(),
                    heights = _getSizeEx2.heights,
                    widths = _getSizeEx2.widths;

                var mergeCells = this.handsontable.getSettings().mergeCells;

                if (mergeCells === false) {
                    mergeCells = null; // 避免强类型语言解析时无法处理动态类型
                }

                return {
                    name: this.getName(),
                    selection: this.getSelection(),
                    data: data.length ? data : []._,
                    rowHeights: heights,
                    colWidths: widths,
                    mergeCells: mergeCells,
                    cellMetas: cells
                };
            }
        }, {
            key: '_getStylesEx',
            value: function _getStylesEx(meta) {
                var ret = {};
                var alignments = this._getAlignmentEx(meta.className);
                if (alignments) {
                    ret.alignments = alignments;
                }
                this._getFontEx(meta, ret);
                this._getBgColorEx(meta, ret);
                return ret;
            }
        }, {
            key: '_getBgColorEx',
            value: function _getBgColorEx(meta, ret) {
                if (meta._style_backgroundColor) {
                    ret.backgroundColor = meta._style_backgroundColor;
                }
            }
        }, {
            key: '_getFontEx',
            value: function _getFontEx(meta, ret) {
                if (meta._style_fontFamily) {
                    ret.fontFamily = meta._style_fontFamily;
                }
                if (meta._style_fontSize) {
                    ret.fontSize = meta._style_fontSize;
                }
                if (meta.className && meta.className.contains('ssd-font-italic')) {
                    ret.fontStyle = 'italic';
                }
                if (meta.className && meta.className.contains('ssd-font-bold')) {
                    ret.fontWeight = 'bold';
                }
                if (meta.className && meta.className.contains('ssd-font-underline')) {
                    ret.textDecoration = 'underline';
                }
                if (meta._style_color) {
                    ret.color = meta._style_color;
                }
            }
        }, {
            key: '_getAlignmentEx',
            value: function _getAlignmentEx(className) {
                var alignment = [];
                if (className) {
                    className.contains('htLeft') && alignment.push('Left');
                    className.contains('htCenter') && alignment.push('Center');
                    className.contains('htRight') && alignment.push('Right');
                    className.contains('htJustify') && alignment.push('Justify');
                    className.contains('htTop') && alignment.push('Top');
                    className.contains('htMiddle') && alignment.push('Middle');
                    className.contains('htBottom') && alignment.push('Bottom');
                }
                return alignment.length ? alignment : false;
            }
        }, {
            key: '_getSizeEx',
            value: function _getSizeEx() {
                var hot = this.handsontable;
                var cols = Math.max(hot.countCols() - hot.countEmptyCols(true), 20);
                var rows = Math.max(hot.countRows() - hot.countEmptyRows(true), 50);
                var heights = [];
                var widths = [];

                for (var i = 0; i < rows; ++i) {
                    var h = hot.getRowHeight(i);
                    if (i === 0 && !h) {
                        // handsontable bug
                        h = 24;
                    }
                    heights.push(h);
                }
                for (var _i = 0; _i < cols; ++_i) {
                    widths.push(hot.getColWidth(_i));
                }
                return { heights: heights, widths: widths };
            }
        }, {
            key: '_getDataMeta',
            value: function _getDataMeta() {
                var hot = this.handsontable;
                var cols = hot.countCols() - hot.countEmptyCols(true);
                var rows = hot.countRows() - hot.countEmptyRows(true);
                var data = [];
                var cells = [];

                for (var i = 0; i < rows; ++i) {
                    var rowResult = [];
                    var rowCellMeta = [];

                    for (var j = 0; j < cols; ++j) {
                        var _sourceData = hot.getSourceDataAtCell(i, j);
                        var _meta = hot.getCellMeta(i, j);
                        var _data = hot.getDataAtCell(i, j);
                        var _cellMata = {};

                        _cellMata.row = i;
                        _cellMata.col = j;
                        _cellMata.isFormula = !!(_sourceData && (_sourceData + '').charAt(0) === '=');
                        _cellMata.sourceValue = _sourceData;
                        _cellMata.value = _data;

                        (function (o, m) {
                            //noinspection JSUnusedLocalSymbols,LoopStatementThatDoesntLoopJS
                            for (var x in o) {
                                m.styles = o;
                                return;
                            }
                        })(this._getStylesEx(_meta), _cellMata);

                        // TODO dataType
                        rowResult.push(_sourceData);
                        rowCellMeta.push(_cellMata);
                    }
                    data.push(rowResult);
                    cells.push(rowCellMeta);
                }
                return { data: data, cells: cells };
            }

            // TODO

        }, {
            key: '_getBordersEx',
            value: function _getBordersEx() {}
        }]);

        return _class;
    }(Sup);
};

},{}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SheetHelper = exports.SheetHelper = function SheetHelper(Sup) {
    return function (_Sup) {
        _inherits(_class, _Sup);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: '_defaultSelection',
            value: function _defaultSelection(selection) {
                return {
                    startRow: selection.row,
                    endRow: selection.endRow || selection.row,
                    startCol: selection.col,
                    endCol: selection.endCol || selection.col
                };
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_removeFormerClass',
            value: function _removeFormerClass(current) {
                if (!current) {
                    return '';
                }

                for (var _len = arguments.length, supported = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    supported[_key - 1] = arguments[_key];
                }

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = supported[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var clazz = _step.value;

                        current = current.split(clazz).join('');
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return current.trim();
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_walkonCellMetas',
            value: function _walkonCellMetas(selection, callback, unhold) {
                var _defaultSelection2 = this._defaultSelection(selection),
                    startRow = _defaultSelection2.startRow,
                    endRow = _defaultSelection2.endRow,
                    startCol = _defaultSelection2.startCol,
                    endCol = _defaultSelection2.endCol;

                for (var i = startRow; i <= endRow; ++i) {
                    for (var j = startCol; j <= endCol; ++j) {
                        var cellMeta = this.handsontable.getCellMeta(i, j);
                        if (cellMeta) {
                            var newMeta = callback.call(this, i, j, cellMeta);
                            newMeta && this.handsontable.setCellMetaObject(i, j, newMeta);
                        } else {
                            unhold && this.handsontable.setCellMetaObject(i, j, unhold);
                        }
                    }
                }
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_walkonCells',
            value: function _walkonCells(selection, callback) {
                var _defaultSelection3 = this._defaultSelection(selection),
                    startRow = _defaultSelection3.startRow,
                    endRow = _defaultSelection3.endRow,
                    startCol = _defaultSelection3.startCol,
                    endCol = _defaultSelection3.endCol;

                for (var i = startRow; i <= endRow; ++i) {
                    for (var j = startCol; j <= endCol; ++j) {
                        var cellTD = this.handsontable.getCell(i, j, true);
                        if (cellTD) {
                            callback.call(this, i, j, cellTD);
                        }
                    }
                }
            }
        }]);

        return _class;
    }(Sup);
};

},{}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _common = require('../../utils/common');

var _ContextMenu_alignment = require('./ContextMenu_alignment');

/**
 * 电子表格右键菜单。
 */
function ContextMenu(spreadSheet) {
    this.spreadSheet = spreadSheet;
    /**
     *
     * @type {Map}
     */
    this.menuItems = new Map();
    this._init();
}

exports.default = ContextMenu;


ContextMenu.prototype.register = function (key, config, handler) {
    this.menuItems.set(key, {
        config: config,
        handler: handler
    });
};

/**
 * 获取 handsontable 需要的菜单配置项
 */
ContextMenu.prototype.getMenuItems4HotTable = function () {
    var _this = this;

    if (!this._hotTableItems) {
        this._hotTableItems = {};
        this.menuItems.forEach(function (_ref, key) {
            var config = _ref.config;
            return _this._hotTableItems[key] = config;
        });
    }
    return this._hotTableItems;
};

/*
 ### handsontable 自带右键功能：###
 row_above
 row_below
 hsep1
 col_left
 col_right
 hsep2
 remove_row
 remove_col
 hsep3
 undo
 redo
 make_read_only
 alignment
 borders
 */
ContextMenu.prototype._init = function () {
    var SEP = '---------';

    this.register('row_above', {
        name: '上方插入一行',
        disabled: function disabled() {
            // 调用者要确保此处 this  为当前 hotTable 实例
            // TODO 限制最大行数
            return false;
        }
    });

    this.register('row_below', {
        name: '下方插入一行'
    });

    this.register('hsep1', SEP);

    this.register('col_left', {
        name: '左侧插入一列'
    });

    this.register('col_right', {
        name: '右侧插入一列'
    });

    this.register('hsep2', SEP);

    // FIXME handsontable 自带的删除功能，在存在单元格合并时有BUG，改成自定义逻辑。
    this.register('remove_row', {
        name: '删除选中行',
        disabled: function disabled() {
            // TODO 限制最小行数
            return false;
        }
    });
    this.register('remove_col', {
        name: '删除选中列'
    });

    this.register('hsep3', SEP);
    this.register('alignment', (0, _ContextMenu_alignment.alignmentItem)());
    this.register('hsep4', SEP);

    this.register('q_merge_cells', {
        name: '单元格合并',
        disabled: function disabled() {
            var _getSelected = this.getSelected(),
                _getSelected2 = _slicedToArray(_getSelected, 4),
                r1 = _getSelected2[0],
                c1 = _getSelected2[1],
                r2 = _getSelected2[2],
                c2 = _getSelected2[3];

            if (r1 === r2 && c1 === c2) {
                return true;
            }
            return !mergeCompare.call(this, 'isEqual');
        }
    }, function (sheet, start, end) {
        sheet.mergeCells(start.row, start.col, end.row - start.row + 1, end.col - start.col + 1);
    });

    this.register('q_cancel_merge_cells', {
        name: '取消单元格合并',
        disabled: function disabled() {
            return mergeCompare.call(this, 'isSubset');
        }
    }, function (sheet, start, end) {
        sheet.unMergeCells(start.row, start.col, end.row - start.row + 1, end.col - start.col + 1);
    });
};

// private
function mergeCompare(type) {
    var merged = this.getSettings().mergeCells;
    if (merged && merged.length) {
        for (var i = 0; i < merged.length; ++i) {
            var _merged$i = merged[i],
                row = _merged$i.row,
                col = _merged$i.col,
                rowspan = _merged$i.rowspan,
                colspan = _merged$i.colspan;

            if (_common.Coordinate[type]([row, col, row + rowspan - 1, col + colspan - 1], this.getSelected())) {
                return false;
            }
        }
    }
    return true;
}

},{"../../utils/common":57,"./ContextMenu_alignment":17}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.alignmentItem = alignmentItem;
// TODO 对齐操作做成 API 方法。
function alignmentItem() {
    return {
        name: '对齐',
        disabled: function disabled() {
            return this.getSelectedRange() && !this.selection.selectedHeader.corner ? false : true;
        },
        submenu: {
            items: [{
                key: 'alignment:left',
                name: function name() {
                    var _this = this;

                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this.getCellMeta(row, col).className;
                        if (className && className.indexOf('htLeft') !== -1) {
                            return true;
                        }
                    });
                    return hasClass ? markLabelAsSelected('左对齐') : '左对齐';
                },
                callback: function callback() {
                    var _this2 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this2.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htLeft';
                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this2.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:center',
                name: function name() {
                    var _this3 = this;

                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this3.getCellMeta(row, col).className;
                        if (className && className.indexOf('htCenter') !== -1) {
                            return true;
                        }
                    });
                    return hasClass ? markLabelAsSelected('水平居中') : '水平居中';
                },
                callback: function callback() {
                    var _this4 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this4.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htCenter';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this4.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:right',
                name: function name() {
                    var _this5 = this;

                    var label = '右对齐';
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this5.getCellMeta(row, col).className;

                        if (className && className.indexOf('htRight') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this6 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this6.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htRight';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this6.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:justify',
                name: function name() {
                    var _this7 = this;

                    var label = '两端对齐';
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this7.getCellMeta(row, col).className;

                        if (className && className.indexOf('htJustify') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this8 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this8.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htJustify';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this8.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                name: '---------'
            }, {
                key: 'alignment:top',
                name: function name() {
                    var _this9 = this;

                    var label = '顶部对齐';
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this9.getCellMeta(row, col).className;
                        if (className && className.indexOf('htTop') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }
                    return label;
                },
                callback: function callback() {
                    var _this10 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this10.getCellMeta(row, col).className;
                    });
                    var type = 'vertical';
                    var alignment = 'htTop';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this10.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:middle',
                name: function name() {
                    var _this11 = this;

                    var label = '垂直居中';
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this11.getCellMeta(row, col).className;

                        if (className && className.indexOf('htMiddle') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this12 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this12.getCellMeta(row, col).className;
                    });
                    var type = 'vertical';
                    var alignment = 'htMiddle';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this12.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:bottom',
                name: function name() {
                    var _this13 = this;

                    var label = '底部对齐';
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this13.getCellMeta(row, col).className;

                        if (className && className.indexOf('htBottom') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this14 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this14.getCellMeta(row, col).className;
                    });
                    var type = 'vertical';
                    var alignment = 'htBottom';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this14.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }]
        }
    };
}

function checkSelectionConsistency(range, comparator) {
    var result = false;
    if (range) {
        range.forAll(function (row, col) {
            if (comparator(row, col)) {
                result = true;
                return false;
            }
        });
    }
    return result;
}

function markLabelAsSelected(label) {
    return '<span class="selected">' + String.fromCharCode(10003) + '</span>' + label;
}

function getAlignmentClasses(range, callback) {
    var classes = {};
    for (var row = range.from.row; row <= range.to.row; row++) {
        for (var col = range.from.col; col <= range.to.col; col++) {
            if (!classes[row]) {
                classes[row] = [];
            }
            classes[row][col] = callback(row, col);
        }
    }
    return classes;
}

function align(range, type, alignment, cellDescriptor) {
    if (range.from.row == range.to.row && range.from.col == range.to.col) {
        applyAlignClassName(range.from.row, range.from.col, type, alignment, cellDescriptor);
    } else {
        for (var row = range.from.row; row <= range.to.row; row++) {
            for (var col = range.from.col; col <= range.to.col; col++) {
                applyAlignClassName(row, col, type, alignment, cellDescriptor);
            }
        }
    }
}

function applyAlignClassName(row, col, type, alignment, cellDescriptor) {
    var cellMeta = cellDescriptor(row, col);
    var className = alignment;

    if (cellMeta.className) {
        if (type === 'vertical') {
            className = prepareVerticalAlignClass(cellMeta.className, alignment);
        } else {
            className = prepareHorizontalAlignClass(cellMeta.className, alignment);
        }
    }
    cellMeta.className = className;
}

function prepareVerticalAlignClass(className, alignment) {
    if (className.indexOf(alignment) != -1) {
        return className;
    }
    className = className.replace('htTop', '').replace('htMiddle', '').replace('htBottom', '').replace('  ', '');

    className += ' ' + alignment;
    return className;
}

function prepareHorizontalAlignClass(className, alignment) {
    if (className.indexOf(alignment) != -1) {
        return className;
    }
    className = className.replace('htLeft', '').replace('htCenter', '').replace('htRight', '').replace('htJustify', '').replace('  ', '');

    className += ' ' + alignment;

    return className;
}

},{}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _domHelper = require('../../utils/domHelper.js');

var _common = require('../../utils/common.js');

var _dataStructure = require('../../utils/dataStructure.js');

var _eventHelper = require('../../utils/eventHelper.js');

var _settings = require('../../settings.js');

var _i18n = require('../../i18n');

var _SheetError = require('.././SheetError');

var CLASS_CURRENT = 'current';
var CLASS_TABS = 'ssd-tabs';
var CLASS_CONTENT = 'ssd-tabs-content';
var CLASS_SECTION = 'ssd-tabs-section';
var CLASS_NAV = 'ssd-tabs-nav';
var CLASS_UL = 'ssd-tabs-ul';
var CLASS_LI = 'ssd-tabs-li';
var CLASS_FX = 'ssd-tabs-fx';

var animated = _settings.globalSettings.sheet.animated;
var regExp = _settings.globalSettings.sheet.sheetName;

/**
 * workbook 对应的视图，实际的 DOM 构成。
 * @private
 * @param {Workbook} workbook
 * @constructor
 */
function Tabs(workbook) {
    this.workbook = workbook;
    /**
     * @type {CaseInsensitiveMap}
     */
    this.liItems = new _dataStructure.CaseInsensitiveMap();
    this.sectionItems = new _dataStructure.CaseInsensitiveMap();
    this._hotTables = new Map();
    this.rootElement = workbook.spreadSheet.getRootElement();
    this.displayMode = workbook.spreadSheet.getDisplayMode();

    this.initDOM();
    this.initBox();
    this.render();
}

Tabs.prototype.render = function () {
    this.rootElement.appendChild(this.TABS);
};

/**
 * @private
 */
Tabs.prototype.initDOM = function () {
    this.TABS = document.createElement('div');
    this.CONTENT = document.createElement('div');
    this.NAV = document.createElement('nav');
    this.UL = document.createElement('ul');

    this.TABS.classList.add(CLASS_TABS);
    this.TABS.id = this.workbook.getId();
    this.CONTENT.classList.add(CLASS_CONTENT);
    this.NAV.classList.add(CLASS_NAV);
    this.UL.classList.add(CLASS_UL);

    this.TABS.appendChild(this.CONTENT);
    this.TABS.appendChild(this.NAV);
    this.NAV.appendChild(this.UL);

    // 增加 sheet 页的 button
    this.appendAddButton();
};

/**
 * @private
 */
Tabs.prototype.initBox = function () {
    var rootEl = this.workbook.spreadSheet.getRootElement();
    this.width = this.workbook.width || (0, _domHelper.outerWidth)(rootEl, false);
    this.height = this.workbook.height || (0, _domHelper.outerHeight)(rootEl, false);

    this.TABS.style.width = this.width + 'px';
    this.TABS.style.height = this.height + 'px';
};

/**
 * 增加一个 tab 页
 * @param {string} sheetName - sheet 名， 即 tab 页的标题
 */
Tabs.prototype.appendTab = function (sheetName) {
    var that = this;
    var li = document.createElement('li');
    var clazz = this.displayMode ? '' : 'close hairline';

    li.innerHTML = '\n        <a href="javascript:;">\n            <span>' + sheetName + '</span>\n            <span class="' + clazz + '"></span>\n        </a>\n    ';
    li.classList.add(CLASS_LI);
    li.setAttribute('data-sheet', sheetName);

    var activeTab = this.TABS.querySelector('.' + CLASS_CURRENT + '.' + CLASS_LI);
    if (activeTab) {
        (0, _domHelper.insertAfter)(activeTab, li);
    } else {
        this.UL.appendChild(li);
    }
    this.liItems.set(sheetName, li);

    li.addEventListener('click', function (e) {
        var sheetName = this.dataset.sheet;
        var sheet = that.workbook.getSheet(sheetName);
        sheet.active();
        (0, _eventHelper.stopImmediatePropagation)(e);
    });

    if (!this.displayMode) {
        li.addEventListener('dblclick', function (e) {
            that._onTabDblclick.call(that, this);
            (0, _eventHelper.stopImmediatePropagation)(e);
        });

        li.querySelector('.close').addEventListener('click', function (e) {
            var sheetName = li.dataset.sheet;
            try {
                that.workbook.closeSheet(sheetName);
            } catch (e) {
                if (e instanceof _SheetError.SheetError) {
                    alert(e.message);
                } else {
                    throw e;
                }
            }
            (0, _eventHelper.stopImmediatePropagation)(e);
        });
    }

    this.appendContent(sheetName);
};

/**
 * 增加一个 tab 页
 * @param {string} sheetName - sheet 名， 即 tab 页的标题
 */
Tabs.prototype.removeTab = function (sheetName) {
    var li = this.liItems.get(sheetName);
    this.UL.removeChild(li);
    this.liItems.delete(sheetName);

    this.removeContent(sheetName);
};

Tabs.prototype.appendAddButton = function () {
    var that = this;
    var li = document.createElement('li');
    var innerHtml = this.displayMode ? '&nbsp;' : '+';

    li.innerHTML = '<a href="javascript:;"><span>' + innerHtml + '</span></a>';
    li.classList.add(CLASS_LI);
    if (!this.displayMode) {
        li.classList.add('add-tab');
    }
    this.UL.appendChild(li);

    if (!this.displayMode) {
        li.addEventListener('click', function () {
            try {
                var newSheet = that.workbook.createSheet();
                newSheet.active();
            } catch (e) {
                if (e instanceof _SheetError.SheetError) {
                    alert(e.message);
                } else {
                    throw e;
                }
            }
        });
    }
};

/**
 * @param {HTMLElement} li
 * @private
 */
Tabs.prototype._onTabDblclick = function (li) {
    var that = this;
    var sheetName = li.dataset.sheet;
    var span = li.getElementsByTagName('span')[0];
    var input = document.createElement('input');

    input.setAttribute('type', 'text');
    input.value = sheetName;
    input.classList.add('editorial');
    input.style.width = (0, _domHelper.outerWidth)(span) + 20 + 'px'; // 名字太短时不好输入，增补20px

    input.addEventListener('blur', function () {
        var check = that._checkTabName(sheetName, this.value);
        if (check === true) {
            that.workbook.renameSheet(sheetName, this.value);
        } else {
            alert(check); // TODO alert 太丑
            that.tabRenameCancel(sheetName, this.value);
        }
    });
    input.addEventListener('keypress', function (event) {
        if (event.keyCode === 13) {
            this.blur();
        }
    });

    (0, _domHelper.empty)(span);
    span.appendChild(input);
    input.select();
};

Tabs.prototype._checkTabName = function (name1, name2) {
    if ((0, _common.isEmptyValue)(name2)) {
        return _i18n.WARNS.S1;
    }
    if (regExp.test(name2)) {
        return _i18n.WARNS.S2;
    }
    // 改成其它已有的sheet名
    if ((0, _common.upperCase)(name1) !== (0, _common.upperCase)(name2) && this.workbook.isSheetExist(name2)) {
        return _i18n.WARNS.S3;
    }
    return true;
};

// 改名时，DOM上的一些操作，进入此方法时代表已经做了合法验证。
Tabs.prototype.tabRename = function (name1, name2) {
    var li = this.liItems.get(name1);
    var span = li.getElementsByTagName('span')[0];
    (0, _domHelper.innerHTML)(span, name2);
    li.dataset.sheet = name2;
    this.liItems.set(name2, li);
    var section = this.sectionItems.get(name1);
    section.dataset.sheet = name2;
    this.sectionItems.delete(name1);
    this.sectionItems.set(name2, section);

    var sheetNow = this.workbook.getSheet(name2);
    sheetNow.emit('afterRename', sheetNow, name1, name2);
};

// 更名失败，将名字设为 name1, name2为失败的名字
Tabs.prototype.tabRenameCancel = function (name1, name2) {
    var li = this.liItems.get(name1);
    var span = li.getElementsByTagName('span')[0];
    (0, _domHelper.innerHTML)(span, name1);

    var sheetNow = this.workbook.getSheet(name1);
    sheetNow.emit('afterRenameCancel', sheetNow, name1, name2);
};

/**
 * 增加标签页对应的内容
 * @param {string} sheetName
 */
Tabs.prototype.appendContent = function (sheetName) {
    var section = document.createElement('section');
    var fx = document.createElement('div');
    var hot = document.createElement('div');

    section.setAttribute('data-sheet', sheetName);
    section.appendChild(fx);
    section.appendChild(hot);
    section.classList.add(CLASS_SECTION);
    animated && section.classList.add('ssd-animated-fast');

    this.CONTENT.appendChild(section);
    this.sectionItems.set(sheetName, section);

    this.appendFx(fx, sheetName);
    this.appendTable(hot, sheetName);
};

Tabs.prototype.removeContent = function (sheetName) {
    var section = this.sectionItems.get(sheetName);
    this.CONTENT.removeChild(section);
    this.sectionItems.delete(sheetName);
};

/**
 *
 * @param {string} sheetName
 */
Tabs.prototype.hideContent = function (sheetName) {
    var section = this.sectionItems.get(sheetName);
    section.style.display = 'none';
};

/**
 * TODO 公式输入框
 * @private
 * @param {HTMLElement} fx
 * @param {string} sheetName
 */
Tabs.prototype.appendFx = function (fx, sheetName) {
    fx.classList.add(CLASS_FX);
    fx.classList.add(CLASS_FX + '-' + sheetName);
};

/**
 * 假渲染 Hansontable 组件。
 * handsontable 的设计无法在DOM中计算视图，必须渲染rootElement之后才能生效。
 * 导致延迟渲染难以实现，有渲染性能问题时再解决。
 * 另外，渲染到先隐藏后显示的元素中时，也无法正常显示。
 * @private
 * @param hot
 * @param sheetName
 */
Tabs.prototype.appendTable = function (hot, sheetName) {
    var _this = this;

    this._hotTables.set(sheetName, {
        container: hot,
        width: this.width,
        height: function height() {
            return _this.height - (0, _domHelper.outerHeight)(_this.NAV);
        }
    });
};

/**
 * 激活指定的标签页
 * @param {string} sheetName - sheet 名
 */
Tabs.prototype.activeTab = function (sheetName) {
    var former = this.TABS.querySelector('.' + CLASS_CURRENT + '.' + CLASS_LI);
    former && former.classList.remove(CLASS_CURRENT);
    var li = this.liItems.get(sheetName);
    li.classList.add(CLASS_CURRENT);
    this.activeContent(sheetName);
};

/**
 * @private
 * @param {string} sheetName - sheet 名
 */
Tabs.prototype.activeContent = function (sheetName) {
    var section = this.sectionItems.get(sheetName);
    var former = this._formerActiveContent;
    if (former) {
        animated && former.classList.remove('fadeIn');
        former.style.display = 'none';
    }
    section.style.display = 'block';
    animated && section.classList.add('fadeIn');

    this._formerActiveContent = section;
};

exports.default = Tabs;

},{"../../i18n":19,"../../settings.js":55,"../../utils/common.js":57,"../../utils/dataStructure.js":58,"../../utils/domHelper.js":59,"../../utils/eventHelper.js":60,".././SheetError":12}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
var WARNS = exports.WARNS = {

    S1: "\u5DE5\u4F5C\u8868\u540D\u4E0D\u80FD\u4E3A\u7A7A\u767D\u3002",
    S2: "\u5DE5\u4F5C\u8868\u540D\u79F0\u5305\u542B\u65E0\u6548\u5B57\u7B26: :  / ? * [ ]\u3002",
    S3: "\u8BE5\u540D\u79F0\u5DF2\u88AB\u4F7F\u7528\uFF0C\u8BF7\u5C1D\u8BD5\u5176\u4ED6\u540D\u79F0\u3002"

};

},{}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Plugin = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.validatePlugin = validatePlugin;
exports.registerPlugin = registerPlugin;
exports.getPlugin = getPlugin;
exports.getAllPlugins = getAllPlugins;

var _PluginError = require('./PluginError');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _plugins = new Map();

/**
 * 插件基类
 */

var Plugin = function () {

    /**
     *
     * @param {SpreadSheet} spreadSheet
     */
    function Plugin(spreadSheet) {
        _classCallCheck(this, Plugin);

        /**
         * @type {SpreadSheet}
         */
        this.spreadsheet = spreadSheet;
        this.enabled = false;
    }

    // 暂时不考虑开放这个方法，用户定义的插件不能扩展 SpreadSheet 的 API


    _createClass(Plugin, [{
        key: '_registerMethod',
        value: function _registerMethod(name) {
            var _this = this;

            var proto = this.spreadsheet.constructor.prototype;
            proto[name] = function () {
                return _this[name]();
            };
        }
    }, {
        key: 'isEnable',
        value: function isEnable() {
            return false;
        }
    }, {
        key: 'enable',
        value: function enable() {}
    }, {
        key: 'destroy',
        value: function destroy() {}
    }]);

    return Plugin;
}();

exports.Plugin = Plugin;
function validatePlugin(p) {
    if (!p.enable) {
        throw new _PluginError.PluginError('插件必须包含启用方法：enable');
    }
    if (!p.destroy) {
        throw new _PluginError.PluginError('插件必须包含销毁方法：destroy');
    }
}

function registerPlugin(name, plugin) {
    _plugins.set(name, plugin);
    plugin.prototype.__name__ = name;
}

function getPlugin(name) {
    var p = _plugins.get(name);
    if (!p) {
        throw new _PluginError.PluginError('插件不存在：' + name);
    }
    return p;
}

/**
 * 获取所有插件
 * @returns {Map}
 */
function getAllPlugins() {
    return _plugins;
}

},{"./PluginError":21}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PluginError = PluginError;

var _SpreadSheetError = require('../SpreadSheetError');

function PluginError(value) {
    this.name = 'PluginError';
    this.message = value;
}
PluginError.prototype = new _SpreadSheetError.SpreadSheetError();
PluginError.prototype.constructor = PluginError;

},{"../SpreadSheetError":5}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Plugin2 = require('../Plugin');

var _Storage = require('./Storage');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Persistent = function (_Plugin) {
    _inherits(Persistent, _Plugin);

    function Persistent(ssd) {
        _classCallCheck(this, Persistent);

        var _this = _possibleConstructorReturn(this, (Persistent.__proto__ || Object.getPrototypeOf(Persistent)).call(this, ssd));

        var settings = _this.spreadsheet.settings;

        if (settings.persistent === true) {
            // persistent 为 `true` 时，使用默认方案
            /**
             * 电子表格本地持久化时使用的 key
             */
            _this.persistentKey = ssd.getId();
        } else {
            // TODO persistent 为对象时，提供 localStorage、session 等方案及超时时间等相关配置
            _this.persistentKey = settings.persistent.key;
        }

        _this.spreadsheet.settings = _Storage.Storage.load(_this.persistentKey) || settings;

        _this._registerMethod('saveState');
        return _this;
    }

    _createClass(Persistent, [{
        key: 'isEnable',
        value: function isEnable() {
            return !!this.spreadsheet.getSettings().persistent;
        }
    }, {
        key: 'enable',
        value: function enable() {
            _get(Persistent.prototype.__proto__ || Object.getPrototypeOf(Persistent.prototype), 'enable', this).call(this);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            _get(Persistent.prototype.__proto__ || Object.getPrototypeOf(Persistent.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'saveState',
        value: function saveState() {
            var data = this.spreadsheet.getExchangeData();
            _Storage.Storage.save(this.persistentKey, data);
        }
    }]);

    return Persistent;
}(_Plugin2.Plugin);

exports.default = Persistent;

},{"../Plugin":20,"./Storage":23}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 存储方案
 */
var Storage = function () {
    function Storage() {
        _classCallCheck(this, Storage);
    }

    _createClass(Storage, null, [{
        key: 'save',
        value: function save(key, value) {
            if (typeof value !== 'string') {
                value = JSON.stringify(value);
            }
            window.localStorage.setItem(Storage.PREFIX + key, value);
        }
    }, {
        key: 'load',
        value: function load(key) {
            var val = window.localStorage.getItem(Storage.PREFIX + key);
            try {
                return JSON.parse(val);
            } catch (e) {
                return val;
            }
        }
    }, {
        key: 'remove',
        value: function remove(key) {
            if (window.localStorage[Storage.PREFIX + key]) {
                window.localStorage.removeItem(Storage.PREFIX + key);
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            window.localStorage.clear();
        }
    }]);

    return Storage;
}();

Storage.PREFIX = '$$brick!storage-';

exports.Storage = Storage;

},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AlterManager = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

var _utils = require('./utils');

var _expressionModifier = require('./expressionModifier');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var mixin = Handsontable.helper.mixin;
var localHooks = Handsontable.utils.localHooks; // private


var AlterManager = function () {
    function AlterManager(sheet) {
        _classCallCheck(this, AlterManager);

        this.sheet = sheet;

        this.dataProvider = sheet.dataProvider;

        this.matrix = sheet.matrix;
    }

    _createClass(AlterManager, [{
        key: 'insertRow',
        value: function insertRow(row, amount, modifyFormula) {
            this._alter('insert', 'row', row, amount, modifyFormula);
        }
    }, {
        key: 'removeRow',
        value: function removeRow(row, amount, modifyFormula) {
            this._alter('remove', 'row', row, -amount, modifyFormula);
        }
    }, {
        key: 'insertColumn',
        value: function insertColumn(column, amount, modifyFormula) {
            this._alter('insert', 'column', column, amount, modifyFormula);
        }
    }, {
        key: 'removeColumn',
        value: function removeColumn(column, amount, modifyFormula) {
            this._alter('remove', 'column', column, -amount, modifyFormula);
        }
    }, {
        key: '_alter',
        value: function _alter(action, axis, start, amount) {
            var _this = this;

            var modifyFormula = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

            var startCoord = function startCoord(cell) {
                return {
                    row: axis === 'row' ? start : cell.row,
                    column: axis === 'column' ? start : cell.column
                };
            };
            var translateCellRefs = function translateCellRefs(row, column) {
                arrayEach(_this.matrix.cellReferences, function (cell) {
                    if (cell[axis] >= start) {
                        cell.translateTo(row, column);
                    }
                });
            };

            var translate = [];
            var indexOffset = Math.abs(amount) - 1;

            if (axis === 'row') {
                translate.push(amount, 0);
            } else if (axis === 'column') {
                translate.push(0, amount);
            }

            if (action === 'remove') {
                (function () {
                    var removedCellRef = _this.matrix.removeCellRefsAtRange(_defineProperty({}, axis, start), _defineProperty({}, axis, start + indexOffset));
                    var toRemove = [];

                    arrayEach(_this.matrix.data, function (cell) {
                        arrayEach(removedCellRef, function (cellRef) {
                            if (!cell.hasPrecedent(cellRef)) {
                                return;
                            }

                            cell.removePrecedent(cellRef);
                            cell.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);

                            arrayEach(_this.sheet.getCellDependencies(cell.row, cell.column), function (cellValue) {
                                cellValue.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
                            });
                        });

                        if (cell[axis] >= start && cell[axis] <= start + indexOffset) {
                            toRemove.push(cell);
                        }
                    });

                    _this.matrix.remove(toRemove);
                })();
            }

            translateCellRefs.apply(undefined, translate);

            arrayEach(this.matrix.data, function (cell) {
                var origRow = cell.row;
                var origColumn = cell.column;

                if (cell[axis] >= start) {
                    cell.translateTo.apply(cell, translate);
                    cell.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
                }

                if (modifyFormula) {
                    var row = cell.row;
                    var column = cell.column;
                    var value = _this.dataProvider.getSourceDataAtCell(row, column);

                    if ((0, _utils.isFormulaExpression)(value)) {
                        var expModifier = new _expressionModifier.ExpressionModifier(value);

                        expModifier.translate(startCoord({ row: origRow, column: origColumn }), _defineProperty({}, axis, amount));

                        _this.dataProvider.updateSourceData(row, column, expModifier.toString());
                    }
                }
            });
            this.runLocalHooks('afterAlter', action, axis, start, amount);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.sheet = null;
            this.dataProvider = null;
            this.matrix = null;
        }
    }]);

    return AlterManager;
}();

mixin(AlterManager, localHooks);

exports.AlterManager = AlterManager;

},{"./CellValue":27,"./expressionModifier":33,"./utils":53}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./parser/utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var isObject = Handsontable.helper.isObject;

var BaseCell = function () {
    function BaseCell(row, column) {
        _classCallCheck(this, BaseCell);

        var rowObject = isObject(row);
        var columnObject = isObject(column);

        this._row = rowObject ? row.index : row;
        this.rowAbsolute = rowObject ? row.isAbsolute : false;
        this._column = columnObject ? column.index : column;
        this.columnAbsolute = columnObject ? column.isAbsolute : false;
        this.rowOffset = 0;
        this.columnOffset = 0;

        Object.defineProperty(this, 'row', {
            get: function get() {
                return this.rowOffset + this._row;
            },
            set: function set(row) {
                this._row = row;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(this, 'column', {
            get: function get() {
                return this.columnOffset + this._column;
            },
            set: function set(column) {
                this._column = column;
            },
            enumerable: true,
            configurable: true
        });
    }

    _createClass(BaseCell, [{
        key: 'translateTo',
        value: function translateTo(rowOffset, columnOffset) {
            this.row = this.row + rowOffset;
            this.column = this.column + columnOffset;
        }
    }, {
        key: 'isEqual',
        value: function isEqual(cell) {
            return cell.row === this.row && cell.column === this.column;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return (0, _utils.toLabel)({ index: this.row, isAbsolute: this.rowAbsolute }, { index: this.column, isAbsolute: this.columnAbsolute });
        }
    }]);

    return BaseCell;
}();

exports.default = BaseCell;

},{"./parser/utils":52}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CellReference = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseCell2 = require('./BaseCell');

var _BaseCell3 = _interopRequireDefault(_BaseCell2);

var _utils = require('./parser/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CellReference = function (_BaseCell) {
    _inherits(CellReference, _BaseCell);

    function CellReference(row, column) {
        _classCallCheck(this, CellReference);

        return _possibleConstructorReturn(this, (CellReference.__proto__ || Object.getPrototypeOf(CellReference)).call(this, row, column));
    }

    _createClass(CellReference, [{
        key: 'toString',
        value: function toString() {
            return (0, _utils.toLabel)({ index: this.row, isAbsolute: false }, { index: this.column, isAbsolute: false });
        }
    }]);

    return CellReference;
}(_BaseCell3.default);

exports.CellReference = CellReference;

},{"./BaseCell":25,"./parser/utils":52}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CellValue = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseCell2 = require('./BaseCell');

var _BaseCell3 = _interopRequireDefault(_BaseCell2);

var _error = require('./parser/error');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var STATE_OUT_OFF_DATE = 1;
var STATE_COMPUTING = 2;
var STATE_UP_TO_DATE = 3;
var states = [STATE_OUT_OFF_DATE, STATE_COMPUTING, STATE_UP_TO_DATE];

var arrayFilter = Handsontable.helper.arrayFilter;

var CellValue = function (_BaseCell) {
    _inherits(CellValue, _BaseCell);

    _createClass(CellValue, null, [{
        key: 'STATE_OUT_OFF_DATE',
        get: function get() {
            return 1;
        }
    }, {
        key: 'STATE_COMPUTING',
        get: function get() {
            return 2;
        }
    }, {
        key: 'STATE_UP_TO_DATE',
        get: function get() {
            return 3;
        }
    }]);

    function CellValue(row, column) {
        _classCallCheck(this, CellValue);

        var _this = _possibleConstructorReturn(this, (CellValue.__proto__ || Object.getPrototypeOf(CellValue)).call(this, row, column));

        _this.precedents = [];
        _this.value = null;
        _this.error = null;
        _this.state = CellValue.STATE_UP_TO_DATE;
        return _this;
    }

    _createClass(CellValue, [{
        key: 'setValue',
        value: function setValue(value) {
            this.value = value;
        }
    }, {
        key: 'getValue',
        value: function getValue() {
            return this.value;
        }
    }, {
        key: 'setError',
        value: function setError(error) {
            this.error = error;
        }
    }, {
        key: 'getError',
        value: function getError() {
            return this.error;
        }
    }, {
        key: 'hasError',
        value: function hasError() {
            return this.error !== null;
        }
    }, {
        key: 'setState',
        value: function setState(state) {
            if (states.indexOf(state) === -1) {
                throw '\u672A\u77E5\u72B6\u6001: ' + state;
            }
            this.state = state;
        }
    }, {
        key: 'isState',
        value: function isState(state) {
            return this.state === state;
        }
    }, {
        key: 'addPrecedent',
        value: function addPrecedent(cellReference) {
            if (this.isEqual(cellReference)) {
                throw Error(_error.ERROR_REF);
            }
            if (!this.hasPrecedent(cellReference)) {
                this.precedents.push(cellReference);
            }
        }
    }, {
        key: 'removePrecedent',
        value: function removePrecedent(cellReference) {
            if (this.isEqual(cellReference)) {
                throw Error(_error.ERROR_REF);
            }
            this.precedents = arrayFilter(this.precedents, function (cell) {
                return !cell.isEqual(cellReference);
            });
        }
    }, {
        key: 'getPrecedents',
        value: function getPrecedents() {
            return this.precedents;
        }
    }, {
        key: 'hasPrecedents',
        value: function hasPrecedents() {
            return this.precedents.length > 0;
        }
    }, {
        key: 'hasPrecedent',
        value: function hasPrecedent(cellReference) {
            return arrayFilter(this.precedents, function (cell) {
                return cell.isEqual(cellReference);
            }).length ? true : false;
        }
    }]);

    return CellValue;
}(_BaseCell3.default);

exports.CellValue = CellValue;

},{"./BaseCell":25,"./parser/error":34}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataProvider = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var rangeEach = Handsontable.helper.rangeEach;

var DataProvider = function () {
    function DataProvider(hot) {
        _classCallCheck(this, DataProvider);

        this.hot = hot;
        this.changes = {};
    }

    _createClass(DataProvider, [{
        key: 'collectChanges',
        value: function collectChanges(row, column, value) {
            if (!(0, _utils.isFormulaExpression)(value)) {
                this.changes[DataProvider._coordId(row, column)] = value;
            }
        }
    }, {
        key: 'clearChanges',
        value: function clearChanges() {
            this.changes = {};
        }
    }, {
        key: 'isInDataRange',
        value: function isInDataRange(row, column) {
            return row >= 0 && row < this.hot.countRows() && column >= 0 && column < this.hot.countCols();
        }
    }, {
        key: 'getDataAtCell',
        value: function getDataAtCell(row, column) {
            var id = DataProvider._coordId(row, column);
            var result = void 0;

            if (this.changes.hasOwnProperty(id)) {
                result = this.changes[id];
            } else {
                result = this.hot.getDataAtCell(row, column);
            }
            return result;
        }
    }, {
        key: 'getDataAtCellInSheet',
        value: function getDataAtCellInSheet(sheetName, row, column) {
            var sheet = this.workbook.getSheet(sheetName);
            var formulas = sheet.handsontable.getPlugin('XFormulas');
            return formulas.sheet.dataProvider.getDataAtCell(row, column);
        }
    }, {
        key: 'getDataByRange',
        value: function getDataByRange(row1, column1, row2, column2) {
            var _this = this;

            var result = this.hot.getData(row1, column1, row2, column2);

            arrayEach(result, function (rowData, rowIndex) {
                arrayEach(rowData, function (value, columnIndex) {
                    var id = DataProvider._coordId(rowIndex + row1, columnIndex + column1);

                    if (_this.changes.hasOwnProperty(id)) {
                        result[rowIndex][columnIndex] = _this.changes[id];
                    }
                });
            });

            return result;
        }
    }, {
        key: 'getSourceDataAtCell',
        value: function getSourceDataAtCell(row, column) {
            return this.hot.getSourceDataAtCell(row, column);
        }
    }, {
        key: 'getSourceDataByRange',
        value: function getSourceDataByRange(row1, column1, row2, column2) {
            return this.hot.getSourceDataArray(row1, column1, row2, column2);
        }
    }, {
        key: 'updateSourceData',
        value: function updateSourceData(row, column, value) {
            this.hot.getSourceData()[row][this.hot.colToProp(column)] = value;
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.hot = null;
            this.changes = null;
        }
    }], [{
        key: '_coordId',
        value: function _coordId(row, column) {
            return row + ':' + column;
        }
    }]);

    return DataProvider;
}();

exports.DataProvider = DataProvider;

},{"./utils":53}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Matrix = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var arrayFilter = Handsontable.helper.arrayFilter;
var arrayReduce = Handsontable.helper.arrayReduce;

var Matrix = function () {
    function Matrix() {
        _classCallCheck(this, Matrix);

        this.data = [];
        this.cellReferences = [];
    }

    _createClass(Matrix, [{
        key: 'getCellAt',
        value: function getCellAt(row, column) {
            var result = null;

            arrayEach(this.data, function (cell) {
                if (cell.row === row && cell.column === column) {
                    result = cell;

                    return false;
                }
            });

            return result;
        }
    }, {
        key: 'getOutOfDateCells',
        value: function getOutOfDateCells() {
            return arrayFilter(this.data, function (cell) {
                return cell.isState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
            });
        }
    }, {
        key: 'add',
        value: function add(cellValue) {
            if (!arrayFilter(this.data, function (cell) {
                return cell.isEqual(cellValue);
            }).length) {
                this.data.push(cellValue);
            }
        }
    }, {
        key: 'remove',
        value: function remove(cellValue) {
            var isArray = Array.isArray(cellValue);
            var isEqual = function isEqual(cell, cellValue) {
                var result = false;

                if (isArray) {
                    arrayEach(cellValue, function (value) {
                        if (cell.isEqual(value)) {
                            result = true;

                            return false;
                        }
                    });
                } else {
                    result = cell.isEqual(cellValue);
                }

                return result;
            };
            this.data = arrayFilter(this.data, function (cell) {
                return !isEqual(cell, cellValue);
            });
        }
    }, {
        key: 'getDependencies',
        value: function getDependencies(cellValue) {
            var _this = this;

            var getDependencies = function getDependencies(cell) {
                return arrayReduce(_this.data, function (acc, cellValue) {
                    if (cellValue.hasPrecedent(cell) && acc.indexOf(cellValue) === -1) {
                        acc.push(cellValue);
                    }

                    return acc;
                }, []);
            };

            var getTotalDependencies = function getTotalDependencies(cell) {
                var deps = getDependencies(cell);

                if (deps.length) {
                    arrayEach(deps, function (cellValue) {
                        if (cellValue.hasPrecedents()) {
                            deps = deps.concat(getTotalDependencies(cellValue));
                        }
                    });
                }

                return deps;
            };

            return getTotalDependencies(cellValue);
        }
    }, {
        key: 'registerCellRef',
        value: function registerCellRef(cellReference) {
            if (!arrayFilter(this.cellReferences, function (cell) {
                return cell.isEqual(cellReference);
            }).length) {
                this.cellReferences.push(cellReference);
            }
        }
    }, {
        key: 'removeCellRefsAtRange',
        value: function removeCellRefsAtRange(_ref, _ref2) {
            var startRow = _ref.row,
                startColumn = _ref.column;
            var endRow = _ref2.row,
                endColumn = _ref2.column;

            var removed = [];

            var rowMatch = function rowMatch(cell) {
                return startRow === void 0 ? true : cell.row >= startRow && cell.row <= endRow;
            };
            var colMatch = function colMatch(cell) {
                return startColumn === void 0 ? true : cell.column >= startColumn && cell.column <= endColumn;
            };

            this.cellReferences = arrayFilter(this.cellReferences, function (cell) {
                if (rowMatch(cell) && colMatch(cell)) {
                    removed.push(cell);

                    return false;
                }

                return true;
            });

            return removed;
        }
    }, {
        key: 'reset',
        value: function reset() {
            this.data.length = 0;
            this.cellReferences.length = 0;
        }
    }]);

    return Matrix;
}();

exports.Matrix = Matrix;

},{"./CellValue":27}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Sheet = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

var _CellReference = require('./CellReference');

var _utils = require('./utils');

var _Matrix = require('./Matrix');

var _AlterManager = require('./AlterManager');

var _parser = require('./parser/parser');

var _error = require('./parser/error');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var STATE_UP_TO_DATE = 1;
var STATE_NEED_REBUILD = 2;
var STATE_NEED_FULL_REBUILD = 3;

var arrayEach = Handsontable.helper.arrayEach;
var arrayMap = Handsontable.helper.arrayMap;
var rangeEach = Handsontable.helper.rangeEach;
var objectEach = Handsontable.helper.objectEach;
var mixin = Handsontable.helper.mixin;
var localHooks = Handsontable.utils.localHooks; // private


var Sheet = function () {
    function Sheet(dataProvider) {
        var _this = this;

        _classCallCheck(this, Sheet);

        this.dataProvider = dataProvider;
        this.parser = new _parser.Parser();
        this.matrix = new _Matrix.Matrix();
        this.alterManager = new _AlterManager.AlterManager(this);

        this._processingCell = null;
        this._state = STATE_NEED_FULL_REBUILD;

        this.parser.on('callCellValue', function () {
            return _this._onCallCellValue.apply(_this, arguments);
        });
        this.parser.on('callRangeValue', function () {
            return _this._onCallRangeValue.apply(_this, arguments);
        });
        this.parser.on('callCellValueInSheet', function () {
            return _this._onCallCellValueInSheet.apply(_this, arguments);
        });
        this.parser.on('callRangeValueInSheet', function () {
            return _this._onCallRangeValueInSheet.apply(_this, arguments);
        });
        this.alterManager.addLocalHook('afterAlter', function () {
            return _this._onAfterAlter.apply(_this, arguments);
        });
    }

    _createClass(Sheet, [{
        key: 'recalculate',
        value: function recalculate() {
            switch (this._state) {
                case STATE_NEED_FULL_REBUILD:
                    this.recalculateFull();
                    break;
                case STATE_NEED_REBUILD:
                    this.recalculateOptimized();
                    break;
            }
        }
    }, {
        key: 'recalculateOptimized',
        value: function recalculateOptimized() {
            var _this2 = this;

            var cells = this.matrix.getOutOfDateCells();

            arrayEach(cells, function (cellValue) {
                var value = _this2.dataProvider.getSourceDataAtCell(cellValue.row, cellValue.column);

                if ((0, _utils.isFormulaExpression)(value)) {
                    _this2.parseExpression(cellValue, value.substr(1));
                }
            });

            this._state = STATE_UP_TO_DATE;
            this.runLocalHooks('afterRecalculate', cells, 'optimized');
        }
    }, {
        key: 'recalculateFull',
        value: function recalculateFull() {
            var _this3 = this;

            var cells = this.dataProvider.getSourceDataByRange();
            this.matrix.reset();

            arrayEach(cells, function (rowData, row) {
                arrayEach(rowData, function (value, column) {
                    if ((0, _utils.isFormulaExpression)(value)) {
                        _this3.parseExpression(new _CellValue.CellValue(row, column), value.substr(1));
                    }
                });
            });

            this._state = STATE_UP_TO_DATE;
            this.runLocalHooks('afterRecalculate', cells, 'full');
        }
    }, {
        key: 'setVariable',
        value: function setVariable(name, value) {
            this.parser.setVariable(name, value);
        }
    }, {
        key: 'getVariable',
        value: function getVariable(name) {
            return this.parser.getVariable(name);
        }
    }, {
        key: 'applyChanges',
        value: function applyChanges(row, column, newValue) {
            // TODO: Move this to recalculate()
            this.matrix.remove({ row: row, column: column });

            // TODO: Move this to recalculate()
            if ((0, _utils.isFormulaExpression)(newValue)) {
                this.parseExpression(new _CellValue.CellValue(row, column), newValue.substr(1));
            }

            var deps = this.getCellDependencies(row, column);

            arrayEach(deps, function (cellValue) {
                cellValue.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
            });

            this._state = STATE_NEED_REBUILD;
        }
    }, {
        key: 'parseExpression',
        value: function parseExpression(cellValue, formula) {
            cellValue.setState(_CellValue.CellValue.STATE_COMPUTING);
            this._processingCell = cellValue;

            // TODO  wrapper formula
            // var sheetNames = this.dataProvider.workbook.getSheetNames();

            var _parser$parse = this.parser.parse((0, _utils.toUpperCaseFormula)(formula)),
                error = _parser$parse.error,
                result = _parser$parse.result;

            cellValue.setValue(result);
            cellValue.setError(error);
            cellValue.setState(_CellValue.CellValue.STATE_UP_TO_DATE);

            this.matrix.add(cellValue);
            this._processingCell = null;
        }
    }, {
        key: 'getCellAt',
        value: function getCellAt(row, column) {
            return this.matrix.getCellAt(row, column);
        }
    }, {
        key: 'getCellDependencies',
        value: function getCellDependencies(row, column) {
            return this.matrix.getDependencies({ row: row, column: column });
        }
    }, {
        key: '_onCallCellValue',
        value: function _onCallCellValue(_ref, done) {
            var row = _ref.row,
                column = _ref.column;

            var cell = new _CellReference.CellReference(row, column);

            if (!this.dataProvider.isInDataRange(cell.row, cell.column)) {
                throw Error(_error.ERROR_REF);
            }

            this.matrix.registerCellRef(cell);
            this._processingCell.addPrecedent(cell);

            done(this.dataProvider.getDataAtCell(cell.row, cell.column));
        }
    }, {
        key: '_onCallCellValueInSheet',
        value: function _onCallCellValueInSheet(_ref2, done) {
            var sheetName = _ref2.sheetName,
                row = _ref2.row,
                column = _ref2.column;

            var cell = new _CellReference.CellReference(row, column);

            // TODO 更改数据时，公式引用的数据级联更新

            done(this.dataProvider.getDataAtCellInSheet(sheetName, cell.row, cell.column));
        }
    }, {
        key: '_onCallRangeValue',
        value: function _onCallRangeValue(_ref3, _ref4, done) {
            var startRow = _ref3.row,
                startColumn = _ref3.column;

            var _this4 = this;

            var endRow = _ref4.row,
                endColumn = _ref4.column;

            rangeEach(startRow.index, endRow.index, function (row) {
                rangeEach(startColumn.index, endColumn.index, function (column) {
                    var cell = new _CellReference.CellReference(row, column);

                    _this4.matrix.registerCellRef(cell);
                    _this4._processingCell.addPrecedent(cell);
                });
            });
            done(this.dataProvider.getDataByRange(startRow.index, startColumn.index, endRow.index, endColumn.index));
        }

        // TODO 调用范围公式

    }, {
        key: '_onCallRangeValueInSheet',
        value: function _onCallRangeValueInSheet(sheetName, _ref5, _ref6, done) {
            var startRow = _ref5.row,
                startColumn = _ref5.column;
            var endRow = _ref6.row,
                endColumn = _ref6.column;


            done('_onCallRangeValueInSheet');
        }
    }, {
        key: '_onAfterAlter',
        value: function _onAfterAlter() {
            this.recalculateOptimized();
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.dataProvider.destroy();
            this.dataProvider = null;
            this.alterManager.destroy();
            this.alterManager = null;
            this.parser = null;
            this.matrix.reset();
            this.matrix = null;
        }
    }]);

    return Sheet;
}();

mixin(Sheet, localHooks);

exports.Sheet = Sheet;

},{"./AlterManager":24,"./CellReference":26,"./CellValue":27,"./Matrix":29,"./parser/error":34,"./parser/parser":50,"./utils":53}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UndoRedoSnapshot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

var _dataStructure = require('../../utils/dataStructure');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var rangeEach = Handsontable.helper.rangeEach;

var UndoRedoSnapshot = function () {
    function UndoRedoSnapshot(sheet) {
        _classCallCheck(this, UndoRedoSnapshot);

        this.sheet = sheet;
        this.stack = new _dataStructure.Stack();
    }

    _createClass(UndoRedoSnapshot, [{
        key: 'save',
        value: function save(axis, index, amount) {
            var _sheet = this.sheet,
                matrix = _sheet.matrix,
                dataProvider = _sheet.dataProvider;

            var changes = [];

            arrayEach(matrix.data, function (cellValue) {
                var row = cellValue.row,
                    column = cellValue.column;


                if (cellValue[axis] < index || cellValue[axis] > index + (amount - 1)) {
                    var value = dataProvider.getSourceDataAtCell(row, column);

                    changes.push({ row: row, column: column, value: value });
                }
            });

            this.stack.push({ axis: axis, index: index, amount: amount, changes: changes });
        }
    }, {
        key: 'restore',
        value: function restore() {
            var _sheet2 = this.sheet,
                matrix = _sheet2.matrix,
                dataProvider = _sheet2.dataProvider;

            var _stack$pop = this.stack.pop(),
                axis = _stack$pop.axis,
                index = _stack$pop.index,
                amount = _stack$pop.amount,
                changes = _stack$pop.changes;

            if (changes) {
                arrayEach(changes, function (change) {
                    if (change[axis] > index + (amount - 1)) {
                        change[axis] -= amount;
                    }
                    var row = change.row,
                        column = change.column,
                        value = change.value;

                    var rawValue = dataProvider.getSourceDataAtCell(row, column);

                    if (rawValue !== value) {
                        dataProvider.updateSourceData(row, column, value);
                        matrix.getCellAt(row, column).setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
                    }
                });
            }
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.sheet = null;
            this.stack = null;
        }
    }]);

    return UndoRedoSnapshot;
}();

exports.UndoRedoSnapshot = UndoRedoSnapshot;

},{"../../utils/dataStructure":58,"./CellValue":27}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XFormulas = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 扩展公式：支持跨工作表的公式。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 示例：
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * + worksheet2中某单元格值为 `=worksheet1!A2+B2`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * + 工作表3中某单元格值为 `=工作表1!A1+工作表2B1`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * + sheet5中某单元格值为`=SUM(sheet3!B1:B5, sheet4!B6)`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * TODO 目前仅支持“相对引用”的坐标形式，但没有公式填充的效果；
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 目前不支持“绝对引用”和“混合引用”方式。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 此插件需要绕开 hansontable 一个插件对应一个实例的设计思路，而同时管理多个实例。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 实例的管理工作交给 Workbook 来做，因此，此插件不可作为独立的 hansontable 插件
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 使用，只能依托于该电子表格设计器。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @plugin External plugin XFormulas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @param hotInstance
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @constructor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

// TODO 禁止公式循环引用 A1=B1, B1=A1

var _utils = require('./utils');

var _Sheet = require('./Sheet');

var _DataProvider = require('./DataProvider');

var _UndoRedoSnapshot = require('./UndoRedoSnapshot');

var arrayEach = Handsontable.helper.arrayEach;
var isObject = Handsontable.helper.isObject;
var objectEach = Handsontable.helper.objectEach;

function XFormulas(hotInstance) {

    Handsontable.plugins.BasePlugin.call(this, hotInstance);
    this._superClass = Handsontable.plugins.BasePlugin;

    this.eventManager = Handsontable.eventManager();
    this.dataProvider = new _DataProvider.DataProvider(this.hot);
    this.sheet = new _Sheet.Sheet(this.dataProvider);
    this.undoRedoSnapshot = new _UndoRedoSnapshot.UndoRedoSnapshot(this.sheet);

    this._skipRendering = false;
}

XFormulas.prototype = Object.create(Handsontable.plugins.BasePlugin.prototype, {
    constructor: {
        writable: true,
        configurable: true,
        value: XFormulas
    }
});

XFormulas.prototype.isEnabled = function () {
    return !!this.hot.getSettings().xFormulas;
};

/**
 * 插件初始化过程。
 * PS: enablePlugin 方法会在 beforeInit hook 中触发，
 *     仅当 isEnabled 方法返回 true 时执行。
 */
XFormulas.prototype.enablePlugin = function () {
    var _this = this;

    if (this.enabled) {
        return;
    }

    var settings = this.hot.getSettings();
    if (!settings._isHotTableAdaptor) {
        throw 'XFormulas 插件启用失败';
    }

    var formulasSettings = settings.formulas;
    if (isObject(formulasSettings)) {
        if (isObject(formulasSettings.variables)) {
            objectEach(formulasSettings.variables, function (value, name) {
                return _this.setVariable(name, value);
            });
        }
    }

    // TODO move to DataProvider
    var worksheet = this.dataProvider.worksheet = this.hot.getSettings()._sheet;
    this.dataProvider.workbook = worksheet.workbook;

    this.addHook('afterCreateCol', function () {
        return _this.onAfterCreateCol.apply(_this, arguments);
    });
    this.addHook('afterCreateRow', function () {
        return _this.onAfterCreateRow.apply(_this, arguments);
    });
    this.addHook('afterLoadData', function () {
        return _this.onAfterLoadData();
    });
    this.addHook('afterRemoveCol', function () {
        return _this.onAfterRemoveCol.apply(_this, arguments);
    });
    this.addHook('afterRemoveRow', function () {
        return _this.onAfterRemoveRow.apply(_this, arguments);
    });
    this.addHook('afterSetDataAtCell', function () {
        return _this.onAfterSetDataAtCell.apply(_this, arguments);
    });
    this.addHook('afterSetDataAtRowProp', function () {
        return _this.onAfterSetDataAtCell.apply(_this, arguments);
    });
    this.addHook('beforeCreateCol', function () {
        return _this.onBeforeCreateCol.apply(_this, arguments);
    });
    this.addHook('beforeCreateRow', function () {
        return _this.onBeforeCreateRow.apply(_this, arguments);
    });
    this.addHook('beforeRemoveCol', function () {
        return _this.onBeforeRemoveCol.apply(_this, arguments);
    });
    this.addHook('beforeRemoveRow', function () {
        return _this.onBeforeRemoveRow.apply(_this, arguments);
    });
    this.addHook('beforeValidate', function () {
        return _this.onBeforeValidate.apply(_this, arguments);
    });
    this.addHook('beforeValueRender', function () {
        return _this.onBeforeValueRender.apply(_this, arguments);
    });
    this.addHook('modifyData', function () {
        return _this.onModifyData.apply(_this, arguments);
    });

    this.sheet.addLocalHook('afterRecalculate', function () {
        return _this.onSheetAfterRecalculate.apply(_this, arguments);
    });

    this._superClass.prototype.enablePlugin.call(this);
};

/**
 * 禁用插件。
 * PS: 注意将所有属性重置为默认值
 */
XFormulas.prototype.disablePlugin = function () {
    this._superClass.prototype.disablePlugin.call(this);
};

/**
 * 重置 Handsontable 的 settings 时，用来重置 XFormulas 插件的属性。
 * PS: 在 afterUpdateSettings hook 中调用。
 */
XFormulas.prototype.updatePlugin = function () {
    this.disablePlugin();
    this.enablePlugin();
    this._superClass.prototype.updatePlugin.call(this);
};

/**
 * 销毁插件
 */
XFormulas.prototype.destroy = function () {
    this.dataProvider.destroy();
    this.dataProvider = null;
    this.sheet.destroy();
    this.sheet = null;
    this._superClass.prototype.destroy.call(this);
};

// ---------------------------------------[start] Hooks

// TODO 工作表改名时，其它工作表关联到它的公式值要改
XFormulas.prototype.onSheetRename = function (sheet, name1, name2) {};

XFormulas.prototype.onSheetAfterRecalculate = function (cells) {
    if (this._skipRendering) {
        this._skipRendering = false;
        return;
    }
    var hot = this.hot;

    arrayEach(cells, function (_ref) {
        var row = _ref.row,
            column = _ref.column;

        hot.validateCell(hot.getDataAtCell(row, column), hot.getCellMeta(row, column), function () {});
    });
    hot.render();
};

XFormulas.prototype.onModifyData = function (row, column, valueHolder, ioMode) {
    if (ioMode === 'get' && this.hasComputedCellValue(row, column)) {
        valueHolder.value = this.getCellValue(row, column);
    } else if (ioMode === 'set' && (0, _utils.isFormulaExpression)(valueHolder.value)) {
        valueHolder.value = (0, _utils.toUpperCaseFormula)(valueHolder.value);
    }
};

XFormulas.prototype.onBeforeValueRender = function (value) {
    if ((0, _utils.isFormulaExpressionEscaped)(value)) {
        value = (0, _utils.unescapeFormulaExpression)(value);
    }
    return value;
};

XFormulas.prototype.onBeforeValidate = function (value, row, prop) {
    var column = this.hot.propToCol(prop);

    if (this.hasComputedCellValue(row, column)) {
        value = this.getCellValue(row, column);
    }

    return value;
};

XFormulas.prototype.onAfterSetDataAtCell = function (changes, source) {
    var _this2 = this;

    if (source === 'loadData') {
        return;
    }

    this.dataProvider.clearChanges();
    arrayEach(changes, function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 4),
            row = _ref3[0],
            column = _ref3[1],
            oldValue = _ref3[2],
            newValue = _ref3[3];

        column = _this2.hot.propToCol(column);
        if ((0, _utils.isFormulaExpression)(newValue)) {
            newValue = (0, _utils.toUpperCaseFormula)(newValue);
        }
        _this2.dataProvider.collectChanges(row, column, newValue);
        if (oldValue !== newValue) {
            _this2.sheet.applyChanges(row, column, newValue);
        }
    });
    this.recalculate();
};

XFormulas.prototype.onBeforeCreateRow = function (row, amount, source) {
    if (source === 'undo') {
        this.undoRedoSnapshot.restore();
    }
};

XFormulas.prototype.onAfterCreateRow = function (row, amount, source) {
    this.sheet.alterManager.insertRow(row, amount, source !== 'undo');
};

XFormulas.prototype.onBeforeRemoveRow = function (row, amount) {
    Storage.save('row', row, amount);
};

XFormulas.prototype.onAfterRemoveRow = function (row, amount) {
    this.sheet.alterManager.removeRow(row, amount);
};

XFormulas.prototype.onBeforeCreateCol = function (column, amount, source) {
    if (source === 'undo') {
        this.undoRedoSnapshot.restore();
    }
};

XFormulas.prototype.onAfterCreateCol = function (column, amount, source) {
    this.sheet.alterManager.insertColumn(column, amount, source !== 'undo');
};

XFormulas.prototype.onBeforeRemoveCol = function (column, amount) {
    Storage.save('column', column, amount);
};

XFormulas.prototype.onAfterRemoveCol = function (column, amount) {
    this.sheet.alterManager.removeColumn(column, amount);
};

XFormulas.prototype.onAfterLoadData = function () {
    this._skipRendering = true;
    this.recalculateFull();
};

// ---------------------------------------[end] Hooks

XFormulas.prototype.getCellValue = function (row, column) {
    var cell = this.sheet.getCellAt(row, column);
    return cell ? cell.getError() || cell.getValue() : void 0;
};

XFormulas.prototype.hasComputedCellValue = function (row, column) {
    return this.sheet.getCellAt(row, column) ? true : false;
};

XFormulas.prototype.recalculate = function () {
    this.sheet.recalculate();
};

XFormulas.prototype.recalculateFull = function () {
    this.sheet.recalculateFull();
};

XFormulas.prototype.recalculateOptimized = function () {
    this.sheet.recalculateOptimized();
};

XFormulas.prototype.setVariable = function (name, value) {
    this.sheet.setVariable(name, value);
};

XFormulas.prototype.getVariable = function (name) {
    return this.sheet.getVariable(name);
};

Handsontable.plugins.registerPlugin('xFormulas', XFormulas);

exports.XFormulas = XFormulas;

},{"./DataProvider":28,"./Sheet":30,"./UndoRedoSnapshot":31,"./utils":53}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExpressionModifier = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

var _utils2 = require('./parser/utils');

var _error = require('./parser/error');

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var arrayFilter = Handsontable.helper.arrayFilter;
var startsWith = Handsontable.helper.startsWith;
var mixin = Handsontable.helper.mixin;
var localHooks = Handsontable.utils.localHooks; // private

var BARE_CELL_STRICT_REGEX = /^\$?[A-Z]+\$?\d+$/;
var BARE_CELL_REGEX = /\$?[A-Z]+\$?\d+/;
var CELL_REGEX = /(?:[^0-9A-Z$: ]|^)\s*(\$?[A-Z]+\$?\d+)\s*(?![0-9A-Z_: ])/g;
var RANGE_REGEX = /\$?[A-Z]+\$?\d+\s*:\s*\$?[A-Z]+\$?\d+/g;
var CELL_AND_RANGE_REGEX = /((?:[^0-9A-Z$: ]|^)\s*(\$?[A-Z]+\$?\d+)\s*(?![0-9A-Z_: ]))|(\$?[A-Z]+\$?\d+\s*:\s*\$?[A-Z]+\$?\d+)/g;

var ExpressionModifier = function () {
    function ExpressionModifier(expression) {
        _classCallCheck(this, ExpressionModifier);

        /**
         * 待修改的表达式
         * @type {String}
         */
        this.expression = '';

        this.cells = [];

        if (typeof expression === 'string') {
            this.setExpression(expression);
        }
    }

    _createClass(ExpressionModifier, [{
        key: 'setExpression',
        value: function setExpression(expression) {
            this.cells.length = 0;
            this.expression = (0, _utils.toUpperCaseFormula)(expression);

            this._extractCells();
            this._extractCellsRange();

            return this;
        }
    }, {
        key: 'translate',
        value: function translate(_ref, _ref2) {
            var baseRow = _ref.row,
                baseColumn = _ref.column;
            var deltaRow = _ref2.row,
                deltaColumn = _ref2.column;

            arrayEach(this.cells, function (cell) {
                if (deltaRow != null) {
                    ExpressionModifier._translateCell(cell, 'row', baseRow, deltaRow);
                }
                if (deltaColumn != null) {
                    ExpressionModifier._translateCell(cell, 'column', baseColumn, deltaColumn);
                }
            });

            return this;
        }
    }, {
        key: 'toString',
        value: function toString() {
            var _this = this;

            var expression = this.expression.replace(CELL_AND_RANGE_REGEX, function (match, p1, p2) {
                var isSingleCell = match.indexOf(':') === -1;
                var result = match;
                var cellLabel = match;
                var translatedCellLabel = null;

                if (isSingleCell) {
                    cellLabel = BARE_CELL_STRICT_REGEX.test(p1) ? p1 : p2;
                }
                var cell = _this._searchCell(cellLabel);

                if (cell) {
                    translatedCellLabel = cell.refError ? (0, _error2.default)(_error.ERROR_REF) : cell.toLabel();

                    if (isSingleCell) {
                        result = match.replace(cellLabel, translatedCellLabel);
                    } else {
                        result = translatedCellLabel;
                    }
                }

                return result;
            });

            if (!startsWith(expression, '=')) {
                expression = '=' + expression;
            }

            return expression;
        }
    }, {
        key: '_extractCells',
        value: function _extractCells() {
            var _this2 = this;

            var matches = this.expression.match(CELL_REGEX);

            if (!matches) {
                return;
            }
            arrayEach(matches, function (coord) {
                coord = coord.match(BARE_CELL_REGEX);

                if (!coord) {
                    return;
                }

                var _extractLabel = (0, _utils2.extractLabel)(coord[0]),
                    _extractLabel2 = _slicedToArray(_extractLabel, 2),
                    row = _extractLabel2[0],
                    column = _extractLabel2[1];

                _this2.cells.push(_this2._createCell({ row: row, column: column }, { row: row, column: column }, coord[0]));
            });
        }
    }, {
        key: '_extractCellsRange',
        value: function _extractCellsRange() {
            var _this3 = this;

            var matches = this.expression.match(RANGE_REGEX);

            if (!matches) {
                return;
            }
            arrayEach(matches, function (match) {
                var _match$split = match.split(':'),
                    _match$split2 = _slicedToArray(_match$split, 2),
                    start = _match$split2[0],
                    end = _match$split2[1];

                var _extractLabel3 = (0, _utils2.extractLabel)(start),
                    _extractLabel4 = _slicedToArray(_extractLabel3, 2),
                    startRow = _extractLabel4[0],
                    startColumn = _extractLabel4[1];

                var _extractLabel5 = (0, _utils2.extractLabel)(end),
                    _extractLabel6 = _slicedToArray(_extractLabel5, 2),
                    endRow = _extractLabel6[0],
                    endColumn = _extractLabel6[1];

                var startCell = {
                    row: startRow,
                    column: startColumn
                };
                var endCell = {
                    row: endRow,
                    column: endColumn
                };

                _this3.cells.push(_this3._createCell(startCell, endCell, match));
            });
        }
    }, {
        key: '_searchCell',
        value: function _searchCell(label) {
            var _arrayFilter = arrayFilter(this.cells, function (cell) {
                return cell.origLabel === label;
            }),
                _arrayFilter2 = _slicedToArray(_arrayFilter, 1),
                cell = _arrayFilter2[0];

            return cell || null;
        }
    }, {
        key: '_createCell',
        value: function _createCell(start, end, label) {
            return {
                start: start,
                end: end,
                origLabel: label,
                type: label.indexOf(':') === -1 ? 'cell' : 'range',
                refError: false,
                toLabel: function toLabel() {
                    var label = (0, _utils2.toLabel)(this.start.row, this.start.column);

                    if (this.type === 'range') {
                        label += ':' + (0, _utils2.toLabel)(this.end.row, this.end.column);
                    }

                    return label;
                }
            };
        }
    }], [{
        key: '_translateCell',
        value: function _translateCell(cell, property) {
            var baseIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var delta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var type = cell.type,
                start = cell.start,
                end = cell.end;

            var startIndex = start[property].index;
            var endIndex = end[property].index;
            var deltaStart = delta;
            var deltaEnd = delta;
            var refError = false;
            var indexOffset = Math.abs(delta) - 1;

            // 增加
            if (delta > 0) {
                if (baseIndex > startIndex) {
                    deltaStart = 0;
                }
                if (baseIndex > endIndex) {
                    deltaEnd = 0;
                }
            } else {
                // 删除
                if (startIndex >= baseIndex && endIndex <= baseIndex + indexOffset) {
                    refError = true;
                }
                if (!refError && type === 'cell') {
                    if (baseIndex >= startIndex) {
                        deltaStart = 0;
                        deltaEnd = 0;
                    }
                }
                if (!refError && type === 'range') {
                    if (baseIndex >= startIndex) {
                        deltaStart = 0;
                    }
                    if (baseIndex > endIndex) {
                        deltaEnd = 0;
                    } else if (endIndex <= baseIndex + indexOffset) {
                        deltaEnd -= Math.min(endIndex - (baseIndex + indexOffset), 0);
                    }
                }
            }

            if (deltaStart && !refError) {
                start[property].index = Math.max(startIndex + deltaStart, 0);
            }
            if (deltaEnd && !refError) {
                end[property].index = Math.max(endIndex + deltaEnd, 0);
            }
            if (refError) {
                cell.refError = true;
            }
        }
    }]);

    return ExpressionModifier;
}();

mixin(ExpressionModifier, localHooks);

exports.ExpressionModifier = ExpressionModifier;

},{"./parser/error":34,"./parser/utils":52,"./utils":53}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _errors;

exports.default = error;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ERROR = exports.ERROR = 'ERROR';
var ERROR_DIV_ZERO = exports.ERROR_DIV_ZERO = 'DIV/0';
var ERROR_NAME = exports.ERROR_NAME = 'NAME';
var ERROR_NEED_UPDATE = exports.ERROR_NEED_UPDATE = 'NEED_UPDATE';
var ERROR_NOT_AVAILABLE = exports.ERROR_NOT_AVAILABLE = 'N/A';
var ERROR_NULL = exports.ERROR_NULL = 'NULL';
var ERROR_NUM = exports.ERROR_NUM = 'NUM';
var ERROR_REF = exports.ERROR_REF = 'REF';
var ERROR_VALUE = exports.ERROR_VALUE = 'VALUE';

var errors = (_errors = {}, _defineProperty(_errors, ERROR, '#ERROR!'), _defineProperty(_errors, ERROR_DIV_ZERO, '#DIV/0!'), _defineProperty(_errors, ERROR_NAME, '#NAME?'), _defineProperty(_errors, ERROR_NEED_UPDATE, '#NEED_UPDATE!'), _defineProperty(_errors, ERROR_NOT_AVAILABLE, '#N/A'), _defineProperty(_errors, ERROR_NULL, '#NULL!'), _defineProperty(_errors, ERROR_NUM, '#NUM!'), _defineProperty(_errors, ERROR_REF, '#REF!'), _defineProperty(_errors, ERROR_VALUE, '#VALUE!'), _errors);

function error(type) {
  var error = void 0;
  type = (type + '').replace(/#|!|\?/g, '');

  if (errors[type]) {
    error = errors[type];
  }
  return error ? error : null;
}

},{}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var grammar = function () {
    var o = function o(k, v, _o, l) {
        for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}return _o;
    },
        $V0 = [1, 5],
        $V1 = [1, 8],
        $V2 = [1, 6],
        $V3 = [1, 7],
        $V4 = [1, 9],
        $V5 = [1, 15],
        $V6 = [1, 16],
        $V7 = [1, 17],
        $V8 = [1, 18],
        $V9 = [1, 13],
        $Va = [1, 14],
        $Vb = [1, 19],
        $Vc = [1, 21],
        $Vd = [1, 22],
        $Ve = [1, 23],
        $Vf = [1, 24],
        $Vg = [1, 25],
        $Vh = [1, 26],
        $Vi = [1, 27],
        $Vj = [1, 28],
        $Vk = [1, 29],
        $Vl = [1, 30],
        $Vm = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33],
        $Vn = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33, 35],
        $Vo = [1, 39],
        $Vp = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33, 37],
        $Vq = [5, 10, 11, 13, 14, 15, 16, 17, 32, 33],
        $Vr = [5, 10, 13, 14, 15, 16, 32, 33],
        $Vs = [5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 32, 33],
        $Vt = [13, 32, 33],
        $Vu = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33, 34, 38];
    var parser = { trace: function trace() {},
        yy: {},
        symbols_: { "error": 2, "expressions": 3, "expression": 4, "EOF": 5, "variableSequence": 6, "number": 7, "STRING": 8, "&": 9, "=": 10, "+": 11, "(": 12, ")": 13, "<": 14, ">": 15, "NOT": 16, "-": 17, "*": 18, "/": 19, "^": 20, "FUNCTION": 21, "expseq": 22, "sheet": 23, "cell": 24, "SHEET_NAME": 25, "!": 26, "ABSOLUTE_CELL": 27, "RELATIVE_CELL": 28, "MIXED_CELL": 29, ":": 30, "ARRAY": 31, ";": 32, ",": 33, "VARIABLE": 34, "DECIMAL": 35, "NUMBER": 36, "%": 37, "#": 38, "$accept": 0, "$end": 1 },
        terminals_: { 5: "EOF", 8: "STRING", 9: "&", 10: "=", 11: "+", 12: "(", 13: ")", 14: "<", 15: ">", 16: "NOT", 17: "-", 18: "*", 19: "/", 20: "^", 21: "FUNCTION", 25: "SHEET_NAME", 26: "!", 27: "ABSOLUTE_CELL", 28: "RELATIVE_CELL", 29: "MIXED_CELL", 30: ":", 31: "ARRAY", 32: ";", 33: ",", 34: "VARIABLE", 35: "DECIMAL", 36: "NUMBER", 37: "%", 38: "#" },
        productions_: [0, [3, 2], [4, 1], [4, 1], [4, 1], [4, 3], [4, 3], [4, 3], [4, 3], [4, 4], [4, 4], [4, 4], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 2], [4, 2], [4, 3], [4, 4], [4, 1], [4, 1], [4, 1], [4, 2], [23, 3], [23, 3], [23, 3], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [24, 1], [24, 1], [24, 1], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [22, 1], [22, 1], [22, 3], [22, 3], [6, 1], [6, 3], [7, 1], [7, 3], [7, 2], [2, 3], [2, 4]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
            /* this == yyval */

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1:

                    return $$[$0 - 1];

                    break;
                case 2:

                    this.$ = yy.callVariable($$[$0][0]);

                    break;
                case 3:

                    this.$ = yy.toNumber($$[$0]);

                    break;
                case 4:

                    this.$ = yy.trimEdges($$[$0]);

                    break;
                case 5:

                    this.$ = yy.evaluateByOperator('&', [$$[$0 - 2], $$[$0]]);

                    break;
                case 6:

                    this.$ = yy.evaluateByOperator('=', [$$[$0 - 2], $$[$0]]);

                    break;
                case 7:

                    this.$ = yy.evaluateByOperator('+', [$$[$0 - 2], $$[$0]]);

                    break;
                case 8:

                    this.$ = yy.toNumber($$[$0 - 1]);

                    break;
                case 9:

                    this.$ = yy.evaluateByOperator('<=', [$$[$0 - 3], $$[$0]]);

                    break;
                case 10:

                    this.$ = yy.evaluateByOperator('>=', [$$[$0 - 3], $$[$0]]);

                    break;
                case 11:

                    this.$ = yy.evaluateByOperator('<>', [$$[$0 - 3], $$[$0]]);

                    break;
                case 12:

                    this.$ = yy.evaluateByOperator('NOT', [$$[$0 - 2], $$[$0]]);

                    break;
                case 13:

                    this.$ = yy.evaluateByOperator('>', [$$[$0 - 2], $$[$0]]);

                    break;
                case 14:

                    this.$ = yy.evaluateByOperator('<', [$$[$0 - 2], $$[$0]]);

                    break;
                case 15:

                    this.$ = yy.evaluateByOperator('-', [$$[$0 - 2], $$[$0]]);

                    break;
                case 16:

                    this.$ = yy.evaluateByOperator('*', [$$[$0 - 2], $$[$0]]);

                    break;
                case 17:

                    this.$ = yy.evaluateByOperator('/', [$$[$0 - 2], $$[$0]]);

                    break;
                case 18:

                    this.$ = yy.evaluateByOperator('^', [$$[$0 - 2], $$[$0]]);

                    break;
                case 19:

                    var n1 = yy.invertNumber($$[$0]);
                    this.$ = n1;
                    if (isNaN(this.$)) {
                        this.$ = 0;
                    }

                    break;
                case 20:

                    var n1 = yy.toNumber($$[$0]);
                    this.$ = n1;
                    if (isNaN(this.$)) {
                        this.$ = 0;
                    }

                    break;
                case 21:

                    this.$ = yy.callFunction($$[$0 - 2]);

                    break;
                case 22:

                    this.$ = yy.callFunction($$[$0 - 3], $$[$0 - 1]);

                    break;
                case 27:case 28:case 29:

                    this.$ = yy.cellValueInSheet($$[$0 - 2], $$[$0]);

                    break;
                case 30:case 31:case 32:case 33:case 34:case 35:case 36:case 37:case 38:

                    this.$ = yy.rangeValueInSheet($$[$0 - 4], $$[$0 - 2], $$[$0]);

                    break;
                case 39:case 40:case 41:

                    this.$ = yy.cellValue($$[$0]);

                    break;
                case 42:case 43:case 44:case 45:case 46:case 47:case 48:case 49:case 50:

                    this.$ = yy.rangeValue($$[$0 - 2], $$[$0]);

                    break;
                case 51:case 55:

                    this.$ = [$$[$0]];

                    break;
                case 52:

                    var result = [];
                    var arr = eval("[" + yytext + "]");

                    arr.forEach(function (item) {
                        result.push(item);
                    });

                    this.$ = result;

                    break;
                case 53:case 54:

                    $$[$0 - 2].push($$[$0]);
                    this.$ = $$[$0 - 2];

                    break;
                case 56:

                    this.$ = Array.isArray($$[$0 - 2]) ? $$[$0 - 2] : [$$[$0 - 2]];
                    this.$.push($$[$0]);

                    break;
                case 57:

                    this.$ = $$[$0];

                    break;
                case 58:

                    this.$ = ($$[$0 - 2] + '.' + $$[$0]) * 1;

                    break;
                case 59:

                    this.$ = $$[$0 - 1] * 0.01;

                    break;
                case 60:case 61:

                    this.$ = yy.throwError($$[$0 - 2] + $$[$0 - 1] + $$[$0]);

                    break;
            }
        },
        table: [{ 2: 12, 3: 1, 4: 2, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 1: [3] }, { 5: [1, 20], 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }, o($Vm, [2, 2], { 35: [1, 31] }), o($Vm, [2, 3], { 37: [1, 32] }), o($Vm, [2, 4]), { 2: 12, 4: 33, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 34, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 35, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 12: [1, 36] }, o($Vm, [2, 23]), o($Vm, [2, 24]), o($Vm, [2, 25], { 2: 37, 34: [1, 38], 38: $Vb }), o($Vn, [2, 55], { 38: $Vo }), o($Vp, [2, 57], { 35: [1, 40] }), { 26: [1, 41] }, o($Vm, [2, 39], { 30: [1, 42] }), o($Vm, [2, 40], { 30: [1, 43] }), o($Vm, [2, 41], { 30: [1, 44] }), { 34: [1, 45] }, { 1: [2, 1] }, { 2: 12, 4: 46, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 47, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 48, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 51, 6: 3, 7: 4, 8: $V0, 10: [1, 49], 11: $V1, 12: $V2, 15: [1, 50], 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 53, 6: 3, 7: 4, 8: $V0, 10: [1, 52], 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 54, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 55, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 56, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 57, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 58, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 34: [1, 59] }, o($Vp, [2, 59]), { 9: $Vc, 10: $Vd, 11: $Ve, 13: [1, 60], 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }, o($Vq, [2, 19], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vq, [2, 20], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), { 2: 12, 4: 63, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 13: [1, 61], 17: $V3, 21: $V4, 22: 62, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 31: [1, 64], 34: $V9, 36: $Va, 38: $Vb }, o($Vm, [2, 26]), { 38: $Vo }, { 34: [1, 65] }, { 36: [1, 66] }, { 27: [1, 67], 28: [1, 68], 29: [1, 69] }, { 27: [1, 70], 28: [1, 71], 29: [1, 72] }, { 27: [1, 73], 28: [1, 74], 29: [1, 75] }, { 27: [1, 76], 28: [1, 77], 29: [1, 78] }, { 26: [1, 79] }, o($Vm, [2, 5]), o([5, 10, 13, 32, 33], [2, 6], { 9: $Vc, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vq, [2, 7], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), { 2: 12, 4: 80, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 81, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, o($Vr, [2, 14], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), { 2: 12, 4: 82, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, o($Vr, [2, 13], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o([5, 10, 13, 16, 32, 33], [2, 12], { 9: $Vc, 11: $Ve, 14: $Vf, 15: $Vg, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vq, [2, 15], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vs, [2, 16], { 9: $Vc, 20: $Vl }), o($Vs, [2, 17], { 9: $Vc, 20: $Vl }), o([5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33], [2, 18], { 9: $Vc }), o($Vn, [2, 56]), o($Vm, [2, 8]), o($Vm, [2, 21]), { 13: [1, 83], 32: [1, 84], 33: [1, 85] }, o($Vt, [2, 51], { 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vt, [2, 52]), { 26: [1, 86] }, o($Vp, [2, 58]), o($Vm, [2, 27], { 30: [1, 87] }), o($Vm, [2, 28], { 30: [1, 88] }), o($Vm, [2, 29], { 30: [1, 89] }), o($Vm, [2, 42]), o($Vm, [2, 43]), o($Vm, [2, 44]), o($Vm, [2, 45]), o($Vm, [2, 46]), o($Vm, [2, 47]), o($Vm, [2, 48]), o($Vm, [2, 49]), o($Vm, [2, 50]), o($Vu, [2, 60]), o($Vr, [2, 9], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vr, [2, 11], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vr, [2, 10], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vm, [2, 22]), { 2: 12, 4: 90, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 91, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, o($Vu, [2, 61]), { 27: [1, 92], 28: [1, 93], 29: [1, 94] }, { 27: [1, 95], 28: [1, 96], 29: [1, 97] }, { 27: [1, 98], 28: [1, 99], 29: [1, 100] }, o($Vt, [2, 53], { 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vt, [2, 54], { 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vm, [2, 30]), o($Vm, [2, 31]), o($Vm, [2, 32]), o($Vm, [2, 33]), o($Vm, [2, 34]), o($Vm, [2, 35]), o($Vm, [2, 36]), o($Vm, [2, 37]), o($Vm, [2, 38])],
        defaultActions: { 20: [2, 1] },
        parseError: function parseError(str, hash) {
            if (hash.recoverable) {
                this.trace(str);
            } else {
                var _parseError = function _parseError(msg, hash) {
                    this.message = msg;
                    this.hash = hash;
                };

                _parseError.prototype = Error;

                throw new _parseError(str, hash);
            }
        },
        parse: function parse(input) {
            var self = this,
                stack = [0],
                tstack = [],
                // token stack
            vstack = [null],
                // semantic value stack
            lstack = [],
                // location stack
            table = this.table,
                yytext = '',
                yylineno = 0,
                yyleng = 0,
                recovering = 0,
                TERROR = 2,
                EOF = 1;

            var args = lstack.slice.call(arguments, 1);

            //this.reductionCount = this.shiftCount = 0;

            var lexer = Object.create(this.lexer);
            var sharedState = { yy: {} };
            // copy state
            for (var k in this.yy) {
                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                    sharedState.yy[k] = this.yy[k];
                }
            }

            lexer.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer;
            sharedState.yy.parser = this;
            if (typeof lexer.yylloc == 'undefined') {
                lexer.yylloc = {};
            }
            var yyloc = lexer.yylloc;
            lstack.push(yyloc);

            var ranges = lexer.options && lexer.options.ranges;

            if (typeof sharedState.yy.parseError === 'function') {
                this.parseError = sharedState.yy.parseError;
            } else {
                this.parseError = Object.getPrototypeOf(this).parseError;
            }

            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }

            _token_stack: var lex = function lex() {
                var token;
                token = lexer.lex() || EOF;
                // if token isn't its numeric value, convert
                if (typeof token !== 'number') {
                    token = self.symbols_[token] || token;
                }
                return token;
            };

            var symbol,
                preErrorSymbol,
                state,
                action,
                a,
                r,
                yyval = {},
                p,
                len,
                newState,
                expected;
            while (true) {
                // retreive state number from top of stack
                state = stack[stack.length - 1];

                // use default actions if available
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == 'undefined') {
                        symbol = lex();
                    }
                    // read action for current state and first input
                    action = table[state] && table[state][symbol];
                }

                _handle_error:
                // handle parse error
                if (typeof action === 'undefined' || !action.length || !action[0]) {

                    // Return the rule stack depth where the nearest error rule can be found.
                    // Return FALSE when no error recovery rule was found.
                    var locateNearestErrorRecoveryRule = function locateNearestErrorRecoveryRule(state) {
                        var stack_probe = stack.length - 1;
                        var depth = 0;

                        // try to recover from error
                        for (;;) {
                            // check for error recovery rule in this state
                            if (TERROR.toString() in table[state]) {
                                return depth;
                            }
                            if (state === 0 || stack_probe < 2) {
                                return false; // No suitable error recovery rule available.
                            }
                            stack_probe -= 2; // popStack(1): [symbol, action]
                            state = stack[stack_probe];
                            ++depth;
                        }
                    };

                    var error_rule_depth;
                    var errStr = '';

                    if (!recovering) {
                        // first see if there's any chance at hitting an error recovery rule:
                        error_rule_depth = locateNearestErrorRecoveryRule(state);

                        // Report error
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push("'" + this.terminals_[p] + "'");
                            }
                        }
                        if (lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ":\n" + lexer.showPosition() + "\nExpecting " + expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                        }
                        this.parseError(errStr, {
                            text: lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: lexer.yylineno,
                            loc: yyloc,
                            expected: expected,
                            recoverable: error_rule_depth !== false
                        });
                    } else if (preErrorSymbol !== EOF) {
                        error_rule_depth = locateNearestErrorRecoveryRule(state);
                    }

                    // just recovered from another error
                    if (recovering == 3) {
                        if (symbol === EOF || preErrorSymbol === EOF) {
                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
                        }

                        // discard current lookahead and grab another
                        yyleng = lexer.yyleng;
                        yytext = lexer.yytext;
                        yylineno = lexer.yylineno;
                        yyloc = lexer.yylloc;
                        symbol = lex();
                    }

                    // try to recover from error
                    if (error_rule_depth === false) {
                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
                    }
                    popStack(error_rule_depth);

                    preErrorSymbol = symbol == TERROR ? null : symbol; // save the lookahead token
                    symbol = TERROR; // insert generic error symbol as new lookahead
                    state = stack[stack.length - 1];
                    action = table[state] && table[state][TERROR];
                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
                }

                // this shouldn't happen, unless resolve defaults are off
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                }

                switch (action[0]) {
                    case 1:
                        // shift
                        //this.shiftCount++;

                        stack.push(symbol);
                        vstack.push(lexer.yytext);
                        lstack.push(lexer.yylloc);
                        stack.push(action[1]); // push state
                        symbol = null;
                        if (!preErrorSymbol) {
                            // normal execution/no error
                            yyleng = lexer.yyleng;
                            yytext = lexer.yytext;
                            yylineno = lexer.yylineno;
                            yyloc = lexer.yylloc;
                            if (recovering > 0) {
                                recovering--;
                            }
                        } else {
                            // error just occurred, resume old lookahead f/ before error
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;

                    case 2:
                        // reduce
                        //this.reductionCount++;

                        len = this.productions_[action[1]][1];

                        // perform semantic action
                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
                        // default location, uses first token for firsts, last for lasts
                        yyval._$ = {
                            first_line: lstack[lstack.length - (len || 1)].first_line,
                            last_line: lstack[lstack.length - 1].last_line,
                            first_column: lstack[lstack.length - (len || 1)].first_column,
                            last_column: lstack[lstack.length - 1].last_column
                        };
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                        }
                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

                        if (typeof r !== 'undefined') {
                            return r;
                        }

                        // pop off stack
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }

                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        // goto new state = table[STATE][NONTERMINAL]
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;

                    case 3:
                        // accept
                        return true;
                }
            }

            return true;
        } };

    /* generated by jison-lex 0.3.4 */
    var lexer = function () {
        var lexer = {

            EOF: 1,

            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },

            // resets the lexer, sets new input
            setInput: function setInput(input, yy) {
                this.yy = yy || this.yy || {};
                this._input = input;
                this._more = this._backtrack = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                };
                if (this.options.ranges) {
                    this.yylloc.range = [0, 0];
                }
                this.offset = 0;
                return this;
            },

            // consumes and returns one char from the input
            input: function input() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) {
                    this.yylloc.range[1]++;
                }

                this._input = this._input.slice(1);
                return ch;
            },

            // unshifts one char (or a string) into the input
            unput: function unput(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);

                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);

                if (lines.length - 1) {
                    this.yylineno -= lines.length - 1;
                }
                var r = this.yylloc.range;

                this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };

                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                this.yyleng = this.yytext.length;
                return this;
            },

            // When called from action, caches matched text and appends it on next action
            more: function more() {
                this._more = true;
                return this;
            },

            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function reject() {
                if (this.options.backtrack_lexer) {
                    this._backtrack = true;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
                return this;
            },

            // retain first n characters of the match
            less: function less(n) {
                this.unput(this.match.slice(n));
            },

            // displays already matched input, i.e. for error messages
            pastInput: function pastInput() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
            },

            // displays upcoming input, i.e. for error messages
            upcomingInput: function upcomingInput() {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },

            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function showPosition() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },

            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function test_match(match, indexed_rule) {
                var token, lines, backup;

                if (this.options.backtrack_lexer) {
                    // save context
                    backup = {
                        yylineno: this.yylineno,
                        yylloc: {
                            first_line: this.yylloc.first_line,
                            last_line: this.last_line,
                            first_column: this.yylloc.first_column,
                            last_column: this.yylloc.last_column
                        },
                        yytext: this.yytext,
                        match: this.match,
                        matches: this.matches,
                        matched: this.matched,
                        yyleng: this.yyleng,
                        offset: this.offset,
                        _more: this._more,
                        _input: this._input,
                        yy: this.yy,
                        conditionStack: this.conditionStack.slice(0),
                        done: this.done
                    };
                    if (this.options.ranges) {
                        backup.yylloc.range = this.yylloc.range.slice(0);
                    }
                }

                lines = match[0].match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno += lines.length;
                }
                this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                };
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._backtrack = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input) {
                    this.done = false;
                }
                if (token) {
                    return token;
                } else if (this._backtrack) {
                    // recover context
                    for (var k in backup) {
                        this[k] = backup[k];
                    }
                    return false; // rule action called reject() implying the next rule should be tested instead.
                }
                return false;
            },

            // return next match in input
            next: function next() {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) {
                    this.done = true;
                }

                var token, match, tempMatch, index;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (this.options.backtrack_lexer) {
                            token = this.test_match(tempMatch, rules[i]);
                            if (token !== false) {
                                return token;
                            } else if (this._backtrack) {
                                match = false;
                                continue; // rule action called reject() implying a rule MISmatch.
                            } else {
                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                return false;
                            }
                        } else if (!this.options.flex) {
                            break;
                        }
                    }
                }
                if (match) {
                    token = this.test_match(match, rules[index]);
                    if (token !== false) {
                        return token;
                    }
                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                    return false;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
            },

            // return next match that has a token
            lex: function lex() {
                var r = this.next();
                if (r) {
                    return r;
                } else {
                    return this.lex();
                }
            },

            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },

            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
                var n = this.conditionStack.length - 1;
                if (n > 0) {
                    return this.conditionStack.pop();
                } else {
                    return this.conditionStack[0];
                }
            },

            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                } else {
                    return this.conditions["INITIAL"].rules;
                }
            },

            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
                n = this.conditionStack.length - 1 - Math.abs(n || 0);
                if (n >= 0) {
                    return this.conditionStack[n];
                } else {
                    return "INITIAL";
                }
            },

            // alias for begin(condition)
            pushState: function pushState(condition) {
                this.begin(condition);
            },

            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
                return this.conditionStack.length;
            },
            options: {},
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                var YYSTATE = YY_START;
                switch ($avoiding_name_collisions) {
                    case 0:
                        /* 跳过空白符 */
                        break;
                    case 1:
                        return 25;
                        break;
                    case 2:
                        return 8;
                        break;
                    case 3:
                        return 8;
                        break;
                    case 4:
                        return 21;
                        break;
                    case 5:
                        return 25;
                        break;
                    case 6:
                        return 27;
                        break;
                    case 7:
                        return 29;
                        break;
                    case 8:
                        return 29;
                        break;
                    case 9:
                        return 28;
                        break;
                    case 10:
                        return 21;
                        break;
                    case 11:
                        return 34;
                        break;
                    case 12:
                        return 34;
                        break;
                    case 13:
                        return 36;
                        break;
                    case 14:
                        return 31;
                        break;
                    case 15:
                        break;
                    case 16:
                        return 9;
                        break;
                    case 17:
                        return ' ';
                        break;
                    case 18:
                        return 35;
                        break;
                    case 19:
                        return 30;
                        break;
                    case 20:
                        return 32;
                        break;
                    case 21:
                        return 33;
                        break;
                    case 22:
                        return 18;
                        break;
                    case 23:
                        return 19;
                        break;
                    case 24:
                        return 17;
                        break;
                    case 25:
                        return 11;
                        break;
                    case 26:
                        return 20;
                        break;
                    case 27:
                        return 12;
                        break;
                    case 28:
                        return 13;
                        break;
                    case 29:
                        return 15;
                        break;
                    case 30:
                        return 14;
                        break;
                    case 31:
                        return 16;
                        break;
                    case 32:
                        return '"';
                        break;
                    case 33:
                        return "'";
                        break;
                    case 34:
                        return "!";
                        break;
                    case 35:
                        return 10;
                        break;
                    case 36:
                        return 37;
                        break;
                    case 37:
                        return 38;
                        break;
                    case 38:
                        return 5;
                        break;
                }
            },
            rules: [/^(?:\s+)/, /^(?:'([^\\/\?\*\[\]\!'"]+)'(?=[!]))/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9\.]+(?=[(]))/, /^(?:[^\\/\?\*\[\]'"\!,\)]+(?=[!]))/, /^(?:\$[A-Za-z]+\$[0-9]+)/, /^(?:\$[A-Za-z]+[0-9]+)/, /^(?:[A-Za-z]+\$[0-9]+)/, /^(?:[A-Za-z]+[0-9]+)/, /^(?:[A-Za-z\.]+(?=[(]))/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9]+)/, /^(?:[A-Za-z_]+)/, /^(?:[0-9]+)/, /^(?:\[(.*)?\])/, /^(?:\$)/, /^(?:&)/, /^(?: )/, /^(?:[.])/, /^(?::)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\/)/, /^(?:-)/, /^(?:\+)/, /^(?:\^)/, /^(?:\()/, /^(?:\))/, /^(?:>)/, /^(?:<)/, /^(?:NOT\b)/, /^(?:")/, /^(?:')/, /^(?:!)/, /^(?:=)/, /^(?:%)/, /^(?:[#])/, /^(?:$)/],
            conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38], "inclusive": true } }
        };
        return lexer;
    }();
    parser.lexer = lexer;
    function Parser() {
        this.yy = {};
    }
    Parser.prototype = parser;parser.Parser = Parser;
    return new Parser();
}();

var Parser = exports.Parser = grammar.Parser;

},{}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '+';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc + (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (Number.isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":34,"./../utils":52}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '&';

function func() {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return params.reduce(function (acc, value) {
    return acc + value.toString();
  }, '');
};

func.SYMBOL = SYMBOL;

},{}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '/';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc / (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (result === Infinity) {
    throw Error(_error.ERROR_DIV_ZERO);
  }
  if (Number.isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":34,"./../utils":52}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '=';

function func(exp1, exp2) {
  return exp1 === exp2;
};

func.SYMBOL = SYMBOL;

},{}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _supportedFormulas = require('./../supported-formulas');

var _supportedFormulas2 = _interopRequireDefault(_supportedFormulas);

var _error = require('./../error');

var _formulajs = require('formulajs');

var formulajs = _interopRequireWildcard(_formulajs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SYMBOL = exports.SYMBOL = _supportedFormulas2.default; /**
                                                            * Excel 公式中的函数，由 formulajs 实现。
                                                            *
                                                            */

function func(symbol) {
    return function () {
        symbol = symbol.toUpperCase();

        var symbolParts = symbol.split('.');
        var foundFormula = false;
        var result = void 0;

        if (symbolParts.length === 1) {
            if (formulajs[symbolParts[0]]) {
                foundFormula = true;
                result = formulajs[symbolParts[0]].apply(formulajs, arguments);
            }
        } else {
            var length = symbolParts.length;
            var index = 0;
            var nestedFormula = formulajs;

            while (index < length) {
                nestedFormula = nestedFormula[symbolParts[index]];
                index++;

                if (!nestedFormula) {
                    nestedFormula = null;
                    break;
                }
            }
            if (nestedFormula) {
                foundFormula = true;
                result = nestedFormula.apply(undefined, arguments);
            }
        }

        if (!foundFormula) {
            throw Error(_error.ERROR_NAME);
        }

        return result;
    };
};

func.isFactory = true;
func.SYMBOL = SYMBOL;

},{"./../error":34,"./../supported-formulas":51,"formulajs":1}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '>=';

function func(exp1, exp2) {
  return exp1 >= exp2;
};

func.SYMBOL = SYMBOL;

},{}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '>';

function func(exp1, exp2) {
  return exp1 > exp2;
};

func.SYMBOL = SYMBOL;

},{}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '<=';

function func(exp1, exp2) {
  return exp1 <= exp2;
};

func.SYMBOL = SYMBOL;

},{}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '<';

function func(exp1, exp2) {
  return exp1 < exp2;
};

func.SYMBOL = SYMBOL;

},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '-';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc - (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":34,"./../utils":52}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '*';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc * (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":34,"./../utils":52}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '<>';

function func(exp1, exp2) {
  return exp1 !== exp2;
};

func.SYMBOL = SYMBOL;

},{}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '^';

function func(exp1, exp2) {
  var result = Math.pow((0, _utils.toNumber)(exp1), (0, _utils.toNumber)(exp2));

  if (Number.isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":34,"./../utils":52}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = evaluateByOperator;
exports.registerOperation = registerOperation;

var _add = require('./operator/add');

var _add2 = _interopRequireDefault(_add);

var _ampersand = require('./operator/ampersand');

var _ampersand2 = _interopRequireDefault(_ampersand);

var _divide = require('./operator/divide');

var _divide2 = _interopRequireDefault(_divide);

var _equal = require('./operator/equal');

var _equal2 = _interopRequireDefault(_equal);

var _formulaFunction = require('./operator/formula-function');

var _formulaFunction2 = _interopRequireDefault(_formulaFunction);

var _greaterThan = require('./operator/greater-than');

var _greaterThan2 = _interopRequireDefault(_greaterThan);

var _greaterThanOrEqual = require('./operator/greater-than-or-equal');

var _greaterThanOrEqual2 = _interopRequireDefault(_greaterThanOrEqual);

var _lessThan = require('./operator/less-than');

var _lessThan2 = _interopRequireDefault(_lessThan);

var _lessThanOrEqual = require('./operator/less-than-or-equal');

var _lessThanOrEqual2 = _interopRequireDefault(_lessThanOrEqual);

var _minus = require('./operator/minus');

var _minus2 = _interopRequireDefault(_minus);

var _multiply = require('./operator/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _notEqual = require('./operator/not-equal');

var _notEqual2 = _interopRequireDefault(_notEqual);

var _power = require('./operator/power');

var _power2 = _interopRequireDefault(_power);

var _error = require('./error');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
// import {default as crossSheet} from './operator/cross-sheet';


var availableOperators = Object.create(null);

registerOperation(_add2.default.SYMBOL, _add2.default);
registerOperation(_ampersand2.default.SYMBOL, _ampersand2.default);
// registerOperation(crossSheet.SYMBOL, crossSheet);
registerOperation(_divide2.default.SYMBOL, _divide2.default);
registerOperation(_equal2.default.SYMBOL, _equal2.default);
registerOperation(_power2.default.SYMBOL, _power2.default);
registerOperation(_formulaFunction2.default.SYMBOL, _formulaFunction2.default);
registerOperation(_greaterThan2.default.SYMBOL, _greaterThan2.default);
registerOperation(_greaterThanOrEqual2.default.SYMBOL, _greaterThanOrEqual2.default);
registerOperation(_lessThan2.default.SYMBOL, _lessThan2.default);
registerOperation(_lessThanOrEqual2.default.SYMBOL, _lessThanOrEqual2.default);
registerOperation(_multiply2.default.SYMBOL, _multiply2.default);
registerOperation(_notEqual2.default.SYMBOL, _notEqual2.default);
registerOperation(_minus2.default.SYMBOL, _minus2.default);

function evaluateByOperator(operator) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    operator = operator.toUpperCase();

    if (!availableOperators[operator]) {
        throw Error(_error.ERROR_NAME);
    }
    return availableOperators[operator].apply(availableOperators, _toConsumableArray(params));
}

/**
 * 注册
 * @param symbol
 * @param func
 */
function registerOperation(symbol, func) {
    if (!Array.isArray(symbol)) {
        symbol = [symbol.toUpperCase()];
    }
    symbol.forEach(function (s) {
        if (func.isFactory) {
            availableOperators[s] = func(s);
        } else {
            availableOperators[s] = func;
        }
    });
}

},{"./error":34,"./operator/add":36,"./operator/ampersand":37,"./operator/divide":38,"./operator/equal":39,"./operator/formula-function":40,"./operator/greater-than":42,"./operator/greater-than-or-equal":41,"./operator/less-than":44,"./operator/less-than-or-equal":43,"./operator/minus":45,"./operator/multiply":46,"./operator/not-equal":47,"./operator/power":48}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Parser = exports.SUPPORTED_FORMULAS = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _supportedFormulas = require('./supported-formulas');

Object.defineProperty(exports, 'SUPPORTED_FORMULAS', {
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_supportedFormulas).default;
    }
});

var _Emitter2 = require('../../../utils/Emitter');

var _Emitter3 = _interopRequireDefault(_Emitter2);

var _operators = require('./operators');

var _operators2 = _interopRequireDefault(_operators);

var _grammar = require('./grammar');

var _utils = require('./utils');

var _error = require('./error');

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 公式解析器。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 底层的语法解析器使用 jison 生成，参见 http://zaa.ch/jison/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 注意: jison 生成的代码使用 AMD 方式导出变量，重新生成后记得改成 ES6 的方式:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *      `export var Parser = grammar.Parser;`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @class Parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fires Parser#callVariable
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fires Parser#callCellValue
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fires Parser#callRangeValue
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var Parser = function (_Emitter) {
    _inherits(Parser, _Emitter);

    function Parser() {
        _classCallCheck(this, Parser);

        var _this = _possibleConstructorReturn(this, (Parser.__proto__ || Object.getPrototypeOf(Parser)).call(this));

        _this.parser = new _grammar.Parser();
        _this.parser.yy = {
            toNumber: _utils.toNumber,
            trimEdges: _utils.trimEdges,
            invertNumber: _utils.invertNumber,
            throwError: function throwError(errorName) {
                return _this._throwError(errorName);
            },
            callVariable: function callVariable(variable) {
                return _this._callVariable(variable);
            },
            evaluateByOperator: _operators2.default,
            callFunction: _operators2.default,
            cellValue: function cellValue(value) {
                return _this._callCellValue(value);
            },
            rangeValue: function rangeValue(start, end) {
                return _this._callRangeValue(start, end);
            },
            cellValueInSheet: function cellValueInSheet(sheetName, value) {
                return _this._callCellValueInSheet(sheetName, value);
            },
            rangeValueInSheet: function rangeValueInSheet(sheetName, start, end) {
                return _this._callRangeValueInSheet(sheetName, start, end);
            },
            parseError: function parseError() {
                return _this._parseError.apply(_this, arguments);
            }
        };
        _this.variables = Object.create(null);

        _this.setVariable('TRUE', true).setVariable('FALSE', false).setVariable('NULL', null);
        return _this;
    }

    /**
     * 解析表达式
     * @param expression
     * @returns {{error: *, result: *}}
     */


    _createClass(Parser, [{
        key: 'parse',
        value: function parse(expression) {
            var result = null;
            var error = null;

            try {
                result = this.parser.parse(expression);
            } catch (ex) {
                var message = (0, _error2.default)(ex.message);
                if (message) {
                    error = message;
                } else {
                    error = (0, _error2.default)(_error.ERROR);
                }
            }

            if (result instanceof Error) {
                error = (0, _error2.default)(result.message) || (0, _error2.default)(_error.ERROR);
                result = null;
            }

            return {
                error: error,
                result: result
            };
        }

        /**
         * 设置变量
         * @param name
         * @param value
         * @returns {Parser}
         */

    }, {
        key: 'setVariable',
        value: function setVariable(name, value) {
            this.variables[name] = value;
            return this;
        }
    }, {
        key: 'getVariable',
        value: function getVariable(name) {
            return this.variables[name];
        }

        /**
         * 调用变量值
         * @param name
         * @returns {*}
         * @private
         */

    }, {
        key: '_callVariable',
        value: function _callVariable(name) {
            var value = this.getVariable(name);

            this.emit('callVariable', name, function (newValue) {
                if (newValue !== void 0) {
                    value = newValue;
                }
            });

            if (value === void 0) {
                throw Error(_error.ERROR_NAME);
            }

            return value;
        }

        /**
         * 调用单元格的值
         * @param {string} label - 例如 `B3`, `B$3`, `B$3`, `$B$3`
         * @returns {*}
         * @private
         */

    }, {
        key: '_callCellValue',
        value: function _callCellValue(label) {
            var _extractLabel = (0, _utils.extractLabel)(label),
                _extractLabel2 = _slicedToArray(_extractLabel, 2),
                row = _extractLabel2[0],
                column = _extractLabel2[1];

            var value = void 0;

            this.emit('callCellValue', { label: label, row: row, column: column }, function (_value) {
                value = _value;
            });

            return value;
        }

        /**
         * 调用指定 sheet 中单元格的值
         * @param sheetName
         * @param label
         * @returns {*}
         * @private
         */

    }, {
        key: '_callCellValueInSheet',
        value: function _callCellValueInSheet(sheetName, label) {
            var _extractLabel3 = (0, _utils.extractLabel)(label),
                _extractLabel4 = _slicedToArray(_extractLabel3, 2),
                row = _extractLabel4[0],
                column = _extractLabel4[1];

            var value = void 0;

            this.emit('callCellValueInSheet', { sheetName: sheetName, label: label, row: row, column: column }, function (_value) {
                value = _value;
            });
            return value;
        }
    }, {
        key: '_callRangeValue',


        /**
         * 调用某范围的单元格值，如 `B3:A1`
         * @param {string} startLabel - 起始标签，如 `B3`
         * @param {string} endLabel - 结束标签，如 `A1`
         * @returns {Array}
         * @private
         */
        value: function _callRangeValue(startLabel, endLabel) {
            var _Parser$_explainCell = Parser._explainCell(startLabel, endLabel),
                startCell = _Parser$_explainCell.startCell,
                endCell = _Parser$_explainCell.endCell;

            var value = [];
            this.emit('callRangeValue', startCell, endCell, function () {
                var _value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

                value = _value;
            });
            return value;
        }

        /**
         * 调用指定 sheet 中某范围的单元格值，如 `工作表1!B3:A1`
         * @param sheetName
         * @param startLabel
         * @param endLabel
         * @returns {Array}
         * @private
         */

    }, {
        key: '_callRangeValueInSheet',
        value: function _callRangeValueInSheet(sheetName, startLabel, endLabel) {
            var _Parser$_explainCell2 = Parser._explainCell(startLabel, endLabel),
                startCell = _Parser$_explainCell2.startCell,
                endCell = _Parser$_explainCell2.endCell;

            var value = [];
            this.emit('callRangeValueInSheet', sheetName, startCell, endCell, function () {
                var _value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

                value = _value;
            });
            return value;
        }

        /**
         *
         * @param errorName
         * @returns {*}
         * @private
         */

    }, {
        key: '_throwError',
        value: function _throwError(errorName) {
            var parsedError = (0, _error2.default)(errorName);
            if (parsedError) {
                throw Error(parsedError);
            }
            return errorName;
        }

        // TODO 解析失败时，给用户提供合适的错误信息。

    }, {
        key: '_parseError',
        value: function _parseError() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            console.log(args);
        }
    }], [{
        key: '_explainCell',
        value: function _explainCell(startLabel, endLabel) {
            var _extractLabel5 = (0, _utils.extractLabel)(startLabel),
                _extractLabel6 = _slicedToArray(_extractLabel5, 2),
                startRow = _extractLabel6[0],
                startColumn = _extractLabel6[1];

            var _extractLabel7 = (0, _utils.extractLabel)(endLabel),
                _extractLabel8 = _slicedToArray(_extractLabel7, 2),
                endRow = _extractLabel8[0],
                endColumn = _extractLabel8[1];

            var startCell = {};
            var endCell = {};

            if (startRow.index <= endRow.index) {
                startCell.row = startRow;
                endCell.row = endRow;
            } else {
                startCell.row = endRow;
                endCell.row = startRow;
            }

            if (startColumn.index <= endColumn.index) {
                startCell.column = startColumn;
                endCell.column = endColumn;
            } else {
                startCell.column = endColumn;
                endCell.column = startColumn;
            }

            startCell.label = (0, _utils.toLabel)(startCell.row, startCell.column);
            endCell.label = (0, _utils.toLabel)(endCell.row, endCell.column);
            return { startCell: startCell, endCell: endCell };
        }
    }]);

    return Parser;
}(_Emitter3.default);

exports.Parser = Parser;

},{"../../../utils/Emitter":56,"./error":34,"./grammar":35,"./operators":49,"./supported-formulas":51,"./utils":52}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SUPPORTED_FORMULAS = ['ABS', 'ACCRINT', 'ACOS', 'ACOSH', 'ACOT', 'ACOTH', 'ADD', 'AGGREGATE', 'AND', 'ARABIC', 'ARGS2ARRAY', 'ASIN', 'ASINH', 'ATAN', 'ATAN2', 'ATANH', 'AVEDEV', 'AVERAGE', 'AVERAGEA', 'AVERAGEIF', 'AVERAGEIFS', 'BASE', 'BESSELI', 'BESSELJ', 'BESSELK', 'BESSELY', 'BETA.DIST', 'BETA.INV', 'BETADIST', 'BETAINV', 'BIN2DEC', 'BIN2HEX', 'BIN2OCT', 'BINOM.DIST', 'BINOM.DIST.RANGE', 'BINOM.INV', 'BINOMDIST', 'BITAND', 'BITLSHIFT', 'BITOR', 'BITRSHIFT', 'BITXOR', 'CEILING', 'CEILINGMATH', 'CEILINGPRECISE', 'CHAR', 'CHISQ.DIST', 'CHISQ.DIST.RT', 'CHISQ.INV', 'CHISQ.INV.RT', 'CHOOSE', 'CHOOSE', 'CLEAN', 'CODE', 'COLUMN', 'COLUMNS', 'COMBIN', 'COMBINA', 'COMPLEX', 'CONCATENATE', 'CONFIDENCE', 'CONFIDENCE.NORM', 'CONFIDENCE.T', 'CONVERT', 'CORREL', 'COS', 'COSH', 'COT', 'COTH', 'COUNT', 'COUNTA', 'COUNTBLANK', 'COUNTIF', 'COUNTIFS', 'COUNTIN', 'COUNTUNIQUE', 'COVARIANCE.P', 'COVARIANCE.S', 'CSC', 'CSCH', 'CUMIPMT', 'CUMPRINC', 'DATE', 'DATEVALUE', 'DAY', 'DAYS', 'DAYS360', 'DB', 'DDB', 'DEC2BIN', 'DEC2HEX', 'DEC2OCT', 'DECIMAL', 'DEGREES', 'DELTA', 'DEVSQ', 'DIVIDE', 'DOLLAR', 'DOLLARDE', 'DOLLARFR', 'E', 'EDATE', 'EFFECT', 'EOMONTH', 'EQ', 'ERF', 'ERFC', 'EVEN', 'EXACT', 'EXPON.DIST', 'EXPONDIST', 'F.DIST', 'F.DIST.RT', 'F.INV', 'F.INV.RT', 'FACT', 'FACTDOUBLE', 'FALSE', 'FDIST', 'FDISTRT', 'FIND', 'FINV', 'FINVRT', 'FISHER', 'FISHERINV', 'FIXED', 'FLATTEN', 'FLOOR', 'FORECAST', 'FREQUENCY', 'FV', 'FVSCHEDULE', 'GAMMA', 'GAMMA.DIST', 'GAMMA.INV', 'GAMMADIST', 'GAMMAINV', 'GAMMALN', 'GAMMALN.PRECISE', 'GAUSS', 'GCD', 'GEOMEAN', 'GESTEP', 'GROWTH', 'GTE', 'HARMEAN', 'HEX2BIN', 'HEX2DEC', 'HEX2OCT', 'HOUR', 'HTML2TEXT', 'HYPGEOM.DIST', 'HYPGEOMDIST', 'IF', 'IMABS', 'IMAGINARY', 'IMARGUMENT', 'IMCONJUGATE', 'IMCOS', 'IMCOSH', 'IMCOT', 'IMCSC', 'IMCSCH', 'IMDIV', 'IMEXP', 'IMLN', 'IMLOG10', 'IMLOG2', 'IMPOWER', 'IMPRODUCT', 'IMREAL', 'IMSEC', 'IMSECH', 'IMSIN', 'IMSINH', 'IMSQRT', 'IMSUB', 'IMSUM', 'IMTAN', 'INT', 'INTERCEPT', 'INTERVAL', 'IPMT', 'IRR', 'ISBINARY', 'ISBLANK', 'ISEVEN', 'ISLOGICAL', 'ISNONTEXT', 'ISNUMBER', 'ISODD', 'ISODD', 'ISOWEEKNUM', 'ISPMT', 'ISTEXT', 'JOIN', 'KURT', 'LARGE', 'LCM', 'LEFT', 'LEN', 'LINEST', 'LN', 'LOG', 'LOG10', 'LOGEST', 'LOGNORM.DIST', 'LOGNORM.INV', 'LOGNORMDIST', 'LOGNORMINV', 'LOWER', 'LT', 'LTE', 'MATCH', 'MAX', 'MAXA', 'MEDIAN', 'MID', 'MIN', 'MINA', 'MINUS', 'MINUTE', 'MIRR', 'MOD', 'MODE.MULT', 'MODE.SNGL', 'MODEMULT', 'MODESNGL', 'MONTH', 'MROUND', 'MULTINOMIAL', 'MULTIPLY', 'NE', 'NEGBINOM.DIST', 'NEGBINOMDIST', 'NETWORKDAYS', 'NOMINAL', 'NORM.DIST', 'NORM.INV', 'NORM.S.DIST', 'NORM.S.INV', 'NORMDIST', 'NORMINV', 'NORMSDIST', 'NORMSINV', 'NOT', 'NOW', 'NPER', 'NPV', 'NUMBERS', 'NUMERAL', 'OCT2BIN', 'OCT2DEC', 'OCT2HEX', 'ODD', 'OR', 'PDURATION', 'PEARSON', 'PERCENTILEEXC', 'PERCENTILEINC', 'PERCENTRANKEXC', 'PERCENTRANKINC', 'PERMUT', 'PERMUTATIONA', 'PHI', 'PI', 'PMT', 'POISSON.DIST', 'POISSONDIST', 'POW', 'POWER', 'PPMT', 'PROB', 'PRODUCT', 'PROPER', 'PV', 'QUARTILE.EXC', 'QUARTILE.INC', 'QUARTILEEXC', 'QUARTILEINC', 'QUOTIENT', 'RADIANS', 'RAND', 'RANDBETWEEN', 'RANK.AVG', 'RANK.EQ', 'RANKAVG', 'RANKEQ', 'RATE', 'REFERENCE', 'REGEXEXTRACT', 'REGEXMATCH', 'REGEXREPLACE', 'REPLACE', 'REPT', 'RIGHT', 'ROMAN', 'ROUND', 'ROUNDDOWN', 'ROUNDUP', 'ROW', 'ROWS', 'RRI', 'RSQ', 'SEARCH', 'SEC', 'SECH', 'SECOND', 'SERIESSUM', 'SIGN', 'SIN', 'SINH', 'SKEW', 'SKEW.P', 'SKEWP', 'SLN', 'SLOPE', 'SMALL', 'SPLIT', 'SPLIT', 'SQRT', 'SQRTPI', 'STANDARDIZE', 'STDEV.P', 'STDEV.S', 'STDEVA', 'STDEVP', 'STDEVPA', 'STDEVS', 'STEYX', 'SUBSTITUTE', 'SUBTOTAL', 'SUM', 'SUMIF', 'SUMIFS', 'SUMPRODUCT', 'SUMSQ', 'SUMX2MY2', 'SUMX2PY2', 'SUMXMY2', 'SWITCH', 'SYD', 'T', 'T.DIST', 'T.DIST.2T', 'T.DIST.RT', 'T.INV', 'T.INV.2T', 'TAN', 'TANH', 'TBILLEQ', 'TBILLPRICE', 'TBILLYIELD', 'TDIST', 'TDIST2T', 'TDISTRT', 'TEXT', 'TIME', 'TIMEVALUE', 'TINV', 'TINV2T', 'TODAY', 'TRANSPOSE', 'TREND', 'TRIM', 'TRIMMEAN', 'TRUE', 'TRUNC', 'UNICHAR', 'UNICODE', 'UNIQUE', 'UPPER', 'VALUE', 'VAR.P', 'VAR.S', 'VARA', 'VARP', 'VARPA', 'VARS', 'WEEKDAY', 'WEEKNUM', 'WEIBULL.DIST', 'WEIBULLDIST', 'WORKDAY', 'XIRR', 'XNPV', 'XOR', 'YEAR', 'YEARFRAC'];

exports.default = SUPPORTED_FORMULAS;

},{}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.extractLabel = extractLabel;
exports.toLabel = toLabel;
exports.columnLabelToIndex = columnLabelToIndex;
exports.columnIndexToLabel = columnIndexToLabel;
exports.rowLabelToIndex = rowLabelToIndex;
exports.rowIndexToLabel = rowIndexToLabel;
exports.toNumber = toNumber;
exports.invertNumber = invertNumber;
exports.trimEdges = trimEdges;
/* ****************************************** *\
 *                  单元格相关
 * ****************************************** */

var LABEL_EXTRACT_REGEXP = /^([$])?([A-Za-z]+)([$])?([0-9]+)$/;

function extractLabel(label) {
    if (!LABEL_EXTRACT_REGEXP.test(label)) {
        return [];
    }

    var _label$match = label.match(LABEL_EXTRACT_REGEXP),
        _label$match2 = _slicedToArray(_label$match, 5),
        columnAbs = _label$match2[1],
        column = _label$match2[2],
        rowAbs = _label$match2[3],
        row = _label$match2[4];

    return [{
        index: rowLabelToIndex(row),
        label: row,
        isAbsolute: rowAbs === '$'
    }, {
        index: columnLabelToIndex(column),
        label: column,
        isAbsolute: columnAbs === '$'
    }];
}

function toLabel(row, column) {
    var rowLabel = (row.isAbsolute ? '$' : '') + rowIndexToLabel(row.index);
    var columnLabel = (column.isAbsolute ? '$' : '') + columnIndexToLabel(column.index);
    return columnLabel + rowLabel;
}

var COLUMN_LABEL_BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
var COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;

function columnLabelToIndex(label) {
    var result = 0;

    if (label) {
        for (var i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {
            result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j) * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);
        }
    }
    --result;

    return result;
}

function columnIndexToLabel(column) {
    var result = '';

    while (column >= 0) {
        result = String.fromCharCode(column % COLUMN_LABEL_BASE_LENGTH + 97) + result;
        column = Math.floor(column / COLUMN_LABEL_BASE_LENGTH) - 1;
    }

    return result.toUpperCase();
}

function rowLabelToIndex(label) {
    var result = parseInt(label, 10);

    if (Number.isNaN(result)) {
        result = -1;
    } else {
        result = Math.max(result - 1, -1);
    }
    return result;
}

function rowIndexToLabel(row) {
    return row >= 0 ? '' + (row + 1) : '';
}

/* ****************************************** *\
 *                  number
 * ****************************************** */

function toNumber(number) {
    var result = void 0;
    if (typeof number === 'number') {
        result = number;
    } else if (typeof number === 'string') {
        result = number.indexOf('.') > -1 ? parseFloat(number) : parseInt(number, 10);
    }
    return result;
}

/**
 * 取负数
 * @param {Number} number
 * @returns {Number}
 */
function invertNumber(number) {
    return -1 * toNumber(number);
}

/* ****************************************** *\
 *                  string
 * ****************************************** */

function trimEdges(string) {
    var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    string = string.substring(margin, string.length - margin);
    return string;
}

},{}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFormulaExpression = isFormulaExpression;
exports.isFormulaExpressionEscaped = isFormulaExpressionEscaped;
exports.unescapeFormulaExpression = unescapeFormulaExpression;
exports.toUpperCaseFormula = toUpperCaseFormula;

/**
 * Check if provided expression is valid formula expression.
 *
 * @param {*} expression Expression to check.
 * @returns {Boolean}
 */
function isFormulaExpression(expression) {
    return expression && (expression + '').charAt(0) === '=' ? true : false;
}

/**
 * Check if provided formula expression is escaped.
 *
 * @param {*} expression Expression to check.
 * @returns {Boolean}
 */
function isFormulaExpressionEscaped(expression) {
    return expression && (expression + '').charAt(0) === '\'' && (expression + '').charAt(1) === '=' ? true : false;
}

/**
 * Replace escaped formula expression into valid string.
 *
 * @param {String} expression Expression to process.
 * @returns {String}
 */
function unescapeFormulaExpression(expression) {
    return isFormulaExpressionEscaped(expression) ? expression.substr(1) : expression;
}

/**
 * Upper case formula expression.
 *
 * @param {String} expression Formula expression.
 * @returns {String}
 */
function toUpperCaseFormula(expression) {
    var PATTERN = /(\\"|"(?:\\"|[^"])*"|(\+))|(\\'|'(?:\\'|[^'])*'|(\+))/g;
    var strings = expression.match(PATTERN) || [];
    var index = -1;

    return expression.toUpperCase().replace(PATTERN, function () {
        ++index;

        return strings[index];
    });
}

},{}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = polyfill;
/**
 * es6 polyfill
 * @param _g 全局变量（即浏览器环境下的 window 对象）
 */
function polyfill(_g) {

    // --------------------------------------------- Number

    if (!_g.Number.isNaN) {
        _g.Number.isNaN = function (x) {
            return x !== x;
        };
    }

    if (typeof _g.String.prototype.contains === 'undefined') {
        _g.String.prototype.contains = function (str) {
            return !!~this.indexOf(str);
        };
    }
}

},{}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * 全局配置。
 */
var globalSettings = {
    idPrefix: 'brick-ssd-',
    idSuffix4Workbook: '-workbook',

    sheet: {

        /**
         * 自动生成工作表名称时的前缀(工作表1, 工作表2...)
         */
        autoPrefix: '工作表',

        /**
         * sheet 名称中的非法字符。微软没有相关文档，以下是 Apache POI 的说明：
         *
         * Note that sheet name in Excel must not exceed 31 characters
         * and must not contain any of the any of the following characters:
         *    - 0x0000
         *    - 0x0003
         *    - colon (:)
         *    - backslash (\)
         *    - asterisk (*)
         *    - question mark (?)
         *    - forward slash (/)
         *    - opening square bracket ([)
         *    - closing square bracket (])
         *
         */
        sheetName: /[\\/\?\*:\[\]'"]/,

        animated: false
    }

};

/**
 * 默认配置
 */
var defaultSettings = {

    workbook: {
        activeSheet: '工作表1',
        sheets: [{
            name: '工作表1'
        }]
    },

    persistent: true

};

exports.globalSettings = globalSettings;
exports.defaultSettings = defaultSettings;

},{}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * 事件发射器
 *
 * PS: nodejs 的系统类库 Emitter 过大，不适合在浏览器环境使用。故引入一个简易实现。
 * @constructor
 */
function Emitter() {
    // 保持此函数为空，以便于继承
}

Emitter.prototype = {

    /**
     * 订阅事件
     * @param {string} name - 事件名
     * @param {function} callback - 事件回调函数
     * @param [ctx] - 设置调用 callback 时的上下文
     * @returns {Emitter}
     */
    on: function on(name, callback, ctx) {
        var e = this.e || (this.e = {});

        (e[name] || (e[name] = [])).push({
            fn: callback,
            ctx: ctx
        });

        return this;
    },

    /**
     * 订阅一次性事件
     * @param {string} name - 事件名
     * @param {function} callback - 事件回调函数
     * @param ctx - 设置调用 callback 时的上下文
     * @returns {*|Emitter}
     */
    once: function once(name, callback, ctx) {
        var self = this;

        function listener() {
            self.off(name, listener);
            callback.apply(ctx, arguments);
        }

        listener._ = callback;
        return this.on(name, listener, ctx);
    },

    /**
     * 发射指定事件
     * @param {string} name - 事件名
     * @returns {Emitter}
     */
    emit: function emit(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;

        for (i; i < len; i++) {
            evtArr[i].fn.apply(evtArr[i].ctx, data);
        }

        return this;
    },

    /**
     * 注销事件
     * @param {string} name - 事件名
     * @param {function} [callback] - 绑定事件时的回调函数，如果不指定则注销所有 `name` 事件
     * @returns {Emitter}
     */
    off: function off(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];

        if (evts && callback) {
            for (var i = 0, len = evts.length; i < len; i++) {
                if (evts[i].fn !== callback && evts[i].fn._ !== callback) {
                    liveEvents.push(evts[i]);
                }
            }
        }

        // 防止内存溢出
        liveEvents.length ? e[name] = liveEvents : delete e[name];

        return this;
    },

    /**
     * 获取全局唯一事件发射器
     */
    getGlobalEmitter: function () {
        var instance = new Emitter();
        return function () {
            return instance;
        };
    }()
};

exports.default = Emitter;

/**
 * 全局唯一事件发射器
 */

var GlobalEmitter = exports.GlobalEmitter = Emitter.prototype.getGlobalEmitter();

},{}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extend = extend;
exports.objectEach = objectEach;
exports.emptyFunction = emptyFunction;
exports.upperCase = upperCase;
exports.upperCaseFirst = upperCaseFirst;
exports.randomString = randomString;
exports.isEmptyValue = isEmptyValue;


// ------------------------------------- object

function extend(target, extension) {
    objectEach(extension, function (value, key) {
        target[key] = value;
    });
    return target;
}

function objectEach(object, iteratee) {
    for (var key in object) {
        if (!object.hasOwnProperty || object.hasOwnProperty && object.hasOwnProperty(key)) {
            if (iteratee(object[key], key, object) === false) {
                break;
            }
        }
    }
    return object;
}

// ------------------------------------- function

var _emptyFn = function _emptyFn() {};

/**
 * 获取空函数。
 * @param newOne 默认 `false`，当为 `true` 时将返回一个新的空函数。
 * @returns {Function}
 */
function emptyFunction() {
    var newOne = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (newOne) {
        return function () {};
    }
    return _emptyFn;
}

// ------------------------------------- string


function upperCase(str) {
    return str.toUpperCase();
}

function upperCaseFirst(str) {
    return str.replace(/^\S/g, function (f) {
        return upperCase(f);
    });
}

/**
 * 生成一个长度为 16 的随机字符串
 * @returns {*}
 */
function randomString() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    return s4() + s4() + s4() + s4();
}

// ------------------------------------- mixed

/**
 * 判断是否为`空`值。
 * PS：此方法的判断逻辑作为单元格是否为空的依据。
 * @param value
 * @returns {boolean}
 */
function isEmptyValue(value) {
    return !!(value === '' || value === null || typeof value === 'undefined');
}

// ------------------------------------- coordinate


var c_isEqual = function c_isEqual(r1, r2) {
    return r1[0] === r2[0] && r1[1] === r2[1] && r1[2] === r2[2] && r1[3] === r2[3];
};

var c_intersection = function c_intersection(r1, r2) {
    var x1 = Math.max(r1[0], r2[0]);
    var y1 = Math.max(r1[1], r2[1]);
    var x2 = Math.min(r1[2], r2[2]);
    var y2 = Math.min(r1[3], r2[3]);

    if (x1 <= x2 && y1 <= y2) {
        return [x1, y1, x2, y2];
    }
    return false;
};

var c_set = function c_set(t) {
    return function (r1, r2) {
        var ins = c_intersection(r1, r2);
        if (ins) {
            return c_isEqual(ins, t === 'sub' ? r1 : r2);
        }
        return false;
    };
};

var Coordinate = exports.Coordinate = {

    /**
     * 判断坐标范围 r1 是否与 r2 相等。
     * @param {Array} r1
     * @param {int} r1[0] - 坐标范围 r1 的起始行坐标
     * @param {int} r1[1] - 坐标范围 r1 的起始列坐标
     * @param {int} r1[2] - 坐标范围 r1 的终止行坐标
     * @param {int} r1[3] - 坐标范围 r1 的终止列坐标
     * @param {Array} r2
     * @param {int} r2[0] - 坐标范围 r2 的起始行坐标
     * @param {int} r2[1] - 坐标范围 r2 的起始列坐标
     * @param {int} r2[2] - 坐标范围 r2 的终止行坐标
     * @param {int} r2[3] - 坐标范围 r2 的终止列坐标
     * @returns {boolean}
     */
    isEqual: c_isEqual,

    /**
     * 判断坐标范围 r1 是否与 r2 存在交集。
     * @returns {boolean}
     */
    intersection: c_intersection,

    /**
     * 判断坐标范围 r1 是否是 r2 的子集。
     * @returns {boolean}
     */
    isSubset: c_set('sub'),

    /**
     * 判断坐标范围 r1 是否是 r2 的超集。
     * @returns {boolean}
     */
    isSuperset: c_set('sup')
};

// -------------------------------------

},{}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Stack = exports.CaseInsensitiveMap = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _common = require('./common.js');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 大小写不敏感的 Map
 */
var CaseInsensitiveMap = function () {
    function CaseInsensitiveMap(iterable) {
        _classCallCheck(this, CaseInsensitiveMap);

        this._map = new Map(iterable);
        this._keys = {};
    }

    _createClass(CaseInsensitiveMap, [{
        key: 'get',
        value: function get(key) {
            var acKey = this._keys[(0, _common.upperCase)(key)];
            return this._map.get(acKey);
        }
    }, {
        key: 'set',
        value: function set(key, value) {
            this._keys[(0, _common.upperCase)(key)] = key;
            return this._map.set(key, value);
        }
    }, {
        key: 'has',
        value: function has(key) {
            return this._keys[(0, _common.upperCase)(key)];
        }
    }, {
        key: 'hasExact',
        value: function hasExact(key) {
            return this._map.has(key);
        }
    }, {
        key: 'clear',
        value: function clear() {
            this._keys = {};
            return this._map.clear();
        }
    }, {
        key: 'delete',
        value: function _delete(key) {
            var acKey = this._keys[(0, _common.upperCase)(key)];
            delete this._keys[(0, _common.upperCase)(key)];
            return this._map.delete(acKey);
        }
    }, {
        key: 'entries',
        value: function entries() {
            return this._map.entries();
        }
    }, {
        key: 'forEach',
        value: function forEach(callbackfn, thisArg) {
            return this._map.forEach(callbackfn, thisArg);
        }

        /**
         *
         * @returns {Iterator.<string>}
         */

    }, {
        key: 'keys',
        value: function keys() {
            return this._map.keys();
        }
    }, {
        key: 'values',
        value: function values() {
            return this._map.values();
        }
    }, {
        key: 'toMap',
        value: function toMap() {
            return this._map;
        }
    }, {
        key: 'size',
        value: function size() {
            return this._map.size;
        }
    }]);

    return CaseInsensitiveMap;
}();

/**
 * Stack
 */


var Stack = function () {
    function Stack() {
        var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        _classCallCheck(this, Stack);

        this.items = initial;
    }

    _createClass(Stack, [{
        key: 'push',
        value: function push() {
            var _items;

            (_items = this.items).push.apply(_items, arguments);
        }
    }, {
        key: 'pop',
        value: function pop() {
            return this.items.pop();
        }
    }, {
        key: 'peek',
        value: function peek() {
            return this.isEmpty() ? void 0 : this.items[this.items.length - 1];
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return !this.size();
        }
    }, {
        key: 'size',
        value: function size() {
            return this.items.length;
        }
    }]);

    return Stack;
}();

exports.CaseInsensitiveMap = CaseInsensitiveMap;
exports.Stack = Stack;

},{"./common.js":57}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.innerHTML = innerHTML;
exports.insertAfter = insertAfter;
exports.closest = closest;
exports.empty = empty;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
var textContextSupport = document.createTextNode('test').textContent ? true : false;
var classListSupport = document.documentElement.classList ? true : false;

var REG_HTML_CHARACTERS = /(<(.*)>|&(.*);)/;

/**
 * 能同时兼容文本节点的 innerHTML 方法。
 *
 * @returns {void}
 */
function innerHTML(element, content) {
    if (REG_HTML_CHARACTERS.test(content)) {
        element.innerHTML = content;
    } else {
        var child = element.firstChild;
        if (child && child.nodeType === 3 && child.nextSibling === null) {
            if (textContextSupport) {
                child.textContent = content;
            } else {
                child.data = content;
            }
        } else {
            empty(element);
            element.appendChild(document.createTextNode(content));
        }
    }
}

/**
 * 在指定节点后插入节点
 * @param element
 * @param content
 */
function insertAfter(element, content) {
    if (REG_HTML_CHARACTERS.test(content)) {
        element.insertAdjacentHTML('afterend', content);
    } else {
        if (content.nodeType === 1) {
            if (element.nextSibling) {
                element.parentNode.insertBefore(content, element.nextSibling);
            } else {
                element.parentNode.appendChild(content);
            }
        } else {
            // TODO
        }
    }
}

function closest(element, selector) {
    var ret;
    do {
        element = element.parentNode;
        if (!element || !element.ownerDocument || (ret = element.querySelector(selector))) {
            break;
        }
    } while (element);

    return ret;
}

/**
 * 清空指定元素的所有子节点。
 *
 * @param element
 * @returns {void}
 */
function empty(element) {
    var child;
    while (child = element.lastChild) {
        // jshint ignore:line
        try {
            element.removeChild(child);
        } catch (e) {
            // TODO 暂时这样处理 https://bugzilla.mozilla.org/show_bug.cgi?id=559561
        }
    }
}

/**
 * 返回指定元素的外高度（包括 padding、border 及可选的 margin 值）。
 *
 * @param el
 * @param {Boolean} withMargin - 高度中是否包括 margin 值
 * @returns {number}
 */
function outerHeight(el) {
    var withMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var height = el.offsetHeight;
    var style;

    if (withMargin === false) {
        return height;
    }
    style = getComputedStyle(el);
    height += parseInt(style.marginTop) + parseInt(style.marginBottom);
    return height;
}

/**
 * 返回指定元素的外宽度（包括 padding、border 及可选的 margin 值）。
 *
 * @param el
 * @param {Boolean} withMargin - 宽度中是否包括 margin 值
 * @returns {number}
 */
function outerWidth(el) {
    var withMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var width = el.offsetWidth;
    var style;

    if (withMargin === false) {
        return width;
    }
    style = getComputedStyle(el);
    width += parseInt(style.marginLeft) + parseInt(style.marginRight);
    return width;
}

},{}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stopImmediatePropagation = stopImmediatePropagation;
exports.stopPropagation = stopPropagation;
/**
 * 阻止其它监听被调用。
 * @param {Event} event
 */
function stopImmediatePropagation(event) {
    event.isImmediatePropagationEnabled = false;
    event.cancelBubble = true;
}

/**
 * 阻止事件冒泡。
 * @param {Event} event
 */
function stopPropagation(event) {
    if (typeof event.stopPropagation === 'function') {
        event.stopPropagation();
    } else {
        event.cancelBubble = true;
    }
}

},{}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL2Rpc3QvZm9ybXVsYS5qcyIsIm5vZGVfbW9kdWxlcy9mb3JtdWxhanMvbm9kZV9tb2R1bGVzL2pTdGF0L2Rpc3QvanN0YXQuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL25vZGVfbW9kdWxlcy9udW1lcmFsL251bWVyYWwuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL25vZGVfbW9kdWxlcy9udW1lcmljL251bWVyaWMtMS4yLjYuanMiLCJzcmMvU3ByZWFkU2hlZXRFcnJvci5qcyIsInNyYy9icm93c2VyLmpzIiwic3JjL2NvcmUuanMiLCJzcmMvZGVzaWduZXIvQ29uZmlnVHJhbnNsYXRvci5qcyIsInNyYy9kZXNpZ25lci9GcmFtZS5qcyIsInNyYy9kZXNpZ25lci9Ib3RUYWJsZUFkYXB0b3IuanMiLCJzcmMvZGVzaWduZXIvU2hlZXQuanMiLCJzcmMvZGVzaWduZXIvU2hlZXRFcnJvci5qcyIsInNyYy9kZXNpZ25lci9Xb3JrYm9vay5qcyIsInNyYy9kZXNpZ25lci9leHQvU2hlZXRfZXhjaGFuZ2UuanMiLCJzcmMvZGVzaWduZXIvZXh0L1NoZWV0X2hlbHBlci5qcyIsInNyYy9kZXNpZ25lci9mcmFtZS9Db250ZXh0TWVudS5qcyIsInNyYy9kZXNpZ25lci9mcmFtZS9Db250ZXh0TWVudV9hbGlnbm1lbnQuanMiLCJzcmMvZGVzaWduZXIvdmlld3MvVGFicy5qcyIsInNyYy9pMThuLmpzIiwic3JjL3BsdWdpbnMvUGx1Z2luLmpzIiwic3JjL3BsdWdpbnMvUGx1Z2luRXJyb3IuanMiLCJzcmMvcGx1Z2lucy9wZXJzaXN0ZW50L1BlcnNpc3RlbnQuanMiLCJzcmMvcGx1Z2lucy9wZXJzaXN0ZW50L1N0b3JhZ2UuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvQWx0ZXJNYW5hZ2VyLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL0Jhc2VDZWxsLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL0NlbGxSZWZlcmVuY2UuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvQ2VsbFZhbHVlLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL0RhdGFQcm92aWRlci5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9NYXRyaXguanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvU2hlZXQuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvVW5kb1JlZG9TbmFwc2hvdC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9YRm9ybXVsYXMuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvZXhwcmVzc2lvbk1vZGlmaWVyLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9lcnJvci5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvZ3JhbW1hci5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvYWRkLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9hbXBlcnNhbmQuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL2RpdmlkZS5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvZXF1YWwuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL2Zvcm11bGEtZnVuY3Rpb24uanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL2dyZWF0ZXItdGhhbi1vci1lcXVhbC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvZ3JlYXRlci10aGFuLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9sZXNzLXRoYW4tb3ItZXF1YWwuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL2xlc3MtdGhhbi5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvbWludXMuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL211bHRpcGx5LmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9ub3QtZXF1YWwuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL3Bvd2VyLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvcnMuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL3BhcnNlci5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvc3VwcG9ydGVkLWZvcm11bGFzLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci91dGlscy5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy91dGlscy5qcyIsInNyYy9wb2x5ZmlsbC5qcyIsInNyYy9zZXR0aW5ncy5qcyIsInNyYy91dGlscy9FbWl0dGVyLmpzIiwic3JjL3V0aWxzL2NvbW1vbi5qcyIsInNyYy91dGlscy9kYXRhU3RydWN0dXJlLmpzIiwic3JjL3V0aWxzL2RvbUhlbHBlci5qcyIsInNyYy91dGlscy9ldmVudEhlbHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHJHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDeDBJ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Q0FBRCxFQUFXLEdBQUcsRUFBSCxDQUFYLENBQTVCLENBQVQ7O0FBRVI7QUFDQSxxQkFBSyxFQUFMOztBQUVRLHlCQUFLLENBQUwsR0FBUyxHQUFHLGtCQUFILENBQXNCLElBQXRCLEVBQTRCLENBQUMsR0FBRyxLQUFHLENBQU4sQ0FBRCxFQUFXLEdBQUcsRUFBSCxDQUFYLENBQTVCLENBQVQ7O0FBRVI7QUFDQSxxQkFBSyxFQUFMOztBQUVRLHlCQUFLLENBQUwsR0FBUyxHQUFHLGtCQUFILENBQXNCLElBQXRCLEVBQTRCLENBQUMsR0FBRyxLQUFHLENBQU4sQ0FBRCxFQUFXLEdBQUcsRUFBSCxDQUFYLENBQTVCLENBQVQ7O0FBRVI7QUFDQSxxQkFBSyxFQUFMOztBQUVRLHlCQUFLLENBQUwsR0FBUyxHQUFHLGtCQUFILENBQXNCLEtBQXRCLEVBQTZCLENBQUMsR0FBRyxLQUFHLENBQU4sQ0FBRCxFQUFXLEdBQUcsRUFBSCxDQUFYLENBQTdCLENBQVQ7O0FBRVI7QUFDQSxxQkFBSyxFQUFMOztBQUVRLHlCQUFLLENBQUwsR0FBUyxHQUFHLGtCQUFILENBQXNCLEdBQXRCLEVBQTJCLENBQUMsR0FBRyxLQUFHLENBQU4sQ0FBRCxFQUFXLEdBQUcsRUFBSCxDQUFYLENBQTNCLENBQVQ7O0FBRVI7QUFDQSxxQkFBSyxFQUFMOztBQUVRLHlCQUFLLENBQUwsR0FBUyxHQUFHLGtCQUFILENBQXNCLEdBQXRCLEVBQTJCLENBQUMsR0FBRyxLQUFHLENBQU4sQ0FBRCxFQUFXLEdBQUcsRUFBSCxDQUFYLENBQTNCLENBQVQ7O0FBRVI7QUFDQSxxQkFBSyxFQUFMOztBQUVRLHlCQUFLLENBQUwsR0FBUyxHQUFHLGtCQUFILENBQXNCLEdBQXRCLEVBQTJCLENBQUMsR0FBRyxLQUFHLENBQU4sQ0FBRCxFQUFXLEdBQUcsRUFBSCxDQUFYLENBQTNCLENBQVQ7O0FBRVI7QUFDQSxxQkFBSyxFQUFMOztBQUVRLHlCQUFLLENBQUwsR0FBUyxHQUFHLGtCQUFILENBQXNCLEdBQXRCLEVBQTJCLENBQUMsR0FBRyxLQUFHLENB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LEVBQTBCO0FBQ3RCLGVBQU8sTUFBUDtBQUNIO0FBQ0QsWUFBUSxpQkFBaUIsRUFBakIsQ0FBUjtBQUNBLGNBQVUsU0FBUyxNQUFNLFNBQWYsSUFBNEIsU0FBUyxNQUFNLFlBQWYsQ0FBdEM7QUFDQSxXQUFPLE1BQVA7QUFDSDs7QUFHRDs7Ozs7OztBQU9PLFNBQVMsVUFBVCxDQUFvQixFQUFwQixFQUEyQztBQUFBLFFBQW5CLFVBQW1CLHVFQUFOLElBQU07O0FBQzlDLFFBQUksUUFBUSxHQUFHLFdBQWY7QUFDQSxRQUFJLEtBQUo7O0FBRUEsUUFBSSxlQUFlLEtBQW5CLEVBQTBCO0FBQ3RCLGVBQU8sS0FBUDtBQUNIO0FBQ0QsWUFBUSxpQkFBaUIsRUFBakIsQ0FBUjtBQUNBLGFBQVMsU0FBUyxNQUFNLFVBQWYsSUFBNkIsU0FBUyxNQUFNLFdBQWYsQ0FBdEM7QUFDQSxXQUFPLEtBQVA7QUFDSDs7Ozs7Ozs7UUNoSGUsd0IsR0FBQSx3QjtRQVNBLGUsR0FBQSxlO0FBYmhCOzs7O0FBSU8sU0FBUyx3QkFBVCxDQUFrQyxLQUFsQyxFQUF5QztBQUM1QyxVQUFNLDZCQUFOLEdBQXNDLEtBQXRDO0FBQ0EsVUFBTSxZQUFOLEdBQXFCLElBQXJCO0FBQ0g7O0FBRUQ7Ozs7QUFJTyxTQUFTLGVBQVQsQ0FBeUIsS0FBekIsRUFBZ0M7QUFDbkMsUUFBSSxPQUFPLE1BQU0sZUFBYixLQUFpQyxVQUFyQyxFQUFpRDtBQUM3QyxjQUFNLGVBQU47QUFDSCxLQUZELE1BRU87QUFDSCxjQUFNLFlBQU4sR0FBcUIsSUFBckI7QUFDSDtBQUNKIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIm51bWVyaWNcIiksIHJlcXVpcmUoXCJudW1lcmFsXCIpLCByZXF1aXJlKFwialN0YXRcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibnVtZXJpY1wiLCBcIm51bWVyYWxcIiwgXCJqU3RhdFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJmb3JtdWxhanNcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJudW1lcmljXCIpLCByZXF1aXJlKFwibnVtZXJhbFwiKSwgcmVxdWlyZShcImpTdGF0XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJmb3JtdWxhanNcIl0gPSBmYWN0b3J5KHJvb3RbXCJudW1lcmljXCJdLCByb290W1wibnVtZXJhbFwiXSwgcm9vdFtcImpTdGF0XCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV85X18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGNhdGVnb3JpZXMgPSBbXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxKSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oNyksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxNCksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxNyksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxMSksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxOCksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg2KSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKVxuXHRdO1xuXG5cdGZvciAodmFyIGMgaW4gY2F0ZWdvcmllcykge1xuXHQgIHZhciBjYXRlZ29yeSA9IGNhdGVnb3JpZXNbY107XG5cdCAgZm9yICh2YXIgZiBpbiBjYXRlZ29yeSkge1xuXHQgICAgZXhwb3J0c1tmXSA9IGV4cG9ydHNbZl0gfHwgY2F0ZWdvcnlbZl07XG5cdCAgfVxuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBtYXRoVHJpZyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBzdGF0aXN0aWNhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBlbmdpbmVlcmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgZGF0ZVRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuXHRmdW5jdGlvbiBzZXQoZm4sIHJvb3QpIHtcblx0ICBpZiAocm9vdCkge1xuXHQgICAgZm9yICh2YXIgaSBpbiByb290KSB7XG5cdCAgICAgIGZuW2ldID0gcm9vdFtpXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGZuO1xuXHR9XG5cblx0ZXhwb3J0cy5CRVRBRElTVCA9IHN0YXRpc3RpY2FsLkJFVEEuRElTVDtcblx0ZXhwb3J0cy5CRVRBSU5WID0gc3RhdGlzdGljYWwuQkVUQS5JTlY7XG5cdGV4cG9ydHMuQklOT01ESVNUID0gc3RhdGlzdGljYWwuQklOT00uRElTVDtcblx0ZXhwb3J0cy5DRUlMSU5HID0gZXhwb3J0cy5JU09DRUlMSU5HID0gc2V0KG1hdGhUcmlnLkNFSUxJTkcuTUFUSCwgbWF0aFRyaWcuQ0VJTElORyk7XG5cdGV4cG9ydHMuQ0VJTElOR01BVEggPSBtYXRoVHJpZy5DRUlMSU5HLk1BVEg7XG5cdGV4cG9ydHMuQ0VJTElOR1BSRUNJU0UgPSBtYXRoVHJpZy5DRUlMSU5HLlBSRUNJU0U7XG5cdGV4cG9ydHMuQ0hJRElTVCA9IHN0YXRpc3RpY2FsLkNISVNRLkRJU1Q7XG5cdGV4cG9ydHMuQ0hJRElTVFJUID0gc3RhdGlzdGljYWwuQ0hJU1EuRElTVC5SVDtcblx0ZXhwb3J0cy5DSElJTlYgPSBzdGF0aXN0aWNhbC5DSElTUS5JTlY7XG5cdGV4cG9ydHMuQ0hJSU5WUlQgPSBzdGF0aXN0aWNhbC5DSElTUS5JTlYuUlQ7XG5cdGV4cG9ydHMuQ0hJVEVTVCA9IHN0YXRpc3RpY2FsLkNISVNRLlRFU1Q7XG5cdGV4cG9ydHMuQ09ORklERU5DRSA9IHNldChzdGF0aXN0aWNhbC5DT05GSURFTkNFLk5PUk0sIHN0YXRpc3RpY2FsLkNPTkZJREVOQ0UpO1xuXHRleHBvcnRzLkNPVkFSID0gc3RhdGlzdGljYWwuQ09WQVJJQU5DRS5QO1xuXHRleHBvcnRzLkNPVkFSSUFOQ0VQID0gc3RhdGlzdGljYWwuQ09WQVJJQU5DRS5QO1xuXHRleHBvcnRzLkNPVkFSSUFOQ0VTID0gc3RhdGlzdGljYWwuQ09WQVJJQU5DRS5TO1xuXHRleHBvcnRzLkNSSVRCSU5PTSA9IHN0YXRpc3RpY2FsLkJJTk9NLklOVjtcblx0ZXhwb3J0cy5FWFBPTkRJU1QgPSBzdGF0aXN0aWNhbC5FWFBPTi5ESVNUO1xuXHRleHBvcnRzLkVSRkNQUkVDSVNFID0gZW5naW5lZXJpbmcuRVJGQy5QUkVDSVNFO1xuXHRleHBvcnRzLkVSRlBSRUNJU0UgPSBlbmdpbmVlcmluZy5FUkYuUFJFQ0lTRTtcblx0ZXhwb3J0cy5GRElTVCA9IHN0YXRpc3RpY2FsLkYuRElTVDtcblx0ZXhwb3J0cy5GRElTVFJUID0gc3RhdGlzdGljYWwuRi5ESVNULlJUO1xuXHRleHBvcnRzLkZJTlZSVCA9IHN0YXRpc3RpY2FsLkYuSU5WLlJUO1xuXHRleHBvcnRzLkZJTlYgPSBzdGF0aXN0aWNhbC5GLklOVjtcblx0ZXhwb3J0cy5GTE9PUiA9IHNldChtYXRoVHJpZy5GTE9PUi5NQVRILCBtYXRoVHJpZy5GTE9PUik7XG5cdGV4cG9ydHMuRkxPT1JNQVRIID0gbWF0aFRyaWcuRkxPT1IuTUFUSDtcblx0ZXhwb3J0cy5GTE9PUlBSRUNJU0UgPSBtYXRoVHJpZy5GTE9PUi5QUkVDSVNFO1xuXHRleHBvcnRzLkZURVNUID0gc3RhdGlzdGljYWwuRi5URVNUO1xuXHRleHBvcnRzLkdBTU1BRElTVCA9IHN0YXRpc3RpY2FsLkdBTU1BLkRJU1Q7XG5cdGV4cG9ydHMuR0FNTUFJTlYgPSBzdGF0aXN0aWNhbC5HQU1NQS5JTlY7XG5cdGV4cG9ydHMuR0FNTUFMTlBSRUNJU0UgPSBzdGF0aXN0aWNhbC5HQU1NQUxOLlBSRUNJU0U7XG5cdGV4cG9ydHMuSFlQR0VPTURJU1QgPSBzdGF0aXN0aWNhbC5IWVBHRU9NLkRJU1Q7XG5cdGV4cG9ydHMuTE9HSU5WID0gc3RhdGlzdGljYWwuTE9HTk9STS5JTlY7XG5cdGV4cG9ydHMuTE9HTk9STUlOViA9IHN0YXRpc3RpY2FsLkxPR05PUk0uSU5WO1xuXHRleHBvcnRzLkxPR05PUk1ESVNUID0gc3RhdGlzdGljYWwuTE9HTk9STS5ESVNUO1xuXHRleHBvcnRzLk1PREUgPSBzZXQoc3RhdGlzdGljYWwuTU9ERS5TTkdMLCBzdGF0aXN0aWNhbC5NT0RFKTtcblx0ZXhwb3J0cy5NT0RFTVVMVCA9IHN0YXRpc3RpY2FsLk1PREUuTVVMVDtcblx0ZXhwb3J0cy5NT0RFU05HTCA9IHN0YXRpc3RpY2FsLk1PREUuU05HTDtcblx0ZXhwb3J0cy5ORUdCSU5PTURJU1QgPSBzdGF0aXN0aWNhbC5ORUdCSU5PTS5ESVNUO1xuXHRleHBvcnRzLk5FVFdPUktEQVlTSU5UTCA9IGRhdGVUaW1lLk5FVFdPUktEQVlTLklOVEw7XG5cdGV4cG9ydHMuTk9STURJU1QgPSBzdGF0aXN0aWNhbC5OT1JNLkRJU1Q7XG5cdGV4cG9ydHMuTk9STUlOViA9IHN0YXRpc3RpY2FsLk5PUk0uSU5WO1xuXHRleHBvcnRzLk5PUk1TRElTVCA9IHN0YXRpc3RpY2FsLk5PUk0uUy5ESVNUO1xuXHRleHBvcnRzLk5PUk1TSU5WID0gc3RhdGlzdGljYWwuTk9STS5TLklOVjtcblx0ZXhwb3J0cy5QRVJDRU5USUxFID0gc2V0KHN0YXRpc3RpY2FsLlBFUkNFTlRJTEUuRVhDLCBzdGF0aXN0aWNhbC5QRVJDRU5USUxFKTtcblx0ZXhwb3J0cy5QRVJDRU5USUxFRVhDID0gc3RhdGlzdGljYWwuUEVSQ0VOVElMRS5FWEM7XG5cdGV4cG9ydHMuUEVSQ0VOVElMRUlOQyA9IHN0YXRpc3RpY2FsLlBFUkNFTlRJTEUuSU5DO1xuXHRleHBvcnRzLlBFUkNFTlRSQU5LID0gc2V0KHN0YXRpc3RpY2FsLlBFUkNFTlRSQU5LLklOQywgc3RhdGlzdGljYWwuUEVSQ0VOVFJBTkspO1xuXHRleHBvcnRzLlBFUkNFTlRSQU5LRVhDID0gc3RhdGlzdGljYWwuUEVSQ0VOVFJBTksuRVhDO1xuXHRleHBvcnRzLlBFUkNFTlRSQU5LSU5DID0gc3RhdGlzdGljYWwuUEVSQ0VOVFJBTksuSU5DO1xuXHRleHBvcnRzLlBPSVNTT04gPSBzZXQoc3RhdGlzdGljYWwuUE9JU1NPTi5ESVNULCBzdGF0aXN0aWNhbC5QT0lTU09OKTtcblx0ZXhwb3J0cy5QT0lTU09ORElTVCA9IHN0YXRpc3RpY2FsLlBPSVNTT04uRElTVDtcblx0ZXhwb3J0cy5RVUFSVElMRSA9IHNldChzdGF0aXN0aWNhbC5RVUFSVElMRS5JTkMsIHN0YXRpc3RpY2FsLlFVQVJUSUxFKTtcblx0ZXhwb3J0cy5RVUFSVElMRUVYQyA9IHN0YXRpc3RpY2FsLlFVQVJUSUxFLkVYQztcblx0ZXhwb3J0cy5RVUFSVElMRUlOQyA9IHN0YXRpc3RpY2FsLlFVQVJUSUxFLklOQztcblx0ZXhwb3J0cy5SQU5LID0gc2V0KHN0YXRpc3RpY2FsLlJBTksuRVEsIHN0YXRpc3RpY2FsLlJBTkspO1xuXHRleHBvcnRzLlJBTktBVkcgPSBzdGF0aXN0aWNhbC5SQU5LLkFWRztcblx0ZXhwb3J0cy5SQU5LRVEgPSBzdGF0aXN0aWNhbC5SQU5LLkVRO1xuXHRleHBvcnRzLlNLRVdQID0gc3RhdGlzdGljYWwuU0tFVy5QO1xuXHRleHBvcnRzLlNUREVWID0gc2V0KHN0YXRpc3RpY2FsLlNUREVWLlMsIHN0YXRpc3RpY2FsLlNUREVWKTtcblx0ZXhwb3J0cy5TVERFVlAgPSBzdGF0aXN0aWNhbC5TVERFVi5QO1xuXHRleHBvcnRzLlNUREVWUyA9IHN0YXRpc3RpY2FsLlNUREVWLlM7XG5cdGV4cG9ydHMuVERJU1QgPSBzdGF0aXN0aWNhbC5ULkRJU1Q7XG5cdGV4cG9ydHMuVERJU1RSVCA9IHN0YXRpc3RpY2FsLlQuRElTVC5SVDtcblx0ZXhwb3J0cy5USU5WID0gc3RhdGlzdGljYWwuVC5JTlY7XG5cdGV4cG9ydHMuVFRFU1QgPSBzdGF0aXN0aWNhbC5ULlRFU1Q7XG5cdGV4cG9ydHMuVkFSID0gc2V0KHN0YXRpc3RpY2FsLlZBUi5TLCBzdGF0aXN0aWNhbC5WQVIpO1xuXHRleHBvcnRzLlZBUlAgPSBzdGF0aXN0aWNhbC5WQVIuUDtcblx0ZXhwb3J0cy5WQVJTID0gc3RhdGlzdGljYWwuVkFSLlM7XG5cdGV4cG9ydHMuV0VJQlVMTCA9IHNldChzdGF0aXN0aWNhbC5XRUlCVUxMLkRJU1QsIHN0YXRpc3RpY2FsLldFSUJVTEwpO1xuXHRleHBvcnRzLldFSUJVTExESVNUID0gc3RhdGlzdGljYWwuV0VJQlVMTC5ESVNUO1xuXHRleHBvcnRzLldPUktEQVlJTlRMID0gZGF0ZVRpbWUuV09SS0RBWS5JTlRMO1xuXHRleHBvcnRzLlpURVNUID0gc3RhdGlzdGljYWwuWi5URVNUO1xuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgbnVtZXJpYyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBzdGF0aXN0aWNhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBpbmZvcm1hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cdGV4cG9ydHMuQUJTID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmFicyh1dGlscy5wYXJzZU51bWJlcihudW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLkFDT1MgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguYWNvcyhudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQUNPU0ggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgubG9nKG51bWJlciArIE1hdGguc3FydChudW1iZXIgKiBudW1iZXIgLSAxKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5BQ09UID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmF0YW4oMSAvIG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5BQ09USCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gMC41ICogTWF0aC5sb2coKG51bWJlciArIDEpIC8gKG51bWJlciAtIDEpKTtcblx0fTtcblxuXHQvL1RPRE86IHVzZSBvcHRpb25zXG5cdGV4cG9ydHMuQUdHUkVHQVRFID0gZnVuY3Rpb24oZnVuY3Rpb25fbnVtLCBvcHRpb25zLCByZWYxLCByZWYyKSB7XG5cdCAgZnVuY3Rpb25fbnVtID0gdXRpbHMucGFyc2VOdW1iZXIoZnVuY3Rpb25fbnVtKTtcblx0ICBvcHRpb25zID0gdXRpbHMucGFyc2VOdW1iZXIoZnVuY3Rpb25fbnVtKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihmdW5jdGlvbl9udW0sIG9wdGlvbnMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHN3aXRjaCAoZnVuY3Rpb25fbnVtKSB7XG5cdCAgICBjYXNlIDE6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5BVkVSQUdFKHJlZjEpO1xuXHQgICAgY2FzZSAyOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQ09VTlQocmVmMSk7XG5cdCAgICBjYXNlIDM6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5DT1VOVEEocmVmMSk7XG5cdCAgICBjYXNlIDQ6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NQVgocmVmMSk7XG5cdCAgICBjYXNlIDU6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NSU4ocmVmMSk7XG5cdCAgICBjYXNlIDY6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBST0RVQ1QocmVmMSk7XG5cdCAgICBjYXNlIDc6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TVERFVi5TKHJlZjEpO1xuXHQgICAgY2FzZSA4OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuU1RERVYuUChyZWYxKTtcblx0ICAgIGNhc2UgOTpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuU1VNKHJlZjEpO1xuXHQgICAgY2FzZSAxMDpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlZBUi5TKHJlZjEpO1xuXHQgICAgY2FzZSAxMTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlZBUi5QKHJlZjEpO1xuXHQgICAgY2FzZSAxMjpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLk1FRElBTihyZWYxKTtcblx0ICAgIGNhc2UgMTM6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NT0RFLlNOR0wocmVmMSk7XG5cdCAgICBjYXNlIDE0OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTEFSR0UocmVmMSwgcmVmMik7XG5cdCAgICBjYXNlIDE1OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuU01BTEwocmVmMSwgcmVmMik7XG5cdCAgICBjYXNlIDE2OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuUEVSQ0VOVElMRS5JTkMocmVmMSwgcmVmMik7XG5cdCAgICBjYXNlIDE3OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuUVVBUlRJTEUuSU5DKHJlZjEsIHJlZjIpO1xuXHQgICAgY2FzZSAxODpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlBFUkNFTlRJTEUuRVhDKHJlZjEsIHJlZjIpO1xuXHQgICAgY2FzZSAxOTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlFVQVJUSUxFLkVYQyhyZWYxLCByZWYyKTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5BUkFCSUMgPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgLy8gQ3JlZGl0czogUmFmYT8gS3VrYXdza2lcblx0ICBpZiAoIS9eTSooPzpEP0N7MCwzfXxDW01EXSkoPzpMP1h7MCwzfXxYW0NMXSkoPzpWP0l7MCwzfXxJW1hWXSkkLy50ZXN0KHRleHQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByID0gMDtcblx0ICB0ZXh0LnJlcGxhY2UoL1tNRExWXXxDW01EXT98WFtDTF0/fElbWFZdPy9nLCBmdW5jdGlvbihpKSB7XG5cdCAgICByICs9IHtcblx0ICAgICAgTTogMTAwMCxcblx0ICAgICAgQ006IDkwMCxcblx0ICAgICAgRDogNTAwLFxuXHQgICAgICBDRDogNDAwLFxuXHQgICAgICBDOiAxMDAsXG5cdCAgICAgIFhDOiA5MCxcblx0ICAgICAgTDogNTAsXG5cdCAgICAgIFhMOiA0MCxcblx0ICAgICAgWDogMTAsXG5cdCAgICAgIElYOiA5LFxuXHQgICAgICBWOiA1LFxuXHQgICAgICBJVjogNCxcblx0ICAgICAgSTogMVxuXHQgICAgfVtpXTtcblx0ICB9KTtcblx0ICByZXR1cm4gcjtcblx0fTtcblxuXHRleHBvcnRzLkFTSU4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguYXNpbihudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQVNJTkggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgubG9nKG51bWJlciArIE1hdGguc3FydChudW1iZXIgKiBudW1iZXIgKyAxKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5BVEFOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmF0YW4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkFUQU4yID0gZnVuY3Rpb24obnVtYmVyX3gsIG51bWJlcl95KSB7XG5cdCAgbnVtYmVyX3ggPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXJfeCk7XG5cdCAgbnVtYmVyX3kgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXJfeSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyX3gsIG51bWJlcl95KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hdGFuMihudW1iZXJfeCwgbnVtYmVyX3kpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQVRBTkggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgubG9nKCgxICsgbnVtYmVyKSAvICgxIC0gbnVtYmVyKSkgLyAyO1xuXHR9O1xuXG5cdGV4cG9ydHMuQkFTRSA9IGZ1bmN0aW9uKG51bWJlciwgcmFkaXgsIG1pbl9sZW5ndGgpIHtcblx0ICBtaW5fbGVuZ3RoID0gbWluX2xlbmd0aCB8fCAwO1xuXG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICByYWRpeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhZGl4KTtcblx0ICBtaW5fbGVuZ3RoID0gdXRpbHMucGFyc2VOdW1iZXIobWluX2xlbmd0aCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCByYWRpeCwgbWluX2xlbmd0aCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgbWluX2xlbmd0aCA9IChtaW5fbGVuZ3RoID09PSB1bmRlZmluZWQpID8gMCA6IG1pbl9sZW5ndGg7XG5cdCAgdmFyIHJlc3VsdCA9IG51bWJlci50b1N0cmluZyhyYWRpeCk7XG5cdCAgcmV0dXJuIG5ldyBBcnJheShNYXRoLm1heChtaW5fbGVuZ3RoICsgMSAtIHJlc3VsdC5sZW5ndGgsIDApKS5qb2luKCcwJykgKyByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5DRUlMSU5HID0gZnVuY3Rpb24obnVtYmVyLCBzaWduaWZpY2FuY2UsIG1vZGUpIHtcblx0ICBzaWduaWZpY2FuY2UgPSAoc2lnbmlmaWNhbmNlID09PSB1bmRlZmluZWQpID8gMSA6IE1hdGguYWJzKHNpZ25pZmljYW5jZSk7XG5cdCAgbW9kZSA9IG1vZGUgfHwgMDtcblxuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgc2lnbmlmaWNhbmNlID0gdXRpbHMucGFyc2VOdW1iZXIoc2lnbmlmaWNhbmNlKTtcblx0ICBtb2RlID0gdXRpbHMucGFyc2VOdW1iZXIobW9kZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBzaWduaWZpY2FuY2UsIG1vZGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChzaWduaWZpY2FuY2UgPT09IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblx0ICB2YXIgcHJlY2lzaW9uID0gLU1hdGguZmxvb3IoTWF0aC5sb2coc2lnbmlmaWNhbmNlKSAvIE1hdGgubG9nKDEwKSk7XG5cdCAgaWYgKG51bWJlciA+PSAwKSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5ST1VORChNYXRoLmNlaWwobnVtYmVyIC8gc2lnbmlmaWNhbmNlKSAqIHNpZ25pZmljYW5jZSwgcHJlY2lzaW9uKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKG1vZGUgPT09IDApIHtcblx0ICAgICAgcmV0dXJuIC1leHBvcnRzLlJPVU5EKE1hdGguZmxvb3IoTWF0aC5hYnMobnVtYmVyKSAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gLWV4cG9ydHMuUk9VTkQoTWF0aC5jZWlsKE1hdGguYWJzKG51bWJlcikgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlLCBwcmVjaXNpb24pO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkNFSUxJTkcuTUFUSCA9IGV4cG9ydHMuQ0VJTElORztcblxuXHRleHBvcnRzLkNFSUxJTkcuUFJFQ0lTRSA9IGV4cG9ydHMuQ0VJTElORztcblxuXHRleHBvcnRzLkNPTUJJTiA9IGZ1bmN0aW9uKG51bWJlciwgbnVtYmVyX2Nob3Nlbikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgbnVtYmVyX2Nob3NlbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcl9jaG9zZW4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgbnVtYmVyX2Nob3NlbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGV4cG9ydHMuRkFDVChudW1iZXIpIC8gKGV4cG9ydHMuRkFDVChudW1iZXJfY2hvc2VuKSAqIGV4cG9ydHMuRkFDVChudW1iZXIgLSBudW1iZXJfY2hvc2VuKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5DT01CSU5BID0gZnVuY3Rpb24obnVtYmVyLCBudW1iZXJfY2hvc2VuKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBudW1iZXJfY2hvc2VuID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyX2Nob3Nlbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBudW1iZXJfY2hvc2VuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKG51bWJlciA9PT0gMCAmJiBudW1iZXJfY2hvc2VuID09PSAwKSA/IDEgOiBleHBvcnRzLkNPTUJJTihudW1iZXIgKyBudW1iZXJfY2hvc2VuIC0gMSwgbnVtYmVyIC0gMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1MgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguY29zKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1NIID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiAoTWF0aC5leHAobnVtYmVyKSArIE1hdGguZXhwKC1udW1iZXIpKSAvIDI7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1QgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIDEgLyBNYXRoLnRhbihudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09USCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICB2YXIgZTIgPSBNYXRoLmV4cCgyICogbnVtYmVyKTtcblx0ICByZXR1cm4gKGUyICsgMSkgLyAoZTIgLSAxKTtcblx0fTtcblxuXHRleHBvcnRzLkNTQyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gMSAvIE1hdGguc2luKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5DU0NIID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiAyIC8gKE1hdGguZXhwKG51bWJlcikgLSBNYXRoLmV4cCgtbnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5ERUNJTUFMID0gZnVuY3Rpb24obnVtYmVyLCByYWRpeCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXG5cdCAgcmV0dXJuIHBhcnNlSW50KG51bWJlciwgcmFkaXgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuREVHUkVFUyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtYmVyICogMTgwIC8gTWF0aC5QSTtcblx0fTtcblxuXHRleHBvcnRzLkVWRU4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIGV4cG9ydHMuQ0VJTElORyhudW1iZXIsIC0yLCAtMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5FWFAgPSBNYXRoLmV4cDtcblxuXHR2YXIgTUVNT0laRURfRkFDVCA9IFtdO1xuXHRleHBvcnRzLkZBQ1QgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgdmFyIG4gPSBNYXRoLmZsb29yKG51bWJlcik7XG5cdCAgaWYgKG4gPT09IDAgfHwgbiA9PT0gMSkge1xuXHQgICAgcmV0dXJuIDE7XG5cdCAgfSBlbHNlIGlmIChNRU1PSVpFRF9GQUNUW25dID4gMCkge1xuXHQgICAgcmV0dXJuIE1FTU9JWkVEX0ZBQ1Rbbl07XG5cdCAgfSBlbHNlIHtcblx0ICAgIE1FTU9JWkVEX0ZBQ1Rbbl0gPSBleHBvcnRzLkZBQ1QobiAtIDEpICogbjtcblx0ICAgIHJldHVybiBNRU1PSVpFRF9GQUNUW25dO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkZBQ1RET1VCTEUgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgdmFyIG4gPSBNYXRoLmZsb29yKG51bWJlcik7XG5cdCAgaWYgKG4gPD0gMCkge1xuXHQgICAgcmV0dXJuIDE7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBuICogZXhwb3J0cy5GQUNURE9VQkxFKG4gLSAyKTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5GTE9PUiA9IGZ1bmN0aW9uKG51bWJlciwgc2lnbmlmaWNhbmNlKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBzaWduaWZpY2FuY2UgPSB1dGlscy5wYXJzZU51bWJlcihzaWduaWZpY2FuY2UpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgc2lnbmlmaWNhbmNlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoc2lnbmlmaWNhbmNlID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICBpZiAoIShudW1iZXIgPiAwICYmIHNpZ25pZmljYW5jZSA+IDApICYmICEobnVtYmVyIDwgMCAmJiBzaWduaWZpY2FuY2UgPCAwKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBzaWduaWZpY2FuY2UgPSBNYXRoLmFicyhzaWduaWZpY2FuY2UpO1xuXHQgIHZhciBwcmVjaXNpb24gPSAtTWF0aC5mbG9vcihNYXRoLmxvZyhzaWduaWZpY2FuY2UpIC8gTWF0aC5sb2coMTApKTtcblx0ICBpZiAobnVtYmVyID49IDApIHtcblx0ICAgIHJldHVybiBleHBvcnRzLlJPVU5EKE1hdGguZmxvb3IobnVtYmVyIC8gc2lnbmlmaWNhbmNlKSAqIHNpZ25pZmljYW5jZSwgcHJlY2lzaW9uKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIC1leHBvcnRzLlJPVU5EKE1hdGguY2VpbChNYXRoLmFicyhudW1iZXIpIC8gc2lnbmlmaWNhbmNlKSwgcHJlY2lzaW9uKTtcblx0ICB9XG5cdH07XG5cblx0Ly9UT0RPOiBWZXJpZnlcblx0ZXhwb3J0cy5GTE9PUi5NQVRIID0gZnVuY3Rpb24obnVtYmVyLCBzaWduaWZpY2FuY2UsIG1vZGUpIHtcblx0ICBzaWduaWZpY2FuY2UgPSAoc2lnbmlmaWNhbmNlID09PSB1bmRlZmluZWQpID8gMSA6IHNpZ25pZmljYW5jZTtcblx0ICBtb2RlID0gKG1vZGUgPT09IHVuZGVmaW5lZCkgPyAwIDogbW9kZTtcblxuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgc2lnbmlmaWNhbmNlID0gdXRpbHMucGFyc2VOdW1iZXIoc2lnbmlmaWNhbmNlKTtcblx0ICBtb2RlID0gdXRpbHMucGFyc2VOdW1iZXIobW9kZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBzaWduaWZpY2FuY2UsIG1vZGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChzaWduaWZpY2FuY2UgPT09IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIHNpZ25pZmljYW5jZSA9IHNpZ25pZmljYW5jZSA/IE1hdGguYWJzKHNpZ25pZmljYW5jZSkgOiAxO1xuXHQgIHZhciBwcmVjaXNpb24gPSAtTWF0aC5mbG9vcihNYXRoLmxvZyhzaWduaWZpY2FuY2UpIC8gTWF0aC5sb2coMTApKTtcblx0ICBpZiAobnVtYmVyID49IDApIHtcblx0ICAgIHJldHVybiBleHBvcnRzLlJPVU5EKE1hdGguZmxvb3IobnVtYmVyIC8gc2lnbmlmaWNhbmNlKSAqIHNpZ25pZmljYW5jZSwgcHJlY2lzaW9uKTtcblx0ICB9IGVsc2UgaWYgKG1vZGUgPT09IDAgfHwgbW9kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gLWV4cG9ydHMuUk9VTkQoTWF0aC5jZWlsKE1hdGguYWJzKG51bWJlcikgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlLCBwcmVjaXNpb24pO1xuXHQgIH1cblx0ICByZXR1cm4gLWV4cG9ydHMuUk9VTkQoTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpIC8gc2lnbmlmaWNhbmNlKSAqIHNpZ25pZmljYW5jZSwgcHJlY2lzaW9uKTtcblx0fTtcblxuXHQvLyBEZXByZWNhdGVkXG5cdGV4cG9ydHMuRkxPT1IuUFJFQ0lTRSA9IGV4cG9ydHMuRkxPT1IuTUFUSDtcblxuXHQvLyBhZGFwdGVkIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9HcmVhdGVzdF9jb21tb25fZGl2aXNvciNKYXZhU2NyaXB0XG5cdGV4cG9ydHMuR0NEID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciByMCA9IHJhbmdlWzBdO1xuXHQgIHZhciB4ID0gcjAgPCAwID8gLXIwIDogcjA7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0ICAgIHZhciByaSA9IHJhbmdlW2ldO1xuXHQgICAgdmFyIHkgPSByaSA8IDAgPyAtcmkgOiByaTtcblx0ICAgIHdoaWxlICh4ICYmIHkpIHtcblx0ICAgICAgaWYgKHggPiB5KSB7XG5cdCAgICAgICAgeCAlPSB5O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHkgJT0geDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgeCArPSB5O1xuXHQgIH1cblx0ICByZXR1cm4geDtcblx0fTtcblxuXG5cdGV4cG9ydHMuSU5UID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG5cdH07XG5cblx0Ly9UT0RPOiB2ZXJpZnlcblx0ZXhwb3J0cy5JU08gPSB7XG5cdCAgQ0VJTElORzogZXhwb3J0cy5DRUlMSU5HXG5cdH07XG5cblx0ZXhwb3J0cy5MQ00gPSBmdW5jdGlvbigpIHtcblx0ICAvLyBDcmVkaXRzOiBKb25hcyBSYW9uaSBTb2FyZXMgU2lsdmFcblx0ICB2YXIgbyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAobyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbztcblx0ICB9XG5cdCAgZm9yICh2YXIgaSwgaiwgbiwgZCwgciA9IDE7XG5cdCAgICAobiA9IG8ucG9wKCkpICE9PSB1bmRlZmluZWQ7KSB7XG5cdCAgICB3aGlsZSAobiA+IDEpIHtcblx0ICAgICAgaWYgKG4gJSAyKSB7XG5cdCAgICAgICAgZm9yIChpID0gMywgaiA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KG4pKTsgaSA8PSBqICYmIG4gJSBpOyBpICs9IDIpIHtcblx0ICAgICAgICAgIC8vZW1wdHlcblx0ICAgICAgICB9XG5cdCAgICAgICAgZCA9IChpIDw9IGopID8gaSA6IG47XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZCA9IDI7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yIChuIC89IGQsIHIgKj0gZCwgaSA9IG8ubGVuZ3RoOyBpO1xuXHQgICAgICAgIChvWy0taV0gJSBkKSA9PT0gMCAmJiAob1tpXSAvPSBkKSA9PT0gMSAmJiBvLnNwbGljZShpLCAxKSkge1xuXHQgICAgICAgIC8vZW1wdHlcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcjtcblx0fTtcblxuXHRleHBvcnRzLkxOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmxvZyhudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTE9HID0gZnVuY3Rpb24obnVtYmVyLCBiYXNlKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBiYXNlID0gdXRpbHMucGFyc2VOdW1iZXIoYmFzZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBiYXNlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBiYXNlID0gKGJhc2UgPT09IHVuZGVmaW5lZCkgPyAxMCA6IGJhc2U7XG5cdCAgcmV0dXJuIE1hdGgubG9nKG51bWJlcikgLyBNYXRoLmxvZyhiYXNlKTtcblx0fTtcblxuXHRleHBvcnRzLkxPRzEwID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmxvZyhudW1iZXIpIC8gTWF0aC5sb2coMTApO1xuXHR9O1xuXG5cdGV4cG9ydHMuTURFVEVSTSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHQgIG1hdHJpeCA9IHV0aWxzLnBhcnNlTWF0cml4KG1hdHJpeCk7XG5cdCAgaWYgKG1hdHJpeCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbWF0cml4O1xuXHQgIH1cblx0ICByZXR1cm4gbnVtZXJpYy5kZXQobWF0cml4KTtcblx0fTtcblxuXHRleHBvcnRzLk1JTlZFUlNFID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdCAgbWF0cml4ID0gdXRpbHMucGFyc2VNYXRyaXgobWF0cml4KTtcblx0ICBpZiAobWF0cml4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBtYXRyaXg7XG5cdCAgfVxuXHQgIHJldHVybiBudW1lcmljLmludihtYXRyaXgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTU1VTFQgPSBmdW5jdGlvbihtYXRyaXgxLCBtYXRyaXgyKSB7XG5cdCAgbWF0cml4MSA9IHV0aWxzLnBhcnNlTWF0cml4KG1hdHJpeDEpO1xuXHQgIG1hdHJpeDIgPSB1dGlscy5wYXJzZU1hdHJpeChtYXRyaXgyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihtYXRyaXgxLCBtYXRyaXgyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtZXJpYy5kb3QobWF0cml4MSwgbWF0cml4Mik7XG5cdH07XG5cblx0ZXhwb3J0cy5NT0QgPSBmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuXHQgIGRpdmlkZW5kID0gdXRpbHMucGFyc2VOdW1iZXIoZGl2aWRlbmQpO1xuXHQgIGRpdmlzb3IgPSB1dGlscy5wYXJzZU51bWJlcihkaXZpc29yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkaXZpZGVuZCwgZGl2aXNvcikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGRpdmlzb3IgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5kaXYwO1xuXHQgIH1cblx0ICB2YXIgbW9kdWx1cyA9IE1hdGguYWJzKGRpdmlkZW5kICUgZGl2aXNvcik7XG5cdCAgcmV0dXJuIChkaXZpc29yID4gMCkgPyBtb2R1bHVzIDogLW1vZHVsdXM7XG5cdH07XG5cblx0ICBleHBvcnRzLk1ST1VORCA9IGZ1bmN0aW9uKG51bWJlciwgbXVsdGlwbGUpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIG11bHRpcGxlID0gdXRpbHMucGFyc2VOdW1iZXIobXVsdGlwbGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgbXVsdGlwbGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChudW1iZXIgKiBtdWx0aXBsZSA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyIC8gbXVsdGlwbGUpICogbXVsdGlwbGU7XG5cdH07XG5cblx0ZXhwb3J0cy5NVUxUSU5PTUlBTCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChhcmdzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBhcmdzO1xuXHQgIH1cblx0ICB2YXIgc3VtID0gMDtcblx0ICB2YXIgZGl2aXNvciA9IDE7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBzdW0gKz0gYXJnc1tpXTtcblx0ICAgIGRpdmlzb3IgKj0gZXhwb3J0cy5GQUNUKGFyZ3NbaV0pO1xuXHQgIH1cblx0ICByZXR1cm4gZXhwb3J0cy5GQUNUKHN1bSkgLyBkaXZpc29yO1xuXHR9O1xuXG5cdGV4cG9ydHMuTVVOSVQgPSBmdW5jdGlvbihkaW1lbnNpb24pIHtcblx0ICBkaW1lbnNpb24gPSB1dGlscy5wYXJzZU51bWJlcihkaW1lbnNpb24pO1xuXHQgIGlmIChkaW1lbnNpb24gaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGRpbWVuc2lvbjtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyaWMuaWRlbnRpdHkoZGltZW5zaW9uKTtcblx0fTtcblxuXHRleHBvcnRzLk9ERCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICB2YXIgdGVtcCA9IE1hdGguY2VpbChNYXRoLmFicyhudW1iZXIpKTtcblx0ICB0ZW1wID0gKHRlbXAgJiAxKSA/IHRlbXAgOiB0ZW1wICsgMTtcblx0ICByZXR1cm4gKG51bWJlciA+IDApID8gdGVtcCA6IC10ZW1wO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEkgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gTWF0aC5QSTtcblx0fTtcblxuXHRleHBvcnRzLlBPV0VSID0gZnVuY3Rpb24obnVtYmVyLCBwb3dlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgcG93ZXIgPSB1dGlscy5wYXJzZU51bWJlcihwb3dlcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBwb3dlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IE1hdGgucG93KG51bWJlciwgcG93ZXIpO1xuXHQgIGlmIChpc05hTihyZXN1bHQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5QUk9EVUNUID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKGFyZ3MgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGFyZ3M7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAxO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICo9IGFyZ3NbaV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5RVU9USUVOVCA9IGZ1bmN0aW9uKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcblx0ICBudW1lcmF0b3IgPSB1dGlscy5wYXJzZU51bWJlcihudW1lcmF0b3IpO1xuXHQgIGRlbm9taW5hdG9yID0gdXRpbHMucGFyc2VOdW1iZXIoZGVub21pbmF0b3IpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWVyYXRvciwgZGVub21pbmF0b3IpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBwYXJzZUludChudW1lcmF0b3IgLyBkZW5vbWluYXRvciwgMTApO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkFESUFOUyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtYmVyICogTWF0aC5QSSAvIDE4MDtcblx0fTtcblxuXHRleHBvcnRzLlJBTkQgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gTWF0aC5yYW5kb20oKTtcblx0fTtcblxuXHRleHBvcnRzLlJBTkRCRVRXRUVOID0gZnVuY3Rpb24oYm90dG9tLCB0b3ApIHtcblx0ICBib3R0b20gPSB1dGlscy5wYXJzZU51bWJlcihib3R0b20pO1xuXHQgIHRvcCA9IHV0aWxzLnBhcnNlTnVtYmVyKHRvcCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYm90dG9tLCB0b3ApKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIC8vIENyZWF0aXZlIENvbW1vbnMgQXR0cmlidXRpb24gMy4wIExpY2Vuc2Vcblx0ICAvLyBDb3B5cmlnaHQgKGMpIDIwMTIgZXFjb2RlXG5cdCAgcmV0dXJuIGJvdHRvbSArIE1hdGguY2VpbCgodG9wIC0gYm90dG9tICsgMSkgKiBNYXRoLnJhbmRvbSgpKSAtIDE7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlJPTUFOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIC8vIFRoZSBNSVQgTGljZW5zZVxuXHQgIC8vIENvcHlyaWdodCAoYykgMjAwOCBTdGV2ZW4gTGV2aXRoYW5cblx0ICB2YXIgZGlnaXRzID0gU3RyaW5nKG51bWJlcikuc3BsaXQoJycpO1xuXHQgIHZhciBrZXkgPSBbJycsICdDJywgJ0NDJywgJ0NDQycsICdDRCcsICdEJywgJ0RDJywgJ0RDQycsICdEQ0NDJywgJ0NNJywgJycsICdYJywgJ1hYJywgJ1hYWCcsICdYTCcsICdMJywgJ0xYJywgJ0xYWCcsICdMWFhYJywgJ1hDJywgJycsICdJJywgJ0lJJywgJ0lJSScsICdJVicsICdWJywgJ1ZJJywgJ1ZJSScsICdWSUlJJywgJ0lYJ107XG5cdCAgdmFyIHJvbWFuID0gJyc7XG5cdCAgdmFyIGkgPSAzO1xuXHQgIHdoaWxlIChpLS0pIHtcblx0ICAgIHJvbWFuID0gKGtleVsrZGlnaXRzLnBvcCgpICsgKGkgKiAxMCldIHx8ICcnKSArIHJvbWFuO1xuXHQgIH1cblx0ICByZXR1cm4gbmV3IEFycmF5KCtkaWdpdHMuam9pbignJykgKyAxKS5qb2luKCdNJykgKyByb21hbjtcblx0fTtcblxuXHRleHBvcnRzLlJPVU5EID0gZnVuY3Rpb24obnVtYmVyLCBkaWdpdHMpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGRpZ2l0cyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpZ2l0cyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBkaWdpdHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBkaWdpdHMpKSAvIE1hdGgucG93KDEwLCBkaWdpdHMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUk9VTkRET1dOID0gZnVuY3Rpb24obnVtYmVyLCBkaWdpdHMpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGRpZ2l0cyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpZ2l0cyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBkaWdpdHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBzaWduID0gKG51bWJlciA+IDApID8gMSA6IC0xO1xuXHQgIHJldHVybiBzaWduICogKE1hdGguZmxvb3IoTWF0aC5hYnMobnVtYmVyKSAqIE1hdGgucG93KDEwLCBkaWdpdHMpKSkgLyBNYXRoLnBvdygxMCwgZGlnaXRzKTtcblx0fTtcblxuXHRleHBvcnRzLlJPVU5EVVAgPSBmdW5jdGlvbihudW1iZXIsIGRpZ2l0cykge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgZGlnaXRzID0gdXRpbHMucGFyc2VOdW1iZXIoZGlnaXRzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIGRpZ2l0cykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHNpZ24gPSAobnVtYmVyID4gMCkgPyAxIDogLTE7XG5cdCAgcmV0dXJuIHNpZ24gKiAoTWF0aC5jZWlsKE1hdGguYWJzKG51bWJlcikgKiBNYXRoLnBvdygxMCwgZGlnaXRzKSkpIC8gTWF0aC5wb3coMTAsIGRpZ2l0cyk7XG5cdH07XG5cblx0ZXhwb3J0cy5TRUMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIDEgLyBNYXRoLmNvcyhudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0VDSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gMiAvIChNYXRoLmV4cChudW1iZXIpICsgTWF0aC5leHAoLW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0VSSUVTU1VNID0gZnVuY3Rpb24oeCwgbiwgbSwgY29lZmZpY2llbnRzKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBtID0gdXRpbHMucGFyc2VOdW1iZXIobSk7XG5cdCAgY29lZmZpY2llbnRzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheShjb2VmZmljaWVudHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG4sIG0sIGNvZWZmaWNpZW50cykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IGNvZWZmaWNpZW50c1swXSAqIE1hdGgucG93KHgsIG4pO1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgY29lZmZpY2llbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gY29lZmZpY2llbnRzW2ldICogTWF0aC5wb3coeCwgbiArIGkgKiBtKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNJR04gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgIHJldHVybiAtMTtcblx0ICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiAxO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLlNJTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5zaW4obnVtYmVyKTtcblx0fTtcblxuXHQgIGV4cG9ydHMuU0lOSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgICAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICAgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gbnVtYmVyO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIChNYXRoLmV4cChudW1iZXIpIC0gTWF0aC5leHAoLW51bWJlcikpIC8gMjtcblx0ICB9O1xuXG5cdCAgZXhwb3J0cy5TUVJUID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgICAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgIHJldHVybiBudW1iZXI7XG5cdCAgICB9XG5cdCAgICBpZiAobnVtYmVyIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIE1hdGguc3FydChudW1iZXIpO1xuXHQgIH07XG5cblx0ICBleHBvcnRzLlNRUlRQSSA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgICAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICAgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gbnVtYmVyO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIE1hdGguc3FydChudW1iZXIgKiBNYXRoLlBJKTtcblx0ICB9O1xuXG5cdGV4cG9ydHMuU1VCVE9UQUwgPSBmdW5jdGlvbihmdW5jdGlvbl9jb2RlLCByZWYxKSB7XG5cdCAgZnVuY3Rpb25fY29kZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1bmN0aW9uX2NvZGUpO1xuXHQgIGlmIChmdW5jdGlvbl9jb2RlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbl9jb2RlO1xuXHQgIH1cblx0ICBzd2l0Y2ggKGZ1bmN0aW9uX2NvZGUpIHtcblx0ICAgIGNhc2UgMTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkFWRVJBR0UocmVmMSk7XG5cdCAgICBjYXNlIDI6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5DT1VOVChyZWYxKTtcblx0ICAgIGNhc2UgMzpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkNPVU5UQShyZWYxKTtcblx0ICAgIGNhc2UgNDpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLk1BWChyZWYxKTtcblx0ICAgIGNhc2UgNTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLk1JTihyZWYxKTtcblx0ICAgIGNhc2UgNjpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUFJPRFVDVChyZWYxKTtcblx0ICAgIGNhc2UgNzpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlNUREVWLlMocmVmMSk7XG5cdCAgICBjYXNlIDg6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TVERFVi5QKHJlZjEpO1xuXHQgICAgY2FzZSA5OlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5TVU0ocmVmMSk7XG5cdCAgICBjYXNlIDEwOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuVkFSLlMocmVmMSk7XG5cdCAgICBjYXNlIDExOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuVkFSLlAocmVmMSk7XG5cdCAgICAgIC8vIG5vIGhpZGRlbiB2YWx1ZXMgZm9yIHVzXG5cdCAgICBjYXNlIDEwMTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkFWRVJBR0UocmVmMSk7XG5cdCAgICBjYXNlIDEwMjpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkNPVU5UKHJlZjEpO1xuXHQgICAgY2FzZSAxMDM6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5DT1VOVEEocmVmMSk7XG5cdCAgICBjYXNlIDEwNDpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLk1BWChyZWYxKTtcblx0ICAgIGNhc2UgMTA1OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTUlOKHJlZjEpO1xuXHQgICAgY2FzZSAxMDY6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBST0RVQ1QocmVmMSk7XG5cdCAgICBjYXNlIDEwNzpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlNUREVWLlMocmVmMSk7XG5cdCAgICBjYXNlIDEwODpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlNUREVWLlAocmVmMSk7XG5cdCAgICBjYXNlIDEwOTpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuU1VNKHJlZjEpO1xuXHQgICAgY2FzZSAxMTA6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5WQVIuUyhyZWYxKTtcblx0ICAgIGNhc2UgMTExOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuVkFSLlAocmVmMSk7XG5cblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5BREQgPSBmdW5jdGlvbiAobnVtMSwgbnVtMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgbnVtMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTEpO1xuXHQgIG51bTIgPSB1dGlscy5wYXJzZU51bWJlcihudW0yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW0xLCBudW0yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBudW0xICsgbnVtMjtcblx0fTtcblxuXHRleHBvcnRzLk1JTlVTID0gZnVuY3Rpb24gKG51bTEsIG51bTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIG51bTEgPSB1dGlscy5wYXJzZU51bWJlcihudW0xKTtcblx0ICBudW0yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtMSwgbnVtMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtMSAtIG51bTI7XG5cdH07XG5cblx0ZXhwb3J0cy5ESVZJREUgPSBmdW5jdGlvbiAoZGl2aWRlbmQsIGRpdmlzb3IpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGRpdmlkZW5kID0gdXRpbHMucGFyc2VOdW1iZXIoZGl2aWRlbmQpO1xuXHQgIGRpdmlzb3IgPSB1dGlscy5wYXJzZU51bWJlcihkaXZpc29yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkaXZpZGVuZCwgZGl2aXNvcikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAoZGl2aXNvciA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLmRpdjA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcblx0fTtcblxuXHRleHBvcnRzLk1VTFRJUExZID0gZnVuY3Rpb24gKGZhY3RvcjEsIGZhY3RvcjIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGZhY3RvcjEgPSB1dGlscy5wYXJzZU51bWJlcihmYWN0b3IxKTtcblx0ICBmYWN0b3IyID0gdXRpbHMucGFyc2VOdW1iZXIoZmFjdG9yMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZmFjdG9yMSwgZmFjdG9yMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gZmFjdG9yMSAqIGZhY3RvcjI7XG5cdH07XG5cblx0ZXhwb3J0cy5HVEUgPSBmdW5jdGlvbiAobnVtMSwgbnVtMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgbnVtMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTEpO1xuXHQgIG51bTIgPSB1dGlscy5wYXJzZU51bWJlcihudW0yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW0xLCBudW0yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLmVycm9yO1xuXHQgIH1cblxuXHQgIHJldHVybiBudW0xID49IG51bTI7XG5cdH07XG5cblx0ZXhwb3J0cy5MVCA9IGZ1bmN0aW9uIChudW0xLCBudW0yKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBudW0xID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMSk7XG5cdCAgbnVtMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bTEsIG51bTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZXJyb3I7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bTEgPCBudW0yO1xuXHR9O1xuXG5cblx0ZXhwb3J0cy5MVEUgPSBmdW5jdGlvbiAobnVtMSwgbnVtMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgbnVtMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTEpO1xuXHQgIG51bTIgPSB1dGlscy5wYXJzZU51bWJlcihudW0yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW0xLCBudW0yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLmVycm9yO1xuXHQgIH1cblxuXHQgIHJldHVybiBudW0xIDw9IG51bTI7XG5cdH07XG5cblx0ZXhwb3J0cy5FUSA9IGZ1bmN0aW9uICh2YWx1ZTEsIHZhbHVlMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHZhbHVlMSA9PT0gdmFsdWUyO1xuXHR9O1xuXG5cdGV4cG9ydHMuTkUgPSBmdW5jdGlvbiAodmFsdWUxLCB2YWx1ZTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIHJldHVybiB2YWx1ZTEgIT09IHZhbHVlMjtcblx0fTtcblxuXHRleHBvcnRzLlBPVyA9IGZ1bmN0aW9uIChiYXNlLCBleHBvbmVudCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgYmFzZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGJhc2UpO1xuXHQgIGV4cG9uZW50ID0gdXRpbHMucGFyc2VOdW1iZXIoZXhwb25lbnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGJhc2UsIGV4cG9uZW50KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLmVycm9yO1xuXHQgIH1cblxuXHQgIHJldHVybiBleHBvcnRzLlBPV0VSKGJhc2UsIGV4cG9uZW50KTtcblx0fTtcblxuXHRleHBvcnRzLlNVTSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIHZhciBhcmdzS2V5cyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50cyk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzS2V5cy5sZW5ndGg7ICsraSkge1xuXHQgICAgdmFyIGVsdCA9IGFyZ3VtZW50c1thcmdzS2V5c1tpXV07XG5cdCAgICBpZiAodHlwZW9mIGVsdCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgcmVzdWx0ICs9IGVsdDtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsdCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlRmxvYXQoZWx0KTtcblx0ICAgICAgIWlzTmFOKHBhcnNlZCkgJiYgKHJlc3VsdCArPSBwYXJzZWQpO1xuXHQgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVsdCkpIHtcblx0ICAgICAgcmVzdWx0ICs9IGV4cG9ydHMuU1VNLmFwcGx5KG51bGwsIGVsdCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU1JRiA9IGZ1bmN0aW9uKHJhbmdlLCBjcml0ZXJpYSkge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IChldmFsKHJhbmdlW2ldICsgY3JpdGVyaWEpKSA/IHJhbmdlW2ldIDogMDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU1JRlMgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLmFyZ3NUb0FycmF5KGFyZ3VtZW50cyk7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3Muc2hpZnQoKSkpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBjcml0ZXJpYSA9IGFyZ3M7XG5cblx0ICB2YXIgbl9yYW5nZV9lbGVtZW50cyA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgbl9jcml0ZXJpYXMgPSBjcml0ZXJpYS5sZW5ndGg7XG5cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG5fcmFuZ2VfZWxlbWVudHM7IGkrKykge1xuXHQgICAgdmFyIGVsID0gcmFuZ2VbaV07XG5cdCAgICB2YXIgY29uZGl0aW9uID0gJyc7XG5cdCAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5fY3JpdGVyaWFzOyBjKyspIHtcblx0ICAgICAgY29uZGl0aW9uICs9IGVsICsgY3JpdGVyaWFbY107XG5cdCAgICAgIGlmIChjICE9PSBuX2NyaXRlcmlhcyAtIDEpIHtcblx0ICAgICAgICBjb25kaXRpb24gKz0gJyYmJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGV2YWwoY29uZGl0aW9uKSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgcmVzdWx0ICs9IGVsO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNUFJPRFVDVCA9IGZ1bmN0aW9uKCkge1xuXHQgIGlmICghYXJndW1lbnRzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIGFycmF5cyA9IGFyZ3VtZW50cy5sZW5ndGggKyAxO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIHZhciBwcm9kdWN0O1xuXHQgIHZhciBrO1xuXHQgIHZhciBfaTtcblx0ICB2YXIgX2lqO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzWzBdLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoIShhcmd1bWVudHNbMF1baV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgICAgcHJvZHVjdCA9IDE7XG5cdCAgICAgIGZvciAoayA9IDE7IGsgPCBhcnJheXM7IGsrKykge1xuXHQgICAgICAgIF9pID0gdXRpbHMucGFyc2VOdW1iZXIoYXJndW1lbnRzW2sgLSAxXVtpXSk7XG5cdCAgICAgICAgaWYgKF9pIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgIHJldHVybiBfaTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcHJvZHVjdCAqPSBfaTtcblx0ICAgICAgfVxuXHQgICAgICByZXN1bHQgKz0gcHJvZHVjdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJndW1lbnRzWzBdW2ldLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgcHJvZHVjdCA9IDE7XG5cdCAgICAgICAgZm9yIChrID0gMTsgayA8IGFycmF5czsgaysrKSB7XG5cdCAgICAgICAgICBfaWogPSB1dGlscy5wYXJzZU51bWJlcihhcmd1bWVudHNbayAtIDFdW2ldW2pdKTtcblx0ICAgICAgICAgIGlmIChfaWogaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICByZXR1cm4gX2lqO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcHJvZHVjdCAqPSBfaWo7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdCArPSBwcm9kdWN0O1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU1TUSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBudW1iZXJzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChudW1iZXJzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXJzO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICB2YXIgbGVuZ3RoID0gbnVtYmVycy5sZW5ndGg7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IChpbmZvcm1hdGlvbi5JU05VTUJFUihudW1iZXJzW2ldKSkgPyBudW1iZXJzW2ldICogbnVtYmVyc1tpXSA6IDA7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU1YMk1ZMiA9IGZ1bmN0aW9uKGFycmF5X3gsIGFycmF5X3kpIHtcblx0ICBhcnJheV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5X3gpKTtcblx0ICBhcnJheV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5X3kpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheV94LCBhcnJheV95KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5X3gubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSBhcnJheV94W2ldICogYXJyYXlfeFtpXSAtIGFycmF5X3lbaV0gKiBhcnJheV95W2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNWDJQWTIgPSBmdW5jdGlvbihhcnJheV94LCBhcnJheV95KSB7XG5cdCAgYXJyYXlfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV94KSk7XG5cdCAgYXJyYXlfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV95KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXlfeCwgYXJyYXlfeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgYXJyYXlfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV94KSk7XG5cdCAgYXJyYXlfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV95KSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheV94Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gYXJyYXlfeFtpXSAqIGFycmF5X3hbaV0gKyBhcnJheV95W2ldICogYXJyYXlfeVtpXTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNVTVhNWTIgPSBmdW5jdGlvbihhcnJheV94LCBhcnJheV95KSB7XG5cdCAgYXJyYXlfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV94KSk7XG5cdCAgYXJyYXlfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV95KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXlfeCwgYXJyYXlfeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgYXJyYXlfeCA9IHV0aWxzLmZsYXR0ZW4oYXJyYXlfeCk7XG5cdCAgYXJyYXlfeSA9IHV0aWxzLmZsYXR0ZW4oYXJyYXlfeSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheV94Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gTWF0aC5wb3coYXJyYXlfeFtpXSAtIGFycmF5X3lbaV0sIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuVEFOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLnRhbihudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVEFOSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICB2YXIgZTIgPSBNYXRoLmV4cCgyICogbnVtYmVyKTtcblx0ICByZXR1cm4gKGUyIC0gMSkgLyAoZTIgKyAxKTtcblx0fTtcblxuXHRleHBvcnRzLlRSVU5DID0gZnVuY3Rpb24obnVtYmVyLCBkaWdpdHMpIHtcblx0ICBkaWdpdHMgPSAoZGlnaXRzID09PSB1bmRlZmluZWQpID8gMCA6IGRpZ2l0cztcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGRpZ2l0cyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpZ2l0cyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBkaWdpdHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBzaWduID0gKG51bWJlciA+IDApID8gMSA6IC0xO1xuXHQgIHJldHVybiBzaWduICogKE1hdGguZmxvb3IoTWF0aC5hYnMobnVtYmVyKSAqIE1hdGgucG93KDEwLCBkaWdpdHMpKSkgLyBNYXRoLnBvdygxMCwgZGlnaXRzKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdGZ1bmN0aW9uIGZsYXR0ZW5TaGFsbG93KGFycmF5KSB7XG5cdCAgaWYgKCFhcnJheSB8fCAhYXJyYXkucmVkdWNlKSB7IHJldHVybiBhcnJheTsgfVxuXHQgIHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgdmFyIGFJc0FycmF5ID0gQXJyYXkuaXNBcnJheShhKTtcblx0ICAgIHZhciBiSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYik7XG5cdCAgICBpZiAoYUlzQXJyYXkgJiYgYklzQXJyYXkgKSB7XG5cdCAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcblx0ICAgIH1cblx0ICAgIGlmIChhSXNBcnJheSkge1xuXHQgICAgICBhLnB1c2goYik7XG5cdCAgICAgIHJldHVybiBhO1xuXHQgICAgfVxuXHQgICAgaWYgKGJJc0FycmF5KSB7XG5cdCAgICAgIHJldHVybiBbYV0uY29uY2F0KGIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFthLCBiXTtcblx0ICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRmxhdChhcnJheSkge1xuXHQgIGlmICghYXJyYXkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV0pKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cblxuXHRleHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmVzdWx0ID0gZXhwb3J0cy5hcmdzVG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHQgIHdoaWxlICghaXNGbGF0KHJlc3VsdCkpIHtcblx0ICAgIHJlc3VsdCA9IGZsYXR0ZW5TaGFsbG93KHJlc3VsdCk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5hcmdzVG9BcnJheSA9IGZ1bmN0aW9uKGFyZ3MpIHtcblx0ICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMCk7XG5cdH07XG5cblx0ZXhwb3J0cy5udW1iZXJzID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHBvc3NpYmxlTnVtYmVycyA9IHRoaXMuZmxhdHRlbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHQgIHJldHVybiBwb3NzaWJsZU51bWJlcnMuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG5cdCAgICByZXR1cm4gdHlwZW9mIGVsID09PSAnbnVtYmVyJztcblx0ICB9KTtcblx0fTtcblxuXHRleHBvcnRzLmNsZWFuRmxvYXQgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICB2YXIgcG93ZXIgPSAxZTE0O1xuXHQgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIHBvd2VyKSAvIHBvd2VyO1xuXHR9O1xuXG5cdGV4cG9ydHMucGFyc2VCb29sID0gZnVuY3Rpb24oYm9vbCkge1xuXHQgIGlmICh0eXBlb2YgYm9vbCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdCAgICByZXR1cm4gYm9vbDtcblx0ICB9XG5cblx0ICBpZiAoYm9vbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gYm9vbDtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIGJvb2wgPT09ICdudW1iZXInKSB7XG5cdCAgICByZXR1cm4gYm9vbCAhPT0gMDtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIGJvb2wgPT09ICdzdHJpbmcnKSB7XG5cdCAgICB2YXIgdXAgPSBib29sLnRvVXBwZXJDYXNlKCk7XG5cdCAgICBpZiAodXAgPT09ICdUUlVFJykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHVwID09PSAnRkFMU0UnKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoYm9vbCBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKGJvb2wpKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5wYXJzZU51bWJlciA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHQgIGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZCB8fCBzdHJpbmcgPT09ICcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmICghaXNOYU4oc3RyaW5nKSkge1xuXHQgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyaW5nKTtcblx0ICB9XG5cdCAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMucGFyc2VOdW1iZXJBcnJheSA9IGZ1bmN0aW9uKGFycikge1xuXHQgIHZhciBsZW47XG5cdCAgaWYgKCFhcnIgfHwgKGxlbiA9IGFyci5sZW5ndGgpID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBwYXJzZWQ7XG5cdCAgd2hpbGUgKGxlbi0tKSB7XG5cdCAgICBwYXJzZWQgPSBleHBvcnRzLnBhcnNlTnVtYmVyKGFycltsZW5dKTtcblx0ICAgIGlmIChwYXJzZWQgPT09IGVycm9yLnZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBwYXJzZWQ7XG5cdCAgICB9XG5cdCAgICBhcnJbbGVuXSA9IHBhcnNlZDtcblx0ICB9XG5cdCAgcmV0dXJuIGFycjtcblx0fTtcblxuXHRleHBvcnRzLnBhcnNlTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdCAgdmFyIG47XG5cdCAgaWYgKCFtYXRyaXggfHwgKG4gPSBtYXRyaXgubGVuZ3RoKSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcG5hcnI7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRyaXgubGVuZ3RoOyBpKyspIHtcblx0ICAgIHBuYXJyID0gZXhwb3J0cy5wYXJzZU51bWJlckFycmF5KG1hdHJpeFtpXSk7XG5cdCAgICBtYXRyaXhbaV0gPSBwbmFycjtcblx0ICAgIGlmIChwbmFyciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgIHJldHVybiBwbmFycjtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG1hdHJpeDtcblx0fTtcblxuXHR2YXIgZDE5MDAgPSBuZXcgRGF0ZSgxOTAwLCAwLCAxKTtcblx0ZXhwb3J0cy5wYXJzZURhdGUgPSBmdW5jdGlvbihkYXRlKSB7XG5cdCAgaWYgKCFpc05hTihkYXRlKSkge1xuXHQgICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdCAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcblx0ICAgIH1cblx0ICAgIHZhciBkID0gcGFyc2VJbnQoZGF0ZSwgMTApO1xuXHQgICAgaWYgKGQgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cdCAgICBpZiAoZCA8PSA2MCkge1xuXHQgICAgICByZXR1cm4gbmV3IERhdGUoZDE5MDAuZ2V0VGltZSgpICsgKGQgLSAxKSAqIDg2NDAwMDAwKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgRGF0ZShkMTkwMC5nZXRUaW1lKCkgKyAoZCAtIDIpICogODY0MDAwMDApO1xuXHQgIH1cblx0ICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG5cdCAgICBpZiAoIWlzTmFOKGRhdGUpKSB7XG5cdCAgICAgIHJldHVybiBkYXRlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5wYXJzZURhdGVBcnJheSA9IGZ1bmN0aW9uKGFycikge1xuXHQgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXHQgIHZhciBwYXJzZWQ7XG5cdCAgd2hpbGUgKGxlbi0tKSB7XG5cdCAgICBwYXJzZWQgPSB0aGlzLnBhcnNlRGF0ZShhcnJbbGVuXSk7XG5cdCAgICBpZiAocGFyc2VkID09PSBlcnJvci52YWx1ZSkge1xuXHQgICAgICByZXR1cm4gcGFyc2VkO1xuXHQgICAgfVxuXHQgICAgYXJyW2xlbl0gPSBwYXJzZWQ7XG5cdCAgfVxuXHQgIHJldHVybiBhcnI7XG5cdH07XG5cblx0ZXhwb3J0cy5hbnlJc0Vycm9yID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgIHdoaWxlIChuLS0pIHtcblx0ICAgIGlmIChhcmd1bWVudHNbbl0gaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdGV4cG9ydHMuYXJyYXlWYWx1ZXNUb051bWJlcnMgPSBmdW5jdGlvbihhcnIpIHtcblx0ICB2YXIgbiA9IGFyci5sZW5ndGg7XG5cdCAgdmFyIGVsO1xuXHQgIHdoaWxlIChuLS0pIHtcblx0ICAgIGVsID0gYXJyW25dO1xuXHQgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cdCAgICBpZiAoZWwgPT09IHRydWUpIHtcblx0ICAgICAgYXJyW25dID0gMTtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cdCAgICBpZiAoZWwgPT09IGZhbHNlKSB7XG5cdCAgICAgIGFycltuXSA9IDA7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgdmFyIG51bWJlciA9IHRoaXMucGFyc2VOdW1iZXIoZWwpO1xuXHQgICAgICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICBhcnJbbl0gPSAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGFycltuXSA9IG51bWJlcjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gYXJyO1xuXHR9O1xuXG5cdGV4cG9ydHMucmVzdCA9IGZ1bmN0aW9uKGFycmF5LCBpZHgpIHtcblx0ICBpZHggPSBpZHggfHwgMTtcblx0ICBpZiAoIWFycmF5IHx8IHR5cGVvZiBhcnJheS5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIGFycmF5O1xuXHQgIH1cblx0ICByZXR1cm4gYXJyYXkuc2xpY2UoaWR4KTtcblx0fTtcblxuXHRleHBvcnRzLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgaWR4KSB7XG5cdCAgaWR4ID0gaWR4IHx8IDE7XG5cdCAgaWYgKCFhcnJheSB8fCB0eXBlb2YgYXJyYXkuc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHJldHVybiBhcnJheTtcblx0ICB9XG5cdCAgcmV0dXJuIGFycmF5LnNsaWNlKDAsIGFycmF5Lmxlbmd0aCAtIGlkeCk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLm5pbCA9IG5ldyBFcnJvcignI05VTEwhJyk7XG5cdGV4cG9ydHMuZGl2MCA9IG5ldyBFcnJvcignI0RJVi8wIScpO1xuXHRleHBvcnRzLnZhbHVlID0gbmV3IEVycm9yKCcjVkFMVUU/Jyk7XG5cdGV4cG9ydHMucmVmID0gbmV3IEVycm9yKCcjUkVGIScpO1xuXHRleHBvcnRzLm5hbWUgPSBuZXcgRXJyb3IoJyNOQU1FPycpO1xuXHRleHBvcnRzLm51bSA9IG5ldyBFcnJvcignI05VTSEnKTtcblx0ZXhwb3J0cy5uYSA9IG5ldyBFcnJvcignI04vQScpO1xuXHRleHBvcnRzLmVycm9yID0gbmV3IEVycm9yKCcjRVJST1IhJyk7XG5cdGV4cG9ydHMuZGF0YSA9IG5ldyBFcnJvcignI0dFVFRJTkdfREFUQScpO1xuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgbWF0aFRyaWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdHZhciBqU3RhdCA9IF9fd2VicGFja19yZXF1aXJlX18oOSkualN0YXQ7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBtaXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cblx0dmFyIFNRUlQyUEkgPSAyLjUwNjYyODI3NDYzMTAwMDI7XG5cblx0ZXhwb3J0cy5BVkVERVYgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LnN1bShqU3RhdChyYW5nZSkuc3VidHJhY3QoalN0YXQubWVhbihyYW5nZSkpLmFicygpWzBdKSAvIHJhbmdlLmxlbmd0aDtcblx0fTtcblxuXHRleHBvcnRzLkFWRVJBR0UgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5udW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHN1bSA9IDA7XG5cdCAgdmFyIGNvdW50ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgc3VtICs9IHJhbmdlW2ldO1xuXHQgICAgY291bnQgKz0gMTtcblx0ICB9XG5cdCAgcmV0dXJuIHN1bSAvIGNvdW50O1xuXHR9O1xuXG5cdGV4cG9ydHMuQVZFUkFHRUEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHN1bSA9IDA7XG5cdCAgdmFyIGNvdW50ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgdmFyIGVsID0gcmFuZ2VbaV07XG5cdCAgICBpZiAodHlwZW9mIGVsID09PSAnbnVtYmVyJykge1xuXHQgICAgICBzdW0gKz0gZWw7XG5cdCAgICB9XG5cdCAgICBpZiAoZWwgPT09IHRydWUpIHtcblx0ICAgICAgc3VtKys7XG5cdCAgICB9XG5cdCAgICBpZiAoZWwgIT09IG51bGwpIHtcblx0ICAgICAgY291bnQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHN1bSAvIGNvdW50O1xuXHR9O1xuXG5cdGV4cG9ydHMuQVZFUkFHRUlGID0gZnVuY3Rpb24ocmFuZ2UsIGNyaXRlcmlhLCBhdmVyYWdlX3JhbmdlKSB7XG5cdCAgYXZlcmFnZV9yYW5nZSA9IGF2ZXJhZ2VfcmFuZ2UgfHwgcmFuZ2U7XG5cdCAgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKHJhbmdlKTtcblx0ICBhdmVyYWdlX3JhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGF2ZXJhZ2VfcmFuZ2UpKTtcblx0ICBpZiAoYXZlcmFnZV9yYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gYXZlcmFnZV9yYW5nZTtcblx0ICB9XG5cdCAgdmFyIGF2ZXJhZ2VfY291bnQgPSAwO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2UubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChldmFsKHJhbmdlW2ldICsgY3JpdGVyaWEpKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICByZXN1bHQgKz0gYXZlcmFnZV9yYW5nZVtpXTtcblx0ICAgICAgYXZlcmFnZV9jb3VudCsrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0IC8gYXZlcmFnZV9jb3VudDtcblx0fTtcblxuXHRleHBvcnRzLkFWRVJBR0VJRlMgPSBmdW5jdGlvbigpIHtcblx0ICAvLyBEb2VzIG5vdCB3b3JrIHdpdGggbXVsdGkgZGltZW5zaW9uYWwgcmFuZ2VzIHlldCFcblx0ICAvL2h0dHA6Ly9vZmZpY2UubWljcm9zb2Z0LmNvbS9lbi0wMDEvZXhjZWwtaGVscC9hdmVyYWdlaWZzLWZ1bmN0aW9uLUhBMDEwMDQ3NDkzLmFzcHhcblx0ICB2YXIgYXJncyA9IHV0aWxzLmFyZ3NUb0FycmF5KGFyZ3VtZW50cyk7XG5cdCAgdmFyIGNyaXRlcmlhID0gKGFyZ3MubGVuZ3RoIC0gMSkgLyAyO1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmZsYXR0ZW4oYXJnc1swXSk7XG5cdCAgdmFyIGNvdW50ID0gMDtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgY29uZGl0aW9uID0gJyc7XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNyaXRlcmlhOyBqKyspIHtcblx0ICAgICAgY29uZGl0aW9uICs9IGFyZ3NbMiAqIGogKyAxXVtpXSArIGFyZ3NbMiAqIGogKyAyXTtcblx0ICAgICAgaWYgKGogIT09IGNyaXRlcmlhIC0gMSkge1xuXHQgICAgICAgIGNvbmRpdGlvbiArPSAnJiYnO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoZXZhbChjb25kaXRpb24pKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICByZXN1bHQgKz0gcmFuZ2VbaV07XG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGF2ZXJhZ2UgPSByZXN1bHQgLyBjb3VudDtcblx0ICBpZiAoaXNOYU4oYXZlcmFnZSkpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gYXZlcmFnZTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5CRVRBID0ge307XG5cblx0ZXhwb3J0cy5CRVRBLkRJU1QgPSBmdW5jdGlvbih4LCBhbHBoYSwgYmV0YSwgY3VtdWxhdGl2ZSwgQSwgQikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIEEgPSAoQSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBBO1xuXHQgIEIgPSAoQiA9PT0gdW5kZWZpbmVkKSA/IDEgOiBCO1xuXG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGFscGhhID0gdXRpbHMucGFyc2VOdW1iZXIoYWxwaGEpO1xuXHQgIGJldGEgPSB1dGlscy5wYXJzZU51bWJlcihiZXRhKTtcblx0ICBBID0gdXRpbHMucGFyc2VOdW1iZXIoQSk7XG5cdCAgQiA9IHV0aWxzLnBhcnNlTnVtYmVyKEIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIGFscGhhLCBiZXRhLCBBLCBCKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHggPSAoeCAtIEEpIC8gKEIgLSBBKTtcblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQuYmV0YS5jZGYoeCwgYWxwaGEsIGJldGEpIDogalN0YXQuYmV0YS5wZGYoeCwgYWxwaGEsIGJldGEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQkVUQS5JTlYgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgYWxwaGEsIGJldGEsIEEsIEIpIHtcblx0ICBBID0gKEEgPT09IHVuZGVmaW5lZCkgPyAwIDogQTtcblx0ICBCID0gKEIgPT09IHVuZGVmaW5lZCkgPyAxIDogQjtcblxuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGFscGhhID0gdXRpbHMucGFyc2VOdW1iZXIoYWxwaGEpO1xuXHQgIGJldGEgPSB1dGlscy5wYXJzZU51bWJlcihiZXRhKTtcblx0ICBBID0gdXRpbHMucGFyc2VOdW1iZXIoQSk7XG5cdCAgQiA9IHV0aWxzLnBhcnNlTnVtYmVyKEIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByb2JhYmlsaXR5LCBhbHBoYSwgYmV0YSwgQSwgQikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuYmV0YS5pbnYocHJvYmFiaWxpdHksIGFscGhhLCBiZXRhKSAqIChCIC0gQSkgKyBBO1xuXHR9O1xuXG5cdGV4cG9ydHMuQklOT00gPSB7fTtcblxuXHRleHBvcnRzLkJJTk9NLkRJU1QgPSBmdW5jdGlvbihzdWNjZXNzZXMsIHRyaWFscywgcHJvYmFiaWxpdHksIGN1bXVsYXRpdmUpIHtcblx0ICBzdWNjZXNzZXMgPSB1dGlscy5wYXJzZU51bWJlcihzdWNjZXNzZXMpO1xuXHQgIHRyaWFscyA9IHV0aWxzLnBhcnNlTnVtYmVyKHRyaWFscyk7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgY3VtdWxhdGl2ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGN1bXVsYXRpdmUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHN1Y2Nlc3NlcywgdHJpYWxzLCBwcm9iYWJpbGl0eSwgY3VtdWxhdGl2ZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LmJpbm9taWFsLmNkZihzdWNjZXNzZXMsIHRyaWFscywgcHJvYmFiaWxpdHkpIDogalN0YXQuYmlub21pYWwucGRmKHN1Y2Nlc3NlcywgdHJpYWxzLCBwcm9iYWJpbGl0eSk7XG5cdH07XG5cblx0ZXhwb3J0cy5CSU5PTS5ESVNULlJBTkdFID0gZnVuY3Rpb24odHJpYWxzLCBwcm9iYWJpbGl0eSwgc3VjY2Vzc2VzLCBzdWNjZXNzZXMyKSB7XG5cdCAgc3VjY2Vzc2VzMiA9IChzdWNjZXNzZXMyID09PSB1bmRlZmluZWQpID8gc3VjY2Vzc2VzIDogc3VjY2Vzc2VzMjtcblxuXHQgIHRyaWFscyA9IHV0aWxzLnBhcnNlTnVtYmVyKHRyaWFscyk7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgc3VjY2Vzc2VzID0gdXRpbHMucGFyc2VOdW1iZXIoc3VjY2Vzc2VzKTtcblx0ICBzdWNjZXNzZXMyID0gdXRpbHMucGFyc2VOdW1iZXIoc3VjY2Vzc2VzMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IodHJpYWxzLCBwcm9iYWJpbGl0eSwgc3VjY2Vzc2VzLCBzdWNjZXNzZXMyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSBzdWNjZXNzZXM7IGkgPD0gc3VjY2Vzc2VzMjsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gbWF0aFRyaWcuQ09NQklOKHRyaWFscywgaSkgKiBNYXRoLnBvdyhwcm9iYWJpbGl0eSwgaSkgKiBNYXRoLnBvdygxIC0gcHJvYmFiaWxpdHksIHRyaWFscyAtIGkpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuQklOT00uSU5WID0gZnVuY3Rpb24odHJpYWxzLCBwcm9iYWJpbGl0eSwgYWxwaGEpIHtcblx0ICB0cmlhbHMgPSB1dGlscy5wYXJzZU51bWJlcih0cmlhbHMpO1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGFscGhhID0gdXRpbHMucGFyc2VOdW1iZXIoYWxwaGEpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHRyaWFscywgcHJvYmFiaWxpdHksIGFscGhhKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHZhciB4ID0gMDtcblx0ICB3aGlsZSAoeCA8PSB0cmlhbHMpIHtcblx0ICAgIGlmIChqU3RhdC5iaW5vbWlhbC5jZGYoeCwgdHJpYWxzLCBwcm9iYWJpbGl0eSkgPj0gYWxwaGEpIHtcblx0ICAgICAgcmV0dXJuIHg7XG5cdCAgICB9XG5cdCAgICB4Kys7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQ0hJU1EgPSB7fTtcblxuXHRleHBvcnRzLkNISVNRLkRJU1QgPSBmdW5jdGlvbih4LCBrLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGsgPSB1dGlscy5wYXJzZU51bWJlcihrKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBrKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5jaGlzcXVhcmUuY2RmKHgsIGspIDogalN0YXQuY2hpc3F1YXJlLnBkZih4LCBrKTtcblx0fTtcblxuXHRleHBvcnRzLkNISVNRLkRJU1QuUlQgPSBmdW5jdGlvbih4LCBrKSB7XG5cdCAgaWYgKCF4IHwgIWspIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoeCA8IDEgfHwgayA+IE1hdGgucG93KDEwLCAxMCkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgayAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIDEgLSAgalN0YXQuY2hpc3F1YXJlLmNkZih4LCBrKTtcblx0fTtcblxuXHRleHBvcnRzLkNISVNRLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBrKSB7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByb2JhYmlsaXR5LCBrKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQuY2hpc3F1YXJlLmludihwcm9iYWJpbGl0eSwgayk7XG5cdH07XG5cblx0ZXhwb3J0cy5DSElTUS5JTlYuUlQgPSBmdW5jdGlvbihwLCBrKSB7XG5cdCAgaWYgKCFwIHwgIWspIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAocCA8IDAgfHwgcCA+IDEgfHwgayA8IDEgfHwgayA+IE1hdGgucG93KDEwLCAxMCkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgcCAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgayAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmNoaXNxdWFyZS5pbnYoMS4wIC0gcCwgayk7XG5cdH07XG5cblx0ZXhwb3J0cy5DSElTUS5URVNUID0gZnVuY3Rpb24ob2JzZXJ2ZWQsIGV4cGVjdGVkKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoKCEob2JzZXJ2ZWQgaW5zdGFuY2VvZiBBcnJheSkpIHx8ICghKGV4cGVjdGVkIGluc3RhbmNlb2YgQXJyYXkpKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChvYnNlcnZlZC5sZW5ndGggIT09IGV4cGVjdGVkLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChvYnNlcnZlZFswXSAmJiBleHBlY3RlZFswXSAmJlxuXHQgICAgICBvYnNlcnZlZFswXS5sZW5ndGggIT09IGV4cGVjdGVkWzBdLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHZhciByb3cgPSBvYnNlcnZlZC5sZW5ndGg7XG5cdCAgdmFyIHRtcCwgaSwgajtcblxuXHQgIC8vIENvbnZlcnQgc2luZ2xlLWRpbWVuc2lvbiBhcnJheSBpbnRvIHR3by1kaW1lbnNpb24gYXJyYXlcblx0ICBmb3IgKGkgPSAwOyBpIDwgcm93OyBpICsrKSB7XG5cdCAgICBpZiAoIShvYnNlcnZlZFtpXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgICB0bXAgPSBvYnNlcnZlZFtpXTtcblx0ICAgICAgb2JzZXJ2ZWRbaV0gPSBbXTtcblx0ICAgICAgb2JzZXJ2ZWRbaV0ucHVzaCh0bXApO1xuXHQgICAgfVxuXHQgICAgaWYgKCEoZXhwZWN0ZWRbaV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgICAgdG1wID0gZXhwZWN0ZWRbaV07XG5cdCAgICAgIGV4cGVjdGVkW2ldID0gW107XG5cdCAgICAgIGV4cGVjdGVkW2ldLnB1c2godG1wKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgY29sID0gb2JzZXJ2ZWRbMF0ubGVuZ3RoO1xuXHQgIHZhciBkb2YgPSAoY29sID09PSAxKSA/IHJvdy0xIDogKHJvdy0xKSooY29sLTEpO1xuXHQgIHZhciB4c3FyID0gMDtcblx0ICB2YXIgUGkgPU1hdGguUEk7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgcm93OyBpICsrKSB7XG5cdCAgICBmb3IgKGogPSAwOyBqIDwgY29sOyBqICsrKSB7XG5cdCAgICAgIHhzcXIgKz0gTWF0aC5wb3coKG9ic2VydmVkW2ldW2pdIC0gZXhwZWN0ZWRbaV1bal0pLCAyKSAvIGV4cGVjdGVkW2ldW2pdO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIEdldCBpbmRlcGVuZGVuY3kgYnkgWCBzcXVhcmUgYW5kIGl0cyBkZWdyZWUgb2YgZnJlZWRvbVxuXHQgIGZ1bmN0aW9uIENoaVNxKHhzcXIsIGRvZikge1xuXHQgICAgdmFyIHAgPSBNYXRoLmV4cCgtMC41ICogeHNxcik7XG5cdCAgICBpZigoZG9mJTIpID09PSAxKSB7XG5cdCAgICAgIHAgPSBwICogTWF0aC5zcXJ0KDIgKiB4c3FyL1BpKTtcblx0ICAgIH1cblx0ICAgIHZhciBrID0gZG9mO1xuXHQgICAgd2hpbGUoayA+PSAyKSB7XG5cdCAgICAgIHAgPSBwICogeHNxci9rO1xuXHQgICAgICBrID0gayAtIDI7XG5cdCAgICB9XG5cdCAgICB2YXIgdCA9IHA7XG5cdCAgICB2YXIgYSA9IGRvZjtcblx0ICAgIHdoaWxlICh0ID4gMC4wMDAwMDAwMDAxKnApIHtcblx0ICAgICAgYSA9IGEgKyAyO1xuXHQgICAgICB0ID0gdCAqIHhzcXIvYTtcblx0ICAgICAgcCA9IHAgKyB0O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIDEtcDtcblx0ICB9XG5cblx0ICByZXR1cm4gTWF0aC5yb3VuZChDaGlTcSh4c3FyLCBkb2YpICogMTAwMDAwMCkgLyAxMDAwMDAwO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09MVU1OID0gZnVuY3Rpb24obWF0cml4LCBpbmRleCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoIShtYXRyaXggaW5zdGFuY2VvZiBBcnJheSkgfHwgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKG1hdHJpeC5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmNvbChtYXRyaXgsIGluZGV4KTtcblx0fTtcblxuXHRleHBvcnRzLkNPTFVNTlMgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICghKG1hdHJpeCBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChtYXRyaXgubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuY29scyhtYXRyaXgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09ORklERU5DRSA9IHt9O1xuXG5cdGV4cG9ydHMuQ09ORklERU5DRS5OT1JNID0gZnVuY3Rpb24oYWxwaGEsIHNkLCBuKSB7XG5cdCAgYWxwaGEgPSB1dGlscy5wYXJzZU51bWJlcihhbHBoYSk7XG5cdCAgc2QgPSB1dGlscy5wYXJzZU51bWJlcihzZCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFscGhhLCBzZCwgbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0Lm5vcm1hbGNpKDEsIGFscGhhLCBzZCwgbilbMV0gLSAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09ORklERU5DRS5UID0gZnVuY3Rpb24oYWxwaGEsIHNkLCBuKSB7XG5cdCAgYWxwaGEgPSB1dGlscy5wYXJzZU51bWJlcihhbHBoYSk7XG5cdCAgc2QgPSB1dGlscy5wYXJzZU51bWJlcihzZCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFscGhhLCBzZCwgbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LnRjaSgxLCBhbHBoYSwgc2QsIG4pWzFdIC0gMTtcblx0fTtcblxuXHRleHBvcnRzLkNPUlJFTCA9IGZ1bmN0aW9uKGFycmF5MSwgYXJyYXkyKSB7XG5cdCAgYXJyYXkxID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5MSkpO1xuXHQgIGFycmF5MiA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheTIpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheTEsIGFycmF5MikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LmNvcnJjb2VmZihhcnJheTEsIGFycmF5Mik7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1VOVCA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiB1dGlscy5udW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSkubGVuZ3RoO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09VTlRBID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHJldHVybiByYW5nZS5sZW5ndGggLSBleHBvcnRzLkNPVU5UQkxBTksocmFuZ2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09VTlRJTiA9IGZ1bmN0aW9uIChyYW5nZSwgdmFsdWUpIHtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAocmFuZ2VbaV0gPT09IHZhbHVlKSB7XG5cdCAgICAgIHJlc3VsdCsrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cblx0ZXhwb3J0cy5DT1VOVEJMQU5LID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciBibGFua3MgPSAwO1xuXHQgIHZhciBlbGVtZW50O1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2UubGVuZ3RoOyBpKyspIHtcblx0ICAgIGVsZW1lbnQgPSByYW5nZVtpXTtcblx0ICAgIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09ICcnKSB7XG5cdCAgICAgIGJsYW5rcysrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gYmxhbmtzO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09VTlRJRiA9IGZ1bmN0aW9uKHJhbmdlLCBjcml0ZXJpYSkge1xuXHQgIHJhbmdlID0gdXRpbHMuZmxhdHRlbihyYW5nZSk7XG5cdCAgaWYgKCEvWzw+PSFdLy50ZXN0KGNyaXRlcmlhKSkge1xuXHQgICAgY3JpdGVyaWEgPSAnPT1cIicgKyBjcml0ZXJpYSArICdcIic7XG5cdCAgfVxuXHQgIHZhciBtYXRjaGVzID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAodHlwZW9mIHJhbmdlW2ldICE9PSAnc3RyaW5nJykge1xuXHQgICAgICBpZiAoZXZhbChyYW5nZVtpXSArIGNyaXRlcmlhKSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgICBtYXRjaGVzKys7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChldmFsKCdcIicgKyByYW5nZVtpXSArICdcIicgKyBjcml0ZXJpYSkpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgICAgbWF0Y2hlcysrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBtYXRjaGVzO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09VTlRJRlMgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLmFyZ3NUb0FycmF5KGFyZ3VtZW50cyk7XG5cdCAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkodXRpbHMuZmxhdHRlbihhcmdzWzBdKS5sZW5ndGgpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0c1tpXSA9IHRydWU7XG5cdCAgfVxuXHQgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICB2YXIgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKGFyZ3NbaV0pO1xuXHQgICAgdmFyIGNyaXRlcmlhID0gYXJnc1tpICsgMV07XG5cdCAgICBpZiAoIS9bPD49IV0vLnRlc3QoY3JpdGVyaWEpKSB7XG5cdCAgICAgIGNyaXRlcmlhID0gJz09XCInICsgY3JpdGVyaWEgKyAnXCInO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCByYW5nZS5sZW5ndGg7IGorKykge1xuXHQgICAgICBpZiAodHlwZW9mIHJhbmdlW2pdICE9PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHJlc3VsdHNbal0gPSByZXN1bHRzW2pdICYmIGV2YWwocmFuZ2Vbal0gKyBjcml0ZXJpYSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlc3VsdHNbal0gPSByZXN1bHRzW2pdICYmIGV2YWwoJ1wiJyArIHJhbmdlW2pdICsgJ1wiJyArIGNyaXRlcmlhKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yIChpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChyZXN1bHRzW2ldKSB7XG5cdCAgICAgIHJlc3VsdCsrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09VTlRVTklRVUUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIG1pc2MuVU5JUVVFLmFwcGx5KG51bGwsIHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSkubGVuZ3RoO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09WQVJJQU5DRSA9IHt9O1xuXG5cdGV4cG9ydHMuQ09WQVJJQU5DRS5QID0gZnVuY3Rpb24oYXJyYXkxLCBhcnJheTIpIHtcblx0ICBhcnJheTEgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkxKSk7XG5cdCAgYXJyYXkyID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5MikpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5MSwgYXJyYXkyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgbWVhbjEgPSBqU3RhdC5tZWFuKGFycmF5MSk7XG5cdCAgdmFyIG1lYW4yID0galN0YXQubWVhbihhcnJheTIpO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIHZhciBuID0gYXJyYXkxLmxlbmd0aDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IChhcnJheTFbaV0gLSBtZWFuMSkgKiAoYXJyYXkyW2ldIC0gbWVhbjIpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0IC8gbjtcblx0fTtcblxuXHRleHBvcnRzLkNPVkFSSUFOQ0UuUyA9IGZ1bmN0aW9uKGFycmF5MSwgYXJyYXkyKSB7XG5cdCAgYXJyYXkxID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5MSkpO1xuXHQgIGFycmF5MiA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheTIpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheTEsIGFycmF5MikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LmNvdmFyaWFuY2UoYXJyYXkxLCBhcnJheTIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuREVWU1EgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKHJhbmdlKTtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gTWF0aC5wb3coKHJhbmdlW2ldIC0gbWVhbiksIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuRVhQT04gPSB7fTtcblxuXHRleHBvcnRzLkVYUE9OLkRJU1QgPSBmdW5jdGlvbih4LCBsYW1iZGEsIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbGFtYmRhID0gdXRpbHMucGFyc2VOdW1iZXIobGFtYmRhKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBsYW1iZGEpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5leHBvbmVudGlhbC5jZGYoeCwgbGFtYmRhKSA6IGpTdGF0LmV4cG9uZW50aWFsLnBkZih4LCBsYW1iZGEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRiA9IHt9O1xuXG5cdGV4cG9ydHMuRi5ESVNUID0gZnVuY3Rpb24oeCwgZDEsIGQyLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGQxID0gdXRpbHMucGFyc2VOdW1iZXIoZDEpO1xuXHQgIGQyID0gdXRpbHMucGFyc2VOdW1iZXIoZDIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIGQxLCBkMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LmNlbnRyYWxGLmNkZih4LCBkMSwgZDIpIDogalN0YXQuY2VudHJhbEYucGRmKHgsIGQxLCBkMik7XG5cdH07XG5cblx0ZXhwb3J0cy5GLkRJU1QuUlQgPSBmdW5jdGlvbih4LCBkMSwgZDIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMykge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICh4IDwgMCB8fCBkMSA8IDEgfHwgZDIgPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHggIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGQxICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBkMiAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIDEgLSBqU3RhdC5jZW50cmFsRi5jZGYoeCwgZDEsIGQyKTtcblx0fTtcblxuXHRleHBvcnRzLkYuSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIGQxLCBkMikge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGQxID0gdXRpbHMucGFyc2VOdW1iZXIoZDEpO1xuXHQgIGQyID0gdXRpbHMucGFyc2VOdW1iZXIoZDIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByb2JhYmlsaXR5LCBkMSwgZDIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChwcm9iYWJpbGl0eSA8PSAwLjAgfHwgcHJvYmFiaWxpdHkgPiAxLjApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmNlbnRyYWxGLmludihwcm9iYWJpbGl0eSwgZDEsIGQyKTtcblx0fTtcblxuXHRleHBvcnRzLkYuSU5WLlJUID0gZnVuY3Rpb24ocCwgZDEsIGQyKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAocCA8IDAgfHwgcCA+IDEgfHwgZDEgPCAxIHx8IGQxID4gTWF0aC5wb3coMTAsIDEwKSB8fCBkMiA8IDEgfHwgZDIgPiBNYXRoLnBvdygxMCwgMTApKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHAgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGQxICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBkMiAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmNlbnRyYWxGLmludigxLjAgLSBwLCBkMSwgZDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRi5URVNUID0gZnVuY3Rpb24oYXJyYXkxLCBhcnJheTIpIHtcblx0ICBpZiAoIWFycmF5MSB8fCAhYXJyYXkyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKCEoYXJyYXkxIGluc3RhbmNlb2YgQXJyYXkpIHx8ICEoYXJyYXkyIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKGFycmF5MS5sZW5ndGggPCAyIHx8IGFycmF5Mi5sZW5ndGggPCAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZGl2MDtcblx0ICB9XG5cblx0ICB2YXIgc3VtT2ZTcXVhcmVzID0gZnVuY3Rpb24odmFsdWVzLCB4MSkge1xuXHQgICAgdmFyIHN1bSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBzdW0gKz1NYXRoLnBvdygodmFsdWVzW2ldIC0geDEpLCAyKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzdW07XG5cdCAgfTtcblxuXHQgIHZhciB4MSA9IG1hdGhUcmlnLlNVTShhcnJheTEpIC8gYXJyYXkxLmxlbmd0aDtcblx0ICB2YXIgeDIgPSBtYXRoVHJpZy5TVU0oYXJyYXkyKSAvIGFycmF5Mi5sZW5ndGg7XG5cdCAgdmFyIHN1bTEgPSBzdW1PZlNxdWFyZXMoYXJyYXkxLCB4MSkgLyAoYXJyYXkxLmxlbmd0aCAtIDEpO1xuXHQgIHZhciBzdW0yID0gc3VtT2ZTcXVhcmVzKGFycmF5MiwgeDIpIC8gKGFycmF5Mi5sZW5ndGggLSAxKTtcblxuXHQgIHJldHVybiBzdW0xIC8gc3VtMjtcblx0fTtcblxuXHRleHBvcnRzLkZJU0hFUiA9IGZ1bmN0aW9uKHgpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgaWYgKHggaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHg7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuXHR9O1xuXG5cdGV4cG9ydHMuRklTSEVSSU5WID0gZnVuY3Rpb24oeSkge1xuXHQgIHkgPSB1dGlscy5wYXJzZU51bWJlcih5KTtcblx0ICBpZiAoeSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4geTtcblx0ICB9XG5cdCAgdmFyIGUyeSA9IE1hdGguZXhwKDIgKiB5KTtcblx0ICByZXR1cm4gKGUyeSAtIDEpIC8gKGUyeSArIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRk9SRUNBU1QgPSBmdW5jdGlvbih4LCBkYXRhX3ksIGRhdGFfeCkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIGRhdGFfeSwgZGF0YV94KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgeG1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeCk7XG5cdCAgdmFyIHltZWFuID0galN0YXQubWVhbihkYXRhX3kpO1xuXHQgIHZhciBuID0gZGF0YV94Lmxlbmd0aDtcblx0ICB2YXIgbnVtID0gMDtcblx0ICB2YXIgZGVuID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgbnVtICs9IChkYXRhX3hbaV0gLSB4bWVhbikgKiAoZGF0YV95W2ldIC0geW1lYW4pO1xuXHQgICAgZGVuICs9IE1hdGgucG93KGRhdGFfeFtpXSAtIHhtZWFuLCAyKTtcblx0ICB9XG5cdCAgdmFyIGIgPSBudW0gLyBkZW47XG5cdCAgdmFyIGEgPSB5bWVhbiAtIGIgKiB4bWVhbjtcblx0ICByZXR1cm4gYSArIGIgKiB4O1xuXHR9O1xuXG5cdGV4cG9ydHMuRlJFUVVFTkNZID0gZnVuY3Rpb24oZGF0YSwgYmlucykge1xuXHQgIGRhdGEgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YSkpO1xuXHQgIGJpbnMgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYmlucykpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRhdGEsIGJpbnMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBuID0gZGF0YS5sZW5ndGg7XG5cdCAgdmFyIGIgPSBiaW5zLmxlbmd0aDtcblx0ICB2YXIgciA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDw9IGI7IGkrKykge1xuXHQgICAgcltpXSA9IDA7XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuXHQgICAgICBpZiAoaSA9PT0gMCkge1xuXHQgICAgICAgIGlmIChkYXRhW2pdIDw9IGJpbnNbMF0pIHtcblx0ICAgICAgICAgIHJbMF0gKz0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAoaSA8IGIpIHtcblx0ICAgICAgICBpZiAoZGF0YVtqXSA+IGJpbnNbaSAtIDFdICYmIGRhdGFbal0gPD0gYmluc1tpXSkge1xuXHQgICAgICAgICAgcltpXSArPSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChpID09PSBiKSB7XG5cdCAgICAgICAgaWYgKGRhdGFbal0gPiBiaW5zW2IgLSAxXSkge1xuXHQgICAgICAgICAgcltiXSArPSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcjtcblx0fTtcblxuXG5cdGV4cG9ydHMuR0FNTUEgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cblx0ICBpZiAobnVtYmVyID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmIChwYXJzZUludChudW1iZXIsIDEwKSA9PT0gbnVtYmVyICYmIG51bWJlciA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmdhbW1hZm4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkdBTU1BLkRJU1QgPSBmdW5jdGlvbih2YWx1ZSwgYWxwaGEsIGJldGEsIGN1bXVsYXRpdmUpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICh2YWx1ZSA8IDAgfHwgYWxwaGEgPD0gMCB8fCBiZXRhIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgYWxwaGEgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGJldGEgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBjdW11bGF0aXZlID8galN0YXQuZ2FtbWEuY2RmKHZhbHVlLCBhbHBoYSwgYmV0YSwgdHJ1ZSkgOiBqU3RhdC5nYW1tYS5wZGYodmFsdWUsIGFscGhhLCBiZXRhLCBmYWxzZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5HQU1NQS5JTlYgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgYWxwaGEsIGJldGEpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMykge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChwcm9iYWJpbGl0eSA8IDAgfHwgcHJvYmFiaWxpdHkgPiAxIHx8IGFscGhhIDw9IDAgfHwgYmV0YSA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHByb2JhYmlsaXR5ICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBhbHBoYSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgYmV0YSAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmdhbW1hLmludihwcm9iYWJpbGl0eSwgYWxwaGEsIGJldGEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR0FNTUFMTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQuZ2FtbWFsbihudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR0FNTUFMTi5QUkVDSVNFID0gZnVuY3Rpb24oeCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHggPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmdhbW1hbG4oeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5HQVVTUyA9IGZ1bmN0aW9uKHopIHtcblx0ICB6ID0gdXRpbHMucGFyc2VOdW1iZXIoeik7XG5cdCAgaWYgKHogaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHo7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5ub3JtYWwuY2RmKHosIDAsIDEpIC0gMC41O1xuXHR9O1xuXG5cdGV4cG9ydHMuR0VPTUVBTiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChhcmdzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBhcmdzO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQuZ2VvbWVhbihhcmdzKTtcblx0fTtcblxuXHRleHBvcnRzLkdST1dUSCA9IGZ1bmN0aW9uKGtub3duX3ksIGtub3duX3gsIG5ld194LCB1c2VfY29uc3QpIHtcblx0ICAvLyBDcmVkaXRzOiBJbG1hcmkgS2Fyb25lbiAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDE2MTk5MC9ob3ctdG8taW1wbGVtZW50LWdyb3d0aC1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0KVxuXG5cdCAga25vd25feSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkoa25vd25feSk7XG5cdCAgaWYgKGtub3duX3kgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGtub3duX3k7XG5cdCAgfVxuXG5cdCAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbmFsIHBhcmFtZXRlcnM6XG5cdCAgdmFyIGk7XG5cdCAgaWYgKGtub3duX3ggPT09IHVuZGVmaW5lZCkge1xuXHQgICAga25vd25feCA9IFtdO1xuXHQgICAgZm9yIChpID0gMTsgaSA8PSBrbm93bl95Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGtub3duX3gucHVzaChpKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKG5ld194ID09PSB1bmRlZmluZWQpIHtcblx0ICAgIG5ld194ID0gW107XG5cdCAgICBmb3IgKGkgPSAxOyBpIDw9IGtub3duX3kubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgbmV3X3gucHVzaChpKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBrbm93bl94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheShrbm93bl94KTtcblx0ICBuZXdfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkobmV3X3gpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGtub3duX3gsIG5ld194KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXG5cdCAgaWYgKHVzZV9jb25zdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB1c2VfY29uc3QgPSB0cnVlO1xuXHQgIH1cblxuXHQgIC8vIENhbGN1bGF0ZSBzdW1zIG92ZXIgdGhlIGRhdGE6XG5cdCAgdmFyIG4gPSBrbm93bl95Lmxlbmd0aDtcblx0ICB2YXIgYXZnX3ggPSAwO1xuXHQgIHZhciBhdmdfeSA9IDA7XG5cdCAgdmFyIGF2Z194eSA9IDA7XG5cdCAgdmFyIGF2Z194eCA9IDA7XG5cdCAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgdmFyIHggPSBrbm93bl94W2ldO1xuXHQgICAgdmFyIHkgPSBNYXRoLmxvZyhrbm93bl95W2ldKTtcblx0ICAgIGF2Z194ICs9IHg7XG5cdCAgICBhdmdfeSArPSB5O1xuXHQgICAgYXZnX3h5ICs9IHggKiB5O1xuXHQgICAgYXZnX3h4ICs9IHggKiB4O1xuXHQgIH1cblx0ICBhdmdfeCAvPSBuO1xuXHQgIGF2Z195IC89IG47XG5cdCAgYXZnX3h5IC89IG47XG5cdCAgYXZnX3h4IC89IG47XG5cblx0ICAvLyBDb21wdXRlIGxpbmVhciByZWdyZXNzaW9uIGNvZWZmaWNpZW50czpcblx0ICB2YXIgYmV0YTtcblx0ICB2YXIgYWxwaGE7XG5cdCAgaWYgKHVzZV9jb25zdCkge1xuXHQgICAgYmV0YSA9IChhdmdfeHkgLSBhdmdfeCAqIGF2Z195KSAvIChhdmdfeHggLSBhdmdfeCAqIGF2Z194KTtcblx0ICAgIGFscGhhID0gYXZnX3kgLSBiZXRhICogYXZnX3g7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGJldGEgPSBhdmdfeHkgLyBhdmdfeHg7XG5cdCAgICBhbHBoYSA9IDA7XG5cdCAgfVxuXG5cdCAgLy8gQ29tcHV0ZSBhbmQgcmV0dXJuIHJlc3VsdCBhcnJheTpcblx0ICB2YXIgbmV3X3kgPSBbXTtcblx0ICBmb3IgKGkgPSAwOyBpIDwgbmV3X3gubGVuZ3RoOyBpKyspIHtcblx0ICAgIG5ld195LnB1c2goTWF0aC5leHAoYWxwaGEgKyBiZXRhICogbmV3X3hbaV0pKTtcblx0ICB9XG5cdCAgcmV0dXJuIG5ld195O1xuXHR9O1xuXG5cdGV4cG9ydHMuSEFSTUVBTiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgZGVuID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgZGVuICs9IDEgLyByYW5nZVtpXTtcblx0ICB9XG5cdCAgcmV0dXJuIG4gLyBkZW47XG5cdH07XG5cblx0ZXhwb3J0cy5IWVBHRU9NID0ge307XG5cblx0ZXhwb3J0cy5IWVBHRU9NLkRJU1QgPSBmdW5jdGlvbih4LCBuLCBNLCBOLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBNID0gdXRpbHMucGFyc2VOdW1iZXIoTSk7XG5cdCAgTiA9IHV0aWxzLnBhcnNlTnVtYmVyKE4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG4sIE0sIE4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcGRmKHgsIG4sIE0sIE4pIHtcblx0ICAgIHJldHVybiBtYXRoVHJpZy5DT01CSU4oTSwgeCkgKiBtYXRoVHJpZy5DT01CSU4oTiAtIE0sIG4gLSB4KSAvIG1hdGhUcmlnLkNPTUJJTihOLCBuKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjZGYoeCwgbiwgTSwgTikge1xuXHQgICAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB4OyBpKyspIHtcblx0ICAgICAgcmVzdWx0ICs9IHBkZihpLCBuLCBNLCBOKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGNkZih4LCBuLCBNLCBOKSA6IHBkZih4LCBuLCBNLCBOKTtcblx0fTtcblxuXHRleHBvcnRzLklOVEVSQ0VQVCA9IGZ1bmN0aW9uKGtub3duX3ksIGtub3duX3gpIHtcblx0ICBrbm93bl95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheShrbm93bl95KTtcblx0ICBrbm93bl94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheShrbm93bl94KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihrbm93bl95LCBrbm93bl94KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoa25vd25feS5sZW5ndGggIT09IGtub3duX3gubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXHQgIHJldHVybiBleHBvcnRzLkZPUkVDQVNUKDAsIGtub3duX3ksIGtub3duX3gpO1xuXHR9O1xuXG5cdGV4cG9ydHMuS1VSVCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgbWVhbiA9IGpTdGF0Lm1lYW4ocmFuZ2UpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzaWdtYSA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHNpZ21hICs9IE1hdGgucG93KHJhbmdlW2ldIC0gbWVhbiwgNCk7XG5cdCAgfVxuXHQgIHNpZ21hID0gc2lnbWEgLyBNYXRoLnBvdyhqU3RhdC5zdGRldihyYW5nZSwgdHJ1ZSksIDQpO1xuXHQgIHJldHVybiAoKG4gKiAobiArIDEpKSAvICgobiAtIDEpICogKG4gLSAyKSAqIChuIC0gMykpKSAqIHNpZ21hIC0gMyAqIChuIC0gMSkgKiAobiAtIDEpIC8gKChuIC0gMikgKiAobiAtIDMpKTtcblx0fTtcblxuXHRleHBvcnRzLkxBUkdFID0gZnVuY3Rpb24ocmFuZ2UsIGspIHtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIGsgPSB1dGlscy5wYXJzZU51bWJlcihrKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYW5nZSwgaykpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgcmV0dXJuIHJhbmdlLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGIgLSBhO1xuXHQgIH0pW2sgLSAxXTtcblx0fTtcblxuXHRleHBvcnRzLkxJTkVTVCA9IGZ1bmN0aW9uKGRhdGFfeSwgZGF0YV94KSB7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHltZWFuID0galN0YXQubWVhbihkYXRhX3kpO1xuXHQgIHZhciB4bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV94KTtcblx0ICB2YXIgbiA9IGRhdGFfeC5sZW5ndGg7XG5cdCAgdmFyIG51bSA9IDA7XG5cdCAgdmFyIGRlbiA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIG51bSArPSAoZGF0YV94W2ldIC0geG1lYW4pICogKGRhdGFfeVtpXSAtIHltZWFuKTtcblx0ICAgIGRlbiArPSBNYXRoLnBvdyhkYXRhX3hbaV0gLSB4bWVhbiwgMik7XG5cdCAgfVxuXHQgIHZhciBtID0gbnVtIC8gZGVuO1xuXHQgIHZhciBiID0geW1lYW4gLSBtICogeG1lYW47XG5cdCAgcmV0dXJuIFttLCBiXTtcblx0fTtcblxuXHQvLyBBY2NvcmRpbmcgdG8gTWljcm9zb2Z0OlxuXHQvLyBodHRwOi8vb2ZmaWNlLm1pY3Jvc29mdC5jb20vZW4tdXMvc3RhcnRlci1oZWxwL2xvZ2VzdC1mdW5jdGlvbi1IUDAxMDM0MjY2NS5hc3B4XG5cdC8vIExPR0VTVCByZXR1cm5zIGFyZSBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIGxpbmVhciBtb2RlbDpcblx0Ly8gbG4geSA9IHgxIGxuIG0xICsgLi4uICsgeG4gbG4gbW4gKyBsbiBiXG5cdGV4cG9ydHMuTE9HRVNUID0gZnVuY3Rpb24oZGF0YV95LCBkYXRhX3gpIHtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRhdGFfeSwgZGF0YV94KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFfeS5sZW5ndGg7IGkgKyspIHtcblx0ICAgIGRhdGFfeVtpXSA9IE1hdGgubG9nKGRhdGFfeVtpXSk7XG5cdCAgfVxuXG5cdCAgdmFyIHJlc3VsdCA9IGV4cG9ydHMuTElORVNUKGRhdGFfeSwgZGF0YV94KTtcblx0ICByZXN1bHRbMF0gPSBNYXRoLnJvdW5kKE1hdGguZXhwKHJlc3VsdFswXSkqMTAwMDAwMCkvMTAwMDAwMDtcblx0ICByZXN1bHRbMV0gPSBNYXRoLnJvdW5kKE1hdGguZXhwKHJlc3VsdFsxXSkqMTAwMDAwMCkvMTAwMDAwMDtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuTE9HTk9STSA9IHt9O1xuXG5cdGV4cG9ydHMuTE9HTk9STS5ESVNUID0gZnVuY3Rpb24oeCwgbWVhbiwgc2QsIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbWVhbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG1lYW4pO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG1lYW4sIHNkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQubG9nbm9ybWFsLmNkZih4LCBtZWFuLCBzZCkgOiBqU3RhdC5sb2dub3JtYWwucGRmKHgsIG1lYW4sIHNkKTtcblx0fTtcblxuXHRleHBvcnRzLkxPR05PUk0uSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIG1lYW4sIHNkKSB7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgbWVhbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG1lYW4pO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByb2JhYmlsaXR5LCBtZWFuLCBzZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LmxvZ25vcm1hbC5pbnYocHJvYmFiaWxpdHksIG1lYW4sIHNkKTtcblx0fTtcblxuXHRleHBvcnRzLk1BWCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLm51bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICByZXR1cm4gKHJhbmdlLmxlbmd0aCA9PT0gMCkgPyAwIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgcmFuZ2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUFYQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmFycmF5VmFsdWVzVG9OdW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgcmV0dXJuIChyYW5nZS5sZW5ndGggPT09IDApID8gMCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHJhbmdlKTtcblx0fTtcblxuXHRleHBvcnRzLk1FRElBTiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmFycmF5VmFsdWVzVG9OdW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgcmV0dXJuIGpTdGF0Lm1lZGlhbihyYW5nZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5NSU4gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5udW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgcmV0dXJuIChyYW5nZS5sZW5ndGggPT09IDApID8gMCA6IE1hdGgubWluLmFwcGx5KE1hdGgsIHJhbmdlKTtcblx0fTtcblxuXHRleHBvcnRzLk1JTkEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5hcnJheVZhbHVlc1RvTnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHJldHVybiAocmFuZ2UubGVuZ3RoID09PSAwKSA/IDAgOiBNYXRoLm1pbi5hcHBseShNYXRoLCByYW5nZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5NT0RFID0ge307XG5cblx0ZXhwb3J0cy5NT0RFLk1VTFQgPSBmdW5jdGlvbigpIHtcblx0ICAvLyBDcmVkaXRzOiBSb8O2bmHDpG5cblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIGNvdW50ID0ge307XG5cdCAgdmFyIG1heEl0ZW1zID0gW107XG5cdCAgdmFyIG1heCA9IDA7XG5cdCAgdmFyIGN1cnJlbnRJdGVtO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGN1cnJlbnRJdGVtID0gcmFuZ2VbaV07XG5cdCAgICBjb3VudFtjdXJyZW50SXRlbV0gPSBjb3VudFtjdXJyZW50SXRlbV0gPyBjb3VudFtjdXJyZW50SXRlbV0gKyAxIDogMTtcblx0ICAgIGlmIChjb3VudFtjdXJyZW50SXRlbV0gPiBtYXgpIHtcblx0ICAgICAgbWF4ID0gY291bnRbY3VycmVudEl0ZW1dO1xuXHQgICAgICBtYXhJdGVtcyA9IFtdO1xuXHQgICAgfVxuXHQgICAgaWYgKGNvdW50W2N1cnJlbnRJdGVtXSA9PT0gbWF4KSB7XG5cdCAgICAgIG1heEl0ZW1zW21heEl0ZW1zLmxlbmd0aF0gPSBjdXJyZW50SXRlbTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG1heEl0ZW1zO1xuXHR9O1xuXG5cdGV4cG9ydHMuTU9ERS5TTkdMID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHJldHVybiBleHBvcnRzLk1PREUuTVVMVChyYW5nZSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSlbMF07XG5cdH07XG5cblx0ZXhwb3J0cy5ORUdCSU5PTSA9IHt9O1xuXG5cdGV4cG9ydHMuTkVHQklOT00uRElTVCA9IGZ1bmN0aW9uKGssIHIsIHAsIGN1bXVsYXRpdmUpIHtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgciA9IHV0aWxzLnBhcnNlTnVtYmVyKHIpO1xuXHQgIHAgPSB1dGlscy5wYXJzZU51bWJlcihwKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihrLCByLCBwKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQubmVnYmluLmNkZihrLCByLCBwKSA6IGpTdGF0Lm5lZ2Jpbi5wZGYoaywgciwgcCk7XG5cdH07XG5cblx0ZXhwb3J0cy5OT1JNID0ge307XG5cblx0ZXhwb3J0cy5OT1JNLkRJU1QgPSBmdW5jdGlvbih4LCBtZWFuLCBzZCwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBtZWFuID0gdXRpbHMucGFyc2VOdW1iZXIobWVhbik7XG5cdCAgc2QgPSB1dGlscy5wYXJzZU51bWJlcihzZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbWVhbiwgc2QpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChzZCA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBub3JtYWwgZGlzdHJpYnV0aW9uIGNvbXB1dGVkIGJ5IGpTdGF0IFtodHRwOi8vanN0YXQub3JnXVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5ub3JtYWwuY2RmKHgsIG1lYW4sIHNkKSA6IGpTdGF0Lm5vcm1hbC5wZGYoeCwgbWVhbiwgc2QpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9STS5JTlYgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgbWVhbiwgc2QpIHtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBtZWFuID0gdXRpbHMucGFyc2VOdW1iZXIobWVhbik7XG5cdCAgc2QgPSB1dGlscy5wYXJzZU51bWJlcihzZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocHJvYmFiaWxpdHksIG1lYW4sIHNkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQubm9ybWFsLmludihwcm9iYWJpbGl0eSwgbWVhbiwgc2QpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9STS5TID0ge307XG5cblx0ZXhwb3J0cy5OT1JNLlMuRElTVCA9IGZ1bmN0aW9uKHosIGN1bXVsYXRpdmUpIHtcblx0ICB6ID0gdXRpbHMucGFyc2VOdW1iZXIoeik7XG5cdCAgaWYgKHogaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQubm9ybWFsLmNkZih6LCAwLCAxKSA6IGpTdGF0Lm5vcm1hbC5wZGYoeiwgMCwgMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5OT1JNLlMuSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHkpIHtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBpZiAocHJvYmFiaWxpdHkgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQubm9ybWFsLmludihwcm9iYWJpbGl0eSwgMCwgMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5QRUFSU09OID0gZnVuY3Rpb24oZGF0YV94LCBkYXRhX3kpIHtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRhdGFfeSwgZGF0YV94KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgeG1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeCk7XG5cdCAgdmFyIHltZWFuID0galN0YXQubWVhbihkYXRhX3kpO1xuXHQgIHZhciBuID0gZGF0YV94Lmxlbmd0aDtcblx0ICB2YXIgbnVtID0gMDtcblx0ICB2YXIgZGVuMSA9IDA7XG5cdCAgdmFyIGRlbjIgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBudW0gKz0gKGRhdGFfeFtpXSAtIHhtZWFuKSAqIChkYXRhX3lbaV0gLSB5bWVhbik7XG5cdCAgICBkZW4xICs9IE1hdGgucG93KGRhdGFfeFtpXSAtIHhtZWFuLCAyKTtcblx0ICAgIGRlbjIgKz0gTWF0aC5wb3coZGF0YV95W2ldIC0geW1lYW4sIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtIC8gTWF0aC5zcXJ0KGRlbjEgKiBkZW4yKTtcblx0fTtcblxuXHRleHBvcnRzLlBFUkNFTlRJTEUgPSB7fTtcblxuXHRleHBvcnRzLlBFUkNFTlRJTEUuRVhDID0gZnVuY3Rpb24oYXJyYXksIGspIHtcblx0ICBhcnJheSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheSkpO1xuXHQgIGsgPSB1dGlscy5wYXJzZU51bWJlcihrKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheSwgaykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgYXJyYXkgPSBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHtcblx0ICAgICAgcmV0dXJuIGEgLSBiO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHZhciBuID0gYXJyYXkubGVuZ3RoO1xuXHQgIGlmIChrIDwgMSAvIChuICsgMSkgfHwgayA+IDEgLSAxIC8gKG4gKyAxKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cdCAgdmFyIGwgPSBrICogKG4gKyAxKSAtIDE7XG5cdCAgdmFyIGZsID0gTWF0aC5mbG9vcihsKTtcblx0ICByZXR1cm4gdXRpbHMuY2xlYW5GbG9hdCgobCA9PT0gZmwpID8gYXJyYXlbbF0gOiBhcnJheVtmbF0gKyAobCAtIGZsKSAqIChhcnJheVtmbCArIDFdIC0gYXJyYXlbZmxdKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5QRVJDRU5USUxFLklOQyA9IGZ1bmN0aW9uKGFycmF5LCBrKSB7XG5cdCAgYXJyYXkgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkpKTtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXksIGspKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGFycmF5ID0gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSk7XG5cdCAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG5cdCAgdmFyIGwgPSBrICogKG4gLSAxKTtcblx0ICB2YXIgZmwgPSBNYXRoLmZsb29yKGwpO1xuXHQgIHJldHVybiB1dGlscy5jbGVhbkZsb2F0KChsID09PSBmbCkgPyBhcnJheVtsXSA6IGFycmF5W2ZsXSArIChsIC0gZmwpICogKGFycmF5W2ZsICsgMV0gLSBhcnJheVtmbF0pKTtcblx0fTtcblxuXHRleHBvcnRzLlBFUkNFTlRSQU5LID0ge307XG5cblx0ZXhwb3J0cy5QRVJDRU5UUkFOSy5FWEMgPSBmdW5jdGlvbihhcnJheSwgeCwgc2lnbmlmaWNhbmNlKSB7XG5cdCAgc2lnbmlmaWNhbmNlID0gKHNpZ25pZmljYW5jZSA9PT0gdW5kZWZpbmVkKSA/IDMgOiBzaWduaWZpY2FuY2U7XG5cdCAgYXJyYXkgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkpKTtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgc2lnbmlmaWNhbmNlID0gdXRpbHMucGFyc2VOdW1iZXIoc2lnbmlmaWNhbmNlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheSwgeCwgc2lnbmlmaWNhbmNlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBhcnJheSA9IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pO1xuXHQgIHZhciB1bmlxdWVzID0gbWlzYy5VTklRVUUuYXBwbHkobnVsbCwgYXJyYXkpO1xuXHQgIHZhciBuID0gYXJyYXkubGVuZ3RoO1xuXHQgIHZhciBtID0gdW5pcXVlcy5sZW5ndGg7XG5cdCAgdmFyIHBvd2VyID0gTWF0aC5wb3coMTAsIHNpZ25pZmljYW5jZSk7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgdmFyIG1hdGNoID0gZmFsc2U7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHdoaWxlICghbWF0Y2ggJiYgaSA8IG0pIHtcblx0ICAgIGlmICh4ID09PSB1bmlxdWVzW2ldKSB7XG5cdCAgICAgIHJlc3VsdCA9IChhcnJheS5pbmRleE9mKHVuaXF1ZXNbaV0pICsgMSkgLyAobiArIDEpO1xuXHQgICAgICBtYXRjaCA9IHRydWU7XG5cdCAgICB9IGVsc2UgaWYgKHggPj0gdW5pcXVlc1tpXSAmJiAoeCA8IHVuaXF1ZXNbaSArIDFdIHx8IGkgPT09IG0gLSAxKSkge1xuXHQgICAgICByZXN1bHQgPSAoYXJyYXkuaW5kZXhPZih1bmlxdWVzW2ldKSArIDEgKyAoeCAtIHVuaXF1ZXNbaV0pIC8gKHVuaXF1ZXNbaSArIDFdIC0gdW5pcXVlc1tpXSkpIC8gKG4gKyAxKTtcblx0ICAgICAgbWF0Y2ggPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgaSsrO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5mbG9vcihyZXN1bHQgKiBwb3dlcikgLyBwb3dlcjtcblx0fTtcblxuXHRleHBvcnRzLlBFUkNFTlRSQU5LLklOQyA9IGZ1bmN0aW9uKGFycmF5LCB4LCBzaWduaWZpY2FuY2UpIHtcblx0ICBzaWduaWZpY2FuY2UgPSAoc2lnbmlmaWNhbmNlID09PSB1bmRlZmluZWQpID8gMyA6IHNpZ25pZmljYW5jZTtcblx0ICBhcnJheSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheSkpO1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBzaWduaWZpY2FuY2UgPSB1dGlscy5wYXJzZU51bWJlcihzaWduaWZpY2FuY2UpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5LCB4LCBzaWduaWZpY2FuY2UpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGFycmF5ID0gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSk7XG5cdCAgdmFyIHVuaXF1ZXMgPSBtaXNjLlVOSVFVRS5hcHBseShudWxsLCBhcnJheSk7XG5cdCAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG5cdCAgdmFyIG0gPSB1bmlxdWVzLmxlbmd0aDtcblx0ICB2YXIgcG93ZXIgPSBNYXRoLnBvdygxMCwgc2lnbmlmaWNhbmNlKTtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICB2YXIgbWF0Y2ggPSBmYWxzZTtcblx0ICB2YXIgaSA9IDA7XG5cdCAgd2hpbGUgKCFtYXRjaCAmJiBpIDwgbSkge1xuXHQgICAgaWYgKHggPT09IHVuaXF1ZXNbaV0pIHtcblx0ICAgICAgcmVzdWx0ID0gYXJyYXkuaW5kZXhPZih1bmlxdWVzW2ldKSAvIChuIC0gMSk7XG5cdCAgICAgIG1hdGNoID0gdHJ1ZTtcblx0ICAgIH0gZWxzZSBpZiAoeCA+PSB1bmlxdWVzW2ldICYmICh4IDwgdW5pcXVlc1tpICsgMV0gfHwgaSA9PT0gbSAtIDEpKSB7XG5cdCAgICAgIHJlc3VsdCA9IChhcnJheS5pbmRleE9mKHVuaXF1ZXNbaV0pICsgKHggLSB1bmlxdWVzW2ldKSAvICh1bmlxdWVzW2kgKyAxXSAtIHVuaXF1ZXNbaV0pKSAvIChuIC0gMSk7XG5cdCAgICAgIG1hdGNoID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGkrKztcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguZmxvb3IocmVzdWx0ICogcG93ZXIpIC8gcG93ZXI7XG5cdH07XG5cblx0ZXhwb3J0cy5QRVJNVVQgPSBmdW5jdGlvbihudW1iZXIsIG51bWJlcl9jaG9zZW4pIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIG51bWJlcl9jaG9zZW4gPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXJfY2hvc2VuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIG51bWJlcl9jaG9zZW4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBtYXRoVHJpZy5GQUNUKG51bWJlcikgLyBtYXRoVHJpZy5GQUNUKG51bWJlciAtIG51bWJlcl9jaG9zZW4pO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVSTVVUQVRJT05BID0gZnVuY3Rpb24obnVtYmVyLCBudW1iZXJfY2hvc2VuKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBudW1iZXJfY2hvc2VuID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyX2Nob3Nlbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBudW1iZXJfY2hvc2VuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5wb3cobnVtYmVyLCBudW1iZXJfY2hvc2VuKTtcblx0fTtcblxuXHRleHBvcnRzLlBISSA9IGZ1bmN0aW9uKHgpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgaWYgKHggaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5leHAoLTAuNSAqIHggKiB4KSAvIFNRUlQyUEk7XG5cdH07XG5cblx0ZXhwb3J0cy5QT0lTU09OID0ge307XG5cblx0ZXhwb3J0cy5QT0lTU09OLkRJU1QgPSBmdW5jdGlvbih4LCBtZWFuLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG1lYW4gPSB1dGlscy5wYXJzZU51bWJlcihtZWFuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBtZWFuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQucG9pc3Nvbi5jZGYoeCwgbWVhbikgOiBqU3RhdC5wb2lzc29uLnBkZih4LCBtZWFuKTtcblx0fTtcblxuXHRleHBvcnRzLlBST0IgPSBmdW5jdGlvbihyYW5nZSwgcHJvYmFiaWxpdHksIGxvd2VyLCB1cHBlcikge1xuXHQgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cdCAgdXBwZXIgPSAodXBwZXIgPT09IHVuZGVmaW5lZCkgPyBsb3dlciA6IHVwcGVyO1xuXG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihwcm9iYWJpbGl0eSkpO1xuXHQgIGxvd2VyID0gdXRpbHMucGFyc2VOdW1iZXIobG93ZXIpO1xuXHQgIHVwcGVyID0gdXRpbHMucGFyc2VOdW1iZXIodXBwZXIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCBwcm9iYWJpbGl0eSwgbG93ZXIsIHVwcGVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChsb3dlciA9PT0gdXBwZXIpIHtcblx0ICAgIHJldHVybiAocmFuZ2UuaW5kZXhPZihsb3dlcikgPj0gMCkgPyBwcm9iYWJpbGl0eVtyYW5nZS5pbmRleE9mKGxvd2VyKV0gOiAwO1xuXHQgIH1cblxuXHQgIHZhciBzb3J0ZWQgPSByYW5nZS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9KTtcblx0ICB2YXIgbiA9IHNvcnRlZC5sZW5ndGg7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGlmIChzb3J0ZWRbaV0gPj0gbG93ZXIgJiYgc29ydGVkW2ldIDw9IHVwcGVyKSB7XG5cdCAgICAgIHJlc3VsdCArPSBwcm9iYWJpbGl0eVtyYW5nZS5pbmRleE9mKHNvcnRlZFtpXSldO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuUVVBUlRJTEUgPSB7fTtcblxuXHRleHBvcnRzLlFVQVJUSUxFLkVYQyA9IGZ1bmN0aW9uKHJhbmdlLCBxdWFydCkge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgcXVhcnQgPSB1dGlscy5wYXJzZU51bWJlcihxdWFydCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIHF1YXJ0KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBzd2l0Y2ggKHF1YXJ0KSB7XG5cdCAgICBjYXNlIDE6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBFUkNFTlRJTEUuRVhDKHJhbmdlLCAwLjI1KTtcblx0ICAgIGNhc2UgMjpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUEVSQ0VOVElMRS5FWEMocmFuZ2UsIDAuNSk7XG5cdCAgICBjYXNlIDM6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBFUkNFTlRJTEUuRVhDKHJhbmdlLCAwLjc1KTtcblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuUVVBUlRJTEUuSU5DID0gZnVuY3Rpb24ocmFuZ2UsIHF1YXJ0KSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBxdWFydCA9IHV0aWxzLnBhcnNlTnVtYmVyKHF1YXJ0KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYW5nZSwgcXVhcnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHN3aXRjaCAocXVhcnQpIHtcblx0ICAgIGNhc2UgMTpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUEVSQ0VOVElMRS5JTkMocmFuZ2UsIDAuMjUpO1xuXHQgICAgY2FzZSAyOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QRVJDRU5USUxFLklOQyhyYW5nZSwgMC41KTtcblx0ICAgIGNhc2UgMzpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUEVSQ0VOVElMRS5JTkMocmFuZ2UsIDAuNzUpO1xuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5SQU5LID0ge307XG5cblx0ZXhwb3J0cy5SQU5LLkFWRyA9IGZ1bmN0aW9uKG51bWJlciwgcmFuZ2UsIG9yZGVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgcmFuZ2UpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJhbmdlID0gdXRpbHMuZmxhdHRlbihyYW5nZSk7XG5cdCAgb3JkZXIgPSBvcmRlciB8fCBmYWxzZTtcblx0ICB2YXIgc29ydCA9IChvcmRlcikgPyBmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSA6IGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBiIC0gYTtcblx0ICB9O1xuXHQgIHJhbmdlID0gcmFuZ2Uuc29ydChzb3J0KTtcblxuXHQgIHZhciBsZW5ndGggPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIGNvdW50ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAocmFuZ2VbaV0gPT09IG51bWJlcikge1xuXHQgICAgICBjb3VudCsrO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiAoY291bnQgPiAxKSA/ICgyICogcmFuZ2UuaW5kZXhPZihudW1iZXIpICsgY291bnQgKyAxKSAvIDIgOiByYW5nZS5pbmRleE9mKG51bWJlcikgKyAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkFOSy5FUSA9IGZ1bmN0aW9uKG51bWJlciwgcmFuZ2UsIG9yZGVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgcmFuZ2UpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIG9yZGVyID0gb3JkZXIgfHwgZmFsc2U7XG5cdCAgdmFyIHNvcnQgPSAob3JkZXIpID8gZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0gOiBmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYiAtIGE7XG5cdCAgfTtcblx0ICByYW5nZSA9IHJhbmdlLnNvcnQoc29ydCk7XG5cdCAgcmV0dXJuIHJhbmdlLmluZGV4T2YobnVtYmVyKSArIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5ST1cgPSBmdW5jdGlvbihtYXRyaXgsIGluZGV4KSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoaW5kZXggPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICghKG1hdHJpeCBpbnN0YW5jZW9mIEFycmF5KSB8fCAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQucm93KG1hdHJpeCwgaW5kZXgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUk9XUyA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKCEobWF0cml4IGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKG1hdHJpeC5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5yb3dzKG1hdHJpeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5SU1EgPSBmdW5jdGlvbihkYXRhX3gsIGRhdGFfeSkgeyAvLyBubyBuZWVkIHRvIGZsYXR0ZW4gaGVyZSwgUEVBUlNPTiB3aWxsIHRha2UgY2FyZSBvZiB0aGF0XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3gsIGRhdGFfeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgucG93KGV4cG9ydHMuUEVBUlNPTihkYXRhX3gsIGRhdGFfeSksIDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0tFVyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgbWVhbiA9IGpTdGF0Lm1lYW4ocmFuZ2UpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzaWdtYSA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHNpZ21hICs9IE1hdGgucG93KHJhbmdlW2ldIC0gbWVhbiwgMyk7XG5cdCAgfVxuXHQgIHJldHVybiBuICogc2lnbWEgLyAoKG4gLSAxKSAqIChuIC0gMikgKiBNYXRoLnBvdyhqU3RhdC5zdGRldihyYW5nZSwgdHJ1ZSksIDMpKTtcblx0fTtcblxuXHRleHBvcnRzLlNLRVcuUCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgbWVhbiA9IGpTdGF0Lm1lYW4ocmFuZ2UpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBtMiA9IDA7XG5cdCAgdmFyIG0zID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgbTMgKz0gTWF0aC5wb3cocmFuZ2VbaV0gLSBtZWFuLCAzKTtcblx0ICAgIG0yICs9IE1hdGgucG93KHJhbmdlW2ldIC0gbWVhbiwgMik7XG5cdCAgfVxuXHQgIG0zID0gbTMgLyBuO1xuXHQgIG0yID0gbTIgLyBuO1xuXHQgIHJldHVybiBtMyAvIE1hdGgucG93KG0yLCAzIC8gMik7XG5cdH07XG5cblx0ZXhwb3J0cy5TTE9QRSA9IGZ1bmN0aW9uKGRhdGFfeSwgZGF0YV94KSB7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHhtZWFuID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciB5bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgbiA9IGRhdGFfeC5sZW5ndGg7XG5cdCAgdmFyIG51bSA9IDA7XG5cdCAgdmFyIGRlbiA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIG51bSArPSAoZGF0YV94W2ldIC0geG1lYW4pICogKGRhdGFfeVtpXSAtIHltZWFuKTtcblx0ICAgIGRlbiArPSBNYXRoLnBvdyhkYXRhX3hbaV0gLSB4bWVhbiwgMik7XG5cdCAgfVxuXHQgIHJldHVybiBudW0gLyBkZW47XG5cdH07XG5cblx0ZXhwb3J0cy5TTUFMTCA9IGZ1bmN0aW9uKHJhbmdlLCBrKSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIGspKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHJldHVybiByYW5nZS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9KVtrIC0gMV07XG5cdH07XG5cblx0ZXhwb3J0cy5TVEFOREFSRElaRSA9IGZ1bmN0aW9uKHgsIG1lYW4sIHNkKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG1lYW4gPSB1dGlscy5wYXJzZU51bWJlcihtZWFuKTtcblx0ICBzZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNkKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBtZWFuLCBzZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuICh4IC0gbWVhbikgLyBzZDtcblx0fTtcblxuXHRleHBvcnRzLlNUREVWID0ge307XG5cblx0ZXhwb3J0cy5TVERFVi5QID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHYgPSBleHBvcnRzLlZBUi5QLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIE1hdGguc3FydCh2KTtcblx0fTtcblxuXHRleHBvcnRzLlNUREVWLlMgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgdiA9IGV4cG9ydHMuVkFSLlMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICByZXR1cm4gTWF0aC5zcXJ0KHYpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1RERVZBID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHYgPSBleHBvcnRzLlZBUkEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICByZXR1cm4gTWF0aC5zcXJ0KHYpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1RERVZQQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciB2ID0gZXhwb3J0cy5WQVJQQS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIHJldHVybiBNYXRoLnNxcnQodik7XG5cdH07XG5cblxuXHRleHBvcnRzLlNURVlYID0gZnVuY3Rpb24oZGF0YV95LCBkYXRhX3gpIHtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRhdGFfeSwgZGF0YV94KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgeG1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeCk7XG5cdCAgdmFyIHltZWFuID0galN0YXQubWVhbihkYXRhX3kpO1xuXHQgIHZhciBuID0gZGF0YV94Lmxlbmd0aDtcblx0ICB2YXIgbGZ0ID0gMDtcblx0ICB2YXIgbnVtID0gMDtcblx0ICB2YXIgZGVuID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgbGZ0ICs9IE1hdGgucG93KGRhdGFfeVtpXSAtIHltZWFuLCAyKTtcblx0ICAgIG51bSArPSAoZGF0YV94W2ldIC0geG1lYW4pICogKGRhdGFfeVtpXSAtIHltZWFuKTtcblx0ICAgIGRlbiArPSBNYXRoLnBvdyhkYXRhX3hbaV0gLSB4bWVhbiwgMik7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLnNxcnQoKGxmdCAtIG51bSAqIG51bSAvIGRlbikgLyAobiAtIDIpKTtcblx0fTtcblxuXHRleHBvcnRzLlRSQU5TUE9TRSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHQgIGlmICghbWF0cml4KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC50cmFuc3Bvc2UobWF0cml4KTtcblx0fTtcblxuXHRleHBvcnRzLlQgPSB0ZXh0LlQ7XG5cblx0ZXhwb3J0cy5ULkRJU1QgPSBmdW5jdGlvbih4LCBkZiwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBkZiA9IHV0aWxzLnBhcnNlTnVtYmVyKGRmKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBkZikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LnN0dWRlbnR0LmNkZih4LCBkZikgOiBqU3RhdC5zdHVkZW50dC5wZGYoeCwgZGYpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVC5ESVNUWycyVCddID0gZnVuY3Rpb24oeCwgZGYpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICh4IDwgMCB8fCBkZiA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZGYgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiAoMSAtIGpTdGF0LnN0dWRlbnR0LmNkZih4ICwgZGYpKSAqIDI7XG5cdH07XG5cblx0ZXhwb3J0cy5ULkRJU1QuUlQgPSBmdW5jdGlvbih4LCBkZikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHggPCAwIHx8IGRmIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBkZiAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIDEgLSBqU3RhdC5zdHVkZW50dC5jZGYoeCAsIGRmKTtcblx0fTtcblxuXHRleHBvcnRzLlQuSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIGRmKSB7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgZGYgPSB1dGlscy5wYXJzZU51bWJlcihkZik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocHJvYmFiaWxpdHksIGRmKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQuc3R1ZGVudHQuaW52KHByb2JhYmlsaXR5LCBkZik7XG5cdH07XG5cblx0ZXhwb3J0cy5ULklOVlsnMlQnXSA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBkZikge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGRmID0gdXRpbHMucGFyc2VOdW1iZXIoZGYpO1xuXHQgIGlmIChwcm9iYWJpbGl0eSA8PSAwIHx8IHByb2JhYmlsaXR5ID4gMSB8fCBkZiA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByb2JhYmlsaXR5LCBkZikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguYWJzKGpTdGF0LnN0dWRlbnR0Lmludihwcm9iYWJpbGl0eS8yLCBkZikpO1xuXHR9O1xuXG5cdC8vIFRoZSBhbGdvcml0aG0gY2FuIGJlIGZvdW5kIGhlcmU6XG5cdC8vIGh0dHA6Ly93d3cuY2hlbS51b2EuZ3IvYXBwbGV0cy9BcHBsZXRUdGVzdC9BcHBsX1R0ZXN0Mi5odG1sXG5cdGV4cG9ydHMuVC5URVNUID0gZnVuY3Rpb24oZGF0YV94LCBkYXRhX3kpIHtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRhdGFfeCwgZGF0YV95KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHZhciBtZWFuX3ggPSBqU3RhdC5tZWFuKGRhdGFfeCk7XG5cdCAgdmFyIG1lYW5feSA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgc194ID0gMDtcblx0ICB2YXIgc195ID0gMDtcblx0ICB2YXIgaTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCBkYXRhX3gubGVuZ3RoOyBpKyspIHtcblx0ICAgIHNfeCArPSBNYXRoLnBvdyhkYXRhX3hbaV0gLSBtZWFuX3gsIDIpO1xuXHQgIH1cblx0ICBmb3IgKGkgPSAwOyBpIDwgZGF0YV95Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBzX3kgKz0gTWF0aC5wb3coZGF0YV95W2ldIC0gbWVhbl95LCAyKTtcblx0ICB9XG5cblx0ICBzX3ggPSBzX3ggLyAoZGF0YV94Lmxlbmd0aC0xKTtcblx0ICBzX3kgPSBzX3kgLyAoZGF0YV95Lmxlbmd0aC0xKTtcblxuXHQgIHZhciB0ID0gTWF0aC5hYnMobWVhbl94IC0gbWVhbl95KSAvIE1hdGguc3FydChzX3gvZGF0YV94Lmxlbmd0aCArIHNfeS9kYXRhX3kubGVuZ3RoKTtcblxuXHQgIHJldHVybiBleHBvcnRzLlQuRElTVFsnMlQnXSh0LCBkYXRhX3gubGVuZ3RoK2RhdGFfeS5sZW5ndGgtMik7XG5cdH07XG5cblx0ZXhwb3J0cy5UUkVORCA9IGZ1bmN0aW9uKGRhdGFfeSwgZGF0YV94LCBuZXdfZGF0YV94KSB7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBuZXdfZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKG5ld19kYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3ksIGRhdGFfeCwgbmV3X2RhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIGxpbmVzdCA9IGV4cG9ydHMuTElORVNUKGRhdGFfeSwgZGF0YV94KTtcblx0ICB2YXIgbSA9IGxpbmVzdFswXTtcblx0ICB2YXIgYiA9IGxpbmVzdFsxXTtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cblx0ICBuZXdfZGF0YV94LmZvckVhY2goZnVuY3Rpb24oeCkge1xuXHQgICAgcmVzdWx0LnB1c2gobSAqIHggKyBiKTtcblx0ICB9KTtcblxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5UUklNTUVBTiA9IGZ1bmN0aW9uKHJhbmdlLCBwZXJjZW50KSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBwZXJjZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocGVyY2VudCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIHBlcmNlbnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciB0cmltID0gbWF0aFRyaWcuRkxPT1IocmFuZ2UubGVuZ3RoICogcGVyY2VudCwgMikgLyAyO1xuXHQgIHJldHVybiBqU3RhdC5tZWFuKHV0aWxzLmluaXRpYWwodXRpbHMucmVzdChyYW5nZS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9KSwgdHJpbSksIHRyaW0pKTtcblx0fTtcblxuXHRleHBvcnRzLlZBUiA9IHt9O1xuXG5cdGV4cG9ydHMuVkFSLlAgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5udW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHNpZ21hID0gMDtcblx0ICB2YXIgbWVhbiA9IGV4cG9ydHMuQVZFUkFHRShyYW5nZSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHNpZ21hICs9IE1hdGgucG93KHJhbmdlW2ldIC0gbWVhbiwgMik7XG5cdCAgfVxuXHQgIHJldHVybiBzaWdtYSAvIG47XG5cdH07XG5cblx0ZXhwb3J0cy5WQVIuUyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLm51bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc2lnbWEgPSAwO1xuXHQgIHZhciBtZWFuID0gZXhwb3J0cy5BVkVSQUdFKHJhbmdlKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgc2lnbWEgKz0gTWF0aC5wb3cocmFuZ2VbaV0gLSBtZWFuLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIHNpZ21hIC8gKG4gLSAxKTtcblx0fTtcblxuXHRleHBvcnRzLlZBUkEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHNpZ21hID0gMDtcblx0ICB2YXIgY291bnQgPSAwO1xuXHQgIHZhciBtZWFuID0gZXhwb3J0cy5BVkVSQUdFQShyYW5nZSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHZhciBlbCA9IHJhbmdlW2ldO1xuXHQgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgc2lnbWEgKz0gTWF0aC5wb3coZWwgLSBtZWFuLCAyKTtcblx0ICAgIH0gZWxzZSBpZiAoZWwgPT09IHRydWUpIHtcblx0ICAgICAgc2lnbWEgKz0gTWF0aC5wb3coMSAtIG1lYW4sIDIpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2lnbWEgKz0gTWF0aC5wb3coMCAtIG1lYW4sIDIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZWwgIT09IG51bGwpIHtcblx0ICAgICAgY291bnQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHNpZ21hIC8gKGNvdW50IC0gMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5WQVJQQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc2lnbWEgPSAwO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgdmFyIG1lYW4gPSBleHBvcnRzLkFWRVJBR0VBKHJhbmdlKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgdmFyIGVsID0gcmFuZ2VbaV07XG5cdCAgICBpZiAodHlwZW9mIGVsID09PSAnbnVtYmVyJykge1xuXHQgICAgICBzaWdtYSArPSBNYXRoLnBvdyhlbCAtIG1lYW4sIDIpO1xuXHQgICAgfSBlbHNlIGlmIChlbCA9PT0gdHJ1ZSkge1xuXHQgICAgICBzaWdtYSArPSBNYXRoLnBvdygxIC0gbWVhbiwgMik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzaWdtYSArPSBNYXRoLnBvdygwIC0gbWVhbiwgMik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlbCAhPT0gbnVsbCkge1xuXHQgICAgICBjb3VudCsrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gc2lnbWEgLyBjb3VudDtcblx0fTtcblxuXHRleHBvcnRzLldFSUJVTEwgPSB7fTtcblxuXHRleHBvcnRzLldFSUJVTEwuRElTVCA9IGZ1bmN0aW9uKHgsIGFscGhhLCBiZXRhLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGFscGhhID0gdXRpbHMucGFyc2VOdW1iZXIoYWxwaGEpO1xuXHQgIGJldGEgPSB1dGlscy5wYXJzZU51bWJlcihiZXRhKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBhbHBoYSwgYmV0YSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IDEgLSBNYXRoLmV4cCgtTWF0aC5wb3coeCAvIGJldGEsIGFscGhhKSkgOiBNYXRoLnBvdyh4LCBhbHBoYSAtIDEpICogTWF0aC5leHAoLU1hdGgucG93KHggLyBiZXRhLCBhbHBoYSkpICogYWxwaGEgLyBNYXRoLnBvdyhiZXRhLCBhbHBoYSk7XG5cdH07XG5cblx0ZXhwb3J0cy5aID0ge307XG5cblx0ZXhwb3J0cy5aLlRFU1QgPSBmdW5jdGlvbihyYW5nZSwgeCwgc2QpIHtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYW5nZSwgeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBzZCA9IHNkIHx8IGV4cG9ydHMuU1RERVYuUyhyYW5nZSk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgcmV0dXJuIDEgLSBleHBvcnRzLk5PUk0uUy5ESVNUKChleHBvcnRzLkFWRVJBR0UocmFuZ2UpIC0geCkgLyAoc2QgLyBNYXRoLnNxcnQobikpLCB0cnVlKTtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIG51bWVyYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG5cdC8vVE9ET1xuXHRleHBvcnRzLkFTQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdBU0MgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly9UT0RPXG5cdGV4cG9ydHMuQkFIVFRFWFQgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQkFIVFRFWFQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5DSEFSID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5DTEVBTiA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICB0ZXh0ID0gdGV4dCB8fCAnJztcblx0ICB2YXIgcmUgPSAvW1xcMC1cXHgxRl0vZztcblx0ICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlLCBcIlwiKTtcblx0fTtcblxuXHRleHBvcnRzLkNPREUgPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgdGV4dCA9IHRleHQgfHwgJyc7XG5cdCAgcmV0dXJuIHRleHQuY2hhckNvZGVBdCgwKTtcblx0fTtcblxuXHRleHBvcnRzLkNPTkNBVEVOQVRFID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cblx0ICB2YXIgdHJ1ZUZvdW5kID0gMDtcblx0ICB3aGlsZSAoKHRydWVGb3VuZCA9IGFyZ3MuaW5kZXhPZih0cnVlKSkgPiAtMSkge1xuXHQgICAgYXJnc1t0cnVlRm91bmRdID0gJ1RSVUUnO1xuXHQgIH1cblxuXHQgIHZhciBmYWxzZUZvdW5kID0gMDtcblx0ICB3aGlsZSAoKGZhbHNlRm91bmQgPSBhcmdzLmluZGV4T2YoZmFsc2UpKSA+IC0xKSB7XG5cdCAgICBhcmdzW2ZhbHNlRm91bmRdID0gJ0ZBTFNFJztcblx0ICB9XG5cblx0ICByZXR1cm4gYXJncy5qb2luKCcnKTtcblx0fTtcblxuXHQvL1RPRE9cblx0ZXhwb3J0cy5EQkNTID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0RCQ1MgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5ET0xMQVIgPSBmdW5jdGlvbihudW1iZXIsIGRlY2ltYWxzKSB7XG5cdCAgZGVjaW1hbHMgPSAoZGVjaW1hbHMgPT09IHVuZGVmaW5lZCkgPyAyIDogZGVjaW1hbHM7XG5cblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGRlY2ltYWxzID0gdXRpbHMucGFyc2VOdW1iZXIoZGVjaW1hbHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgZGVjaW1hbHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBmb3JtYXQgPSAnJztcblx0ICBpZiAoZGVjaW1hbHMgPD0gMCkge1xuXHQgICAgbnVtYmVyID0gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgZGVjaW1hbHMpKSAvIE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG5cdCAgICBmb3JtYXQgPSAnKCQwLDApJztcblx0ICB9IGVsc2UgaWYgKGRlY2ltYWxzID4gMCkge1xuXHQgICAgZm9ybWF0ID0gJygkMCwwLicgKyBuZXcgQXJyYXkoZGVjaW1hbHMgKyAxKS5qb2luKCcwJykgKyAnKSc7XG5cdCAgfVxuXHQgIHJldHVybiBudW1lcmFsKG51bWJlcikuZm9ybWF0KGZvcm1hdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5FWEFDVCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xuXHQgIHJldHVybiB0ZXh0MSA9PT0gdGV4dDI7XG5cdH07XG5cblx0ZXhwb3J0cy5GSU5EID0gZnVuY3Rpb24oZmluZF90ZXh0LCB3aXRoaW5fdGV4dCwgcG9zaXRpb24pIHtcblx0ICBwb3NpdGlvbiA9IChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSA/IDAgOiBwb3NpdGlvbjtcblx0ICByZXR1cm4gd2l0aGluX3RleHQgPyB3aXRoaW5fdGV4dC5pbmRleE9mKGZpbmRfdGV4dCwgcG9zaXRpb24gLSAxKSArIDEgOiBudWxsO1xuXHR9O1xuXG5cdGV4cG9ydHMuRklYRUQgPSBmdW5jdGlvbihudW1iZXIsIGRlY2ltYWxzLCBub19jb21tYXMpIHtcblx0ICBkZWNpbWFscyA9IChkZWNpbWFscyA9PT0gdW5kZWZpbmVkKSA/IDIgOiBkZWNpbWFscztcblx0ICBub19jb21tYXMgPSAobm9fY29tbWFzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBub19jb21tYXM7XG5cblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGRlY2ltYWxzID0gdXRpbHMucGFyc2VOdW1iZXIoZGVjaW1hbHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgZGVjaW1hbHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgdmFyIGZvcm1hdCA9IG5vX2NvbW1hcyA/ICcwJyA6ICcwLDAnO1xuXHQgIGlmIChkZWNpbWFscyA8PSAwKSB7XG5cdCAgICBudW1iZXIgPSBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBkZWNpbWFscykpIC8gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcblx0ICB9IGVsc2UgaWYgKGRlY2ltYWxzID4gMCkge1xuXHQgICAgZm9ybWF0ICs9ICcuJyArIG5ldyBBcnJheShkZWNpbWFscyArIDEpLmpvaW4oJzAnKTtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyYWwobnVtYmVyKS5mb3JtYXQoZm9ybWF0KTtcblx0fTtcblxuXHRleHBvcnRzLkhUTUwyVEVYVCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgIHZhciByZXN1bHQgPSAnJztcblxuXHQgIGlmICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuXHQgICAgICAgIGlmIChyZXN1bHQgIT09ICcnKSB7XG5cdCAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdCArPSAobGluZS5yZXBsYWNlKC88KD86LnxcXG4pKj8+L2dtLCAnJykpO1xuXHQgICAgICB9KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoLzwoPzoufFxcbikqPz4vZ20sICcnKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuTEVGVCA9IGZ1bmN0aW9uKHRleHQsIG51bWJlcikge1xuXHQgIG51bWJlciA9IChudW1iZXIgPT09IHVuZGVmaW5lZCkgPyAxIDogbnVtYmVyO1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gdGV4dCA/IHRleHQuc3Vic3RyaW5nKDAsIG51bWJlcikgOiBudWxsO1xuXHR9O1xuXG5cdGV4cG9ydHMuTEVOID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZXJyb3I7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIHRleHQgPyB0ZXh0Lmxlbmd0aCA6IDA7XG5cdCAgfVxuXG5cdCAgaWYgKHRleHQubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMuTE9XRVIgPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gdGV4dCA/IHRleHQudG9Mb3dlckNhc2UoKSA6IHRleHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5NSUQgPSBmdW5jdGlvbih0ZXh0LCBzdGFydCwgbnVtYmVyKSB7XG5cdCAgc3RhcnQgPSB1dGlscy5wYXJzZU51bWJlcihzdGFydCk7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihzdGFydCwgbnVtYmVyKSB8fCB0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgdmFyIGJlZ2luID0gc3RhcnQgLSAxO1xuXHQgIHZhciBlbmQgPSBiZWdpbiArIG51bWJlcjtcblxuXHQgIHJldHVybiB0ZXh0LnN1YnN0cmluZyhiZWdpbiwgZW5kKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuTlVNQkVSVkFMVUUgPSBmdW5jdGlvbiAodGV4dCwgZGVjaW1hbF9zZXBhcmF0b3IsIGdyb3VwX3NlcGFyYXRvcikgIHtcblx0ICBkZWNpbWFsX3NlcGFyYXRvciA9ICh0eXBlb2YgZGVjaW1hbF9zZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnKSA/ICcuJyA6IGRlY2ltYWxfc2VwYXJhdG9yO1xuXHQgIGdyb3VwX3NlcGFyYXRvciA9ICh0eXBlb2YgZ3JvdXBfc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJykgPyAnLCcgOiBncm91cF9zZXBhcmF0b3I7XG5cdCAgcmV0dXJuIE51bWJlcih0ZXh0LnJlcGxhY2UoZGVjaW1hbF9zZXBhcmF0b3IsICcuJykucmVwbGFjZShncm91cF9zZXBhcmF0b3IsICcnKSk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlBST05FVElDID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1BST05FVElDIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUFJPUEVSID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dC5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHRleHQgPT09IHRydWUpIHtcblx0ICAgIHRleHQgPSAnVFJVRSc7XG5cdCAgfVxuXHQgIGlmICh0ZXh0ID09PSBmYWxzZSkge1xuXHQgICAgdGV4dCA9ICdGQUxTRSc7XG5cdCAgfVxuXHQgIGlmIChpc05hTih0ZXh0KSAmJiB0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuXHQgICAgdGV4dCA9ICcnICsgdGV4dDtcblx0ICB9XG5cblx0ICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHdcXFMqL2csIGZ1bmN0aW9uKHR4dCkge1xuXHQgICAgcmV0dXJuIHR4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR4dC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcblx0ICB9KTtcblx0fTtcblxuXHRleHBvcnRzLlJFR0VYRVhUUkFDVCA9IGZ1bmN0aW9uICh0ZXh0LCByZWd1bGFyX2V4cHJlc3Npb24pIHtcblx0ICB2YXIgbWF0Y2ggPSB0ZXh0Lm1hdGNoKG5ldyBSZWdFeHAocmVndWxhcl9leHByZXNzaW9uKSk7XG5cdCAgcmV0dXJuIG1hdGNoID8gKG1hdGNoW21hdGNoLmxlbmd0aCA+IDEgPyBtYXRjaC5sZW5ndGggLSAxIDogMF0pIDogbnVsbDtcblx0fTtcblxuXHRleHBvcnRzLlJFR0VYTUFUQ0ggPSBmdW5jdGlvbiAodGV4dCwgcmVndWxhcl9leHByZXNzaW9uLCBmdWxsKSB7XG5cdCAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaChuZXcgUmVnRXhwKHJlZ3VsYXJfZXhwcmVzc2lvbikpO1xuXHQgIHJldHVybiBmdWxsID8gbWF0Y2ggOiAhIW1hdGNoO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkVHRVhSRVBMQUNFID0gZnVuY3Rpb24gKHRleHQsIHJlZ3VsYXJfZXhwcmVzc2lvbiwgcmVwbGFjZW1lbnQpIHtcblx0ICByZXR1cm4gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAocmVndWxhcl9leHByZXNzaW9uKSwgcmVwbGFjZW1lbnQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkVQTEFDRSA9IGZ1bmN0aW9uKHRleHQsIHBvc2l0aW9uLCBsZW5ndGgsIG5ld190ZXh0KSB7XG5cdCAgcG9zaXRpb24gPSB1dGlscy5wYXJzZU51bWJlcihwb3NpdGlvbik7XG5cdCAgbGVuZ3RoID0gdXRpbHMucGFyc2VOdW1iZXIobGVuZ3RoKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwb3NpdGlvbiwgbGVuZ3RoKSB8fFxuXHQgICAgdHlwZW9mIHRleHQgIT09ICdzdHJpbmcnIHx8XG5cdCAgICB0eXBlb2YgbmV3X3RleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiB0ZXh0LnN1YnN0cigwLCBwb3NpdGlvbiAtIDEpICsgbmV3X3RleHQgKyB0ZXh0LnN1YnN0cihwb3NpdGlvbiAtIDEgKyBsZW5ndGgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkVQVCA9IGZ1bmN0aW9uKHRleHQsIG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gbmV3IEFycmF5KG51bWJlciArIDEpLmpvaW4odGV4dCk7XG5cdH07XG5cblx0ZXhwb3J0cy5SSUdIVCA9IGZ1bmN0aW9uKHRleHQsIG51bWJlcikge1xuXHQgIG51bWJlciA9IChudW1iZXIgPT09IHVuZGVmaW5lZCkgPyAxIDogbnVtYmVyO1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gdGV4dCA/IHRleHQuc3Vic3RyaW5nKHRleHQubGVuZ3RoIC0gbnVtYmVyKSA6IG51bGw7XG5cdH07XG5cblx0ZXhwb3J0cy5TRUFSQ0ggPSBmdW5jdGlvbihmaW5kX3RleHQsIHdpdGhpbl90ZXh0LCBwb3NpdGlvbikge1xuXHQgIHZhciBmb3VuZEF0O1xuXHQgIGlmICh0eXBlb2YgZmluZF90ZXh0ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygd2l0aGluX3RleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHBvc2l0aW9uID0gKHBvc2l0aW9uID09PSB1bmRlZmluZWQpID8gMCA6IHBvc2l0aW9uO1xuXHQgIGZvdW5kQXQgPSB3aXRoaW5fdGV4dC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoZmluZF90ZXh0LnRvTG93ZXJDYXNlKCksIHBvc2l0aW9uIC0gMSkrMTtcblx0ICByZXR1cm4gKGZvdW5kQXQgPT09IDApP2Vycm9yLnZhbHVlOmZvdW5kQXQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TUExJVCA9IGZ1bmN0aW9uICh0ZXh0LCBzZXBhcmF0b3IpIHtcblx0ICByZXR1cm4gdGV4dC5zcGxpdChzZXBhcmF0b3IpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VCU1RJVFVURSA9IGZ1bmN0aW9uKHRleHQsIG9sZF90ZXh0LCBuZXdfdGV4dCwgb2NjdXJyZW5jZSkge1xuXHQgIGlmICghdGV4dCB8fCAhb2xkX3RleHQgfHwgIW5ld190ZXh0KSB7XG5cdCAgICByZXR1cm4gdGV4dDtcblx0ICB9IGVsc2UgaWYgKG9jY3VycmVuY2UgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIHRleHQucmVwbGFjZShuZXcgUmVnRXhwKG9sZF90ZXh0LCAnZycpLCBuZXdfdGV4dCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBpbmRleCA9IDA7XG5cdCAgICB2YXIgaSA9IDA7XG5cdCAgICB3aGlsZSAodGV4dC5pbmRleE9mKG9sZF90ZXh0LCBpbmRleCkgPiAwKSB7XG5cdCAgICAgIGluZGV4ID0gdGV4dC5pbmRleE9mKG9sZF90ZXh0LCBpbmRleCArIDEpO1xuXHQgICAgICBpKys7XG5cdCAgICAgIGlmIChpID09PSBvY2N1cnJlbmNlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKDAsIGluZGV4KSArIG5ld190ZXh0ICsgdGV4dC5zdWJzdHJpbmcoaW5kZXggKyBvbGRfdGV4dC5sZW5ndGgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuVCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpID8gdmFsdWUgOiAnJztcblx0fTtcblxuXHQvLyBUT0RPIGluY29tcGxldGUgaW1wbGVtZW50YXRpb25cblx0ZXhwb3J0cy5URVhUID0gZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuXHQgIHZhbHVlID0gdXRpbHMucGFyc2VOdW1iZXIodmFsdWUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIHJldHVybiBudW1lcmFsKHZhbHVlKS5mb3JtYXQoZm9ybWF0KTtcblx0fTtcblxuXHRleHBvcnRzLlRSSU0gPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gdGV4dC5yZXBsYWNlKC8gKy9nLCAnICcpLnRyaW0oKTtcblx0fTtcblxuXHRleHBvcnRzLlVOSUNIQVIgPSB0aGlzLkNIQVI7XG5cblx0ZXhwb3J0cy5VTklDT0RFID0gdGhpcy5DT0RFO1xuXG5cdGV4cG9ydHMuVVBQRVIgPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gdGV4dC50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVkFMVUUgPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtZXJhbCgpLnVuZm9ybWF0KHRleHQpO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOF9fO1xuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzlfXztcblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgdXRpbHMgICA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBudW1lcmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuXHRleHBvcnRzLlVOSVFVRSA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcblx0ICAgIHZhciBoYXNFbGVtZW50ID0gZmFsc2U7XG5cdCAgICB2YXIgZWxlbWVudCAgICA9IGFyZ3VtZW50c1tpXTtcblxuXHQgICAgLy8gQ2hlY2sgaWYgd2UndmUgYWxyZWFkeSBzZWVuIHRoaXMgZWxlbWVudC5cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVzdWx0Lmxlbmd0aDsgKytqKSB7XG5cdCAgICAgIGhhc0VsZW1lbnQgPSByZXN1bHRbal0gPT09IGVsZW1lbnQ7XG5cdCAgICAgIGlmIChoYXNFbGVtZW50KSB7IGJyZWFrOyB9XG5cdCAgICB9XG5cblx0ICAgIC8vIElmIHdlIGRpZCBub3QgZmluZCBpdCwgYWRkIGl0IHRvIHRoZSByZXN1bHQuXG5cdCAgICBpZiAoIWhhc0VsZW1lbnQpIHtcblx0ICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5GTEFUVEVOID0gdXRpbHMuZmxhdHRlbjtcblxuXHRleHBvcnRzLkFSR1MyQVJSQVkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdH07XG5cblx0ZXhwb3J0cy5SRUZFUkVOQ0UgPSBmdW5jdGlvbiAoY29udGV4dCwgcmVmZXJlbmNlKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBwYXRoID0gcmVmZXJlbmNlLnNwbGl0KCcuJyk7XG5cdCAgICB2YXIgcmVzdWx0ID0gY29udGV4dDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuXHQgICAgICB2YXIgc3RlcCA9IHBhdGhbaV07XG5cdCAgICAgIGlmIChzdGVwW3N0ZXAubGVuZ3RoIC0gMV0gPT09ICddJykge1xuXHQgICAgICAgIHZhciBvcGVuaW5nID0gc3RlcC5pbmRleE9mKCdbJyk7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gc3RlcC5zdWJzdHJpbmcob3BlbmluZyArIDEsIHN0ZXAubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgcmVzdWx0ID0gcmVzdWx0W3N0ZXAuc3Vic3RyaW5nKDAsIG9wZW5pbmcpXVtpbmRleF07XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmVzdWx0ID0gcmVzdWx0W3N0ZXBdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7fVxuXHR9O1xuXG5cdGV4cG9ydHMuSk9JTiA9IGZ1bmN0aW9uIChhcnJheSwgc2VwYXJhdG9yKSB7XG5cdCAgcmV0dXJuIGFycmF5LmpvaW4oc2VwYXJhdG9yKTtcblx0fTtcblxuXHRleHBvcnRzLk5VTUJFUlMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHBvc3NpYmxlTnVtYmVycyA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICByZXR1cm4gcG9zc2libGVOdW1iZXJzLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcblx0ICAgIHJldHVybiB0eXBlb2YgZWwgPT09ICdudW1iZXInO1xuXHQgIH0pO1xuXHR9O1xuXG5cdGV4cG9ydHMuTlVNRVJBTCA9IGZ1bmN0aW9uIChudW1iZXIsIGZvcm1hdCkge1xuXHQgIHJldHVybiBudW1lcmFsKG51bWJlcikuZm9ybWF0KGZvcm1hdCk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ0VMTCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdDRUxMIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRVJST1IgPSB7fTtcblx0ZXhwb3J0cy5FUlJPUi5UWVBFID0gZnVuY3Rpb24oZXJyb3JfdmFsKSB7XG5cdCAgc3dpdGNoIChlcnJvcl92YWwpIHtcblx0ICAgIGNhc2UgZXJyb3IubmlsOiByZXR1cm4gMTtcblx0ICAgIGNhc2UgZXJyb3IuZGl2MDogcmV0dXJuIDI7XG5cdCAgICBjYXNlIGVycm9yLnZhbHVlOiByZXR1cm4gMztcblx0ICAgIGNhc2UgZXJyb3IucmVmOiByZXR1cm4gNDtcblx0ICAgIGNhc2UgZXJyb3IubmFtZTogcmV0dXJuIDU7XG5cdCAgICBjYXNlIGVycm9yLm51bTogcmV0dXJuIDY7XG5cdCAgICBjYXNlIGVycm9yLm5hOiByZXR1cm4gNztcblx0ICAgIGNhc2UgZXJyb3IuZGF0YTogcmV0dXJuIDg7XG5cdCAgfVxuXHQgIHJldHVybiBlcnJvci5uYTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuSU5GTyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdJTkZPIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNCTEFOSyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNCSU5BUlkgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG5cdCAgcmV0dXJuICgvXlswMV17MSwxMH0kLykudGVzdChudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNFUlIgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiAoW2Vycm9yLnZhbHVlLCBlcnJvci5yZWYsIGVycm9yLmRpdjAsIGVycm9yLm51bSwgZXJyb3IubmFtZSwgZXJyb3IubmlsXSkuaW5kZXhPZih2YWx1ZSkgPj0gMCB8fFxuXHQgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JU0VSUk9SID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gZXhwb3J0cy5JU0VSUih2YWx1ZSkgfHwgdmFsdWUgPT09IGVycm9yLm5hO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNFVkVOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgcmV0dXJuIChNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpICYgMSkgPyBmYWxzZSA6IHRydWU7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLklTRk9STVVMQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignSVNGT1JNVUxBIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNMT0dJQ0FMID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNOQSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09PSBlcnJvci5uYTtcblx0fTtcblxuXHRleHBvcnRzLklTTk9OVEVYVCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgIT09ICdzdHJpbmcnO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNOVU1CRVIgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIGlzRmluaXRlKHZhbHVlKTtcblx0fTtcblxuXHRleHBvcnRzLklTT0REID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgcmV0dXJuIChNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpICYgMSkgPyB0cnVlIDogZmFsc2U7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLklTUkVGID0gZnVuY3Rpb24oKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdJU1JFRiBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLklTVEVYVCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09ICdzdHJpbmcnO1xuXHR9O1xuXG5cdGV4cG9ydHMuTiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgaWYgKHRoaXMuSVNOVU1CRVIodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHQgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0ICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XG5cdCAgfVxuXHQgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuXHQgICAgcmV0dXJuIDE7XG5cdCAgfVxuXHQgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblx0ICBpZiAodGhpcy5JU0VSUk9SKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gMDtcblx0fTtcblxuXHRleHBvcnRzLk5BID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIGVycm9yLm5hO1xuXHR9O1xuXG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlNIRUVUID0gZnVuY3Rpb24oKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdTSEVFVCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuU0hFRVRTID0gZnVuY3Rpb24oKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdTSEVFVFMgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5UWVBFID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICBpZiAodGhpcy5JU05VTUJFUih2YWx1ZSkpIHtcblx0ICAgIHJldHVybiAxO1xuXHQgIH1cblx0ICBpZiAodGhpcy5JU1RFWFQodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gMjtcblx0ICB9XG5cdCAgaWYgKHRoaXMuSVNMT0dJQ0FMKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIDQ7XG5cdCAgfVxuXHQgIGlmICh0aGlzLklTRVJST1IodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gMTY7XG5cdCAgfVxuXHQgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIDY0O1xuXHQgIH1cblx0fTtcblxuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBqU3RhdCA9IF9fd2VicGFja19yZXF1aXJlX18oOSkualN0YXQ7XG5cdHZhciB0ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIGJlc3NlbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5cdGZ1bmN0aW9uIGlzVmFsaWRCaW5hcnlOdW1iZXIobnVtYmVyKSB7XG5cdCAgcmV0dXJuICgvXlswMV17MSwxMH0kLykudGVzdChudW1iZXIpO1xuXHR9XG5cblx0ZXhwb3J0cy5CRVNTRUxJID0gZnVuY3Rpb24oeCwgbikge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGJlc3NlbC5iZXNzZWxpKHgsIG4pO1xuXHR9O1xuXG5cdGV4cG9ydHMuQkVTU0VMSiA9IGZ1bmN0aW9uKHgsIG4pIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBiZXNzZWwuYmVzc2Vsaih4LCBuKTtcblx0fTtcblxuXHRleHBvcnRzLkJFU1NFTEsgPSBmdW5jdGlvbih4LCBuKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gYmVzc2VsLmJlc3NlbGsoeCwgbik7XG5cdH07XG5cblx0ZXhwb3J0cy5CRVNTRUxZID0gZnVuY3Rpb24oeCwgbikge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGJlc3NlbC5iZXNzZWx5KHgsIG4pO1xuXHR9O1xuXG5cdGV4cG9ydHMuQklOMkRFQyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGJpbmFyeSBvciBjb250YWlucyBtb3JlIHRoYW4gMTAgY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghaXNWYWxpZEJpbmFyeU51bWJlcihudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgYmluYXJ5IG51bWJlciB0byBkZWNpbWFsXG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMik7XG5cblx0ICAvLyBIYW5kbGUgbmVnYXRpdmUgbnVtYmVyc1xuXHQgIHZhciBzdHJpbmdpZmllZCA9IG51bWJlci50b1N0cmluZygpO1xuXHQgIGlmIChzdHJpbmdpZmllZC5sZW5ndGggPT09IDEwICYmIHN0cmluZ2lmaWVkLnN1YnN0cmluZygwLCAxKSA9PT0gJzEnKSB7XG5cdCAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5naWZpZWQuc3Vic3RyaW5nKDEpLCAyKSAtIDUxMjtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cdH07XG5cblxuXHRleHBvcnRzLkJJTjJIRVggPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGJpbmFyeSBvciBjb250YWlucyBtb3JlIHRoYW4gMTAgY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghaXNWYWxpZEJpbmFyeU51bWJlcihudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBoZXhhZGVjaW1hbCBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgdmFyIHN0cmluZ2lmaWVkID0gbnVtYmVyLnRvU3RyaW5nKCk7XG5cdCAgaWYgKHN0cmluZ2lmaWVkLmxlbmd0aCA9PT0gMTAgJiYgc3RyaW5naWZpZWQuc3Vic3RyaW5nKDAsIDEpID09PSAnMScpIHtcblx0ICAgIHJldHVybiAoMTA5OTUxMTYyNzI2NCArIHBhcnNlSW50KHN0cmluZ2lmaWVkLnN1YnN0cmluZygxKSwgMikpLnRvU3RyaW5nKDE2KTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGJpbmFyeSBudW1iZXIgdG8gaGV4YWRlY2ltYWxcblx0ICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQobnVtYmVyLCAyKS50b1N0cmluZygxNik7XG5cblx0ICAvLyBSZXR1cm4gaGV4YWRlY2ltYWwgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHBsYWNlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5CSU4yT0NUID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBiaW5hcnkgb3IgY29udGFpbnMgbW9yZSB0aGFuIDEwIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIWlzVmFsaWRCaW5hcnlOdW1iZXIobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgb2N0YWwgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIHZhciBzdHJpbmdpZmllZCA9IG51bWJlci50b1N0cmluZygpO1xuXHQgIGlmIChzdHJpbmdpZmllZC5sZW5ndGggPT09IDEwICYmIHN0cmluZ2lmaWVkLnN1YnN0cmluZygwLCAxKSA9PT0gJzEnKSB7XG5cdCAgICByZXR1cm4gKDEwNzM3NDEzMTIgKyBwYXJzZUludChzdHJpbmdpZmllZC5zdWJzdHJpbmcoMSksIDIpKS50b1N0cmluZyg4KTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGJpbmFyeSBudW1iZXIgdG8gb2N0YWxcblx0ICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQobnVtYmVyLCAyKS50b1N0cmluZyg4KTtcblxuXHQgIC8vIFJldHVybiBvY3RhbCBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAocGxhY2VzID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkJJVEFORCA9IGZ1bmN0aW9uKG51bWJlcjEsIG51bWJlcjIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBhIG5vbi1udW1lcmljIHZhbHVlXG5cdCAgbnVtYmVyMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjEpO1xuXHQgIG51bWJlcjIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIxLCBudW1iZXIyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGxlc3MgdGhhbiAwXG5cdCAgaWYgKG51bWJlcjEgPCAwIHx8IG51bWJlcjIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGEgbm9uLWludGVnZXJcblx0ICBpZiAoTWF0aC5mbG9vcihudW1iZXIxKSAhPT0gbnVtYmVyMSB8fCBNYXRoLmZsb29yKG51bWJlcjIpICE9PSBudW1iZXIyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiAoMl40OCktMVxuXHQgIGlmIChudW1iZXIxID4gMjgxNDc0OTc2NzEwNjU1IHx8IG51bWJlcjIgPiAyODE0NzQ5NzY3MTA2NTUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGJpdHdpc2UgQU5EIG9mIHR3byBudW1iZXJzXG5cdCAgcmV0dXJuIG51bWJlcjEgJiBudW1iZXIyO1xuXHR9O1xuXG5cdGV4cG9ydHMuQklUTFNISUZUID0gZnVuY3Rpb24obnVtYmVyLCBzaGlmdCkge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgc2hpZnQgPSB1dGlscy5wYXJzZU51bWJlcihzaGlmdCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBzaGlmdCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGxlc3MgdGhhbiAwXG5cdCAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBhIG5vbi1pbnRlZ2VyXG5cdCAgaWYgKE1hdGguZmxvb3IobnVtYmVyKSAhPT0gbnVtYmVyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgZ3JlYXRlciB0aGFuICgyXjQ4KS0xXG5cdCAgaWYgKG51bWJlciA+IDI4MTQ3NDk3NjcxMDY1NSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgdGhlIGFic29sdXRlIHZhbHVlIG9mIHNoaWZ0IGlzIGdyZWF0ZXIgdGhhbiA1M1xuXHQgIGlmIChNYXRoLmFicyhzaGlmdCkgPiA1Mykge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gbnVtYmVyIHNoaWZ0ZWQgYnkgc2hpZnQgYml0cyB0byB0aGUgbGVmdCBvciB0byB0aGUgcmlnaHQgaWYgc2hpZnQgaXMgbmVnYXRpdmVcblx0ICByZXR1cm4gKHNoaWZ0ID49IDApID8gbnVtYmVyIDw8IHNoaWZ0IDogbnVtYmVyID4+IC1zaGlmdDtcblx0fTtcblxuXHRleHBvcnRzLkJJVE9SID0gZnVuY3Rpb24obnVtYmVyMSwgbnVtYmVyMikge1xuXHQgIG51bWJlcjEgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIxKTtcblx0ICBudW1iZXIyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyMSwgbnVtYmVyMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBsZXNzIHRoYW4gMFxuXHQgIGlmIChudW1iZXIxIDwgMCB8fCBudW1iZXIyIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBhIG5vbi1pbnRlZ2VyXG5cdCAgaWYgKE1hdGguZmxvb3IobnVtYmVyMSkgIT09IG51bWJlcjEgfHwgTWF0aC5mbG9vcihudW1iZXIyKSAhPT0gbnVtYmVyMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBncmVhdGVyIHRoYW4gKDJeNDgpLTFcblx0ICBpZiAobnVtYmVyMSA+IDI4MTQ3NDk3NjcxMDY1NSB8fCBudW1iZXIyID4gMjgxNDc0OTc2NzEwNjU1KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBiaXR3aXNlIE9SIG9mIHR3byBudW1iZXJzXG5cdCAgcmV0dXJuIG51bWJlcjEgfCBudW1iZXIyO1xuXHR9O1xuXG5cdGV4cG9ydHMuQklUUlNISUZUID0gZnVuY3Rpb24obnVtYmVyLCBzaGlmdCkge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgc2hpZnQgPSB1dGlscy5wYXJzZU51bWJlcihzaGlmdCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBzaGlmdCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGxlc3MgdGhhbiAwXG5cdCAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBhIG5vbi1pbnRlZ2VyXG5cdCAgaWYgKE1hdGguZmxvb3IobnVtYmVyKSAhPT0gbnVtYmVyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgZ3JlYXRlciB0aGFuICgyXjQ4KS0xXG5cdCAgaWYgKG51bWJlciA+IDI4MTQ3NDk3NjcxMDY1NSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgdGhlIGFic29sdXRlIHZhbHVlIG9mIHNoaWZ0IGlzIGdyZWF0ZXIgdGhhbiA1M1xuXHQgIGlmIChNYXRoLmFicyhzaGlmdCkgPiA1Mykge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gbnVtYmVyIHNoaWZ0ZWQgYnkgc2hpZnQgYml0cyB0byB0aGUgcmlnaHQgb3IgdG8gdGhlIGxlZnQgaWYgc2hpZnQgaXMgbmVnYXRpdmVcblx0ICByZXR1cm4gKHNoaWZ0ID49IDApID8gbnVtYmVyID4+IHNoaWZ0IDogbnVtYmVyIDw8IC1zaGlmdDtcblx0fTtcblxuXHRleHBvcnRzLkJJVFhPUiA9IGZ1bmN0aW9uKG51bWJlcjEsIG51bWJlcjIpIHtcblx0ICBudW1iZXIxID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMSk7XG5cdCAgbnVtYmVyMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlcjEsIG51bWJlcjIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgbGVzcyB0aGFuIDBcblx0ICBpZiAobnVtYmVyMSA8IDAgfHwgbnVtYmVyMiA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgYSBub24taW50ZWdlclxuXHQgIGlmIChNYXRoLmZsb29yKG51bWJlcjEpICE9PSBudW1iZXIxIHx8IE1hdGguZmxvb3IobnVtYmVyMikgIT09IG51bWJlcjIpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgZ3JlYXRlciB0aGFuICgyXjQ4KS0xXG5cdCAgaWYgKG51bWJlcjEgPiAyODE0NzQ5NzY3MTA2NTUgfHwgbnVtYmVyMiA+IDI4MTQ3NDk3NjcxMDY1NSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYml0d2lzZSBYT1Igb2YgdHdvIG51bWJlcnNcblx0ICByZXR1cm4gbnVtYmVyMSBeIG51bWJlcjI7XG5cdH07XG5cblx0ZXhwb3J0cy5DT01QTEVYID0gZnVuY3Rpb24ocmVhbCwgaW1hZ2luYXJ5LCBzdWZmaXgpIHtcblx0ICByZWFsID0gdXRpbHMucGFyc2VOdW1iZXIocmVhbCk7XG5cdCAgaW1hZ2luYXJ5ID0gdXRpbHMucGFyc2VOdW1iZXIoaW1hZ2luYXJ5KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyZWFsLCBpbWFnaW5hcnkpKSB7XG5cdCAgICByZXR1cm4gcmVhbDtcblx0ICB9XG5cblx0ICAvLyBTZXQgc3VmZml4XG5cdCAgc3VmZml4ID0gKHN1ZmZpeCA9PT0gdW5kZWZpbmVkKSA/ICdpJyA6IHN1ZmZpeDtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBzdWZmaXggaXMgbmVpdGhlciBcImlcIiBub3IgXCJqXCJcblx0ICBpZiAoc3VmZml4ICE9PSAnaScgJiYgc3VmZml4ICE9PSAnaicpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gY29tcGxleCBudW1iZXJcblx0ICBpZiAocmVhbCA9PT0gMCAmJiBpbWFnaW5hcnkgPT09IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH0gZWxzZSBpZiAocmVhbCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIChpbWFnaW5hcnkgPT09IDEpID8gc3VmZml4IDogaW1hZ2luYXJ5LnRvU3RyaW5nKCkgKyBzdWZmaXg7XG5cdCAgfSBlbHNlIGlmIChpbWFnaW5hcnkgPT09IDApIHtcblx0ICAgIHJldHVybiByZWFsLnRvU3RyaW5nKCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBzaWduID0gKGltYWdpbmFyeSA+IDApID8gJysnIDogJyc7XG5cdCAgICByZXR1cm4gcmVhbC50b1N0cmluZygpICsgc2lnbiArICgoaW1hZ2luYXJ5ID09PSAxKSA/IHN1ZmZpeCA6IGltYWdpbmFyeS50b1N0cmluZygpICsgc3VmZml4KTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5DT05WRVJUID0gZnVuY3Rpb24obnVtYmVyLCBmcm9tX3VuaXQsIHRvX3VuaXQpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cblx0ICAvLyBMaXN0IG9mIHVuaXRzIHN1cHBvcnRlZCBieSBDT05WRVJUIGFuZCB1bml0cyBkZWZpbmVkIGJ5IHRoZSBJbnRlcm5hdGlvbmFsIFN5c3RlbSBvZiBVbml0c1xuXHQgIC8vIFtOYW1lLCBTeW1ib2wsIEFsdGVybmF0ZSBzeW1ib2xzLCBRdWFudGl0eSwgSVNVLCBDT05WRVJULCBDb252ZXJzaW9uIHJhdGlvXVxuXHQgIHZhciB1bml0cyA9IFtcblx0ICAgIFtcImEudS4gb2YgYWN0aW9uXCIsIFwiP1wiLCBudWxsLCBcImFjdGlvblwiLCBmYWxzZSwgZmFsc2UsIDEuMDU0NTcxNjgxODE4MThlLTM0XSxcblx0ICAgIFtcImEudS4gb2YgY2hhcmdlXCIsIFwiZVwiLCBudWxsLCBcImVsZWN0cmljX2NoYXJnZVwiLCBmYWxzZSwgZmFsc2UsIDEuNjAyMTc2NTMxNDE0MTRlLTE5XSxcblx0ICAgIFtcImEudS4gb2YgZW5lcmd5XCIsIFwiRWhcIiwgbnVsbCwgXCJlbmVyZ3lcIiwgZmFsc2UsIGZhbHNlLCA0LjM1OTc0NDE3NzU3NTc2ZS0xOF0sXG5cdCAgICBbXCJhLnUuIG9mIGxlbmd0aFwiLCBcImE/XCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCBmYWxzZSwgNS4yOTE3NzIxMDgxODE4MmUtMTFdLFxuXHQgICAgW1wiYS51LiBvZiBtYXNzXCIsIFwibT9cIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCBmYWxzZSwgOS4xMDkzODI2MTYxNjE2MmUtMzFdLFxuXHQgICAgW1wiYS51LiBvZiB0aW1lXCIsIFwiPy9FaFwiLCBudWxsLCBcInRpbWVcIiwgZmFsc2UsIGZhbHNlLCAyLjQxODg4NDMyNjUwNTE2ZS0xN10sXG5cdCAgICBbXCJhZG1pcmFsdHkga25vdFwiLCBcImFkbWtuXCIsIG51bGwsIFwic3BlZWRcIiwgZmFsc2UsIHRydWUsIDAuNTE0NzczMzMzXSxcblx0ICAgIFtcImFtcGVyZVwiLCBcIkFcIiwgbnVsbCwgXCJlbGVjdHJpY19jdXJyZW50XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImFtcGVyZSBwZXIgbWV0ZXJcIiwgXCJBL21cIiwgbnVsbCwgXCJtYWduZXRpY19maWVsZF9pbnRlbnNpdHlcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiw6VuZ3N0csO2bVwiLCBcIsOFXCIsIFtcImFuZ1wiXSwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDFlLTEwXSxcblx0ICAgIFtcImFyZVwiLCBcImFyXCIsIG51bGwsIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMTAwXSxcblx0ICAgIFtcImFzdHJvbm9taWNhbCB1bml0XCIsIFwidWFcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIGZhbHNlLCAxLjQ5NTk3ODcwNjkxNjY3ZS0xMV0sXG5cdCAgICBbXCJiYXJcIiwgXCJiYXJcIiwgbnVsbCwgXCJwcmVzc3VyZVwiLCBmYWxzZSwgZmFsc2UsIDEwMDAwMF0sXG5cdCAgICBbXCJiYXJuXCIsIFwiYlwiLCBudWxsLCBcImFyZWFcIiwgZmFsc2UsIGZhbHNlLCAxZS0yOF0sXG5cdCAgICBbXCJiZWNxdWVyZWxcIiwgXCJCcVwiLCBudWxsLCBcInJhZGlvYWN0aXZpdHlcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiYml0XCIsIFwiYml0XCIsIFtcImJcIl0sIFwiaW5mb3JtYXRpb25cIiwgZmFsc2UsIHRydWUsIDFdLFxuXHQgICAgW1wiYnR1XCIsIFwiQlRVXCIsIFtcImJ0dVwiXSwgXCJlbmVyZ3lcIiwgZmFsc2UsIHRydWUsIDEwNTUuMDU1ODUyNjJdLFxuXHQgICAgW1wiYnl0ZVwiLCBcImJ5dGVcIiwgbnVsbCwgXCJpbmZvcm1hdGlvblwiLCBmYWxzZSwgdHJ1ZSwgOF0sXG5cdCAgICBbXCJjYW5kZWxhXCIsIFwiY2RcIiwgbnVsbCwgXCJsdW1pbm91c19pbnRlbnNpdHlcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiY2FuZGVsYSBwZXIgc3F1YXJlIG1ldHJlXCIsIFwiY2QvbT9cIiwgbnVsbCwgXCJsdW1pbmFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiY291bG9tYlwiLCBcIkNcIiwgbnVsbCwgXCJlbGVjdHJpY19jaGFyZ2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiY3ViaWMgw6VuZ3N0csO2bVwiLCBcImFuZzNcIiwgW1wiYW5nXjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAxZS0zMF0sXG5cdCAgICBbXCJjdWJpYyBmb290XCIsIFwiZnQzXCIsIFtcImZ0XjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAyODMxNjg0NjU5Ml0sXG5cdCAgICBbXCJjdWJpYyBpbmNoXCIsIFwiaW4zXCIsIFtcImluXjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAxNjM4NzA2NF0sXG5cdCAgICBbXCJjdWJpYyBsaWdodC15ZWFyXCIsIFwibHkzXCIsIFtcImx5XjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCA4LjQ2Nzg2NjY0NjIzNzE1ZS00N10sXG5cdCAgICBbXCJjdWJpYyBtZXRyZVwiLCBcIm0/XCIsIG51bGwsIFwidm9sdW1lXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wiY3ViaWMgbWlsZVwiLCBcIm1pM1wiLCBbXCJtaV4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgNDE2ODE4MTgyNS40NDA1OF0sXG5cdCAgICBbXCJjdWJpYyBuYXV0aWNhbCBtaWxlXCIsIFwiTm1pM1wiLCBbXCJObWleM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDYzNTIxODIyMDhdLFxuXHQgICAgW1wiY3ViaWMgUGljYVwiLCBcIlBpY2EzXCIsIFtcIlBpY2FwdDNcIiwgXCJQaWNhXjNcIiwgXCJQaWNhcHReM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDcuNTg2NjAzNzAzNzAzNjllLThdLFxuXHQgICAgW1wiY3ViaWMgeWFyZFwiLCBcInlkM1wiLCBbXCJ5ZF4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC43NjQ1NTQ4NTc5ODRdLFxuXHQgICAgW1wiY3VwXCIsIFwiY3VwXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDIzNjU4ODIzNjVdLFxuXHQgICAgW1wiZGFsdG9uXCIsIFwiRGFcIiwgW1widVwiXSwgXCJtYXNzXCIsIGZhbHNlLCBmYWxzZSwgMS42NjA1Mzg4NjI4MjgyOGUtMjddLFxuXHQgICAgW1wiZGF5XCIsIFwiZFwiLCBbXCJkYXlcIl0sIFwidGltZVwiLCBmYWxzZSwgdHJ1ZSwgODY0MDBdLFxuXHQgICAgW1wiZGVncmVlXCIsIFwiwrBcIiwgbnVsbCwgXCJhbmdsZVwiLCBmYWxzZSwgZmFsc2UsIDAuMDE3NDUzMjkyNTE5OTQzM10sXG5cdCAgICBbXCJkZWdyZWVzIFJhbmtpbmVcIiwgXCJSYW5rXCIsIG51bGwsIFwidGVtcGVyYXR1cmVcIiwgZmFsc2UsIHRydWUsIDAuNTU1NTU1NTU1NTU1NTU2XSxcblx0ICAgIFtcImR5bmVcIiwgXCJkeW5cIiwgW1wiZHlcIl0sIFwiZm9yY2VcIiwgZmFsc2UsIHRydWUsIDAuMDAwMDFdLFxuXHQgICAgW1wiZWxlY3Ryb252b2x0XCIsIFwiZVZcIiwgW1wiZXZcIl0sIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCAxLjYwMjE3NjU2NTE0MTQxXSxcblx0ICAgIFtcImVsbFwiLCBcImVsbFwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMS4xNDNdLFxuXHQgICAgW1wiZXJnXCIsIFwiZXJnXCIsIFtcImVcIl0sIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCAxZS03XSxcblx0ICAgIFtcImZhcmFkXCIsIFwiRlwiLCBudWxsLCBcImVsZWN0cmljX2NhcGFjaXRhbmNlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImZsdWlkIG91bmNlXCIsIFwib3pcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwMDI5NTczNTI5NTYyNV0sXG5cdCAgICBbXCJmb290XCIsIFwiZnRcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDAuMzA0OF0sXG5cdCAgICBbXCJmb290LXBvdW5kXCIsIFwiZmxiXCIsIG51bGwsIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCAxLjM1NTgxNzk0ODMzMTRdLFxuXHQgICAgW1wiZ2FsXCIsIFwiR2FsXCIsIG51bGwsIFwiYWNjZWxlcmF0aW9uXCIsIGZhbHNlLCBmYWxzZSwgMC4wMV0sXG5cdCAgICBbXCJnYWxsb25cIiwgXCJnYWxcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAzNzg1NDExNzg0XSxcblx0ICAgIFtcImdhdXNzXCIsIFwiR1wiLCBbXCJnYVwiXSwgXCJtYWduZXRpY19mbHV4X2RlbnNpdHlcIiwgZmFsc2UsIHRydWUsIDFdLFxuXHQgICAgW1wiZ3JhaW5cIiwgXCJncmFpblwiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDAuMDAwMDY0Nzk4OV0sXG5cdCAgICBbXCJncmFtXCIsIFwiZ1wiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDAuMDAxXSxcblx0ICAgIFtcImdyYXlcIiwgXCJHeVwiLCBudWxsLCBcImFic29yYmVkX2Rvc2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiZ3Jvc3MgcmVnaXN0ZXJlZCB0b25cIiwgXCJHUlRcIiwgW1wicmVndG9uXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMi44MzE2ODQ2NTkyXSxcblx0ICAgIFtcImhlY3RhcmVcIiwgXCJoYVwiLCBudWxsLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDEwMDAwXSxcblx0ICAgIFtcImhlbnJ5XCIsIFwiSFwiLCBudWxsLCBcImluZHVjdGFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiaGVydHpcIiwgXCJIelwiLCBudWxsLCBcImZyZXF1ZW5jeVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJob3JzZXBvd2VyXCIsIFwiSFBcIiwgW1wiaFwiXSwgXCJwb3dlclwiLCBmYWxzZSwgdHJ1ZSwgNzQ1LjY5OTg3MTU4MjI3XSxcblx0ICAgIFtcImhvcnNlcG93ZXItaG91clwiLCBcIkhQaFwiLCBbXCJoaFwiLCBcImhwaFwiXSwgXCJlbmVyZ3lcIiwgZmFsc2UsIHRydWUsIDI2ODQ1MTkuNTM4XSxcblx0ICAgIFtcImhvdXJcIiwgXCJoXCIsIFtcImhyXCJdLCBcInRpbWVcIiwgZmFsc2UsIHRydWUsIDM2MDBdLFxuXHQgICAgW1wiaW1wZXJpYWwgZ2FsbG9uIChVLksuKVwiLCBcInVrX2dhbFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDQ1NDYwOV0sXG5cdCAgICBbXCJpbXBlcmlhbCBodW5kcmVkd2VpZ2h0XCIsIFwibGN3dFwiLCBbXCJ1a19jd3RcIiwgXCJod2VpZ2h0XCJdLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDUwLjgwMjM0NV0sXG5cdCAgICBbXCJpbXBlcmlhbCBxdWFydCAoVS5LKVwiLCBcInVrX3F0XCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMTEzNjUyMjVdLFxuXHQgICAgW1wiaW1wZXJpYWwgdG9uXCIsIFwiYnJ0b25cIiwgW1widWtfdG9uXCIsIFwiTFRPTlwiXSwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCAxMDE2LjA0NjkwOV0sXG5cdCAgICBbXCJpbmNoXCIsIFwiaW5cIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDAuMDI1NF0sXG5cdCAgICBbXCJpbnRlcm5hdGlvbmFsIGFjcmVcIiwgXCJ1a19hY3JlXCIsIG51bGwsIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgNDA0Ni44NTY0MjI0XSxcblx0ICAgIFtcIklUIGNhbG9yaWVcIiwgXCJjYWxcIiwgbnVsbCwgXCJlbmVyZ3lcIiwgZmFsc2UsIHRydWUsIDQuMTg2OF0sXG5cdCAgICBbXCJqb3VsZVwiLCBcIkpcIiwgbnVsbCwgXCJlbmVyZ3lcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJrYXRhbFwiLCBcImthdFwiLCBudWxsLCBcImNhdGFseXRpY19hY3Rpdml0eVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJrZWx2aW5cIiwgXCJLXCIsIFtcImtlbFwiXSwgXCJ0ZW1wZXJhdHVyZVwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcImtpbG9ncmFtXCIsIFwia2dcIiwgbnVsbCwgXCJtYXNzXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wia25vdFwiLCBcImtuXCIsIG51bGwsIFwic3BlZWRcIiwgZmFsc2UsIHRydWUsIDAuNTE0NDQ0NDQ0NDQ0NDQ0XSxcblx0ICAgIFtcImxpZ2h0LXllYXJcIiwgXCJseVwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgOTQ2MDczMDQ3MjU4MDgwMF0sXG5cdCAgICBbXCJsaXRyZVwiLCBcIkxcIiwgW1wibFwiLCBcImx0XCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDFdLFxuXHQgICAgW1wibHVtZW5cIiwgXCJsbVwiLCBudWxsLCBcImx1bWlub3VzX2ZsdXhcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wibHV4XCIsIFwibHhcIiwgbnVsbCwgXCJpbGx1bWluYW5jZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJtYXh3ZWxsXCIsIFwiTXhcIiwgbnVsbCwgXCJtYWduZXRpY19mbHV4XCIsIGZhbHNlLCBmYWxzZSwgMWUtMThdLFxuXHQgICAgW1wibWVhc3VyZW1lbnQgdG9uXCIsIFwiTVRPTlwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMS4xMzI2NzM4NjM2OF0sXG5cdCAgICBbXCJtZXRlciBwZXIgaG91clwiLCBcIm0vaFwiLCBbXCJtL2hyXCJdLCBcInNwZWVkXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDI3Nzc3Nzc3Nzc3Nzc4XSxcblx0ICAgIFtcIm1ldGVyIHBlciBzZWNvbmRcIiwgXCJtL3NcIiwgW1wibS9zZWNcIl0sIFwic3BlZWRcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJtZXRlciBwZXIgc2Vjb25kIHNxdWFyZWRcIiwgXCJtP3M/P1wiLCBudWxsLCBcImFjY2VsZXJhdGlvblwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJwYXJzZWNcIiwgXCJwY1wiLCBbXCJwYXJzZWNcIl0sIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAzMDg1Njc3NTgxNDY3MTkwMF0sXG5cdCAgICBbXCJtZXRlciBzcXVhcmVkIHBlciBzZWNvbmRcIiwgXCJtPy9zXCIsIG51bGwsIFwia2luZW1hdGljX3Zpc2Nvc2l0eVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJtZXRyZVwiLCBcIm1cIiwgbnVsbCwgXCJsZW5ndGhcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJtaWxlcyBwZXIgaG91clwiLCBcIm1waFwiLCBudWxsLCBcInNwZWVkXCIsIGZhbHNlLCB0cnVlLCAwLjQ0NzA0XSxcblx0ICAgIFtcIm1pbGxpbWV0cmUgb2YgbWVyY3VyeVwiLCBcIm1tSGdcIiwgbnVsbCwgXCJwcmVzc3VyZVwiLCBmYWxzZSwgZmFsc2UsIDEzMy4zMjJdLFxuXHQgICAgW1wibWludXRlXCIsIFwiP1wiLCBudWxsLCBcImFuZ2xlXCIsIGZhbHNlLCBmYWxzZSwgMC4wMDAyOTA4ODgyMDg2NjU3MjJdLFxuXHQgICAgW1wibWludXRlXCIsIFwibWluXCIsIFtcIm1uXCJdLCBcInRpbWVcIiwgZmFsc2UsIHRydWUsIDYwXSxcblx0ICAgIFtcIm1vZGVybiB0ZWFzcG9vblwiLCBcInRzcG1cIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwMDA1XSxcblx0ICAgIFtcIm1vbGVcIiwgXCJtb2xcIiwgbnVsbCwgXCJhbW91bnRfb2Zfc3Vic3RhbmNlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcIm1vcmdlblwiLCBcIk1vcmdlblwiLCBudWxsLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDI1MDBdLFxuXHQgICAgW1wibi51LiBvZiBhY3Rpb25cIiwgXCI/XCIsIG51bGwsIFwiYWN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgMS4wNTQ1NzE2ODE4MTgxOGUtMzRdLFxuXHQgICAgW1wibi51LiBvZiBtYXNzXCIsIFwibT9cIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCBmYWxzZSwgOS4xMDkzODI2MTYxNjE2MmUtMzFdLFxuXHQgICAgW1wibi51LiBvZiBzcGVlZFwiLCBcImM/XCIsIG51bGwsIFwic3BlZWRcIiwgZmFsc2UsIGZhbHNlLCAyOTk3OTI0NThdLFxuXHQgICAgW1wibi51LiBvZiB0aW1lXCIsIFwiPy8obWU/Yz8/KVwiLCBudWxsLCBcInRpbWVcIiwgZmFsc2UsIGZhbHNlLCAxLjI4ODA4ODY2Nzc4Njg3ZS0yMV0sXG5cdCAgICBbXCJuYXV0aWNhbCBtaWxlXCIsIFwiTVwiLCBbXCJObWlcIl0sIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAxODUyXSxcblx0ICAgIFtcIm5ld3RvblwiLCBcIk5cIiwgbnVsbCwgXCJmb3JjZVwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcIsWTcnN0ZWRcIiwgXCJPZSBcIiwgbnVsbCwgXCJtYWduZXRpY19maWVsZF9pbnRlbnNpdHlcIiwgZmFsc2UsIGZhbHNlLCA3OS41Nzc0NzE1NDU5NDc3XSxcblx0ICAgIFtcIm9obVwiLCBcIs6pXCIsIG51bGwsIFwiZWxlY3RyaWNfcmVzaXN0YW5jZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJvdW5jZSBtYXNzXCIsIFwib3ptXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgMC4wMjgzNDk1MjMxMjVdLFxuXHQgICAgW1wicGFzY2FsXCIsIFwiUGFcIiwgbnVsbCwgXCJwcmVzc3VyZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJwYXNjYWwgc2Vjb25kXCIsIFwiUGE/c1wiLCBudWxsLCBcImR5bmFtaWNfdmlzY29zaXR5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcInBmZXJkZXN0w6Rya2VcIiwgXCJQU1wiLCBudWxsLCBcInBvd2VyXCIsIGZhbHNlLCB0cnVlLCA3MzUuNDk4NzVdLFxuXHQgICAgW1wicGhvdFwiLCBcInBoXCIsIG51bGwsIFwiaWxsdW1pbmFuY2VcIiwgZmFsc2UsIGZhbHNlLCAwLjAwMDFdLFxuXHQgICAgW1wicGljYSAoMS82IGluY2gpXCIsIFwicGljYVwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAzNTI3Nzc3Nzc3Nzc3OF0sXG5cdCAgICBbXCJwaWNhICgxLzcyIGluY2gpXCIsIFwiUGljYVwiLCBbXCJQaWNhcHRcIl0sIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAwLjAwNDIzMzMzMzMzMzMzMzMzXSxcblx0ICAgIFtcInBvaXNlXCIsIFwiUFwiLCBudWxsLCBcImR5bmFtaWNfdmlzY29zaXR5XCIsIGZhbHNlLCBmYWxzZSwgMC4xXSxcblx0ICAgIFtcInBvbmRcIiwgXCJwb25kXCIsIG51bGwsIFwiZm9yY2VcIiwgZmFsc2UsIHRydWUsIDAuMDA5ODA2NjVdLFxuXHQgICAgW1wicG91bmQgZm9yY2VcIiwgXCJsYmZcIiwgbnVsbCwgXCJmb3JjZVwiLCBmYWxzZSwgdHJ1ZSwgNC40NDgyMjE2MTUyNjA1XSxcblx0ICAgIFtcInBvdW5kIG1hc3NcIiwgXCJsYm1cIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCAwLjQ1MzU5MjM3XSxcblx0ICAgIFtcInF1YXJ0XCIsIFwicXRcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwOTQ2MzUyOTQ2XSxcblx0ICAgIFtcInJhZGlhblwiLCBcInJhZFwiLCBudWxsLCBcImFuZ2xlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcInNlY29uZFwiLCBcIj9cIiwgbnVsbCwgXCJhbmdsZVwiLCBmYWxzZSwgZmFsc2UsIDAuMDAwMDA0ODQ4MTM2ODExMDk1MzZdLFxuXHQgICAgW1wic2Vjb25kXCIsIFwic1wiLCBbXCJzZWNcIl0sIFwidGltZVwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcInNob3J0IGh1bmRyZWR3ZWlnaHRcIiwgXCJjd3RcIiwgW1wic2h3ZWlnaHRcIl0sIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgNDUuMzU5MjM3XSxcblx0ICAgIFtcInNpZW1lbnNcIiwgXCJTXCIsIG51bGwsIFwiZWxlY3RyaWNhbF9jb25kdWN0YW5jZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJzaWV2ZXJ0XCIsIFwiU3ZcIiwgbnVsbCwgXCJlcXVpdmFsZW50X2Rvc2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wic2x1Z1wiLCBcInNnXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgMTQuNTkzOTAyOTRdLFxuXHQgICAgW1wic3F1YXJlIMOlbmdzdHLDtm1cIiwgXCJhbmcyXCIsIFtcImFuZ14yXCJdLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDFlLTIwXSxcblx0ICAgIFtcInNxdWFyZSBmb290XCIsIFwiZnQyXCIsIFtcImZ0XjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMC4wOTI5MDMwNF0sXG5cdCAgICBbXCJzcXVhcmUgaW5jaFwiLCBcImluMlwiLCBbXCJpbl4yXCJdLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDAuMDAwNjQ1MTZdLFxuXHQgICAgW1wic3F1YXJlIGxpZ2h0LXllYXJcIiwgXCJseTJcIiwgW1wibHleMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCA4Ljk1MDU0MjEwNzQ4MTg5ZSszMV0sXG5cdCAgICBbXCJzcXVhcmUgbWV0ZXJcIiwgXCJtP1wiLCBudWxsLCBcImFyZWFcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJzcXVhcmUgbWlsZVwiLCBcIm1pMlwiLCBbXCJtaV4yXCJdLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDI1ODk5ODguMTEwMzM2XSxcblx0ICAgIFtcInNxdWFyZSBuYXV0aWNhbCBtaWxlXCIsIFwiTm1pMlwiLCBbXCJObWleMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAzNDI5OTA0XSxcblx0ICAgIFtcInNxdWFyZSBQaWNhXCIsIFwiUGljYTJcIiwgW1wiUGljYXB0MlwiLCBcIlBpY2FeMlwiLCBcIlBpY2FwdF4yXCJdLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDAuMDAwMDE3OTIxMTExMTExMTFdLFxuXHQgICAgW1wic3F1YXJlIHlhcmRcIiwgXCJ5ZDJcIiwgW1wieWReMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAwLjgzNjEyNzM2XSxcblx0ICAgIFtcInN0YXR1dGUgbWlsZVwiLCBcIm1pXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAxNjA5LjM0NF0sXG5cdCAgICBbXCJzdGVyYWRpYW5cIiwgXCJzclwiLCBudWxsLCBcInNvbGlkX2FuZ2xlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcInN0aWxiXCIsIFwic2JcIiwgbnVsbCwgXCJsdW1pbmFuY2VcIiwgZmFsc2UsIGZhbHNlLCAwLjAwMDFdLFxuXHQgICAgW1wic3Rva2VzXCIsIFwiU3RcIiwgbnVsbCwgXCJraW5lbWF0aWNfdmlzY29zaXR5XCIsIGZhbHNlLCBmYWxzZSwgMC4wMDAxXSxcblx0ICAgIFtcInN0b25lXCIsIFwic3RvbmVcIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCA2LjM1MDI5MzE4XSxcblx0ICAgIFtcInRhYmxlc3Bvb25cIiwgXCJ0YnNcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwMDE0Nzg2OF0sXG5cdCAgICBbXCJ0ZWFzcG9vblwiLCBcInRzcFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAwMDQ5Mjg5Ml0sXG5cdCAgICBbXCJ0ZXNsYVwiLCBcIlRcIiwgbnVsbCwgXCJtYWduZXRpY19mbHV4X2RlbnNpdHlcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJ0aGVybW9keW5hbWljIGNhbG9yaWVcIiwgXCJjXCIsIG51bGwsIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCA0LjE4NF0sXG5cdCAgICBbXCJ0b25cIiwgXCJ0b25cIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCA5MDcuMTg0NzRdLFxuXHQgICAgW1widG9ubmVcIiwgXCJ0XCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgZmFsc2UsIDEwMDBdLFxuXHQgICAgW1wiVS5LLiBwaW50XCIsIFwidWtfcHRcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwNTY4MjYxMjVdLFxuXHQgICAgW1wiVS5TLiBidXNoZWxcIiwgXCJidXNoZWxcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDM1MjM5MDddLFxuXHQgICAgW1wiVS5TLiBvaWwgYmFycmVsXCIsIFwiYmFycmVsXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjE1ODk4NzI5NV0sXG5cdCAgICBbXCJVLlMuIHBpbnRcIiwgXCJwdFwiLCBbXCJ1c19wdFwiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwNDczMTc2NDczXSxcblx0ICAgIFtcIlUuUy4gc3VydmV5IG1pbGVcIiwgXCJzdXJ2ZXlfbWlcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDE2MDkuMzQ3MjE5XSxcblx0ICAgIFtcIlUuUy4gc3VydmV5L3N0YXR1dGUgYWNyZVwiLCBcInVzX2FjcmVcIiwgbnVsbCwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCA0MDQ2Ljg3MjYxXSxcblx0ICAgIFtcInZvbHRcIiwgXCJWXCIsIG51bGwsIFwidm9sdGFnZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJ3YXR0XCIsIFwiV1wiLCBudWxsLCBcInBvd2VyXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wid2F0dC1ob3VyXCIsIFwiV2hcIiwgW1wid2hcIl0sIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCAzNjAwXSxcblx0ICAgIFtcIndlYmVyXCIsIFwiV2JcIiwgbnVsbCwgXCJtYWduZXRpY19mbHV4XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcInlhcmRcIiwgXCJ5ZFwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMC45MTQ0XSxcblx0ICAgIFtcInllYXJcIiwgXCJ5clwiLCBudWxsLCBcInRpbWVcIiwgZmFsc2UsIHRydWUsIDMxNTU3NjAwXVxuXHQgIF07XG5cblx0ICAvLyBCaW5hcnkgcHJlZml4ZXNcblx0ICAvLyBbTmFtZSwgUHJlZml4IHBvd2VyIG9mIDIgdmFsdWUsIFByZXZpeCB2YWx1ZSwgQWJicmV2aWF0aW9uLCBEZXJpdmVkIGZyb21dXG5cdCAgdmFyIGJpbmFyeV9wcmVmaXhlcyA9IHtcblx0ICAgIFlpOiBbXCJ5b2JpXCIsIDgwLCAxMjA4OTI1ODE5NjE0NjI5MTc0NzA2MTc2LCBcIllpXCIsIFwieW90dGFcIl0sXG5cdCAgICBaaTogW1wiemViaVwiLCA3MCwgMTE4MDU5MTYyMDcxNzQxMTMwMzQyNCwgXCJaaVwiLCBcInpldHRhXCJdLFxuXHQgICAgRWk6IFtcImV4YmlcIiwgNjAsIDExNTI5MjE1MDQ2MDY4NDY5NzYsIFwiRWlcIiwgXCJleGFcIl0sXG5cdCAgICBQaTogW1wicGViaVwiLCA1MCwgMTEyNTg5OTkwNjg0MjYyNCwgXCJQaVwiLCBcInBldGFcIl0sXG5cdCAgICBUaTogW1widGViaVwiLCA0MCwgMTA5OTUxMTYyNzc3NiwgXCJUaVwiLCBcInRlcmFcIl0sXG5cdCAgICBHaTogW1wiZ2liaVwiLCAzMCwgMTA3Mzc0MTgyNCwgXCJHaVwiLCBcImdpZ2FcIl0sXG5cdCAgICBNaTogW1wibWViaVwiLCAyMCwgMTA0ODU3NiwgXCJNaVwiLCBcIm1lZ2FcIl0sXG5cdCAgICBraTogW1wia2liaVwiLCAxMCwgMTAyNCwgXCJraVwiLCBcImtpbG9cIl1cblx0ICB9O1xuXG5cdCAgLy8gVW5pdCBwcmVmaXhlc1xuXHQgIC8vIFtOYW1lLCBNdWx0aXBsaWVyLCBBYmJyZXZpYXRpb25dXG5cdCAgdmFyIHVuaXRfcHJlZml4ZXMgPSB7XG5cdCAgICBZOiBbXCJ5b3R0YVwiLCAxZSsyNCwgXCJZXCJdLFxuXHQgICAgWjogW1wiemV0dGFcIiwgMWUrMjEsIFwiWlwiXSxcblx0ICAgIEU6IFtcImV4YVwiLCAxZSsxOCwgXCJFXCJdLFxuXHQgICAgUDogW1wicGV0YVwiLCAxZSsxNSwgXCJQXCJdLFxuXHQgICAgVDogW1widGVyYVwiLCAxZSsxMiwgXCJUXCJdLFxuXHQgICAgRzogW1wiZ2lnYVwiLCAxZSswOSwgXCJHXCJdLFxuXHQgICAgTTogW1wibWVnYVwiLCAxZSswNiwgXCJNXCJdLFxuXHQgICAgazogW1wia2lsb1wiLCAxZSswMywgXCJrXCJdLFxuXHQgICAgaDogW1wiaGVjdG9cIiwgMWUrMDIsIFwiaFwiXSxcblx0ICAgIGU6IFtcImRla2FvXCIsIDFlKzAxLCBcImVcIl0sXG5cdCAgICBkOiBbXCJkZWNpXCIsIDFlLTAxLCBcImRcIl0sXG5cdCAgICBjOiBbXCJjZW50aVwiLCAxZS0wMiwgXCJjXCJdLFxuXHQgICAgbTogW1wibWlsbGlcIiwgMWUtMDMsIFwibVwiXSxcblx0ICAgIHU6IFtcIm1pY3JvXCIsIDFlLTA2LCBcInVcIl0sXG5cdCAgICBuOiBbXCJuYW5vXCIsIDFlLTA5LCBcIm5cIl0sXG5cdCAgICBwOiBbXCJwaWNvXCIsIDFlLTEyLCBcInBcIl0sXG5cdCAgICBmOiBbXCJmZW10b1wiLCAxZS0xNSwgXCJmXCJdLFxuXHQgICAgYTogW1wiYXR0b1wiLCAxZS0xOCwgXCJhXCJdLFxuXHQgICAgejogW1wiemVwdG9cIiwgMWUtMjEsIFwielwiXSxcblx0ICAgIHk6IFtcInlvY3RvXCIsIDFlLTI0LCBcInlcIl1cblx0ICB9O1xuXG5cdCAgLy8gSW5pdGlhbGl6ZSB1bml0cyBhbmQgbXVsdGlwbGllcnNcblx0ICB2YXIgZnJvbSA9IG51bGw7XG5cdCAgdmFyIHRvID0gbnVsbDtcblx0ICB2YXIgYmFzZV9mcm9tX3VuaXQgPSBmcm9tX3VuaXQ7XG5cdCAgdmFyIGJhc2VfdG9fdW5pdCA9IHRvX3VuaXQ7XG5cdCAgdmFyIGZyb21fbXVsdGlwbGllciA9IDE7XG5cdCAgdmFyIHRvX211bHRpcGxpZXIgPSAxO1xuXHQgIHZhciBhbHQ7XG5cblx0ICAvLyBMb29rdXAgZnJvbSBhbmQgdG8gdW5pdHNcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBhbHQgPSAodW5pdHNbaV1bMl0gPT09IG51bGwpID8gW10gOiB1bml0c1tpXVsyXTtcblx0ICAgIGlmICh1bml0c1tpXVsxXSA9PT0gYmFzZV9mcm9tX3VuaXQgfHwgYWx0LmluZGV4T2YoYmFzZV9mcm9tX3VuaXQpID49IDApIHtcblx0ICAgICAgZnJvbSA9IHVuaXRzW2ldO1xuXHQgICAgfVxuXHQgICAgaWYgKHVuaXRzW2ldWzFdID09PSBiYXNlX3RvX3VuaXQgfHwgYWx0LmluZGV4T2YoYmFzZV90b191bml0KSA+PSAwKSB7XG5cdCAgICAgIHRvID0gdW5pdHNbaV07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGZyb20gcHJlZml4XG5cdCAgaWYgKGZyb20gPT09IG51bGwpIHtcblx0ICAgIHZhciBmcm9tX2JpbmFyeV9wcmVmaXggPSBiaW5hcnlfcHJlZml4ZXNbZnJvbV91bml0LnN1YnN0cmluZygwLCAyKV07XG5cdCAgICB2YXIgZnJvbV91bml0X3ByZWZpeCA9IHVuaXRfcHJlZml4ZXNbZnJvbV91bml0LnN1YnN0cmluZygwLCAxKV07XG5cblx0ICAgIC8vIEhhbmRsZSBkZWthbyB1bml0IHByZWZpeCAob25seSB1bml0IHByZWZpeCB3aXRoIHR3byBjaGFyYWN0ZXJzKVxuXHQgICAgaWYgKGZyb21fdW5pdC5zdWJzdHJpbmcoMCwgMikgPT09ICdkYScpIHtcblx0ICAgICAgZnJvbV91bml0X3ByZWZpeCA9IFtcImRla2FvXCIsIDFlKzAxLCBcImRhXCJdO1xuXHQgICAgfVxuXG5cdCAgICAvLyBIYW5kbGUgYmluYXJ5IHByZWZpeGVzIGZpcnN0IChzbyB0aGF0ICdZaScgaXMgcHJvY2Vzc2VkIGJlZm9yZSAnWScpXG5cdCAgICBpZiAoZnJvbV9iaW5hcnlfcHJlZml4KSB7XG5cdCAgICAgIGZyb21fbXVsdGlwbGllciA9IGZyb21fYmluYXJ5X3ByZWZpeFsyXTtcblx0ICAgICAgYmFzZV9mcm9tX3VuaXQgPSBmcm9tX3VuaXQuc3Vic3RyaW5nKDIpO1xuXHQgICAgfSBlbHNlIGlmIChmcm9tX3VuaXRfcHJlZml4KSB7XG5cdCAgICAgIGZyb21fbXVsdGlwbGllciA9IGZyb21fdW5pdF9wcmVmaXhbMV07XG5cdCAgICAgIGJhc2VfZnJvbV91bml0ID0gZnJvbV91bml0LnN1YnN0cmluZyhmcm9tX3VuaXRfcHJlZml4WzJdLmxlbmd0aCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIExvb2t1cCBmcm9tIHVuaXRcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgdW5pdHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgYWx0ID0gKHVuaXRzW2pdWzJdID09PSBudWxsKSA/IFtdIDogdW5pdHNbal1bMl07XG5cdCAgICAgIGlmICh1bml0c1tqXVsxXSA9PT0gYmFzZV9mcm9tX3VuaXQgfHwgYWx0LmluZGV4T2YoYmFzZV9mcm9tX3VuaXQpID49IDApIHtcblx0ICAgICAgICBmcm9tID0gdW5pdHNbal07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBMb29rdXAgdG8gcHJlZml4XG5cdCAgaWYgKHRvID09PSBudWxsKSB7XG5cdCAgICB2YXIgdG9fYmluYXJ5X3ByZWZpeCA9IGJpbmFyeV9wcmVmaXhlc1t0b191bml0LnN1YnN0cmluZygwLCAyKV07XG5cdCAgICB2YXIgdG9fdW5pdF9wcmVmaXggPSB1bml0X3ByZWZpeGVzW3RvX3VuaXQuc3Vic3RyaW5nKDAsIDEpXTtcblxuXHQgICAgLy8gSGFuZGxlIGRla2FvIHVuaXQgcHJlZml4IChvbmx5IHVuaXQgcHJlZml4IHdpdGggdHdvIGNoYXJhY3RlcnMpXG5cdCAgICBpZiAodG9fdW5pdC5zdWJzdHJpbmcoMCwgMikgPT09ICdkYScpIHtcblx0ICAgICAgdG9fdW5pdF9wcmVmaXggPSBbXCJkZWthb1wiLCAxZSswMSwgXCJkYVwiXTtcblx0ICAgIH1cblxuXHQgICAgLy8gSGFuZGxlIGJpbmFyeSBwcmVmaXhlcyBmaXJzdCAoc28gdGhhdCAnWWknIGlzIHByb2Nlc3NlZCBiZWZvcmUgJ1knKVxuXHQgICAgaWYgKHRvX2JpbmFyeV9wcmVmaXgpIHtcblx0ICAgICAgdG9fbXVsdGlwbGllciA9IHRvX2JpbmFyeV9wcmVmaXhbMl07XG5cdCAgICAgIGJhc2VfdG9fdW5pdCA9IHRvX3VuaXQuc3Vic3RyaW5nKDIpO1xuXHQgICAgfSBlbHNlIGlmICh0b191bml0X3ByZWZpeCkge1xuXHQgICAgICB0b19tdWx0aXBsaWVyID0gdG9fdW5pdF9wcmVmaXhbMV07XG5cdCAgICAgIGJhc2VfdG9fdW5pdCA9IHRvX3VuaXQuc3Vic3RyaW5nKHRvX3VuaXRfcHJlZml4WzJdLmxlbmd0aCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIExvb2t1cCB0byB1bml0XG5cdCAgICBmb3IgKHZhciBrID0gMDsgayA8IHVuaXRzLmxlbmd0aDsgaysrKSB7XG5cdCAgICAgIGFsdCA9ICh1bml0c1trXVsyXSA9PT0gbnVsbCkgPyBbXSA6IHVuaXRzW2tdWzJdO1xuXHQgICAgICBpZiAodW5pdHNba11bMV0gPT09IGJhc2VfdG9fdW5pdCB8fCBhbHQuaW5kZXhPZihiYXNlX3RvX3VuaXQpID49IDApIHtcblx0ICAgICAgICB0byA9IHVuaXRzW2tdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGEgdW5pdCBkb2VzIG5vdCBleGlzdFxuXHQgIGlmIChmcm9tID09PSBudWxsIHx8IHRvID09PSBudWxsKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHVuaXRzIHJlcHJlc2VudCBkaWZmZXJlbnQgcXVhbnRpdGllc1xuXHQgIGlmIChmcm9tWzNdICE9PSB0b1szXSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBjb252ZXJ0ZWQgbnVtYmVyXG5cdCAgcmV0dXJuIG51bWJlciAqIGZyb21bNl0gKiBmcm9tX211bHRpcGxpZXIgLyAodG9bNl0gKiB0b19tdWx0aXBsaWVyKTtcblx0fTtcblxuXHRleHBvcnRzLkRFQzJCSU4gPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGRlY2ltYWwsIGlzIGxvd2VyIHRoYW4gLTUxMiwgb3IgaXMgZ3JlYXRlciB0aGFuIDUxMVxuXHQgIGlmICghL14tP1swLTldezEsM30kLy50ZXN0KG51bWJlcikgfHwgbnVtYmVyIDwgLTUxMiB8fCBudW1iZXIgPiA1MTEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIGJpbmFyeSBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgIHJldHVybiAnMScgKyB0ZXh0LlJFUFQoJzAnLCA5IC0gKDUxMiArIG51bWJlcikudG9TdHJpbmcoMikubGVuZ3RoKSArICg1MTIgKyBudW1iZXIpLnRvU3RyaW5nKDIpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGVjaW1hbCBudW1iZXIgdG8gYmluYXJ5XG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMTApLnRvU3RyaW5nKDIpO1xuXG5cdCAgLy8gUmV0dXJuIGJpbmFyeSBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAodHlwZW9mIHBsYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkRFQzJIRVggPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGRlY2ltYWwsIGlzIGxvd2VyIHRoYW4gLTU0OTc1NTgxMzg4OCwgb3IgaXMgZ3JlYXRlciB0aGFuIDU0OTc1NTgxMzg4N1xuXHQgIGlmICghL14tP1swLTldezEsMTJ9JC8udGVzdChudW1iZXIpIHx8IG51bWJlciA8IC01NDk3NTU4MTM4ODggfHwgbnVtYmVyID4gNTQ5NzU1ODEzODg3KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBoZXhhZGVjaW1hbCBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgIHJldHVybiAoMTA5OTUxMTYyNzc3NiArIG51bWJlcikudG9TdHJpbmcoMTYpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGVjaW1hbCBudW1iZXIgdG8gaGV4YWRlY2ltYWxcblx0ICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQobnVtYmVyLCAxMCkudG9TdHJpbmcoMTYpO1xuXG5cdCAgLy8gUmV0dXJuIGhleGFkZWNpbWFsIG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmICh0eXBlb2YgcGxhY2VzID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuREVDMk9DVCA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgZGVjaW1hbCwgaXMgbG93ZXIgdGhhbiAtNTQ5NzU1ODEzODg4LCBvciBpcyBncmVhdGVyIHRoYW4gNTQ5NzU1ODEzODg3XG5cdCAgaWYgKCEvXi0/WzAtOV17MSw5fSQvLnRlc3QobnVtYmVyKSB8fCBudW1iZXIgPCAtNTM2ODcwOTEyIHx8IG51bWJlciA+IDUzNjg3MDkxMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgb2N0YWwgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gKDEwNzM3NDE4MjQgKyBudW1iZXIpLnRvU3RyaW5nKDgpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGVjaW1hbCBudW1iZXIgdG8gb2N0YWxcblx0ICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQobnVtYmVyLCAxMCkudG9TdHJpbmcoOCk7XG5cblx0ICAvLyBSZXR1cm4gb2N0YWwgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHR5cGVvZiBwbGFjZXMgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5ERUxUQSA9IGZ1bmN0aW9uKG51bWJlcjEsIG51bWJlcjIpIHtcblx0ICAvLyBTZXQgbnVtYmVyMiB0byB6ZXJvIGlmIHVuZGVmaW5lZFxuXHQgIG51bWJlcjIgPSAobnVtYmVyMiA9PT0gdW5kZWZpbmVkKSA/IDAgOiBudW1iZXIyO1xuXHQgIG51bWJlcjEgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIxKTtcblx0ICBudW1iZXIyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyMSwgbnVtYmVyMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZGVsdGFcblx0ICByZXR1cm4gKG51bWJlcjEgPT09IG51bWJlcjIpID8gMSA6IDA7XG5cdH07XG5cblx0Ly8gVE9ETzogd2h5IGlzIHVwcGVyX2JvdW5kIG5vdCB1c2VkID8gVGhlIGV4Y2VsIGRvY3VtZW50YXRpb24gaGFzIG5vIGV4YW1wbGVzIHdpdGggdXBwZXJfYm91bmRcblx0ZXhwb3J0cy5FUkYgPSBmdW5jdGlvbihsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpIHtcblx0ICAvLyBTZXQgbnVtYmVyMiB0byB6ZXJvIGlmIHVuZGVmaW5lZFxuXHQgIHVwcGVyX2JvdW5kID0gKHVwcGVyX2JvdW5kID09PSB1bmRlZmluZWQpID8gMCA6IHVwcGVyX2JvdW5kO1xuXG5cdCAgbG93ZXJfYm91bmQgPSB1dGlscy5wYXJzZU51bWJlcihsb3dlcl9ib3VuZCk7XG5cdCAgdXBwZXJfYm91bmQgPSB1dGlscy5wYXJzZU51bWJlcih1cHBlcl9ib3VuZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5lcmYobG93ZXJfYm91bmQpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5FUkYuUFJFQ0lTRSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdFUkYuUFJFQ0lTRSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkVSRkMgPSBmdW5jdGlvbih4KSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHggaXMgbm90IGEgbnVtYmVyXG5cdCAgaWYgKGlzTmFOKHgpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmVyZmMoeCk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkVSRkMuUFJFQ0lTRSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdFUkZDLlBSRUNJU0UgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5HRVNURVAgPSBmdW5jdGlvbihudW1iZXIsIHN0ZXApIHtcblx0ICBzdGVwID0gc3RlcCB8fCAwO1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioc3RlcCwgbnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZGVsdGFcblx0ICByZXR1cm4gKG51bWJlciA+PSBzdGVwKSA/IDEgOiAwO1xuXHR9O1xuXG5cdGV4cG9ydHMuSEVYMkJJTiA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgaGV4YWRlY2ltYWwgb3IgY29udGFpbnMgbW9yZSB0aGFuIHRlbiBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCEvXlswLTlBLUZhLWZdezEsMTB9JC8udGVzdChudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENoZWNrIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIHZhciBuZWdhdGl2ZSA9IChudW1iZXIubGVuZ3RoID09PSAxMCAmJiBudW1iZXIuc3Vic3RyaW5nKDAsIDEpLnRvTG93ZXJDYXNlKCkgPT09ICdmJykgPyB0cnVlIDogZmFsc2U7XG5cblx0ICAvLyBDb252ZXJ0IGhleGFkZWNpbWFsIG51bWJlciB0byBkZWNpbWFsXG5cdCAgdmFyIGRlY2ltYWwgPSAobmVnYXRpdmUpID8gcGFyc2VJbnQobnVtYmVyLCAxNikgLSAxMDk5NTExNjI3Nzc2IDogcGFyc2VJbnQobnVtYmVyLCAxNik7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGxvd2VyIHRoYW4gLTUxMiBvciBncmVhdGVyIHRoYW4gNTExXG5cdCAgaWYgKGRlY2ltYWwgPCAtNTEyIHx8IGRlY2ltYWwgPiA1MTEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIGJpbmFyeSBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKG5lZ2F0aXZlKSB7XG5cdCAgICByZXR1cm4gJzEnICsgdGV4dC5SRVBUKCcwJywgOSAtICg1MTIgKyBkZWNpbWFsKS50b1N0cmluZygyKS5sZW5ndGgpICsgKDUxMiArIGRlY2ltYWwpLnRvU3RyaW5nKDIpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGVjaW1hbCBudW1iZXIgdG8gYmluYXJ5XG5cdCAgdmFyIHJlc3VsdCA9IGRlY2ltYWwudG9TdHJpbmcoMik7XG5cblx0ICAvLyBSZXR1cm4gYmluYXJ5IG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmIChwbGFjZXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuSEVYMkRFQyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGhleGFkZWNpbWFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC05QS1GYS1mXXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGhleGFkZWNpbWFsIG51bWJlciB0byBkZWNpbWFsXG5cdCAgdmFyIGRlY2ltYWwgPSBwYXJzZUludChudW1iZXIsIDE2KTtcblxuXHQgIC8vIFJldHVybiBkZWNpbWFsIG51bWJlclxuXHQgIHJldHVybiAoZGVjaW1hbCA+PSA1NDk3NTU4MTM4ODgpID8gZGVjaW1hbCAtIDEwOTk1MTE2Mjc3NzYgOiBkZWNpbWFsO1xuXHR9O1xuXG5cdGV4cG9ydHMuSEVYMk9DVCA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgaGV4YWRlY2ltYWwgb3IgY29udGFpbnMgbW9yZSB0aGFuIHRlbiBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCEvXlswLTlBLUZhLWZdezEsMTB9JC8udGVzdChudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgaGV4YWRlY2ltYWwgbnVtYmVyIHRvIGRlY2ltYWxcblx0ICB2YXIgZGVjaW1hbCA9IHBhcnNlSW50KG51bWJlciwgMTYpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBwb3NpdGl2ZSBhbmQgZ3JlYXRlciB0aGFuIDB4MWZmZmZmZmYgKDUzNjg3MDkxMSlcblx0ICBpZiAoZGVjaW1hbCA+IDUzNjg3MDkxMSAmJiBkZWNpbWFsIDwgMTA5ODk3NDc1Njg2NCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgb2N0YWwgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChkZWNpbWFsID49IDEwOTg5NzQ3NTY4NjQpIHtcblx0ICAgIHJldHVybiAoZGVjaW1hbCAtIDEwOTg0Mzc4ODU5NTIpLnRvU3RyaW5nKDgpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGVjaW1hbCBudW1iZXIgdG8gb2N0YWxcblx0ICB2YXIgcmVzdWx0ID0gZGVjaW1hbC50b1N0cmluZyg4KTtcblxuXHQgIC8vIFJldHVybiBvY3RhbCBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAocGxhY2VzID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLklNQUJTID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIGV4cG9ydHMuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgY29lZmZpY2llbnQgaXMgbm90IGEgbnVtYmVyXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYWJzb2x1dGUgdmFsdWUgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1BR0lOQVJZID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIGlmIChpbnVtYmVyID09PSB1bmRlZmluZWQgfHwgaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAwIGlmIGludW1iZXIgaXMgZXF1YWwgdG8gMFxuXHQgIGlmIChpbnVtYmVyID09PSAwIHx8IGludW1iZXIgPT09ICcwJykge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcblx0ICBpZiAoWydpJywgJ2onXS5pbmRleE9mKGludW1iZXIpID49IDApIHtcblx0ICAgIHJldHVybiAxO1xuXHQgIH1cblxuXHQgIC8vIE5vcm1hbGl6ZSBpbWFnaW5hcnkgY29lZmZpY2llbnRcblx0ICBpbnVtYmVyID0gaW51bWJlci5yZXBsYWNlKCcraScsICcrMWknKS5yZXBsYWNlKCctaScsICctMWknKS5yZXBsYWNlKCcraicsICcrMWonKS5yZXBsYWNlKCctaicsICctMWonKTtcblxuXHQgIC8vIExvb2t1cCBzaWduXG5cdCAgdmFyIHBsdXMgPSBpbnVtYmVyLmluZGV4T2YoJysnKTtcblx0ICB2YXIgbWludXMgPSBpbnVtYmVyLmluZGV4T2YoJy0nKTtcblx0ICBpZiAocGx1cyA9PT0gMCkge1xuXHQgICAgcGx1cyA9IGludW1iZXIuaW5kZXhPZignKycsIDEpO1xuXHQgIH1cblxuXHQgIGlmIChtaW51cyA9PT0gMCkge1xuXHQgICAgbWludXMgPSBpbnVtYmVyLmluZGV4T2YoJy0nLCAxKTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgbGFzdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSwgaW51bWJlci5sZW5ndGgpO1xuXHQgIHZhciB1bml0ID0gKGxhc3QgPT09ICdpJyB8fCBsYXN0ID09PSAnaicpO1xuXG5cdCAgaWYgKHBsdXMgPj0gMCB8fCBtaW51cyA+PSAwKSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgaW1hZ2luYXJ5IHVuaXQgaXMgbmVpdGhlciBpIG5vciBqXG5cdCAgICBpZiAoIXVuaXQpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGltYWdpbmFyeSBjb2VmZmljaWVudCBvZiBjb21wbGV4IG51bWJlclxuXHQgICAgaWYgKHBsdXMgPj0gMCkge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKDAsIHBsdXMpKSB8fCBpc05hTihpbnVtYmVyLnN1YnN0cmluZyhwbHVzICsgMSwgaW51bWJlci5sZW5ndGggLSAxKSkpID9cblx0ICAgICAgICBlcnJvci5udW0gOlxuXHQgICAgICAgIE51bWJlcihpbnVtYmVyLnN1YnN0cmluZyhwbHVzICsgMSwgaW51bWJlci5sZW5ndGggLSAxKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKDAsIG1pbnVzKSkgfHwgaXNOYU4oaW51bWJlci5zdWJzdHJpbmcobWludXMgKyAxLCBpbnVtYmVyLmxlbmd0aCAtIDEpKSkgP1xuXHQgICAgICAgIGVycm9yLm51bSA6XG5cdCAgICAgICAgLU51bWJlcihpbnVtYmVyLnN1YnN0cmluZyhtaW51cyArIDEsIGludW1iZXIubGVuZ3RoIC0gMSkpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAodW5pdCkge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKDAsIGludW1iZXIubGVuZ3RoIC0gMSkpKSA/IGVycm9yLm51bSA6IGludW1iZXIuc3Vic3RyaW5nKDAsIGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIpKSA/IGVycm9yLm51bSA6IDA7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuSU1BUkdVTUVOVCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBleHBvcnRzLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIGNvZWZmaWNpZW50IGlzIG5vdCBhIG51bWJlclxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGludW1iZXIgaXMgZXF1YWwgdG8gemVyb1xuXHQgIGlmICh4ID09PSAwICYmIHkgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5kaXYwO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBQSS8yIGlmIHggaXMgZXF1YWwgdG8gemVybyBhbmQgeSBpcyBwb3NpdGl2ZVxuXHQgIGlmICh4ID09PSAwICYmIHkgPiAwKSB7XG5cdCAgICByZXR1cm4gTWF0aC5QSSAvIDI7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIC1QSS8yIGlmIHggaXMgZXF1YWwgdG8gemVybyBhbmQgeSBpcyBuZWdhdGl2ZVxuXHQgIGlmICh4ID09PSAwICYmIHkgPCAwKSB7XG5cdCAgICByZXR1cm4gLU1hdGguUEkgLyAyO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiB6ZXJvIGlmIHggaXMgbmVnYXRpdmUgYW5kIHkgaXMgZXF1YWwgdG8gemVyb1xuXHQgIGlmICh5ID09PSAwICYmIHggPiAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gemVybyBpZiB4IGlzIG5lZ2F0aXZlIGFuZCB5IGlzIGVxdWFsIHRvIHplcm9cblx0ICBpZiAoeSA9PT0gMCAmJiB4IDwgMCkge1xuXHQgICAgcmV0dXJuIC1NYXRoLlBJO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBhcmd1bWVudCBvZiBjb21wbGV4IG51bWJlclxuXHQgIGlmICh4ID4gMCkge1xuXHQgICAgcmV0dXJuIE1hdGguYXRhbih5IC8geCk7XG5cdCAgfSBlbHNlIGlmICh4IDwgMCAmJiB5ID49IDApIHtcblx0ICAgIHJldHVybiBNYXRoLmF0YW4oeSAvIHgpICsgTWF0aC5QSTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIE1hdGguYXRhbih5IC8geCkgLSBNYXRoLlBJO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLklNQ09OSlVHQVRFID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIGV4cG9ydHMuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGNvbmp1Z2F0ZSBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiAoeSAhPT0gMCkgPyBleHBvcnRzLkNPTVBMRVgoeCwgLXksIHVuaXQpIDogaW51bWJlcjtcblx0fTtcblxuXHRleHBvcnRzLklNQ09TID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIGV4cG9ydHMuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGNvc2luZSBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5jb3MoeCkgKiAoTWF0aC5leHAoeSkgKyBNYXRoLmV4cCgteSkpIC8gMiwgLU1hdGguc2luKHgpICogKE1hdGguZXhwKHkpIC0gTWF0aC5leHAoLXkpKSAvIDIsIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1DT1NIID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIGV4cG9ydHMuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGh5cGVyYm9saWMgY29zaW5lIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChNYXRoLmNvcyh5KSAqIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgLyAyLCBNYXRoLnNpbih5KSAqIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNQ09UID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGNvdGFuZ2VudCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLklNRElWKGV4cG9ydHMuSU1DT1MoaW51bWJlciksIGV4cG9ydHMuSU1TSU4oaW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1ESVYgPSBmdW5jdGlvbihpbnVtYmVyMSwgaW51bWJlcjIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgYSA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIxKTtcblx0ICB2YXIgYiA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIxKTtcblx0ICB2YXIgYyA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIyKTtcblx0ICB2YXIgZCA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGEsIGIsIGMsIGQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQxID0gaW51bWJlcjEuc3Vic3RyaW5nKGludW1iZXIxLmxlbmd0aCAtIDEpO1xuXHQgIHZhciB1bml0MiA9IGludW1iZXIyLnN1YnN0cmluZyhpbnVtYmVyMi5sZW5ndGggLSAxKTtcblx0ICB2YXIgdW5pdCA9ICdpJztcblx0ICBpZiAodW5pdDEgPT09ICdqJykge1xuXHQgICAgdW5pdCA9ICdqJztcblx0ICB9IGVsc2UgaWYgKHVuaXQyID09PSAnaicpIHtcblx0ICAgIHVuaXQgPSAnaic7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGludW1iZXIyIGlzIG51bGxcblx0ICBpZiAoYyA9PT0gMCAmJiBkID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBleHBvbmVudGlhbCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHZhciBkZW4gPSBjICogYyArIGQgKiBkO1xuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoKGEgKiBjICsgYiAqIGQpIC8gZGVuLCAoYiAqIGMgLSBhICogZCkgLyBkZW4sIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1FWFAgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICB2YXIgZSA9IE1hdGguZXhwKHgpO1xuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoZSAqIE1hdGguY29zKHkpLCBlICogTWF0aC5zaW4oeSksIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1MTiA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBleHBvbmVudGlhbCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5sb2coTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKSwgTWF0aC5hdGFuKHkgLyB4KSwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUxPRzEwID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGV4cG9uZW50aWFsIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChNYXRoLmxvZyhNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpIC8gTWF0aC5sb2coMTApLCBNYXRoLmF0YW4oeSAvIHgpIC8gTWF0aC5sb2coMTApLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNTE9HMiA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBleHBvbmVudGlhbCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5sb2coTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKSAvIE1hdGgubG9nKDIpLCBNYXRoLmF0YW4oeSAvIHgpIC8gTWF0aC5sb2coMiksIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1QT1dFUiA9IGZ1bmN0aW9uKGludW1iZXIsIG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBDYWxjdWxhdGUgcG93ZXIgb2YgbW9kdWx1c1xuXHQgIHZhciBwID0gTWF0aC5wb3coZXhwb3J0cy5JTUFCUyhpbnVtYmVyKSwgbnVtYmVyKTtcblxuXHQgIC8vIENhbGN1bGF0ZSBhcmd1bWVudFxuXHQgIHZhciB0ID0gZXhwb3J0cy5JTUFSR1VNRU5UKGludW1iZXIpO1xuXG5cdCAgLy8gUmV0dXJuIGV4cG9uZW50aWFsIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChwICogTWF0aC5jb3MobnVtYmVyICogdCksIHAgKiBNYXRoLnNpbihudW1iZXIgKiB0KSwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVBST0RVQ1QgPSBmdW5jdGlvbigpIHtcblx0ICAvLyBJbml0aWFsaXplIHJlc3VsdFxuXHQgIHZhciByZXN1bHQgPSBhcmd1bWVudHNbMF07XG5cblx0ICAvLyBMb29wIG9uIGFsbCBudW1iZXJzXG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIC8vIExvb2t1cCBjb2VmZmljaWVudHMgb2YgdHdvIGNvbXBsZXggbnVtYmVyc1xuXHQgICAgdmFyIGEgPSBleHBvcnRzLklNUkVBTChyZXN1bHQpO1xuXHQgICAgdmFyIGIgPSBleHBvcnRzLklNQUdJTkFSWShyZXN1bHQpO1xuXHQgICAgdmFyIGMgPSBleHBvcnRzLklNUkVBTChhcmd1bWVudHNbaV0pO1xuXHQgICAgdmFyIGQgPSBleHBvcnRzLklNQUdJTkFSWShhcmd1bWVudHNbaV0pO1xuXG5cdCAgICBpZiAodXRpbHMuYW55SXNFcnJvcihhLCBiLCBjLCBkKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIENvbXBsdXRlIHByb2R1Y3Qgb2YgdHdvIGNvbXBsZXggbnVtYmVyc1xuXHQgICAgcmVzdWx0ID0gZXhwb3J0cy5DT01QTEVYKGEgKiBjIC0gYiAqIGQsIGEgKiBkICsgYiAqIGMpO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBwcm9kdWN0IG9mIGNvbXBsZXggbnVtYmVyc1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVJFQUwgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgaWYgKGludW1iZXIgPT09IHVuZGVmaW5lZCB8fCBpbnVtYmVyID09PSB0cnVlIHx8IGludW1iZXIgPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIDAgaWYgaW51bWJlciBpcyBlcXVhbCB0byAwXG5cdCAgaWYgKGludW1iZXIgPT09IDAgfHwgaW51bWJlciA9PT0gJzAnKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlc1xuXHQgIGlmIChbJ2knLCAnK2knLCAnMWknLCAnKzFpJywgJy1pJywgJy0xaScsICdqJywgJytqJywgJzFqJywgJysxaicsICctaicsICctMWonXS5pbmRleE9mKGludW1iZXIpID49IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBzaWduXG5cdCAgdmFyIHBsdXMgPSBpbnVtYmVyLmluZGV4T2YoJysnKTtcblx0ICB2YXIgbWludXMgPSBpbnVtYmVyLmluZGV4T2YoJy0nKTtcblx0ICBpZiAocGx1cyA9PT0gMCkge1xuXHQgICAgcGx1cyA9IGludW1iZXIuaW5kZXhPZignKycsIDEpO1xuXHQgIH1cblx0ICBpZiAobWludXMgPT09IDApIHtcblx0ICAgIG1pbnVzID0gaW51bWJlci5pbmRleE9mKCctJywgMSk7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIGxhc3QgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEsIGludW1iZXIubGVuZ3RoKTtcblx0ICB2YXIgdW5pdCA9IChsYXN0ID09PSAnaScgfHwgbGFzdCA9PT0gJ2onKTtcblxuXHQgIGlmIChwbHVzID49IDAgfHwgbWludXMgPj0gMCkge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIGltYWdpbmFyeSB1bml0IGlzIG5laXRoZXIgaSBub3IgalxuXHQgICAgaWYgKCF1bml0KSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiByZWFsIGNvZWZmaWNpZW50IG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgICBpZiAocGx1cyA+PSAwKSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlci5zdWJzdHJpbmcoMCwgcGx1cykpIHx8IGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKHBsdXMgKyAxLCBpbnVtYmVyLmxlbmd0aCAtIDEpKSkgP1xuXHQgICAgICAgIGVycm9yLm51bSA6XG5cdCAgICAgICAgTnVtYmVyKGludW1iZXIuc3Vic3RyaW5nKDAsIHBsdXMpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlci5zdWJzdHJpbmcoMCwgbWludXMpKSB8fCBpc05hTihpbnVtYmVyLnN1YnN0cmluZyhtaW51cyArIDEsIGludW1iZXIubGVuZ3RoIC0gMSkpKSA/XG5cdCAgICAgICAgZXJyb3IubnVtIDpcblx0ICAgICAgICBOdW1iZXIoaW51bWJlci5zdWJzdHJpbmcoMCwgbWludXMpKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHVuaXQpIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyLnN1YnN0cmluZygwLCBpbnVtYmVyLmxlbmd0aCAtIDEpKSkgPyBlcnJvci5udW0gOiAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyKSkgPyBlcnJvci5udW0gOiBpbnVtYmVyO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLklNU0VDID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBpbnVtYmVyIGlzIGEgbG9naWNhbCB2YWx1ZVxuXHQgIGlmIChpbnVtYmVyID09PSB0cnVlIHx8IGludW1iZXIgPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gc2VjYW50IG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuSU1ESVYoJzEnLCBleHBvcnRzLklNQ09TKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNU0VDSCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBoeXBlcmJvbGljIHNlY2FudCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLklNRElWKCcxJywgZXhwb3J0cy5JTUNPU0goaW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1TSU4gPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gc2luZSBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5zaW4oeCkgKiAoTWF0aC5leHAoeSkgKyBNYXRoLmV4cCgteSkpIC8gMiwgTWF0aC5jb3MoeCkgKiAoTWF0aC5leHAoeSkgLSBNYXRoLmV4cCgteSkpIC8gMiwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNJTkggPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gaHlwZXJib2xpYyBzaW5lIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChNYXRoLmNvcyh5KSAqIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyLCBNYXRoLnNpbih5KSAqIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgLyAyLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNU1FSVCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIENhbGN1bGF0ZSBwb3dlciBvZiBtb2R1bHVzXG5cdCAgdmFyIHMgPSBNYXRoLnNxcnQoZXhwb3J0cy5JTUFCUyhpbnVtYmVyKSk7XG5cblx0ICAvLyBDYWxjdWxhdGUgYXJndW1lbnRcblx0ICB2YXIgdCA9IGV4cG9ydHMuSU1BUkdVTUVOVChpbnVtYmVyKTtcblxuXHQgIC8vIFJldHVybiBleHBvbmVudGlhbCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgocyAqIE1hdGguY29zKHQgLyAyKSwgcyAqIE1hdGguc2luKHQgLyAyKSwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUNTQyA9IGZ1bmN0aW9uIChpbnVtYmVyKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGludW1iZXIgaXMgYSBsb2dpY2FsIHZhbHVlXG5cdCAgaWYgKGludW1iZXIgPT09IHRydWUgfHwgaW51bWJlciA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIGNvZWZmaWNpZW50IGlzIG5vdCBhIG51bWJlclxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBjb3NlY2FudCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLklNRElWKCcxJywgZXhwb3J0cy5JTVNJTihpbnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUNTQ0ggPSBmdW5jdGlvbiAoaW51bWJlcikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBpbnVtYmVyIGlzIGEgbG9naWNhbCB2YWx1ZVxuXHQgIGlmIChpbnVtYmVyID09PSB0cnVlIHx8IGludW1iZXIgPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBjb2VmZmljaWVudCBpcyBub3QgYSBudW1iZXJcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gaHlwZXJib2xpYyBjb3NlY2FudCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLklNRElWKCcxJywgZXhwb3J0cy5JTVNJTkgoaW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1TVUIgPSBmdW5jdGlvbihpbnVtYmVyMSwgaW51bWJlcjIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgYSA9IHRoaXMuSU1SRUFMKGludW1iZXIxKTtcblx0ICB2YXIgYiA9IHRoaXMuSU1BR0lOQVJZKGludW1iZXIxKTtcblx0ICB2YXIgYyA9IHRoaXMuSU1SRUFMKGludW1iZXIyKTtcblx0ICB2YXIgZCA9IHRoaXMuSU1BR0lOQVJZKGludW1iZXIyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGEsIGIsIGMsIGQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQxID0gaW51bWJlcjEuc3Vic3RyaW5nKGludW1iZXIxLmxlbmd0aCAtIDEpO1xuXHQgIHZhciB1bml0MiA9IGludW1iZXIyLnN1YnN0cmluZyhpbnVtYmVyMi5sZW5ndGggLSAxKTtcblx0ICB2YXIgdW5pdCA9ICdpJztcblx0ICBpZiAodW5pdDEgPT09ICdqJykge1xuXHQgICAgdW5pdCA9ICdqJztcblx0ICB9IGVsc2UgaWYgKHVuaXQyID09PSAnaicpIHtcblx0ICAgIHVuaXQgPSAnaic7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIF8gb2YgdHdvIGNvbXBsZXggbnVtYmVyc1xuXHQgIHJldHVybiB0aGlzLkNPTVBMRVgoYSAtIGMsIGIgLSBkLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNU1VNID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cblx0ICAvLyBJbml0aWFsaXplIHJlc3VsdFxuXHQgIHZhciByZXN1bHQgPSBhcmdzWzBdO1xuXG5cdCAgLy8gTG9vcCBvbiBhbGwgbnVtYmVyc1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgLy8gTG9va3VwIGNvZWZmaWNpZW50cyBvZiB0d28gY29tcGxleCBudW1iZXJzXG5cdCAgICB2YXIgYSA9IHRoaXMuSU1SRUFMKHJlc3VsdCk7XG5cdCAgICB2YXIgYiA9IHRoaXMuSU1BR0lOQVJZKHJlc3VsdCk7XG5cdCAgICB2YXIgYyA9IHRoaXMuSU1SRUFMKGFyZ3NbaV0pO1xuXHQgICAgdmFyIGQgPSB0aGlzLklNQUdJTkFSWShhcmdzW2ldKTtcblxuXHQgICAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYSwgYiwgYywgZCkpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBDb21wbHV0ZSBwcm9kdWN0IG9mIHR3byBjb21wbGV4IG51bWJlcnNcblx0ICAgIHJlc3VsdCA9IHRoaXMuQ09NUExFWChhICsgYywgYiArIGQpO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBzdW0gb2YgY29tcGxleCBudW1iZXJzXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLklNVEFOID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBpbnVtYmVyIGlzIGEgbG9naWNhbCB2YWx1ZVxuXHQgIGlmIChpbnVtYmVyID09PSB0cnVlIHx8IGludW1iZXIgPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gdGFuZ2VudCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiB0aGlzLklNRElWKHRoaXMuSU1TSU4oaW51bWJlciksIHRoaXMuSU1DT1MoaW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuT0NUMkJJTiA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgaGV4YWRlY2ltYWwgb3IgY29udGFpbnMgbW9yZSB0aGFuIHRlbiBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCEvXlswLTddezEsMTB9JC8udGVzdChudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENoZWNrIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIHZhciBuZWdhdGl2ZSA9IChudW1iZXIubGVuZ3RoID09PSAxMCAmJiBudW1iZXIuc3Vic3RyaW5nKDAsIDEpID09PSAnNycpID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdCAgLy8gQ29udmVydCBvY3RhbCBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciBkZWNpbWFsID0gKG5lZ2F0aXZlKSA/IHBhcnNlSW50KG51bWJlciwgOCkgLSAxMDczNzQxODI0IDogcGFyc2VJbnQobnVtYmVyLCA4KTtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbG93ZXIgdGhhbiAtNTEyIG9yIGdyZWF0ZXIgdGhhbiA1MTFcblx0ICBpZiAoZGVjaW1hbCA8IC01MTIgfHwgZGVjaW1hbCA+IDUxMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgYmluYXJ5IG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICBpZiAobmVnYXRpdmUpIHtcblx0ICAgIHJldHVybiAnMScgKyB0ZXh0LlJFUFQoJzAnLCA5IC0gKDUxMiArIGRlY2ltYWwpLnRvU3RyaW5nKDIpLmxlbmd0aCkgKyAoNTEyICsgZGVjaW1hbCkudG9TdHJpbmcoMik7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBkZWNpbWFsIG51bWJlciB0byBiaW5hcnlcblx0ICB2YXIgcmVzdWx0ID0gZGVjaW1hbC50b1N0cmluZygyKTtcblxuXHQgIC8vIFJldHVybiBiaW5hcnkgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHR5cGVvZiBwbGFjZXMgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5PQ1QyREVDID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3Qgb2N0YWwgb3IgY29udGFpbnMgbW9yZSB0aGFuIHRlbiBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCEvXlswLTddezEsMTB9JC8udGVzdChudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgb2N0YWwgbnVtYmVyIHRvIGRlY2ltYWxcblx0ICB2YXIgZGVjaW1hbCA9IHBhcnNlSW50KG51bWJlciwgOCk7XG5cblx0ICAvLyBSZXR1cm4gZGVjaW1hbCBudW1iZXJcblx0ICByZXR1cm4gKGRlY2ltYWwgPj0gNTM2ODcwOTEyKSA/IGRlY2ltYWwgLSAxMDczNzQxODI0IDogZGVjaW1hbDtcblx0fTtcblxuXHRleHBvcnRzLk9DVDJIRVggPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IG9jdGFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC03XXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IG9jdGFsIG51bWJlciB0byBkZWNpbWFsXG5cdCAgdmFyIGRlY2ltYWwgPSBwYXJzZUludChudW1iZXIsIDgpO1xuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIG9jdGFsIG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICBpZiAoZGVjaW1hbCA+PSA1MzY4NzA5MTIpIHtcblx0ICAgIHJldHVybiAnZmYnICsgKGRlY2ltYWwgKyAzMjIxMjI1NDcyKS50b1N0cmluZygxNik7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBkZWNpbWFsIG51bWJlciB0byBoZXhhZGVjaW1hbFxuXHQgIHZhciByZXN1bHQgPSBkZWNpbWFsLnRvU3RyaW5nKDE2KTtcblxuXHQgIC8vIFJldHVybiBoZXhhZGVjaW1hbCBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAocGxhY2VzID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgTSA9IE1hdGg7XG5cdGZ1bmN0aW9uIF9ob3JuZXIoYXJyLCB2KSB7IHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uKHosdyl7cmV0dXJuIHYgKiB6ICsgdzt9LDApOyB9O1xuXHRmdW5jdGlvbiBfYmVzc2VsX2l0ZXIoeCwgbiwgZjAsIGYxLCBzaWduKSB7XG5cdCAgaWYoIXNpZ24pIHNpZ24gPSAtMTtcblx0ICB2YXIgdGR4ID0gMiAvIHgsIGYyO1xuXHQgIGlmKG4gPT09IDApIHJldHVybiBmMDtcblx0ICBpZihuID09PSAxKSByZXR1cm4gZjE7XG5cdCAgZm9yKHZhciBvID0gMTsgbyAhPSBuOyArK28pIHtcblx0ICAgIGYyID0gZjEgKiBvICogdGR4ICsgc2lnbiAqIGYwO1xuXHQgICAgZjAgPSBmMTsgZjEgPSBmMjtcblx0ICB9XG5cdCAgcmV0dXJuIGYxO1xuXHR9XG5cdGZ1bmN0aW9uIF9iZXNzZWxfd3JhcChiZXNzZWwwLCBiZXNzZWwxLCBuYW1lLCBub256ZXJvLCBzaWduKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIGJlc3NlbCh4LG4pIHtcblx0ICAgIGlmKG4gPT09IDApIHJldHVybiBiZXNzZWwwKHgpO1xuXHQgICAgaWYobiA9PT0gMSkgcmV0dXJuIGJlc3NlbDEoeCk7XG5cdCAgICBpZihuIDwgMCkgdGhyb3cgbmFtZSArICc6IE9yZGVyICgnICsgbiArICcpIG11c3QgYmUgbm9ubmVnYXRpdmUnO1xuXHQgICAgaWYobm9uemVybyA9PSAxICYmIHggPT09IDApIHRocm93IG5hbWUgKyAnOiBVbmRlZmluZWQgd2hlbiB4ID09IDAnO1xuXHQgICAgaWYobm9uemVybyA9PSAyICYmIHggPD0gMCkgdGhyb3cgbmFtZSArICc6IFVuZGVmaW5lZCB3aGVuIHggPD0gMCc7XG5cdCAgICB2YXIgYjAgPSBiZXNzZWwwKHgpLCBiMSA9IGJlc3NlbDEoeCk7XG5cdCAgICByZXR1cm4gX2Jlc3NlbF9pdGVyKHgsIG4sIGIwLCBiMSwgc2lnbik7XG5cdCAgfTtcblx0fVxuXHR2YXIgYmVzc2VsaiA9IChmdW5jdGlvbigpIHtcblx0ICB2YXIgYjBfYTFhID0gWzU3NTY4NDkwNTc0LjAsLTEzMzYyNTkwMzU0LjAsNjUxNjE5NjQwLjcsLTExMjE0NDI0LjE4LDc3MzkyLjMzMDE3LC0xODQuOTA1MjQ1Nl0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMmEgPSBbNTc1Njg0OTA0MTEuMCwxMDI5NTMyOTg1LjAsOTQ5NDY4MC43MTgsNTkyNzIuNjQ4NTMsMjY3Ljg1MzI3MTIsMS4wXS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIwX2ExYiA9IFsxLjAsIC0wLjEwOTg2Mjg2MjdlLTIsIDAuMjczNDUxMDQwN2UtNCwgLTAuMjA3MzM3MDYzOWUtNSwgMC4yMDkzODg3MjExZS02XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIwX2EyYiA9IFstMC4xNTYyNDk5OTk1ZS0xLCAwLjE0MzA0ODg3NjVlLTMsIC0wLjY5MTExNDc2NTFlLTUsIDAuNzYyMTA5NTE2MWUtNiwgLTAuOTM0OTM1MTUyZS03XS5yZXZlcnNlKCk7XG5cdCAgdmFyIFcgPSAwLjYzNjYxOTc3MjsgLy8gMiAvIE1hdGguUElcblxuXHQgIGZ1bmN0aW9uIGJlc3NlbDAoeCkge1xuXHQgICAgdmFyIGEsIGExLCBhMiwgeSA9IHggKiB4LCB4eCA9IE0uYWJzKHgpIC0gMC43ODUzOTgxNjQ7XG5cdCAgICBpZihNLmFicyh4KSA8IDgpIHtcblx0ICAgICAgYTEgPSBfaG9ybmVyKGIwX2ExYSwgeSk7XG5cdCAgICAgIGEyID0gX2hvcm5lcihiMF9hMmEsIHkpO1xuXHQgICAgICBhID0gYTEvYTI7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgeSA9IDY0IC8geTtcblx0ICAgICAgYTEgPSBfaG9ybmVyKGIwX2ExYiwgeSk7XG5cdCAgICAgIGEyID0gX2hvcm5lcihiMF9hMmIsIHkpO1xuXHQgICAgICBhID0gTS5zcXJ0KFcvTS5hYnMoeCkpKihNLmNvcyh4eCkqYTEtTS5zaW4oeHgpKmEyKjgvTS5hYnMoeCkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGE7XG5cdCAgfVxuXHQgIHZhciBiMV9hMWEgPSBbNzIzNjI2MTQyMzIuMCwtNzg5NTA1OTIzNS4wLDI0MjM5Njg1My4xLC0yOTcyNjExLjQzOSwgMTU3MDQuNDgyNjAsIC0zMC4xNjAzNjYwNl0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMV9hMmEgPSBbMTQ0NzI1MjI4NDQyLjAsIDIzMDA1MzUxNzguMCwgMTg1ODMzMDQuNzQsIDk5NDQ3LjQzMzk0LCAzNzYuOTk5MTM5NywgMS4wXS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIxX2ExYiA9IFsxLjAsIDAuMTgzMTA1ZS0yLCAtMC4zNTE2Mzk2NDk2ZS00LCAwLjI0NTc1MjAxNzRlLTUsIC0wLjI0MDMzNzAxOWUtNl0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMV9hMmIgPSBbMC4wNDY4NzQ5OTk5NSwgLTAuMjAwMjY5MDg3M2UtMywgMC44NDQ5MTk5MDk2ZS01LCAtMC44ODIyODk4N2UtNiwgMC4xMDU3ODc0MTJlLTZdLnJldmVyc2UoKTtcblx0ICBmdW5jdGlvbiBiZXNzZWwxKHgpIHtcblx0ICAgIHZhciBhLCBhMSwgYTIsIHkgPSB4KngsIHh4ID0gTS5hYnMoeCkgLSAyLjM1NjE5NDQ5MTtcblx0ICAgIGlmKE1hdGguYWJzKHgpPCA4KSB7XG5cdCAgICAgIGExID0geCpfaG9ybmVyKGIxX2ExYSwgeSk7XG5cdCAgICAgIGEyID0gX2hvcm5lcihiMV9hMmEsIHkpO1xuXHQgICAgICBhID0gYTEgLyBhMjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHkgPSA2NCAvIHk7XG5cdCAgICAgIGExPV9ob3JuZXIoYjFfYTFiLCB5KTtcblx0ICAgICAgYTI9X2hvcm5lcihiMV9hMmIsIHkpO1xuXHQgICAgICBhPU0uc3FydChXL00uYWJzKHgpKSooTS5jb3MoeHgpKmExLU0uc2luKHh4KSphMio4L00uYWJzKHgpKTtcblx0ICAgICAgaWYoeCA8IDApIGEgPSAtYTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBhO1xuXHQgIH1cblx0ICByZXR1cm4gZnVuY3Rpb24gYmVzc2Vsaih4LCBuKSB7XG5cdCAgICBuID0gTWF0aC5yb3VuZChuKTtcblx0ICAgIGlmKG4gPT09IDApIHJldHVybiBiZXNzZWwwKE0uYWJzKHgpKTtcblx0ICAgIGlmKG4gPT09IDEpIHJldHVybiBiZXNzZWwxKE0uYWJzKHgpKTtcblx0ICAgIGlmKG4gPCAwKSB0aHJvdyAnQkVTU0VMSjogT3JkZXIgKCcgKyBuICsgJykgbXVzdCBiZSBub25uZWdhdGl2ZSc7XG5cdCAgICBpZihNLmFicyh4KSA9PT0gMCkgcmV0dXJuIDA7XG5cblx0ICAgIHZhciByZXQsIGosIHRveCA9IDIgLyBNLmFicyh4KSwgbSwganN1bSwgc3VtLCBianAsIGJqLCBiam07XG5cdCAgICBpZihNLmFicyh4KSA+IG4pIHtcblx0ICAgICAgcmV0ID0gX2Jlc3NlbF9pdGVyKHgsIG4sIGJlc3NlbDAoTS5hYnMoeCkpLCBiZXNzZWwxKE0uYWJzKHgpKSwtMSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBtPTIqTS5mbG9vcigobitNLmZsb29yKE0uc3FydCg0MCpuKSkpLzIpO1xuXHQgICAgICBqc3VtPTA7XG5cdCAgICAgIGJqcD1yZXQ9c3VtPTAuMDtcblx0ICAgICAgYmo9MS4wO1xuXHQgICAgICBmb3IgKGo9bTtqPjA7ai0tKSB7XG5cdCAgICAgICAgYmptPWoqdG94KmJqLWJqcDtcblx0ICAgICAgICBianA9Ymo7XG5cdCAgICAgICAgYmo9YmptO1xuXHQgICAgICAgIGlmIChNLmFicyhiaikgPiAxRTEwKSB7XG5cdCAgICAgICAgICBiaiAqPSAxRS0xMDtcblx0ICAgICAgICAgIGJqcCAqPSAxRS0xMDtcblx0ICAgICAgICAgIHJldCAqPSAxRS0xMDtcblx0ICAgICAgICAgIHN1bSAqPSAxRS0xMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGpzdW0pIHN1bSArPSBiajtcblx0ICAgICAgICBqc3VtPSFqc3VtO1xuXHQgICAgICAgIGlmIChqID09IG4pIHJldD1ianA7XG5cdCAgICAgIH1cblx0ICAgICAgc3VtPTIuMCpzdW0tYmo7XG5cdCAgICAgIHJldCAvPSBzdW07XG5cdCAgICB9XG5cdCAgICByZXR1cm4geCA8IDAgJiYgKG4lMikgPyAtcmV0IDogcmV0O1xuXHQgIH07XG5cdH0pKCk7XG5cdHZhciBiZXNzZWx5ID0gKGZ1bmN0aW9uKCkge1xuXHQgIHZhciBiMF9hMWEgPSBbLTI5NTc4MjEzODkuMCwgNzA2MjgzNDA2NS4wLCAtNTEyMzU5ODAzLjYsIDEwODc5ODgxLjI5LCAtODYzMjcuOTI3NTcsIDIyOC40NjIyNzMzXS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIwX2EyYSA9IFs0MDA3NjU0NDI2OS4wLCA3NDUyNDk5NjQuOCwgNzE4OTQ2Ni40MzgsIDQ3NDQ3LjI2NDcwLCAyMjYuMTAzMDI0NCwgMS4wXS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIwX2ExYiA9IFsxLjAsIC0wLjEwOTg2Mjg2MjdlLTIsIDAuMjczNDUxMDQwN2UtNCwgLTAuMjA3MzM3MDYzOWUtNSwgMC4yMDkzODg3MjExZS02XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIwX2EyYiA9IFstMC4xNTYyNDk5OTk1ZS0xLCAwLjE0MzA0ODg3NjVlLTMsIC0wLjY5MTExNDc2NTFlLTUsIDAuNzYyMTA5NTE2MWUtNiwgLTAuOTM0OTQ1MTUyZS03XS5yZXZlcnNlKCk7XG5cblx0ICB2YXIgVyA9IDAuNjM2NjE5NzcyO1xuXHQgIGZ1bmN0aW9uIGJlc3NlbDAoeCkge1xuXHQgICAgdmFyIGEsIGExLCBhMiwgeSA9IHggKiB4LCB4eCA9IHggLSAwLjc4NTM5ODE2NDtcblx0ICAgIGlmKHggPCA4KSB7XG5cdCAgICAgIGExID0gX2hvcm5lcihiMF9hMWEsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjBfYTJhLCB5KTtcblx0ICAgICAgYSA9IGExL2EyICsgVyAqIGJlc3NlbGooeCwwKSAqIE0ubG9nKHgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgeSA9IDY0IC8geTtcblx0ICAgICAgYTEgPSBfaG9ybmVyKGIwX2ExYiwgeSk7XG5cdCAgICAgIGEyID0gX2hvcm5lcihiMF9hMmIsIHkpO1xuXHQgICAgICBhID0gTS5zcXJ0KFcveCkqKE0uc2luKHh4KSphMStNLmNvcyh4eCkqYTIqOC94KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBhO1xuXHQgIH1cblxuXHQgIHZhciBiMV9hMWEgPSBbLTAuNDkwMDYwNDk0M2UxMywgMC4xMjc1Mjc0MzkwZTEzLCAtMC41MTUzNDM4MTM5ZTExLCAwLjczNDkyNjQ1NTFlOSwgLTAuNDIzNzkyMjcyNmU3LCAwLjg1MTE5Mzc5MzVlNF0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMV9hMmEgPSBbMC4yNDk5NTgwNTcwZTE0LCAwLjQyNDQ0MTk2NjRlMTIsIDAuMzczMzY1MDM2N2UxMCwgMC4yMjQ1OTA0MDAyZTgsIDAuMTAyMDQyNjA1MGU2LCAwLjM1NDk2MzI4ODVlMywgMV0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMV9hMWIgPSBbMS4wLCAwLjE4MzEwNWUtMiwgLTAuMzUxNjM5NjQ5NmUtNCwgMC4yNDU3NTIwMTc0ZS01LCAtMC4yNDAzMzcwMTllLTZdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTJiID0gWzAuMDQ2ODc0OTk5OTUsIC0wLjIwMDI2OTA4NzNlLTMsIDAuODQ0OTE5OTA5NmUtNSwgLTAuODgyMjg5ODdlLTYsIDAuMTA1Nzg3NDEyZS02XS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG5cdCAgICB2YXIgYSwgYTEsIGEyLCB5ID0geCp4LCB4eCA9IHggLSAyLjM1NjE5NDQ5MTtcblx0ICAgIGlmKHggPCA4KSB7XG5cdCAgICAgIGExID0geCpfaG9ybmVyKGIxX2ExYSwgeSk7XG5cdCAgICAgIGEyID0gX2hvcm5lcihiMV9hMmEsIHkpO1xuXHQgICAgICBhID0gYTEvYTIgKyBXICogKGJlc3NlbGooeCwxKSAqIE0ubG9nKHgpIC0gMSAvIHgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgeSA9IDY0IC8geTtcblx0ICAgICAgYTE9X2hvcm5lcihiMV9hMWIsIHkpO1xuXHQgICAgICBhMj1faG9ybmVyKGIxX2EyYiwgeSk7XG5cdCAgICAgIGE9TS5zcXJ0KFcveCkqKE0uc2luKHh4KSphMStNLmNvcyh4eCkqYTIqOC94KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBhO1xuXHQgIH1cblxuXHQgIHJldHVybiBfYmVzc2VsX3dyYXAoYmVzc2VsMCwgYmVzc2VsMSwgJ0JFU1NFTFknLCAxLCAtMSk7XG5cdH0pKCk7XG5cdHZhciBiZXNzZWxpID0gKGZ1bmN0aW9uKCkge1xuXHQgIHZhciBiMF9hID0gWzEuMCwgMy41MTU2MjI5LCAzLjA4OTk0MjQsIDEuMjA2NzQ5MiwgMC4yNjU5NzMyLCAwLjM2MDc2OGUtMSwgMC40NTgxM2UtMl0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9iID0gWzAuMzk4OTQyMjgsIDAuMTMyODU5MmUtMSwgMC4yMjUzMTllLTIsIC0wLjE1NzU2NWUtMiwgMC45MTYyODFlLTIsIC0wLjIwNTc3MDZlLTEsIDAuMjYzNTUzN2UtMSwgLTAuMTY0NzYzM2UtMSwgMC4zOTIzNzdlLTJdLnJldmVyc2UoKTtcblx0ICBmdW5jdGlvbiBiZXNzZWwwKHgpIHtcblx0ICAgIGlmKHggPD0gMy43NSkgcmV0dXJuIF9ob3JuZXIoYjBfYSwgeCp4LygzLjc1KjMuNzUpKTtcblx0ICAgIHJldHVybiBNLmV4cChNLmFicyh4KSkvTS5zcXJ0KE0uYWJzKHgpKSpfaG9ybmVyKGIwX2IsIDMuNzUvTS5hYnMoeCkpO1xuXHQgIH1cblxuXHQgIHZhciBiMV9hID0gWzAuNSwgMC44Nzg5MDU5NCwgMC41MTQ5ODg2OSwgMC4xNTA4NDkzNCwgMC4yNjU4NzMzZS0xLCAwLjMwMTUzMmUtMiwgMC4zMjQxMWUtM10ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMV9iID0gWzAuMzk4OTQyMjgsIC0wLjM5ODgwMjRlLTEsIC0wLjM2MjAxOGUtMiwgMC4xNjM4MDFlLTIsIC0wLjEwMzE1NTVlLTEsIDAuMjI4Mjk2N2UtMSwgLTAuMjg5NTMxMmUtMSwgMC4xNzg3NjU0ZS0xLCAtMC40MjAwNTllLTJdLnJldmVyc2UoKTtcblx0ICBmdW5jdGlvbiBiZXNzZWwxKHgpIHtcblx0ICAgIGlmKHggPCAzLjc1KSByZXR1cm4geCAqIF9ob3JuZXIoYjFfYSwgeCp4LygzLjc1KjMuNzUpKTtcblx0ICAgIHJldHVybiAoeCA8IDAgPyAtMSA6IDEpICogTS5leHAoTS5hYnMoeCkpL00uc3FydChNLmFicyh4KSkqX2hvcm5lcihiMV9iLCAzLjc1L00uYWJzKHgpKTtcblx0ICB9XG5cblx0ICByZXR1cm4gZnVuY3Rpb24gYmVzc2VsaSh4LCBuKSB7XG5cdCAgICBuID0gTWF0aC5yb3VuZChuKTtcblx0ICAgIGlmKG4gPT09IDApIHJldHVybiBiZXNzZWwwKHgpO1xuXHQgICAgaWYobiA9PSAxKSByZXR1cm4gYmVzc2VsMSh4KTtcblx0ICAgIGlmKG4gPCAwKSB0aHJvdyAnQkVTU0VMSSBPcmRlciAoJyArIG4gKyAnKSBtdXN0IGJlIG5vbm5lZ2F0aXZlJztcblx0ICAgIGlmKE0uYWJzKHgpID09PSAwKSByZXR1cm4gMDtcblxuXHQgICAgdmFyIHJldCwgaiwgdG94ID0gMiAvIE0uYWJzKHgpLCBtLCBiaXAsIGJpLCBiaW07XG5cdCAgICBtPTIqTS5yb3VuZCgobitNLnJvdW5kKE0uc3FydCg0MCpuKSkpLzIpO1xuXHQgICAgYmlwPXJldD0wLjA7XG5cdCAgICBiaT0xLjA7XG5cdCAgICBmb3IgKGo9bTtqPjA7ai0tKSB7XG5cdCAgICAgIGJpbT1qKnRveCpiaSArIGJpcDtcblx0ICAgICAgYmlwPWJpOyBiaT1iaW07XG5cdCAgICAgIGlmIChNLmFicyhiaSkgPiAxRTEwKSB7XG5cdCAgICAgICAgYmkgKj0gMUUtMTA7XG5cdCAgICAgICAgYmlwICo9IDFFLTEwO1xuXHQgICAgICAgIHJldCAqPSAxRS0xMDtcblx0ICAgICAgfVxuXHQgICAgICBpZihqID09IG4pIHJldCA9IGJpcDtcblx0ICAgIH1cblx0ICAgIHJldCAqPSBiZXNzZWxpKHgsIDApIC8gYmk7XG5cdCAgICByZXR1cm4geCA8IDAgJiYgKG4lMikgPyAtcmV0IDogcmV0O1xuXHQgIH07XG5cblx0fSkoKTtcblxuXHR2YXIgYmVzc2VsayA9IChmdW5jdGlvbigpIHtcblx0ICB2YXIgYjBfYSA9IFstMC41NzcyMTU2NiwgMC40MjI3ODQyMCwgMC4yMzA2OTc1NiwgMC4zNDg4NTkwZS0xLCAwLjI2MjY5OGUtMiwgMC4xMDc1MGUtMywgMC43NGUtNV0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9iID0gWzEuMjUzMzE0MTQsIC0wLjc4MzIzNThlLTEsIDAuMjE4OTU2OGUtMSwgLTAuMTA2MjQ0NmUtMSwgMC41ODc4NzJlLTIsIC0wLjI1MTU0MGUtMiwgMC41MzIwOGUtM10ucmV2ZXJzZSgpO1xuXHQgIGZ1bmN0aW9uIGJlc3NlbDAoeCkge1xuXHQgICAgaWYoeCA8PSAyKSByZXR1cm4gLU0ubG9nKHgvMikqYmVzc2VsaSh4LDApICsgX2hvcm5lcihiMF9hLCB4KngvNCk7XG5cdCAgICByZXR1cm4gTS5leHAoLXgpL00uc3FydCh4KSpfaG9ybmVyKGIwX2IsIDIveCk7XG5cdCAgfVxuXG5cdCAgdmFyIGIxX2EgPSBbMS4wLCAwLjE1NDQzMTQ0LCAtMC42NzI3ODU3OSwgLTAuMTgxNTY4OTcsIC0wLjE5MTk0MDJlLTEsIC0wLjExMDQwNGUtMiwgLTAuNDY4NmUtNF0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMV9iID0gWzEuMjUzMzE0MTQsIDAuMjM0OTg2MTksIC0wLjM2NTU2MjBlLTEsIDAuMTUwNDI2OGUtMSwgLTAuNzgwMzUzZS0yLCAwLjMyNTYxNGUtMiwgLTAuNjgyNDVlLTNdLnJldmVyc2UoKTtcblx0ICBmdW5jdGlvbiBiZXNzZWwxKHgpIHtcblx0ICAgIGlmKHggPD0gMikgcmV0dXJuIE0ubG9nKHgvMikqYmVzc2VsaSh4LDEpICsgKDEveCkqX2hvcm5lcihiMV9hLCB4KngvNCk7XG5cdCAgICByZXR1cm4gTS5leHAoLXgpL00uc3FydCh4KSpfaG9ybmVyKGIxX2IsIDIveCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIF9iZXNzZWxfd3JhcChiZXNzZWwwLCBiZXNzZWwxLCAnQkVTU0VMSycsIDIsIDEpO1xuXHR9KSgpO1xuXHRpZih0cnVlKSB7XG5cdCAgZXhwb3J0cy5iZXNzZWxqID0gYmVzc2Vsajtcblx0ICBleHBvcnRzLmJlc3NlbHkgPSBiZXNzZWx5O1xuXHQgIGV4cG9ydHMuYmVzc2VsaSA9IGJlc3NlbGk7XG5cdCAgZXhwb3J0cy5iZXNzZWxrID0gYmVzc2Vsaztcblx0fVxuXG5cblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdHZhciBkMTkwMCA9IG5ldyBEYXRlKDE5MDAsIDAsIDEpO1xuXHR2YXIgV0VFS19TVEFSVFMgPSBbXG5cdCAgdW5kZWZpbmVkLFxuXHQgIDAsXG5cdCAgMSxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICAxLFxuXHQgIDIsXG5cdCAgMyxcblx0ICA0LFxuXHQgIDUsXG5cdCAgNixcblx0ICAwXG5cdF07XG5cdHZhciBXRUVLX1RZUEVTID0gW1xuXHQgIFtdLFxuXHQgIFsxLCAyLCAzLCA0LCA1LCA2LCA3XSxcblx0ICBbNywgMSwgMiwgMywgNCwgNSwgNl0sXG5cdCAgWzYsIDAsIDEsIDIsIDMsIDQsIDVdLFxuXHQgIFtdLFxuXHQgIFtdLFxuXHQgIFtdLFxuXHQgIFtdLFxuXHQgIFtdLFxuXHQgIFtdLFxuXHQgIFtdLFxuXHQgIFs3LCAxLCAyLCAzLCA0LCA1LCA2XSxcblx0ICBbNiwgNywgMSwgMiwgMywgNCwgNV0sXG5cdCAgWzUsIDYsIDcsIDEsIDIsIDMsIDRdLFxuXHQgIFs0LCA1LCA2LCA3LCAxLCAyLCAzXSxcblx0ICBbMywgNCwgNSwgNiwgNywgMSwgMl0sXG5cdCAgWzIsIDMsIDQsIDUsIDYsIDcsIDFdLFxuXHQgIFsxLCAyLCAzLCA0LCA1LCA2LCA3XVxuXHRdO1xuXHR2YXIgV0VFS0VORF9UWVBFUyA9IFtcblx0ICBbXSxcblx0ICBbNiwgMF0sXG5cdCAgWzAsIDFdLFxuXHQgIFsxLCAyXSxcblx0ICBbMiwgM10sXG5cdCAgWzMsIDRdLFxuXHQgIFs0LCA1XSxcblx0ICBbNSwgNl0sXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsIFswLCAwXSxcblx0ICBbMSwgMV0sXG5cdCAgWzIsIDJdLFxuXHQgIFszLCAzXSxcblx0ICBbNCwgNF0sXG5cdCAgWzUsIDVdLFxuXHQgIFs2LCA2XVxuXHRdO1xuXG5cdGV4cG9ydHMuREFURSA9IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0ICB5ZWFyID0gdXRpbHMucGFyc2VOdW1iZXIoeWVhcik7XG5cdCAgbW9udGggPSB1dGlscy5wYXJzZU51bWJlcihtb250aCk7XG5cdCAgZGF5ID0gdXRpbHMucGFyc2VOdW1iZXIoZGF5KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih5ZWFyLCBtb250aCwgZGF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoeWVhciA8IDAgfHwgbW9udGggPCAwIHx8IGRheSA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHQgIHZhciBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuXHQgIHJldHVybiBkYXRlO1xuXHR9O1xuXG5cdGV4cG9ydHMuREFURVZBTFVFID0gZnVuY3Rpb24oZGF0ZV90ZXh0KSB7XG5cdCAgaWYgKHR5cGVvZiBkYXRlX3RleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBkYXRlID0gRGF0ZS5wYXJzZShkYXRlX3RleHQpO1xuXHQgIGlmIChpc05hTihkYXRlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoZGF0ZSA8PSAtMjIwMzg5MTIwMDAwMCkge1xuXHQgICAgcmV0dXJuIChkYXRlIC0gZDE5MDApIC8gODY0MDAwMDAgKyAxO1xuXHQgIH1cblx0ICByZXR1cm4gKGRhdGUgLSBkMTkwMCkgLyA4NjQwMDAwMCArIDI7XG5cdH07XG5cblx0ZXhwb3J0cy5EQVkgPSBmdW5jdGlvbihzZXJpYWxfbnVtYmVyKSB7XG5cdCAgdmFyIGRhdGUgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKGRhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGRhdGU7XG5cdCAgfVxuXHQgIHJldHVybiBkYXRlLmdldERhdGUoKTtcblx0fTtcblxuXHRleHBvcnRzLkRBWVMgPSBmdW5jdGlvbihlbmRfZGF0ZSwgc3RhcnRfZGF0ZSkge1xuXHQgIGVuZF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKGVuZF9kYXRlKTtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGlmIChlbmRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZW5kX2RhdGU7XG5cdCAgfVxuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICByZXR1cm4gc2VyaWFsKGVuZF9kYXRlKSAtIHNlcmlhbChzdGFydF9kYXRlKTtcblx0fTtcblxuXHRleHBvcnRzLkRBWVMzNjAgPSBmdW5jdGlvbihzdGFydF9kYXRlLCBlbmRfZGF0ZSwgbWV0aG9kKSB7XG5cdCAgbWV0aG9kID0gdXRpbHMucGFyc2VCb29sKG1ldGhvZCk7XG5cdCAgc3RhcnRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzdGFydF9kYXRlKTtcblx0ICBlbmRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShlbmRfZGF0ZSk7XG5cdCAgaWYgKHN0YXJ0X2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHN0YXJ0X2RhdGU7XG5cdCAgfVxuXHQgIGlmIChlbmRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZW5kX2RhdGU7XG5cdCAgfVxuXHQgIGlmIChtZXRob2QgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG1ldGhvZDtcblx0ICB9XG5cdCAgdmFyIHNtID0gc3RhcnRfZGF0ZS5nZXRNb250aCgpO1xuXHQgIHZhciBlbSA9IGVuZF9kYXRlLmdldE1vbnRoKCk7XG5cdCAgdmFyIHNkLCBlZDtcblx0ICBpZiAobWV0aG9kKSB7XG5cdCAgICBzZCA9IHN0YXJ0X2RhdGUuZ2V0RGF0ZSgpID09PSAzMSA/IDMwIDogc3RhcnRfZGF0ZS5nZXREYXRlKCk7XG5cdCAgICBlZCA9IGVuZF9kYXRlLmdldERhdGUoKSA9PT0gMzEgPyAzMCA6IGVuZF9kYXRlLmdldERhdGUoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHNtZCA9IG5ldyBEYXRlKHN0YXJ0X2RhdGUuZ2V0RnVsbFllYXIoKSwgc20gKyAxLCAwKS5nZXREYXRlKCk7XG5cdCAgICB2YXIgZW1kID0gbmV3IERhdGUoZW5kX2RhdGUuZ2V0RnVsbFllYXIoKSwgZW0gKyAxLCAwKS5nZXREYXRlKCk7XG5cdCAgICBzZCA9IHN0YXJ0X2RhdGUuZ2V0RGF0ZSgpID09PSBzbWQgPyAzMCA6IHN0YXJ0X2RhdGUuZ2V0RGF0ZSgpO1xuXHQgICAgaWYgKGVuZF9kYXRlLmdldERhdGUoKSA9PT0gZW1kKSB7XG5cdCAgICAgIGlmIChzZCA8IDMwKSB7XG5cdCAgICAgICAgZW0rKztcblx0ICAgICAgICBlZCA9IDE7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZWQgPSAzMDtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZWQgPSBlbmRfZGF0ZS5nZXREYXRlKCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiAzNjAgKiAoZW5kX2RhdGUuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0X2RhdGUuZ2V0RnVsbFllYXIoKSkgK1xuXHQgICAgMzAgKiAoZW0gLSBzbSkgKyAoZWQgLSBzZCk7XG5cdH07XG5cblx0ZXhwb3J0cy5FREFURSA9IGZ1bmN0aW9uKHN0YXJ0X2RhdGUsIG1vbnRocykge1xuXHQgIHN0YXJ0X2RhdGUgPSB1dGlscy5wYXJzZURhdGUoc3RhcnRfZGF0ZSk7XG5cdCAgaWYgKHN0YXJ0X2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHN0YXJ0X2RhdGU7XG5cdCAgfVxuXHQgIGlmIChpc05hTihtb250aHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIG1vbnRocyA9IHBhcnNlSW50KG1vbnRocywgMTApO1xuXHQgIHN0YXJ0X2RhdGUuc2V0TW9udGgoc3RhcnRfZGF0ZS5nZXRNb250aCgpICsgbW9udGhzKTtcblx0ICByZXR1cm4gc2VyaWFsKHN0YXJ0X2RhdGUpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRU9NT05USCA9IGZ1bmN0aW9uKHN0YXJ0X2RhdGUsIG1vbnRocykge1xuXHQgIHN0YXJ0X2RhdGUgPSB1dGlscy5wYXJzZURhdGUoc3RhcnRfZGF0ZSk7XG5cdCAgaWYgKHN0YXJ0X2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHN0YXJ0X2RhdGU7XG5cdCAgfVxuXHQgIGlmIChpc05hTihtb250aHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIG1vbnRocyA9IHBhcnNlSW50KG1vbnRocywgMTApO1xuXHQgIHJldHVybiBzZXJpYWwobmV3IERhdGUoc3RhcnRfZGF0ZS5nZXRGdWxsWWVhcigpLCBzdGFydF9kYXRlLmdldE1vbnRoKCkgKyBtb250aHMgKyAxLCAwKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5IT1VSID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBzZXJpYWxfbnVtYmVyLmdldEhvdXJzKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTlRFUlZBTCA9IGZ1bmN0aW9uIChzZWNvbmQpIHtcblx0ICBpZiAodHlwZW9mIHNlY29uZCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHNlY29uZCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgc2Vjb25kID0gcGFyc2VJbnQoc2Vjb25kLCAxMCk7XG5cdCAgfVxuXG5cdCAgdmFyIHllYXIgID0gTWF0aC5mbG9vcihzZWNvbmQvOTQ2MDgwMDAwKTtcblx0ICBzZWNvbmQgICAgPSBzZWNvbmQlOTQ2MDgwMDAwO1xuXHQgIHZhciBtb250aCA9IE1hdGguZmxvb3Ioc2Vjb25kLzI1OTIwMDApO1xuXHQgIHNlY29uZCAgICA9IHNlY29uZCUyNTkyMDAwO1xuXHQgIHZhciBkYXkgICA9IE1hdGguZmxvb3Ioc2Vjb25kLzg2NDAwKTtcblx0ICBzZWNvbmQgICAgPSBzZWNvbmQlODY0MDA7XG5cblx0ICB2YXIgaG91ciAgPSBNYXRoLmZsb29yKHNlY29uZC8zNjAwKTtcblx0ICBzZWNvbmQgICAgPSBzZWNvbmQlMzYwMDtcblx0ICB2YXIgbWluICAgPSBNYXRoLmZsb29yKHNlY29uZC82MCk7XG5cdCAgc2Vjb25kICAgID0gc2Vjb25kJTYwO1xuXHQgIHZhciBzZWMgICA9IHNlY29uZDtcblxuXHQgIHllYXIgID0gKHllYXIgID4gMCkgPyB5ZWFyICArICdZJyA6ICcnO1xuXHQgIG1vbnRoID0gKG1vbnRoID4gMCkgPyBtb250aCArICdNJyA6ICcnO1xuXHQgIGRheSAgID0gKGRheSAgID4gMCkgPyBkYXkgICArICdEJyA6ICcnO1xuXHQgIGhvdXIgID0gKGhvdXIgID4gMCkgPyBob3VyICArICdIJyA6ICcnO1xuXHQgIG1pbiAgID0gKG1pbiAgID4gMCkgPyBtaW4gICArICdNJyA6ICcnO1xuXHQgIHNlYyAgID0gKHNlYyAgID4gMCkgPyBzZWMgICArICdTJyA6ICcnO1xuXG5cdCAgcmV0dXJuICdQJyArIHllYXIgKyBtb250aCArIGRheSArXG5cdCAgJ1QnICsgaG91ciArIG1pbiArIHNlYztcblx0fTtcblxuXHRleHBvcnRzLklTT1dFRUtOVU0gPSBmdW5jdGlvbihkYXRlKSB7XG5cdCAgZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShkYXRlKTtcblx0ICBpZiAoZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZGF0ZTtcblx0ICB9XG5cblx0ICBkYXRlLnNldEhvdXJzKDAsIDAsIDApO1xuXHQgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDQgLSAoZGF0ZS5nZXREYXkoKSB8fCA3KSk7XG5cdCAgdmFyIHllYXJTdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG5cdCAgcmV0dXJuIE1hdGguY2VpbCgoKChkYXRlIC0geWVhclN0YXJ0KSAvIDg2NDAwMDAwKSArIDEpIC8gNyk7XG5cdH07XG5cblx0ZXhwb3J0cy5NSU5VVEUgPSBmdW5jdGlvbihzZXJpYWxfbnVtYmVyKSB7XG5cdCAgc2VyaWFsX251bWJlciA9IHV0aWxzLnBhcnNlRGF0ZShzZXJpYWxfbnVtYmVyKTtcblx0ICBpZiAoc2VyaWFsX251bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc2VyaWFsX251bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIHNlcmlhbF9udW1iZXIuZ2V0TWludXRlcygpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTU9OVEggPSBmdW5jdGlvbihzZXJpYWxfbnVtYmVyKSB7XG5cdCAgc2VyaWFsX251bWJlciA9IHV0aWxzLnBhcnNlRGF0ZShzZXJpYWxfbnVtYmVyKTtcblx0ICBpZiAoc2VyaWFsX251bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc2VyaWFsX251bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIHNlcmlhbF9udW1iZXIuZ2V0TW9udGgoKSArIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5ORVRXT1JLREFZUyA9IGZ1bmN0aW9uKHN0YXJ0X2RhdGUsIGVuZF9kYXRlLCBob2xpZGF5cykge1xuXHQgIHJldHVybiB0aGlzLk5FVFdPUktEQVlTLklOVEwoc3RhcnRfZGF0ZSwgZW5kX2RhdGUsIDEsIGhvbGlkYXlzKTtcblx0fTtcblxuXHRleHBvcnRzLk5FVFdPUktEQVlTLklOVEwgPSBmdW5jdGlvbihzdGFydF9kYXRlLCBlbmRfZGF0ZSwgd2Vla2VuZCwgaG9saWRheXMpIHtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBlbmRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShlbmRfZGF0ZSk7XG5cdCAgaWYgKGVuZF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlbmRfZGF0ZTtcblx0ICB9XG5cdCAgaWYgKHdlZWtlbmQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgd2Vla2VuZCA9IFdFRUtFTkRfVFlQRVNbMV07XG5cdCAgfSBlbHNlIHtcblx0ICAgIHdlZWtlbmQgPSBXRUVLRU5EX1RZUEVTW3dlZWtlbmRdO1xuXHQgIH1cblx0ICBpZiAoISh3ZWVrZW5kIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChob2xpZGF5cyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBob2xpZGF5cyA9IFtdO1xuXHQgIH0gZWxzZSBpZiAoIShob2xpZGF5cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgaG9saWRheXMgPSBbaG9saWRheXNdO1xuXHQgIH1cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGhvbGlkYXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgaCA9IHV0aWxzLnBhcnNlRGF0ZShob2xpZGF5c1tpXSk7XG5cdCAgICBpZiAoaCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgIHJldHVybiBoO1xuXHQgICAgfVxuXHQgICAgaG9saWRheXNbaV0gPSBoO1xuXHQgIH1cblx0ICB2YXIgZGF5cyA9IChlbmRfZGF0ZSAtIHN0YXJ0X2RhdGUpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpICsgMTtcblx0ICB2YXIgdG90YWwgPSBkYXlzO1xuXHQgIHZhciBkYXkgPSBzdGFydF9kYXRlO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBkYXlzOyBpKyspIHtcblx0ICAgIHZhciBkID0gKG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSA+IDApID8gZGF5LmdldFVUQ0RheSgpIDogZGF5LmdldERheSgpO1xuXHQgICAgdmFyIGRlYyA9IGZhbHNlO1xuXHQgICAgaWYgKGQgPT09IHdlZWtlbmRbMF0gfHwgZCA9PT0gd2Vla2VuZFsxXSkge1xuXHQgICAgICBkZWMgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBob2xpZGF5cy5sZW5ndGg7IGorKykge1xuXHQgICAgICB2YXIgaG9saWRheSA9IGhvbGlkYXlzW2pdO1xuXHQgICAgICBpZiAoaG9saWRheS5nZXREYXRlKCkgPT09IGRheS5nZXREYXRlKCkgJiZcblx0ICAgICAgICBob2xpZGF5LmdldE1vbnRoKCkgPT09IGRheS5nZXRNb250aCgpICYmXG5cdCAgICAgICAgaG9saWRheS5nZXRGdWxsWWVhcigpID09PSBkYXkuZ2V0RnVsbFllYXIoKSkge1xuXHQgICAgICAgIGRlYyA9IHRydWU7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChkZWMpIHtcblx0ICAgICAgdG90YWwtLTtcblx0ICAgIH1cblx0ICAgIGRheS5zZXREYXRlKGRheS5nZXREYXRlKCkgKyAxKTtcblx0ICB9XG5cdCAgcmV0dXJuIHRvdGFsO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9XID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIG5ldyBEYXRlKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5TRUNPTkQgPSBmdW5jdGlvbihzZXJpYWxfbnVtYmVyKSB7XG5cdCAgc2VyaWFsX251bWJlciA9IHV0aWxzLnBhcnNlRGF0ZShzZXJpYWxfbnVtYmVyKTtcblx0ICBpZiAoc2VyaWFsX251bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc2VyaWFsX251bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIHNlcmlhbF9udW1iZXIuZ2V0U2Vjb25kcygpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVElNRSA9IGZ1bmN0aW9uKGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSB7XG5cdCAgaG91ciA9IHV0aWxzLnBhcnNlTnVtYmVyKGhvdXIpO1xuXHQgIG1pbnV0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKG1pbnV0ZSk7XG5cdCAgc2Vjb25kID0gdXRpbHMucGFyc2VOdW1iZXIoc2Vjb25kKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihob3VyLCBtaW51dGUsIHNlY29uZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGhvdXIgPCAwIHx8IG1pbnV0ZSA8IDAgfHwgc2Vjb25kIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cdCAgcmV0dXJuICgzNjAwICogaG91ciArIDYwICogbWludXRlICsgc2Vjb25kKSAvIDg2NDAwO1xuXHR9O1xuXG5cdGV4cG9ydHMuVElNRVZBTFVFID0gZnVuY3Rpb24odGltZV90ZXh0KSB7XG5cdCAgdGltZV90ZXh0ID0gdXRpbHMucGFyc2VEYXRlKHRpbWVfdGV4dCk7XG5cdCAgaWYgKHRpbWVfdGV4dCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gdGltZV90ZXh0O1xuXHQgIH1cblx0ICByZXR1cm4gKDM2MDAgKiB0aW1lX3RleHQuZ2V0SG91cnMoKSArXG5cdCAgICA2MCAqIHRpbWVfdGV4dC5nZXRNaW51dGVzKCkgK1xuXHQgICAgdGltZV90ZXh0LmdldFNlY29uZHMoKSkgLyA4NjQwMDtcblx0fTtcblxuXHRleHBvcnRzLlRPREFZID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIG5ldyBEYXRlKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5XRUVLREFZID0gZnVuY3Rpb24oc2VyaWFsX251bWJlciwgcmV0dXJuX3R5cGUpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICBpZiAocmV0dXJuX3R5cGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuX3R5cGUgPSAxO1xuXHQgIH1cblx0ICB2YXIgZGF5ID0gc2VyaWFsX251bWJlci5nZXREYXkoKTtcblx0ICByZXR1cm4gV0VFS19UWVBFU1tyZXR1cm5fdHlwZV1bZGF5XTtcblx0fTtcblxuXHRleHBvcnRzLldFRUtOVU0gPSBmdW5jdGlvbihzZXJpYWxfbnVtYmVyLCByZXR1cm5fdHlwZSkge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIGlmIChyZXR1cm5fdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm5fdHlwZSA9IDE7XG5cdCAgfVxuXHQgIGlmIChyZXR1cm5fdHlwZSA9PT0gMjEpIHtcblx0ICAgIHJldHVybiB0aGlzLklTT1dFRUtOVU0oc2VyaWFsX251bWJlcik7XG5cdCAgfVxuXHQgIHZhciB3ZWVrX3N0YXJ0ID0gV0VFS19TVEFSVFNbcmV0dXJuX3R5cGVdO1xuXHQgIHZhciBqYW4gPSBuZXcgRGF0ZShzZXJpYWxfbnVtYmVyLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuXHQgIHZhciBpbmMgPSBqYW4uZ2V0RGF5KCkgPCB3ZWVrX3N0YXJ0ID8gMSA6IDA7XG5cdCAgamFuIC09IE1hdGguYWJzKGphbi5nZXREYXkoKSAtIHdlZWtfc3RhcnQpICogMjQgKiA2MCAqIDYwICogMTAwMDtcblx0ICByZXR1cm4gTWF0aC5mbG9vcigoKHNlcmlhbF9udW1iZXIgLSBqYW4pIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSAvIDcgKyAxKSArIGluYztcblx0fTtcblxuXHRleHBvcnRzLldPUktEQVkgPSBmdW5jdGlvbihzdGFydF9kYXRlLCBkYXlzLCBob2xpZGF5cykge1xuXHQgIHJldHVybiB0aGlzLldPUktEQVkuSU5UTChzdGFydF9kYXRlLCBkYXlzLCAxLCBob2xpZGF5cyk7XG5cdH07XG5cblx0ZXhwb3J0cy5XT1JLREFZLklOVEwgPSBmdW5jdGlvbihzdGFydF9kYXRlLCBkYXlzLCB3ZWVrZW5kLCBob2xpZGF5cykge1xuXHQgIHN0YXJ0X2RhdGUgPSB1dGlscy5wYXJzZURhdGUoc3RhcnRfZGF0ZSk7XG5cdCAgaWYgKHN0YXJ0X2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHN0YXJ0X2RhdGU7XG5cdCAgfVxuXHQgIGRheXMgPSB1dGlscy5wYXJzZU51bWJlcihkYXlzKTtcblx0ICBpZiAoZGF5cyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZGF5cztcblx0ICB9XG5cdCAgaWYgKGRheXMgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0ICBpZiAod2Vla2VuZCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB3ZWVrZW5kID0gV0VFS0VORF9UWVBFU1sxXTtcblx0ICB9IGVsc2Uge1xuXHQgICAgd2Vla2VuZCA9IFdFRUtFTkRfVFlQRVNbd2Vla2VuZF07XG5cdCAgfVxuXHQgIGlmICghKHdlZWtlbmQgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGhvbGlkYXlzID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGhvbGlkYXlzID0gW107XG5cdCAgfSBlbHNlIGlmICghKGhvbGlkYXlzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICBob2xpZGF5cyA9IFtob2xpZGF5c107XG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9saWRheXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBoID0gdXRpbHMucGFyc2VEYXRlKGhvbGlkYXlzW2ldKTtcblx0ICAgIGlmIChoIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIGg7XG5cdCAgICB9XG5cdCAgICBob2xpZGF5c1tpXSA9IGg7XG5cdCAgfVxuXHQgIHZhciBkID0gMDtcblx0ICB3aGlsZSAoZCA8IGRheXMpIHtcblx0ICAgIHN0YXJ0X2RhdGUuc2V0RGF0ZShzdGFydF9kYXRlLmdldERhdGUoKSArIDEpO1xuXHQgICAgdmFyIGRheSA9IHN0YXJ0X2RhdGUuZ2V0RGF5KCk7XG5cdCAgICBpZiAoZGF5ID09PSB3ZWVrZW5kWzBdIHx8IGRheSA9PT0gd2Vla2VuZFsxXSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgaG9saWRheXMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgdmFyIGhvbGlkYXkgPSBob2xpZGF5c1tqXTtcblx0ICAgICAgaWYgKGhvbGlkYXkuZ2V0RGF0ZSgpID09PSBzdGFydF9kYXRlLmdldERhdGUoKSAmJlxuXHQgICAgICAgIGhvbGlkYXkuZ2V0TW9udGgoKSA9PT0gc3RhcnRfZGF0ZS5nZXRNb250aCgpICYmXG5cdCAgICAgICAgaG9saWRheS5nZXRGdWxsWWVhcigpID09PSBzdGFydF9kYXRlLmdldEZ1bGxZZWFyKCkpIHtcblx0ICAgICAgICBkLS07XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGQrKztcblx0ICB9XG5cdCAgcmV0dXJuIHN0YXJ0X2RhdGU7XG5cdH07XG5cblx0ZXhwb3J0cy5ZRUFSID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBzZXJpYWxfbnVtYmVyLmdldEZ1bGxZZWFyKCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG5cdCAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIDEsIDI5KS5nZXRNb250aCgpID09PSAxO1xuXHR9XG5cblx0Ly8gVE9ETyA6IFVzZSBEQVlTID9cblx0ZnVuY3Rpb24gZGF5c0JldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIHtcblx0ICByZXR1cm4gTWF0aC5jZWlsKChlbmRfZGF0ZSAtIHN0YXJ0X2RhdGUpIC8gMTAwMCAvIDYwIC8gNjAgLyAyNCk7XG5cdH1cblxuXHRleHBvcnRzLllFQVJGUkFDID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZW5kX2RhdGUsIGJhc2lzKSB7XG5cdCAgc3RhcnRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzdGFydF9kYXRlKTtcblx0ICBpZiAoc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0ICB9XG5cdCAgZW5kX2RhdGUgPSB1dGlscy5wYXJzZURhdGUoZW5kX2RhdGUpO1xuXHQgIGlmIChlbmRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZW5kX2RhdGU7XG5cdCAgfVxuXG5cdCAgYmFzaXMgPSBiYXNpcyB8fCAwO1xuXHQgIHZhciBzZCA9IHN0YXJ0X2RhdGUuZ2V0RGF0ZSgpO1xuXHQgIHZhciBzbSA9IHN0YXJ0X2RhdGUuZ2V0TW9udGgoKSArIDE7XG5cdCAgdmFyIHN5ID0gc3RhcnRfZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHQgIHZhciBlZCA9IGVuZF9kYXRlLmdldERhdGUoKTtcblx0ICB2YXIgZW0gPSBlbmRfZGF0ZS5nZXRNb250aCgpICsgMTtcblx0ICB2YXIgZXkgPSBlbmRfZGF0ZS5nZXRGdWxsWWVhcigpO1xuXG5cdCAgc3dpdGNoIChiYXNpcykge1xuXHQgICAgY2FzZSAwOlxuXHQgICAgICAvLyBVUyAoTkFTRCkgMzAvMzYwXG5cdCAgICAgIGlmIChzZCA9PT0gMzEgJiYgZWQgPT09IDMxKSB7XG5cdCAgICAgICAgc2QgPSAzMDtcblx0ICAgICAgICBlZCA9IDMwO1xuXHQgICAgICB9IGVsc2UgaWYgKHNkID09PSAzMSkge1xuXHQgICAgICAgIHNkID0gMzA7XG5cdCAgICAgIH0gZWxzZSBpZiAoc2QgPT09IDMwICYmIGVkID09PSAzMSkge1xuXHQgICAgICAgIGVkID0gMzA7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuICgoZWQgKyBlbSAqIDMwICsgZXkgKiAzNjApIC0gKHNkICsgc20gKiAzMCArIHN5ICogMzYwKSkgLyAzNjA7XG5cdCAgICBjYXNlIDE6XG5cdCAgICAgIC8vIEFjdHVhbC9hY3R1YWxcblx0ICAgICAgdmFyIGZlYjI5QmV0d2VlbiA9IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuXHQgICAgICAgIHZhciB5ZWFyMSA9IGRhdGUxLmdldEZ1bGxZZWFyKCk7XG5cdCAgICAgICAgdmFyIG1hcjF5ZWFyMSA9IG5ldyBEYXRlKHllYXIxLCAyLCAxKTtcblx0ICAgICAgICBpZiAoaXNMZWFwWWVhcih5ZWFyMSkgJiYgZGF0ZTEgPCBtYXIxeWVhcjEgJiYgZGF0ZTIgPj0gbWFyMXllYXIxKSB7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHllYXIyID0gZGF0ZTIuZ2V0RnVsbFllYXIoKTtcblx0ICAgICAgICB2YXIgbWFyMXllYXIyID0gbmV3IERhdGUoeWVhcjIsIDIsIDEpO1xuXHQgICAgICAgIHJldHVybiAoaXNMZWFwWWVhcih5ZWFyMikgJiYgZGF0ZTIgPj0gbWFyMXllYXIyICYmIGRhdGUxIDwgbWFyMXllYXIyKTtcblx0ICAgICAgfTtcblx0ICAgICAgdmFyIHlsZW5ndGggPSAzNjU7XG5cdCAgICAgIGlmIChzeSA9PT0gZXkgfHwgKChzeSArIDEpID09PSBleSkgJiYgKChzbSA+IGVtKSB8fCAoKHNtID09PSBlbSkgJiYgKHNkID49IGVkKSkpKSB7XG5cdCAgICAgICAgaWYgKChzeSA9PT0gZXkgJiYgaXNMZWFwWWVhcihzeSkpIHx8XG5cdCAgICAgICAgICAgIGZlYjI5QmV0d2VlbihzdGFydF9kYXRlLCBlbmRfZGF0ZSkgfHxcblx0ICAgICAgICAgICAgKGVtID09PSAxICYmIGVkID09PSAyOSkpIHtcblx0ICAgICAgICAgIHlsZW5ndGggPSAzNjY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBkYXlzQmV0d2VlbihzdGFydF9kYXRlLCBlbmRfZGF0ZSkgLyB5bGVuZ3RoO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciB5ZWFycyA9IChleSAtIHN5KSArIDE7XG5cdCAgICAgIHZhciBkYXlzID0gKG5ldyBEYXRlKGV5ICsgMSwgMCwgMSkgLSBuZXcgRGF0ZShzeSwgMCwgMSkpIC8gMTAwMCAvIDYwIC8gNjAgLyAyNDtcblx0ICAgICAgdmFyIGF2ZXJhZ2UgPSBkYXlzIC8geWVhcnM7XG5cdCAgICAgIHJldHVybiBkYXlzQmV0d2VlbihzdGFydF9kYXRlLCBlbmRfZGF0ZSkgLyBhdmVyYWdlO1xuXHQgICAgY2FzZSAyOlxuXHQgICAgICAvLyBBY3R1YWwvMzYwXG5cdCAgICAgIHJldHVybiBkYXlzQmV0d2VlbihzdGFydF9kYXRlLCBlbmRfZGF0ZSkgLyAzNjA7XG5cdCAgICBjYXNlIDM6XG5cdCAgICAgIC8vIEFjdHVhbC8zNjVcblx0ICAgICAgcmV0dXJuIGRheXNCZXR3ZWVuKHN0YXJ0X2RhdGUsIGVuZF9kYXRlKSAvIDM2NTtcblx0ICAgIGNhc2UgNDpcblx0ICAgICAgLy8gRXVyb3BlYW4gMzAvMzYwXG5cdCAgICAgIHJldHVybiAoKGVkICsgZW0gKiAzMCArIGV5ICogMzYwKSAtIChzZCArIHNtICogMzAgKyBzeSAqIDM2MCkpIC8gMzYwO1xuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBzZXJpYWwoZGF0ZSkge1xuXHQgIHZhciBhZGRPbiA9IChkYXRlID4gLTIyMDM4OTEyMDAwMDApPzI6MTtcblx0ICByZXR1cm4gKGRhdGUgLSBkMTkwMCkgLyA4NjQwMDAwMCArIGFkZE9uO1xuXHR9XG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIHN0YXRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIG1hdGhzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXHRmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG5cdCAgaWYgKCFhcnJheSkgeyByZXR1cm4gYXJyYXk7IH1cblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuXHQgICAgaWYgKCFhcnJheVtpXSkgeyBjb250aW51ZTsgfVxuXHQgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZXhwb3J0cy5GSU5ERklFTEQgPSBmdW5jdGlvbihkYXRhYmFzZSwgdGl0bGUpIHtcblx0ICB2YXIgaW5kZXggPSBudWxsO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YWJhc2UubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChkYXRhYmFzZVtpXVswXSA9PT0gdGl0bGUpIHtcblx0ICAgICAgaW5kZXggPSBpO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgdGhlIGlucHV0IGZpZWxkIHRpdGxlIGlzIGluY29ycmVjdFxuXHQgIGlmIChpbmRleCA9PSBudWxsKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBpbmRleDtcblx0fTtcblxuXHRmdW5jdGlvbiBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhcykge1xuXHQgIHZhciBtYXRjaGVzID0ge307XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBkYXRhYmFzZVswXS5sZW5ndGg7ICsraSkge1xuXHQgICAgbWF0Y2hlc1tpXSA9IHRydWU7XG5cdCAgfVxuXHQgIHZhciBtYXhDcml0ZXJpYUxlbmd0aCA9IGNyaXRlcmlhc1swXS5sZW5ndGg7XG5cdCAgZm9yIChpID0gMTsgaSA8IGNyaXRlcmlhcy5sZW5ndGg7ICsraSkge1xuXHQgICAgaWYgKGNyaXRlcmlhc1tpXS5sZW5ndGggPiBtYXhDcml0ZXJpYUxlbmd0aCkge1xuXHQgICAgICBtYXhDcml0ZXJpYUxlbmd0aCA9IGNyaXRlcmlhc1tpXS5sZW5ndGg7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZm9yICh2YXIgayA9IDE7IGsgPCBkYXRhYmFzZS5sZW5ndGg7ICsraykge1xuXHQgICAgZm9yICh2YXIgbCA9IDE7IGwgPCBkYXRhYmFzZVtrXS5sZW5ndGg7ICsrbCkge1xuXHQgICAgICB2YXIgY3VycmVudENyaXRlcmlhUmVzdWx0ID0gZmFsc2U7XG5cdCAgICAgIHZhciBoYXNNYXRjaGluZ0NyaXRlcmlhICAgPSBmYWxzZTtcblx0ICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjcml0ZXJpYXMubGVuZ3RoOyArK2opIHtcblx0ICAgICAgICB2YXIgY3JpdGVyaWEgPSBjcml0ZXJpYXNbal07XG5cdCAgICAgICAgaWYgKGNyaXRlcmlhLmxlbmd0aCA8IG1heENyaXRlcmlhTGVuZ3RoKSB7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgY3JpdGVyaWFGaWVsZCA9IGNyaXRlcmlhWzBdO1xuXHQgICAgICAgIGlmIChkYXRhYmFzZVtrXVswXSAhPT0gY3JpdGVyaWFGaWVsZCkge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGhhc01hdGNoaW5nQ3JpdGVyaWEgPSB0cnVlO1xuXHQgICAgICAgIGZvciAodmFyIHAgPSAxOyBwIDwgY3JpdGVyaWEubGVuZ3RoOyArK3ApIHtcblx0ICAgICAgICAgIGN1cnJlbnRDcml0ZXJpYVJlc3VsdCA9IGN1cnJlbnRDcml0ZXJpYVJlc3VsdCB8fCBldmFsKGRhdGFiYXNlW2tdW2xdICsgY3JpdGVyaWFbcF0pOyAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChoYXNNYXRjaGluZ0NyaXRlcmlhKSB7XG5cdCAgICAgICAgbWF0Y2hlc1tsXSA9IG1hdGNoZXNbbF0gJiYgY3VycmVudENyaXRlcmlhUmVzdWx0O1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgIGZvciAodmFyIG4gPSAwOyBuIDwgZGF0YWJhc2VbMF0ubGVuZ3RoOyArK24pIHtcblx0ICAgIGlmIChtYXRjaGVzW25dKSB7XG5cdCAgICAgIHJlc3VsdC5wdXNoKG4gLSAxKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8vIERhdGFiYXNlIGZ1bmN0aW9uc1xuXHRleHBvcnRzLkRBVkVSQUdFID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgc3VtID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHN1bSArPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHRJbmRleGVzLmxlbmd0aCA9PT0gMCA/IGVycm9yLmRpdjAgOiBzdW0gLyByZXN1bHRJbmRleGVzLmxlbmd0aDtcblx0fTtcblxuXHRleHBvcnRzLkRDT1VOVCA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHRhcmdldFZhbHVlcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdGFyZ2V0VmFsdWVzW2ldID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICByZXR1cm4gc3RhdHMuQ09VTlQodGFyZ2V0VmFsdWVzKTtcblx0fTtcblxuXHRleHBvcnRzLkRDT1VOVEEgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgcmV0dXJuIHN0YXRzLkNPVU5UQSh0YXJnZXRWYWx1ZXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuREdFVCA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG5vIHJlY29yZCBtZWV0cyB0aGUgY3JpdGVyaWFcblx0ICBpZiAocmVzdWx0SW5kZXhlcy5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgLy8gUmV0dXJucyB0aGUgI05VTSEgZXJyb3IgdmFsdWUgYmVjYXVzZSBtb3JlIHRoYW4gb25lIHJlY29yZCBtZWV0cyB0aGVcblx0ICAvLyBjcml0ZXJpYVxuXHQgIGlmIChyZXN1bHRJbmRleGVzLmxlbmd0aCA+IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzWzBdXTtcblx0fTtcblxuXHRleHBvcnRzLkRNQVggPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciBtYXhWYWx1ZSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzWzBdXTtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChtYXhWYWx1ZSA8IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXSkge1xuXHQgICAgICBtYXhWYWx1ZSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG1heFZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMuRE1JTiA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIG1pblZhbHVlID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbMF1dO1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKG1pblZhbHVlID4gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dKSB7XG5cdCAgICAgIG1pblZhbHVlID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gbWluVmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5EUFJPRFVDVCA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHRhcmdldFZhbHVlcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdGFyZ2V0VmFsdWVzW2ldID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICB0YXJnZXRWYWx1ZXMgPSBjb21wYWN0KHRhcmdldFZhbHVlcyk7XG5cdCAgdmFyIHJlc3VsdCA9IDE7XG5cdCAgZm9yIChpID0gMDsgaSA8IHRhcmdldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICo9IHRhcmdldFZhbHVlc1tpXTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkRTVERFViA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHRhcmdldFZhbHVlcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdGFyZ2V0VmFsdWVzW2ldID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICB0YXJnZXRWYWx1ZXMgPSBjb21wYWN0KHRhcmdldFZhbHVlcyk7XG5cdCAgcmV0dXJuIHN0YXRzLlNUREVWLlModGFyZ2V0VmFsdWVzKTtcblx0fTtcblxuXHRleHBvcnRzLkRTVERFVlAgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgdGFyZ2V0VmFsdWVzID0gY29tcGFjdCh0YXJnZXRWYWx1ZXMpO1xuXHQgIHJldHVybiBzdGF0cy5TVERFVi5QKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblx0ZXhwb3J0cy5EU1VNID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHJldHVybiBtYXRocy5TVU0odGFyZ2V0VmFsdWVzKTtcblx0fTtcblxuXHRleHBvcnRzLkRWQVIgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgcmV0dXJuIHN0YXRzLlZBUi5TKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblx0ZXhwb3J0cy5EVkFSUCA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHRhcmdldFZhbHVlcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdGFyZ2V0VmFsdWVzW2ldID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICByZXR1cm4gc3RhdHMuVkFSLlAodGFyZ2V0VmFsdWVzKTtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBpbmZvcm1hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cdGV4cG9ydHMuQU5EID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgdmFyIHJlc3VsdCA9IHRydWU7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoIWFyZ3NbaV0pIHtcblx0ICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5DSE9PU0UgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICB2YXIgaW5kZXggPSBhcmd1bWVudHNbMF07XG5cdCAgaWYgKGluZGV4IDwgMSB8fCBpbmRleCA+IDI1NCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgaW5kZXggKyAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGFyZ3VtZW50c1tpbmRleF07XG5cdH07XG5cblx0ZXhwb3J0cy5GQUxTRSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRleHBvcnRzLklGID0gZnVuY3Rpb24odGVzdCwgdGhlbl92YWx1ZSwgb3RoZXJ3aXNlX3ZhbHVlKSB7XG5cdCAgcmV0dXJuIHRlc3QgPyB0aGVuX3ZhbHVlIDogb3RoZXJ3aXNlX3ZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMuSUZFUlJPUiA9IGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZUlmRXJyb3IpIHtcblx0ICBpZiAoaW5mb3JtYXRpb24uSVNFUlJPUih2YWx1ZSkpIHtcblx0ICAgIHJldHVybiB2YWx1ZUlmRXJyb3I7XG5cdCAgfVxuXHQgIHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLklGTkEgPSBmdW5jdGlvbih2YWx1ZSwgdmFsdWVfaWZfbmEpIHtcblx0ICByZXR1cm4gdmFsdWUgPT09IGVycm9yLm5hID8gdmFsdWVfaWZfbmEgOiB2YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLk5PVCA9IGZ1bmN0aW9uKGxvZ2ljYWwpIHtcblx0ICByZXR1cm4gIWxvZ2ljYWw7XG5cdH07XG5cblx0ZXhwb3J0cy5PUiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciByZXN1bHQgPSBmYWxzZTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChhcmdzW2ldKSB7XG5cdCAgICAgIHJlc3VsdCA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5UUlVFID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIHRydWU7XG5cdH07XG5cblx0ZXhwb3J0cy5YT1IgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChhcmdzW2ldKSB7XG5cdCAgICAgIHJlc3VsdCsrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gKE1hdGguZmxvb3IoTWF0aC5hYnMocmVzdWx0KSkgJiAxKSA/IHRydWUgOiBmYWxzZTtcblx0fTtcblxuXHRleHBvcnRzLlNXSVRDSCA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgcmVzdWx0O1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgIHtcblx0ICAgIHZhciB0YXJnZXRWYWx1ZSA9IGFyZ3VtZW50c1swXTtcblx0ICAgIHZhciBhcmdjID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cdCAgICB2YXIgc3dpdGNoQ291bnQgPSBNYXRoLmZsb29yKGFyZ2MgLyAyKTtcblx0ICAgIHZhciBzd2l0Y2hTYXRpc2ZpZWQgPSBmYWxzZTtcblx0ICAgIHZhciBkZWZhdWx0Q2xhdXNlID0gYXJnYyAlIDIgPT09IDAgPyBudWxsIDogYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblxuXHQgICAgaWYgKHN3aXRjaENvdW50KSB7XG5cdCAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzd2l0Y2hDb3VudDsgaW5kZXgrKykge1xuXHQgICAgICAgIGlmICh0YXJnZXRWYWx1ZSA9PT0gYXJndW1lbnRzW2luZGV4ICogMiArIDFdKSB7XG5cdCAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbaW5kZXggKiAyICsgMl07XG5cdCAgICAgICAgICBzd2l0Y2hTYXRpc2ZpZWQgPSB0cnVlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICghc3dpdGNoU2F0aXNmaWVkICYmIGRlZmF1bHRDbGF1c2UpIHtcblx0ICAgICAgcmVzdWx0ID0gZGVmYXVsdENsYXVzZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIGRhdGVUaW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblx0ZnVuY3Rpb24gdmFsaWREYXRlKGQpIHtcblx0ICByZXR1cm4gZCAmJiBkLmdldFRpbWUgJiYgIWlzTmFOKGQuZ2V0VGltZSgpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuc3VyZURhdGUoZCkge1xuXHQgIHJldHVybiAoZCBpbnN0YW5jZW9mIERhdGUpP2Q6bmV3IERhdGUoZCk7XG5cdH1cblxuXHRleHBvcnRzLkFDQ1JJTlQgPSBmdW5jdGlvbihpc3N1ZSwgZmlyc3QsIHNldHRsZW1lbnQsIHJhdGUsIHBhciwgZnJlcXVlbmN5LCBiYXNpcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgZGF0ZSBpcyBpbnZhbGlkXG5cdCAgaXNzdWUgICAgICA9IGVuc3VyZURhdGUoaXNzdWUpO1xuXHQgIGZpcnN0ICAgICAgPSBlbnN1cmVEYXRlKGZpcnN0KTtcblx0ICBzZXR0bGVtZW50ID0gZW5zdXJlRGF0ZShzZXR0bGVtZW50KTtcblx0ICBpZiAoIXZhbGlkRGF0ZShpc3N1ZSkgfHwgIXZhbGlkRGF0ZShmaXJzdCkgfHwgIXZhbGlkRGF0ZShzZXR0bGVtZW50KSkge1xuXHQgICAgcmV0dXJuICcjVkFMVUUhJztcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIHJhdGUgb3IgcGFyIGFyZSBsb3dlciB0aGFuIG9yIGVxdWFsIHRvIHplcm9cblx0ICBpZiAocmF0ZSA8PSAwIHx8IHBhciA8PSAwKSB7XG5cdCAgICByZXR1cm4gJyNOVU0hJztcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZnJlcXVlbmN5IGlzIG5laXRoZXIgMSwgMiwgb3IgNFxuXHQgIGlmIChbMSwgMiwgNF0uaW5kZXhPZihmcmVxdWVuY3kpID09PSAtMSkge1xuXHQgICAgcmV0dXJuICcjTlVNISc7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGJhc2lzIGlzIG5laXRoZXIgMCwgMSwgMiwgMywgb3IgNFxuXHQgIGlmIChbMCwgMSwgMiwgMywgNF0uaW5kZXhPZihiYXNpcykgPT09IC0xKSB7XG5cdCAgICByZXR1cm4gJyNOVU0hJztcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgc2V0dGxlbWVudCBpcyBiZWZvcmUgb3IgZXF1YWwgdG8gaXNzdWVcblx0ICBpZiAoc2V0dGxlbWVudCA8PSBpc3N1ZSkge1xuXHQgICAgcmV0dXJuICcjTlVNISc7XG5cdCAgfVxuXG5cdCAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzXG5cdCAgcGFyICAgPSBwYXIgICB8fCAwO1xuXHQgIGJhc2lzID0gYmFzaXMgfHwgMDtcblxuXHQgIC8vIENvbXB1dGUgYWNjcnVlZCBpbnRlcmVzdFxuXHQgIHJldHVybiBwYXIgKiByYXRlICogZGF0ZVRpbWUuWUVBUkZSQUMoaXNzdWUsIHNldHRsZW1lbnQsIGJhc2lzKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQUNDUklOVE0gPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQUNDUklOVE0gaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkFNT1JERUdSQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdBTU9SREVHUkMgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkFNT1JMSU5DID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0FNT1JMSU5DIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5DT1VQREFZQlMgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ09VUERBWUJTIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5DT1VQREFZUyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdDT1VQREFZUyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ09VUERBWVNOQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdDT1VQREFZU05DIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5DT1VQTkNEID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0NPVVBOQ0QgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNPVVBOVU0gPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ09VUE5VTSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ09VUFBDRCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdDT1VQUENEIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ1VNSVBNVCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZHMsIHZhbHVlLCBzdGFydCwgZW5kLCB0eXBlKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cdCAgLy8gQ3JlZGl0czogSGFubmVzIFN0aWViaXR6aG9mZXIgZm9yIHRoZSB0cmFuc2xhdGlvbnMgb2YgZnVuY3Rpb24gYW5kIHZhcmlhYmxlIG5hbWVzXG5cdCAgLy8gUmVxdWlyZXMgZXhwb3J0cy5GVigpIGFuZCBleHBvcnRzLlBNVCgpIGZyb20gZXhwb3J0cy5qcyBbaHR0cDovL3N0b2ljLmNvbS9leHBvcnRzL11cblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgdmFsdWUgPSB1dGlscy5wYXJzZU51bWJlcih2YWx1ZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcywgdmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciByYXRlLCBwZXJpb2RzLCBvciB2YWx1ZSBhcmUgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHJhdGUgPD0gMCB8fCBwZXJpb2RzIDw9IDAgfHwgdmFsdWUgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgc3RhcnQgPCAxLCBlbmQgPCAxLCBvciBzdGFydCA+IGVuZFxuXHQgIGlmIChzdGFydCA8IDEgfHwgZW5kIDwgMSB8fCBzdGFydCA+IGVuZCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgdHlwZSBpcyBuZWl0aGVyIDAgbm9yIDFcblx0ICBpZiAodHlwZSAhPT0gMCAmJiB0eXBlICE9PSAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENvbXB1dGUgY3VtdWxhdGl2ZSBpbnRlcmVzdFxuXHQgIHZhciBwYXltZW50ID0gZXhwb3J0cy5QTVQocmF0ZSwgcGVyaW9kcywgdmFsdWUsIDAsIHR5cGUpO1xuXHQgIHZhciBpbnRlcmVzdCA9IDA7XG5cblx0ICBpZiAoc3RhcnQgPT09IDEpIHtcblx0ICAgIGlmICh0eXBlID09PSAwKSB7XG5cdCAgICAgIGludGVyZXN0ID0gLXZhbHVlO1xuXHQgICAgICBzdGFydCsrO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuXHQgICAgaWYgKHR5cGUgPT09IDEpIHtcblx0ICAgICAgaW50ZXJlc3QgKz0gZXhwb3J0cy5GVihyYXRlLCBpIC0gMiwgcGF5bWVudCwgdmFsdWUsIDEpIC0gcGF5bWVudDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGludGVyZXN0ICs9IGV4cG9ydHMuRlYocmF0ZSwgaSAtIDEsIHBheW1lbnQsIHZhbHVlLCAwKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgaW50ZXJlc3QgKj0gcmF0ZTtcblxuXHQgIC8vIFJldHVybiBjdW11bGF0aXZlIGludGVyZXN0XG5cdCAgcmV0dXJuIGludGVyZXN0O1xuXHR9O1xuXG5cdGV4cG9ydHMuQ1VNUFJJTkMgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzLCB2YWx1ZSwgc3RhcnQsIGVuZCwgdHlwZSkge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXHQgIC8vIENyZWRpdHM6IEhhbm5lcyBTdGllYml0emhvZmVyIGZvciB0aGUgdHJhbnNsYXRpb25zIG9mIGZ1bmN0aW9uIGFuZCB2YXJpYWJsZSBuYW1lc1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICB2YWx1ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHZhbHVlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2RzLCB2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIHJhdGUsIHBlcmlvZHMsIG9yIHZhbHVlIGFyZSBsb3dlciB0aGFuIG9yIGVxdWFsIHRvIHplcm9cblx0ICBpZiAocmF0ZSA8PSAwIHx8IHBlcmlvZHMgPD0gMCB8fCB2YWx1ZSA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBzdGFydCA8IDEsIGVuZCA8IDEsIG9yIHN0YXJ0ID4gZW5kXG5cdCAgaWYgKHN0YXJ0IDwgMSB8fCBlbmQgPCAxIHx8IHN0YXJ0ID4gZW5kKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB0eXBlIGlzIG5laXRoZXIgMCBub3IgMVxuXHQgIGlmICh0eXBlICE9PSAwICYmIHR5cGUgIT09IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ29tcHV0ZSBjdW11bGF0aXZlIHByaW5jaXBhbFxuXHQgIHZhciBwYXltZW50ID0gZXhwb3J0cy5QTVQocmF0ZSwgcGVyaW9kcywgdmFsdWUsIDAsIHR5cGUpO1xuXHQgIHZhciBwcmluY2lwYWwgPSAwO1xuXHQgIGlmIChzdGFydCA9PT0gMSkge1xuXHQgICAgaWYgKHR5cGUgPT09IDApIHtcblx0ICAgICAgcHJpbmNpcGFsID0gcGF5bWVudCArIHZhbHVlICogcmF0ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHByaW5jaXBhbCA9IHBheW1lbnQ7XG5cdCAgICB9XG5cdCAgICBzdGFydCsrO1xuXHQgIH1cblx0ICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcblx0ICAgIGlmICh0eXBlID4gMCkge1xuXHQgICAgICBwcmluY2lwYWwgKz0gcGF5bWVudCAtIChleHBvcnRzLkZWKHJhdGUsIGkgLSAyLCBwYXltZW50LCB2YWx1ZSwgMSkgLSBwYXltZW50KSAqIHJhdGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBwcmluY2lwYWwgKz0gcGF5bWVudCAtIGV4cG9ydHMuRlYocmF0ZSwgaSAtIDEsIHBheW1lbnQsIHZhbHVlLCAwKSAqIHJhdGU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGN1bXVsYXRpdmUgcHJpbmNpcGFsXG5cdCAgcmV0dXJuIHByaW5jaXBhbDtcblx0fTtcblxuXHRleHBvcnRzLkRCID0gZnVuY3Rpb24oY29zdCwgc2FsdmFnZSwgbGlmZSwgcGVyaW9kLCBtb250aCkge1xuXHQgIC8vIEluaXRpYWxpemUgbW9udGhcblx0ICBtb250aCA9IChtb250aCA9PT0gdW5kZWZpbmVkKSA/IDEyIDogbW9udGg7XG5cblx0ICBjb3N0ID0gdXRpbHMucGFyc2VOdW1iZXIoY29zdCk7XG5cdCAgc2FsdmFnZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNhbHZhZ2UpO1xuXHQgIGxpZmUgPSB1dGlscy5wYXJzZU51bWJlcihsaWZlKTtcblx0ICBwZXJpb2QgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2QpO1xuXHQgIG1vbnRoID0gdXRpbHMucGFyc2VOdW1iZXIobW9udGgpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGNvc3QsIHNhbHZhZ2UsIGxpZmUsIHBlcmlvZCwgbW9udGgpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBpcyBuZWdhdGl2ZVxuXHQgIGlmIChjb3N0IDwgMCB8fCBzYWx2YWdlIDwgMCB8fCBsaWZlIDwgMCB8fCBwZXJpb2QgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBtb250aCBpcyBub3QgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDEyXG5cdCAgaWYgKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyXS5pbmRleE9mKG1vbnRoKSA9PT0gLTEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHBlcmlvZCBpcyBncmVhdGVyIHRoYW4gbGlmZVxuXHQgIGlmIChwZXJpb2QgPiBsaWZlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAwICh6ZXJvKSBpZiBzYWx2YWdlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBjb3N0XG5cdCAgaWYgKHNhbHZhZ2UgPj0gY29zdCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgLy8gUmF0ZSBpcyByb3VuZGVkIHRvIHRocmVlIGRlY2ltYWxzIHBsYWNlc1xuXHQgIHZhciByYXRlID0gKDEgLSBNYXRoLnBvdyhzYWx2YWdlIC8gY29zdCwgMSAvIGxpZmUpKS50b0ZpeGVkKDMpO1xuXG5cdCAgLy8gQ29tcHV0ZSBpbml0aWFsIGRlcHJlY2lhdGlvblxuXHQgIHZhciBpbml0aWFsID0gY29zdCAqIHJhdGUgKiBtb250aCAvIDEyO1xuXG5cdCAgLy8gQ29tcHV0ZSB0b3RhbCBkZXByZWNpYXRpb25cblx0ICB2YXIgdG90YWwgPSBpbml0aWFsO1xuXHQgIHZhciBjdXJyZW50ID0gMDtcblx0ICB2YXIgY2VpbGluZyA9IChwZXJpb2QgPT09IGxpZmUpID8gbGlmZSAtIDEgOiBwZXJpb2Q7XG5cdCAgZm9yICh2YXIgaSA9IDI7IGkgPD0gY2VpbGluZzsgaSsrKSB7XG5cdCAgICBjdXJyZW50ID0gKGNvc3QgLSB0b3RhbCkgKiByYXRlO1xuXHQgICAgdG90YWwgKz0gY3VycmVudDtcblx0ICB9XG5cblx0ICAvLyBEZXByZWNpYXRpb24gZm9yIHRoZSBmaXJzdCBhbmQgbGFzdCBwZXJpb2RzIGFyZSBzcGVjaWFsIGNhc2VzXG5cdCAgaWYgKHBlcmlvZCA9PT0gMSkge1xuXHQgICAgLy8gRmlyc3QgcGVyaW9kXG5cdCAgICByZXR1cm4gaW5pdGlhbDtcblx0ICB9IGVsc2UgaWYgKHBlcmlvZCA9PT0gbGlmZSkge1xuXHQgICAgLy8gTGFzdCBwZXJpb2Rcblx0ICAgIHJldHVybiAoY29zdCAtIHRvdGFsKSAqIHJhdGU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBjdXJyZW50O1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkREQiA9IGZ1bmN0aW9uKGNvc3QsIHNhbHZhZ2UsIGxpZmUsIHBlcmlvZCwgZmFjdG9yKSB7XG5cdCAgLy8gSW5pdGlhbGl6ZSBmYWN0b3Jcblx0ICBmYWN0b3IgPSAoZmFjdG9yID09PSB1bmRlZmluZWQpID8gMiA6IGZhY3RvcjtcblxuXHQgIGNvc3QgPSB1dGlscy5wYXJzZU51bWJlcihjb3N0KTtcblx0ICBzYWx2YWdlID0gdXRpbHMucGFyc2VOdW1iZXIoc2FsdmFnZSk7XG5cdCAgbGlmZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGxpZmUpO1xuXHQgIHBlcmlvZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZCk7XG5cdCAgZmFjdG9yID0gdXRpbHMucGFyc2VOdW1iZXIoZmFjdG9yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QsIGZhY3RvcikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGlzIG5lZ2F0aXZlIG9yIGlmIGZhY3RvciBpcyBudWxsXG5cdCAgaWYgKGNvc3QgPCAwIHx8IHNhbHZhZ2UgPCAwIHx8IGxpZmUgPCAwIHx8IHBlcmlvZCA8IDAgfHwgZmFjdG9yIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHBlcmlvZCBpcyBncmVhdGVyIHRoYW4gbGlmZVxuXHQgIGlmIChwZXJpb2QgPiBsaWZlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAwICh6ZXJvKSBpZiBzYWx2YWdlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBjb3N0XG5cdCAgaWYgKHNhbHZhZ2UgPj0gY29zdCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgLy8gQ29tcHV0ZSBkZXByZWNpYXRpb25cblx0ICB2YXIgdG90YWwgPSAwO1xuXHQgIHZhciBjdXJyZW50ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8PSBwZXJpb2Q7IGkrKykge1xuXHQgICAgY3VycmVudCA9IE1hdGgubWluKChjb3N0IC0gdG90YWwpICogKGZhY3RvciAvIGxpZmUpLCAoY29zdCAtIHNhbHZhZ2UgLSB0b3RhbCkpO1xuXHQgICAgdG90YWwgKz0gY3VycmVudDtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZGVwcmVjaWF0aW9uXG5cdCAgcmV0dXJuIGN1cnJlbnQ7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkRJU0MgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignRElTQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkRPTExBUkRFID0gZnVuY3Rpb24oZG9sbGFyLCBmcmFjdGlvbikge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXG5cdCAgZG9sbGFyID0gdXRpbHMucGFyc2VOdW1iZXIoZG9sbGFyKTtcblx0ICBmcmFjdGlvbiA9IHV0aWxzLnBhcnNlTnVtYmVyKGZyYWN0aW9uKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkb2xsYXIsIGZyYWN0aW9uKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmcmFjdGlvbiBpcyBuZWdhdGl2ZVxuXHQgIGlmIChmcmFjdGlvbiA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZyYWN0aW9uIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIGFuZCBsZXNzIHRoYW4gMVxuXHQgIGlmIChmcmFjdGlvbiA+PSAwICYmIGZyYWN0aW9uIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLmRpdjA7XG5cdCAgfVxuXG5cdCAgLy8gVHJ1bmNhdGUgZnJhY3Rpb24gaWYgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICBmcmFjdGlvbiA9IHBhcnNlSW50KGZyYWN0aW9uLCAxMCk7XG5cblx0ICAvLyBDb21wdXRlIGludGVnZXIgcGFydFxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChkb2xsYXIsIDEwKTtcblxuXHQgIC8vIEFkZCBkZWNpbWFsIHBhcnRcblx0ICByZXN1bHQgKz0gKGRvbGxhciAlIDEpICogTWF0aC5wb3coMTAsIE1hdGguY2VpbChNYXRoLmxvZyhmcmFjdGlvbikgLyBNYXRoLkxOMTApKSAvIGZyYWN0aW9uO1xuXG5cdCAgLy8gUm91bmQgcmVzdWx0XG5cdCAgdmFyIHBvd2VyID0gTWF0aC5wb3coMTAsIE1hdGguY2VpbChNYXRoLmxvZyhmcmFjdGlvbikgLyBNYXRoLkxOMikgKyAxKTtcblx0ICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCAqIHBvd2VyKSAvIHBvd2VyO1xuXG5cdCAgLy8gUmV0dXJuIGNvbnZlcnRlZCBkb2xsYXIgcHJpY2Vcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuRE9MTEFSRlIgPSBmdW5jdGlvbihkb2xsYXIsIGZyYWN0aW9uKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cblx0ICBkb2xsYXIgPSB1dGlscy5wYXJzZU51bWJlcihkb2xsYXIpO1xuXHQgIGZyYWN0aW9uID0gdXRpbHMucGFyc2VOdW1iZXIoZnJhY3Rpb24pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRvbGxhciwgZnJhY3Rpb24pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZyYWN0aW9uIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKGZyYWN0aW9uIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZnJhY3Rpb24gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3MgdGhhbiAxXG5cdCAgaWYgKGZyYWN0aW9uID49IDAgJiYgZnJhY3Rpb24gPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZGl2MDtcblx0ICB9XG5cblx0ICAvLyBUcnVuY2F0ZSBmcmFjdGlvbiBpZiBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgIGZyYWN0aW9uID0gcGFyc2VJbnQoZnJhY3Rpb24sIDEwKTtcblxuXHQgIC8vIENvbXB1dGUgaW50ZWdlciBwYXJ0XG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KGRvbGxhciwgMTApO1xuXG5cdCAgLy8gQWRkIGRlY2ltYWwgcGFydFxuXHQgIHJlc3VsdCArPSAoZG9sbGFyICUgMSkgKiBNYXRoLnBvdygxMCwgLU1hdGguY2VpbChNYXRoLmxvZyhmcmFjdGlvbikgLyBNYXRoLkxOMTApKSAqIGZyYWN0aW9uO1xuXG5cdCAgLy8gUmV0dXJuIGNvbnZlcnRlZCBkb2xsYXIgcHJpY2Vcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5EVVJBVElPTiA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdEVVJBVElPTiBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkVGRkVDVCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZHMpIHtcblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHJhdGUgPD0wIG9yIHBlcmlvZHMgPCAxXG5cdCAgaWYgKHJhdGUgPD0gMCB8fCBwZXJpb2RzIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBUcnVuY2F0ZSBwZXJpb2RzIGlmIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgcGVyaW9kcyA9IHBhcnNlSW50KHBlcmlvZHMsIDEwKTtcblxuXHQgIC8vIFJldHVybiBlZmZlY3RpdmUgYW5udWFsIGludGVyZXN0IHJhdGVcblx0ICByZXR1cm4gTWF0aC5wb3coMSArIHJhdGUgLyBwZXJpb2RzLCBwZXJpb2RzKSAtIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5GViA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZHMsIHBheW1lbnQsIHZhbHVlLCB0eXBlKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cblx0ICB2YWx1ZSA9IHZhbHVlIHx8IDA7XG5cdCAgdHlwZSA9IHR5cGUgfHwgMDtcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgcGF5bWVudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBheW1lbnQpO1xuXHQgIHZhbHVlID0gdXRpbHMucGFyc2VOdW1iZXIodmFsdWUpO1xuXHQgIHR5cGUgPSB1dGlscy5wYXJzZU51bWJlcih0eXBlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2RzLCBwYXltZW50LCB2YWx1ZSwgdHlwZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZnV0dXJlIHZhbHVlXG5cdCAgdmFyIHJlc3VsdDtcblx0ICBpZiAocmF0ZSA9PT0gMCkge1xuXHQgICAgcmVzdWx0ID0gdmFsdWUgKyBwYXltZW50ICogcGVyaW9kcztcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHRlcm0gPSBNYXRoLnBvdygxICsgcmF0ZSwgcGVyaW9kcyk7XG5cdCAgICBpZiAodHlwZSA9PT0gMSkge1xuXHQgICAgICByZXN1bHQgPSB2YWx1ZSAqIHRlcm0gKyBwYXltZW50ICogKDEgKyByYXRlKSAqICh0ZXJtIC0gMSkgLyByYXRlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzdWx0ID0gdmFsdWUgKiB0ZXJtICsgcGF5bWVudCAqICh0ZXJtIC0gMSkgLyByYXRlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gLXJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkZWU0NIRURVTEUgPSBmdW5jdGlvbihwcmluY2lwYWwsIHNjaGVkdWxlKSB7XG5cdCAgcHJpbmNpcGFsID0gdXRpbHMucGFyc2VOdW1iZXIocHJpbmNpcGFsKTtcblx0ICBzY2hlZHVsZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihzY2hlZHVsZSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByaW5jaXBhbCwgc2NoZWR1bGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgdmFyIG4gPSBzY2hlZHVsZS5sZW5ndGg7XG5cdCAgdmFyIGZ1dHVyZSA9IHByaW5jaXBhbDtcblxuXHQgIC8vIEFwcGx5IGFsbCBpbnRlcmVzdHMgaW4gc2NoZWR1bGVcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgLy8gQXBwbHkgc2NoZWR1bGVkIGludGVyZXN0XG5cdCAgICBmdXR1cmUgKj0gMSArIHNjaGVkdWxlW2ldO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBmdXR1cmUgdmFsdWVcblx0ICByZXR1cm4gZnV0dXJlO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5JTlRSQVRFID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0lOVFJBVEUgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5JUE1UID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kLCBwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIGZ1dHVyZSA9IGZ1dHVyZSB8fCAwO1xuXHQgIHR5cGUgPSB0eXBlIHx8IDA7XG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgcHJlc2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByZXNlbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgdHlwZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHR5cGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIENvbXB1dGUgcGF5bWVudFxuXHQgIHZhciBwYXltZW50ID0gZXhwb3J0cy5QTVQocmF0ZSwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKTtcblxuXHQgIC8vIENvbXB1dGUgaW50ZXJlc3Rcblx0ICB2YXIgaW50ZXJlc3Q7XG5cdCAgaWYgKHBlcmlvZCA9PT0gMSkge1xuXHQgICAgaWYgKHR5cGUgPT09IDEpIHtcblx0ICAgICAgaW50ZXJlc3QgPSAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaW50ZXJlc3QgPSAtcHJlc2VudDtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHR5cGUgPT09IDEpIHtcblx0ICAgICAgaW50ZXJlc3QgPSBleHBvcnRzLkZWKHJhdGUsIHBlcmlvZCAtIDIsIHBheW1lbnQsIHByZXNlbnQsIDEpIC0gcGF5bWVudDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGludGVyZXN0ID0gZXhwb3J0cy5GVihyYXRlLCBwZXJpb2QgLSAxLCBwYXltZW50LCBwcmVzZW50LCAwKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gaW50ZXJlc3Rcblx0ICByZXR1cm4gaW50ZXJlc3QgKiByYXRlO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVJSID0gZnVuY3Rpb24odmFsdWVzLCBndWVzcykge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXG5cdCAgZ3Vlc3MgPSBndWVzcyB8fCAwO1xuXG5cdCAgdmFsdWVzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHZhbHVlcykpO1xuXHQgIGd1ZXNzID0gdXRpbHMucGFyc2VOdW1iZXIoZ3Vlc3MpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHZhbHVlcywgZ3Vlc3MpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gQ2FsY3VsYXRlcyB0aGUgcmVzdWx0aW5nIGFtb3VudFxuXHQgIHZhciBpcnJSZXN1bHQgPSBmdW5jdGlvbih2YWx1ZXMsIGRhdGVzLCByYXRlKSB7XG5cdCAgICB2YXIgciA9IHJhdGUgKyAxO1xuXHQgICAgdmFyIHJlc3VsdCA9IHZhbHVlc1swXTtcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHJlc3VsdCArPSB2YWx1ZXNbaV0gLyBNYXRoLnBvdyhyLCAoZGF0ZXNbaV0gLSBkYXRlc1swXSkgLyAzNjUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgLy8gQ2FsY3VsYXRlcyB0aGUgZmlyc3QgZGVyaXZhdGlvblxuXHQgIHZhciBpcnJSZXN1bHREZXJpdiA9IGZ1bmN0aW9uKHZhbHVlcywgZGF0ZXMsIHJhdGUpIHtcblx0ICAgIHZhciByID0gcmF0ZSArIDE7XG5cdCAgICB2YXIgcmVzdWx0ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBmcmFjID0gKGRhdGVzW2ldIC0gZGF0ZXNbMF0pIC8gMzY1O1xuXHQgICAgICByZXN1bHQgLT0gZnJhYyAqIHZhbHVlc1tpXSAvIE1hdGgucG93KHIsIGZyYWMgKyAxKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblxuXHQgIC8vIEluaXRpYWxpemUgZGF0ZXMgYW5kIGNoZWNrIHRoYXQgdmFsdWVzIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBwb3NpdGl2ZSB2YWx1ZSBhbmQgb25lIG5lZ2F0aXZlIHZhbHVlXG5cdCAgdmFyIGRhdGVzID0gW107XG5cdCAgdmFyIHBvc2l0aXZlID0gZmFsc2U7XG5cdCAgdmFyIG5lZ2F0aXZlID0gZmFsc2U7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGRhdGVzW2ldID0gKGkgPT09IDApID8gMCA6IGRhdGVzW2kgLSAxXSArIDM2NTtcblx0ICAgIGlmICh2YWx1ZXNbaV0gPiAwKSB7XG5cdCAgICAgIHBvc2l0aXZlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICh2YWx1ZXNbaV0gPCAwKSB7XG5cdCAgICAgIG5lZ2F0aXZlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgdmFsdWVzIGRvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHBvc2l0aXZlIHZhbHVlIGFuZCBvbmUgbmVnYXRpdmUgdmFsdWVcblx0ICBpZiAoIXBvc2l0aXZlIHx8ICFuZWdhdGl2ZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJbml0aWFsaXplIGd1ZXNzIGFuZCByZXN1bHRSYXRlXG5cdCAgZ3Vlc3MgPSAoZ3Vlc3MgPT09IHVuZGVmaW5lZCkgPyAwLjEgOiBndWVzcztcblx0ICB2YXIgcmVzdWx0UmF0ZSA9IGd1ZXNzO1xuXG5cdCAgLy8gU2V0IG1heGltdW0gZXBzaWxvbiBmb3IgZW5kIG9mIGl0ZXJhdGlvblxuXHQgIHZhciBlcHNNYXggPSAxZS0xMDtcblxuXHQgIC8vIEltcGxlbWVudCBOZXd0b24ncyBtZXRob2Rcblx0ICB2YXIgbmV3UmF0ZSwgZXBzUmF0ZSwgcmVzdWx0VmFsdWU7XG5cdCAgdmFyIGNvbnRMb29wID0gdHJ1ZTtcblx0ICBkbyB7XG5cdCAgICByZXN1bHRWYWx1ZSA9IGlyclJlc3VsdCh2YWx1ZXMsIGRhdGVzLCByZXN1bHRSYXRlKTtcblx0ICAgIG5ld1JhdGUgPSByZXN1bHRSYXRlIC0gcmVzdWx0VmFsdWUgLyBpcnJSZXN1bHREZXJpdih2YWx1ZXMsIGRhdGVzLCByZXN1bHRSYXRlKTtcblx0ICAgIGVwc1JhdGUgPSBNYXRoLmFicyhuZXdSYXRlIC0gcmVzdWx0UmF0ZSk7XG5cdCAgICByZXN1bHRSYXRlID0gbmV3UmF0ZTtcblx0ICAgIGNvbnRMb29wID0gKGVwc1JhdGUgPiBlcHNNYXgpICYmIChNYXRoLmFicyhyZXN1bHRWYWx1ZSkgPiBlcHNNYXgpO1xuXHQgIH0gd2hpbGUgKGNvbnRMb29wKTtcblxuXHQgIC8vIFJldHVybiBpbnRlcm5hbCByYXRlIG9mIHJldHVyblxuXHQgIHJldHVybiByZXN1bHRSYXRlO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNQTVQgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHZhbHVlKSB7XG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZCk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHZhbHVlID0gdXRpbHMucGFyc2VOdW1iZXIodmFsdWUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgdmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGludGVyZXN0XG5cdCAgcmV0dXJuIHZhbHVlICogcmF0ZSAqIChwZXJpb2QgLyBwZXJpb2RzIC0gMSk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk1EVVJBVElPTiA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdNRFVSQVRJT04gaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5NSVJSID0gZnVuY3Rpb24odmFsdWVzLCBmaW5hbmNlX3JhdGUsIHJlaW52ZXN0X3JhdGUpIHtcblx0ICB2YWx1ZXMgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4odmFsdWVzKSk7XG5cdCAgZmluYW5jZV9yYXRlID0gdXRpbHMucGFyc2VOdW1iZXIoZmluYW5jZV9yYXRlKTtcblx0ICByZWludmVzdF9yYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmVpbnZlc3RfcmF0ZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IodmFsdWVzLCBmaW5hbmNlX3JhdGUsIHJlaW52ZXN0X3JhdGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gSW5pdGlhbGl6ZSBudW1iZXIgb2YgdmFsdWVzXG5cdCAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuXG5cdCAgLy8gTG9va3VwIHBheW1lbnRzIChuZWdhdGl2ZSB2YWx1ZXMpIGFuZCBpbmNvbWVzIChwb3NpdGl2ZSB2YWx1ZXMpXG5cdCAgdmFyIHBheW1lbnRzID0gW107XG5cdCAgdmFyIGluY29tZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgaWYgKHZhbHVlc1tpXSA8IDApIHtcblx0ICAgICAgcGF5bWVudHMucHVzaCh2YWx1ZXNbaV0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaW5jb21lcy5wdXNoKHZhbHVlc1tpXSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG1vZGlmaWVkIGludGVybmFsIHJhdGUgb2YgcmV0dXJuXG5cdCAgdmFyIG51bSA9IC1leHBvcnRzLk5QVihyZWludmVzdF9yYXRlLCBpbmNvbWVzKSAqIE1hdGgucG93KDEgKyByZWludmVzdF9yYXRlLCBuIC0gMSk7XG5cdCAgdmFyIGRlbiA9IGV4cG9ydHMuTlBWKGZpbmFuY2VfcmF0ZSwgcGF5bWVudHMpICogKDEgKyBmaW5hbmNlX3JhdGUpO1xuXHQgIHJldHVybiBNYXRoLnBvdyhudW0gLyBkZW4sIDEgLyAobiAtIDEpKSAtIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5OT01JTkFMID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcykge1xuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcmF0ZSA8PTAgb3IgcGVyaW9kcyA8IDFcblx0ICBpZiAocmF0ZSA8PSAwIHx8IHBlcmlvZHMgPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFRydW5jYXRlIHBlcmlvZHMgaWYgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICBwZXJpb2RzID0gcGFyc2VJbnQocGVyaW9kcywgMTApO1xuXG5cdCAgLy8gUmV0dXJuIG5vbWluYWwgYW5udWFsIGludGVyZXN0IHJhdGVcblx0ICByZXR1cm4gKE1hdGgucG93KHJhdGUgKyAxLCAxIC8gcGVyaW9kcykgLSAxKSAqIHBlcmlvZHM7XG5cdH07XG5cblx0ZXhwb3J0cy5OUEVSID0gZnVuY3Rpb24ocmF0ZSwgcGF5bWVudCwgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG5cdCAgdHlwZSA9ICh0eXBlID09PSB1bmRlZmluZWQpID8gMCA6IHR5cGU7XG5cdCAgZnV0dXJlID0gKGZ1dHVyZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBmdXR1cmU7XG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGF5bWVudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBheW1lbnQpO1xuXHQgIHByZXNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwcmVzZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIHR5cGUgPSB1dGlscy5wYXJzZU51bWJlcih0eXBlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwYXltZW50LCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG51bWJlciBvZiBwZXJpb2RzXG5cdCAgdmFyIG51bSA9IHBheW1lbnQgKiAoMSArIHJhdGUgKiB0eXBlKSAtIGZ1dHVyZSAqIHJhdGU7XG5cdCAgdmFyIGRlbiA9IChwcmVzZW50ICogcmF0ZSArIHBheW1lbnQgKiAoMSArIHJhdGUgKiB0eXBlKSk7XG5cdCAgcmV0dXJuIE1hdGgubG9nKG51bSAvIGRlbikgLyBNYXRoLmxvZygxICsgcmF0ZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5OUFYgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAoYXJncyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gYXJncztcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgcmF0ZVxuXHQgIHZhciByYXRlID0gYXJnc1swXTtcblxuXHQgIC8vIEluaXRpYWxpemUgbmV0IHByZXNlbnQgdmFsdWVcblx0ICB2YXIgdmFsdWUgPSAwO1xuXG5cdCAgLy8gTG9vcCBvbiBhbGwgdmFsdWVzXG5cdCAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzLmxlbmd0aDsgaisrKSB7XG5cdCAgICB2YWx1ZSArPSBhcmdzW2pdIC8gTWF0aC5wb3coMSArIHJhdGUsIGopO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBuZXQgcHJlc2VudCB2YWx1ZVxuXHQgIHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuT0RERlBSSUNFID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ09EREZQUklDRSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuT0RERllJRUxEID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ09EREZZSUVMRCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuT0RETFBSSUNFID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ09ERExQUklDRSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuT0RETFlJRUxEID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ09ERExZSUVMRCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLlBEVVJBVElPTiA9IGZ1bmN0aW9uKHJhdGUsIHByZXNlbnQsIGZ1dHVyZSkge1xuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwcmVzZW50LCBmdXR1cmUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHJhdGUgPD0wXG5cdCAgaWYgKHJhdGUgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gbnVtYmVyIG9mIHBlcmlvZHNcblx0ICByZXR1cm4gKE1hdGgubG9nKGZ1dHVyZSkgLSBNYXRoLmxvZyhwcmVzZW50KSkgLyBNYXRoLmxvZygxICsgcmF0ZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5QTVQgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIGZ1dHVyZSA9IGZ1dHVyZSB8fCAwO1xuXHQgIHR5cGUgPSB0eXBlIHx8IDA7XG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHByZXNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwcmVzZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIHR5cGUgPSB1dGlscy5wYXJzZU51bWJlcih0eXBlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHBheW1lbnRcblx0ICB2YXIgcmVzdWx0O1xuXHQgIGlmIChyYXRlID09PSAwKSB7XG5cdCAgICByZXN1bHQgPSAocHJlc2VudCArIGZ1dHVyZSkgLyBwZXJpb2RzO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgdGVybSA9IE1hdGgucG93KDEgKyByYXRlLCBwZXJpb2RzKTtcblx0ICAgIGlmICh0eXBlID09PSAxKSB7XG5cdCAgICAgIHJlc3VsdCA9IChmdXR1cmUgKiByYXRlIC8gKHRlcm0gLSAxKSArIHByZXNlbnQgKiByYXRlIC8gKDEgLSAxIC8gdGVybSkpIC8gKDEgKyByYXRlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlc3VsdCA9IGZ1dHVyZSAqIHJhdGUgLyAodGVybSAtIDEpICsgcHJlc2VudCAqIHJhdGUgLyAoMSAtIDEgLyB0ZXJtKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIC1yZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5QUE1UID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kLCBwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpIHtcblx0ICBmdXR1cmUgPSBmdXR1cmUgfHwgMDtcblx0ICB0eXBlID0gdHlwZSB8fCAwO1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBleHBvcnRzLlBNVChyYXRlLCBwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpIC0gZXhwb3J0cy5JUE1UKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuUFJJQ0UgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignUFJJQ0UgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlBSSUNFRElTQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdQUklDRURJU0MgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlBSSUNFTUFUID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1BSSUNFTUFUIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUFYgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzLCBwYXltZW50LCBmdXR1cmUsIHR5cGUpIHtcblx0ICBmdXR1cmUgPSBmdXR1cmUgfHwgMDtcblx0ICB0eXBlID0gdHlwZSB8fCAwO1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBwYXltZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocGF5bWVudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcywgcGF5bWVudCwgZnV0dXJlLCB0eXBlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBwcmVzZW50IHZhbHVlXG5cdCAgaWYgKHJhdGUgPT09IDApIHtcblx0ICAgIHJldHVybiAtcGF5bWVudCAqIHBlcmlvZHMgLSBmdXR1cmU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiAoKCgxIC0gTWF0aC5wb3coMSArIHJhdGUsIHBlcmlvZHMpKSAvIHJhdGUpICogcGF5bWVudCAqICgxICsgcmF0ZSAqIHR5cGUpIC0gZnV0dXJlKSAvIE1hdGgucG93KDEgKyByYXRlLCBwZXJpb2RzKTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5SQVRFID0gZnVuY3Rpb24ocGVyaW9kcywgcGF5bWVudCwgcHJlc2VudCwgZnV0dXJlLCB0eXBlLCBndWVzcykge1xuXHQgIC8vIENyZWRpdHM6IHJhYnVnZW50b1xuXG5cdCAgZ3Vlc3MgPSAoZ3Vlc3MgPT09IHVuZGVmaW5lZCkgPyAwLjAxIDogZ3Vlc3M7XG5cdCAgZnV0dXJlID0gKGZ1dHVyZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBmdXR1cmU7XG5cdCAgdHlwZSA9ICh0eXBlID09PSB1bmRlZmluZWQpID8gMCA6IHR5cGU7XG5cblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgcGF5bWVudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBheW1lbnQpO1xuXHQgIHByZXNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwcmVzZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIHR5cGUgPSB1dGlscy5wYXJzZU51bWJlcih0eXBlKTtcblx0ICBndWVzcyA9IHV0aWxzLnBhcnNlTnVtYmVyKGd1ZXNzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwZXJpb2RzLCBwYXltZW50LCBwcmVzZW50LCBmdXR1cmUsIHR5cGUsIGd1ZXNzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFNldCBtYXhpbXVtIGVwc2lsb24gZm9yIGVuZCBvZiBpdGVyYXRpb25cblx0ICB2YXIgZXBzTWF4ID0gMWUtNjtcblxuXHQgIC8vIFNldCBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zXG5cdCAgdmFyIGl0ZXJNYXggPSAxMDA7XG5cdCAgdmFyIGl0ZXIgPSAwO1xuXHQgIHZhciBjbG9zZSA9IGZhbHNlO1xuXHQgIHZhciByYXRlID0gZ3Vlc3M7XG5cblx0ICB3aGlsZSAoaXRlciA8IGl0ZXJNYXggJiYgIWNsb3NlKSB7XG5cdCAgICB2YXIgdDEgPSBNYXRoLnBvdyhyYXRlICsgMSwgcGVyaW9kcyk7XG5cdCAgICB2YXIgdDIgPSBNYXRoLnBvdyhyYXRlICsgMSwgcGVyaW9kcyAtIDEpO1xuXG5cdCAgICB2YXIgZjEgPSBmdXR1cmUgKyB0MSAqIHByZXNlbnQgKyBwYXltZW50ICogKHQxIC0gMSkgKiAocmF0ZSAqIHR5cGUgKyAxKSAvIHJhdGU7XG5cdCAgICB2YXIgZjIgPSBwZXJpb2RzICogdDIgKiBwcmVzZW50IC0gcGF5bWVudCAqICh0MSAtIDEpICoocmF0ZSAqIHR5cGUgKyAxKSAvIE1hdGgucG93KHJhdGUsMik7XG5cdCAgICB2YXIgZjMgPSBwZXJpb2RzICogcGF5bWVudCAqIHQyICogKHJhdGUgKiB0eXBlICsgMSkgLyByYXRlICsgcGF5bWVudCAqICh0MSAtIDEpICogdHlwZSAvIHJhdGU7XG5cblx0ICAgIHZhciBuZXdSYXRlID0gcmF0ZSAtIGYxIC8gKGYyICsgZjMpO1xuXG5cdCAgICBpZiAoTWF0aC5hYnMobmV3UmF0ZSAtIHJhdGUpIDwgZXBzTWF4KSBjbG9zZSA9IHRydWU7XG5cdCAgICBpdGVyKytcblx0ICAgIHJhdGUgPSBuZXdSYXRlO1xuXHQgIH1cblxuXHQgIGlmICghY2xvc2UpIHJldHVybiBOdW1iZXIuTmFOICsgcmF0ZTtcblx0ICByZXR1cm4gcmF0ZTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuUkVDRUlWRUQgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignUkVDRUlWRUQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5SUkkgPSBmdW5jdGlvbihwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUpIHtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgcHJlc2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByZXNlbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocGVyaW9kcywgcHJlc2VudCwgZnV0dXJlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBwZXJpb2RzIG9yIHByZXNlbnQgaXMgZXF1YWwgdG8gMCAoemVybylcblx0ICBpZiAocGVyaW9kcyA9PT0gMCB8fCBwcmVzZW50ID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcXVpdmFsZW50IGludGVyZXN0IHJhdGVcblx0ICByZXR1cm4gTWF0aC5wb3coZnV0dXJlIC8gcHJlc2VudCwgMSAvIHBlcmlvZHMpIC0gMTtcblx0fTtcblxuXHRleHBvcnRzLlNMTiA9IGZ1bmN0aW9uKGNvc3QsIHNhbHZhZ2UsIGxpZmUpIHtcblx0ICBjb3N0ID0gdXRpbHMucGFyc2VOdW1iZXIoY29zdCk7XG5cdCAgc2FsdmFnZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNhbHZhZ2UpO1xuXHQgIGxpZmUgPSB1dGlscy5wYXJzZU51bWJlcihsaWZlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihjb3N0LCBzYWx2YWdlLCBsaWZlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBsaWZlIGVxdWFsIHRvIDAgKHplcm8pXG5cdCAgaWYgKGxpZmUgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHN0cmFpZ2h0LWxpbmUgZGVwcmVjaWF0aW9uXG5cdCAgcmV0dXJuIChjb3N0IC0gc2FsdmFnZSkgLyBsaWZlO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1lEID0gZnVuY3Rpb24oY29zdCwgc2FsdmFnZSwgbGlmZSwgcGVyaW9kKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBpcyBub3QgYSBudW1iZXJcblx0ICBjb3N0ID0gdXRpbHMucGFyc2VOdW1iZXIoY29zdCk7XG5cdCAgc2FsdmFnZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNhbHZhZ2UpO1xuXHQgIGxpZmUgPSB1dGlscy5wYXJzZU51bWJlcihsaWZlKTtcblx0ICBwZXJpb2QgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2QpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGNvc3QsIHNhbHZhZ2UsIGxpZmUsIHBlcmlvZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbGlmZSBlcXVhbCB0byAwICh6ZXJvKVxuXHQgIGlmIChsaWZlID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBwZXJpb2QgaXMgbG93ZXIgdGhhbiAxIG9yIGdyZWF0ZXIgdGhhbiBsaWZlXG5cdCAgaWYgKHBlcmlvZCA8IDEgfHwgcGVyaW9kID4gbGlmZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBUcnVuY2F0ZSBwZXJpb2QgaWYgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICBwZXJpb2QgPSBwYXJzZUludChwZXJpb2QsIDEwKTtcblxuXHQgIC8vIFJldHVybiBzdHJhaWdodC1saW5lIGRlcHJlY2lhdGlvblxuXHQgIHJldHVybiAoKGNvc3QgLSBzYWx2YWdlKSAqIChsaWZlIC0gcGVyaW9kICsgMSkgKiAyKSAvIChsaWZlICogKGxpZmUgKyAxKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5UQklMTEVRID0gZnVuY3Rpb24oc2V0dGxlbWVudCwgbWF0dXJpdHksIGRpc2NvdW50KSB7XG5cdCAgc2V0dGxlbWVudCA9IHV0aWxzLnBhcnNlRGF0ZShzZXR0bGVtZW50KTtcblx0ICBtYXR1cml0eSA9IHV0aWxzLnBhcnNlRGF0ZShtYXR1cml0eSk7XG5cdCAgZGlzY291bnQgPSB1dGlscy5wYXJzZU51bWJlcihkaXNjb3VudCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioc2V0dGxlbWVudCwgbWF0dXJpdHksIGRpc2NvdW50KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBkaXNjb3VudCBpcyBsb3dlciB0aGFuIG9yIGVxdWFsIHRvIHplcm9cblx0ICBpZiAoZGlzY291bnQgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgc2V0dGxlbWVudCBpcyBncmVhdGVyIHRoYW4gbWF0dXJpdHlcblx0ICBpZiAoc2V0dGxlbWVudCA+IG1hdHVyaXR5KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBtYXR1cml0eSBpcyBtb3JlIHRoYW4gb25lIHllYXIgYWZ0ZXIgc2V0dGxlbWVudFxuXHQgIGlmIChtYXR1cml0eSAtIHNldHRsZW1lbnQgPiAzNjUgKiAyNCAqIDYwICogNjAgKiAxMDAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBib25kLWVxdWl2YWxlbnQgeWllbGRcblx0ICByZXR1cm4gKDM2NSAqIGRpc2NvdW50KSAvICgzNjAgLSBkaXNjb3VudCAqIGRhdGVUaW1lLkRBWVMzNjAoc2V0dGxlbWVudCwgbWF0dXJpdHksIGZhbHNlKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5UQklMTFBSSUNFID0gZnVuY3Rpb24oc2V0dGxlbWVudCwgbWF0dXJpdHksIGRpc2NvdW50KSB7XG5cdCAgc2V0dGxlbWVudCA9IHV0aWxzLnBhcnNlRGF0ZShzZXR0bGVtZW50KTtcblx0ICBtYXR1cml0eSA9IHV0aWxzLnBhcnNlRGF0ZShtYXR1cml0eSk7XG5cdCAgZGlzY291bnQgPSB1dGlscy5wYXJzZU51bWJlcihkaXNjb3VudCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioc2V0dGxlbWVudCwgbWF0dXJpdHksIGRpc2NvdW50KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBkaXNjb3VudCBpcyBsb3dlciB0aGFuIG9yIGVxdWFsIHRvIHplcm9cblx0ICBpZiAoZGlzY291bnQgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgc2V0dGxlbWVudCBpcyBncmVhdGVyIHRoYW4gbWF0dXJpdHlcblx0ICBpZiAoc2V0dGxlbWVudCA+IG1hdHVyaXR5KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBtYXR1cml0eSBpcyBtb3JlIHRoYW4gb25lIHllYXIgYWZ0ZXIgc2V0dGxlbWVudFxuXHQgIGlmIChtYXR1cml0eSAtIHNldHRsZW1lbnQgPiAzNjUgKiAyNCAqIDYwICogNjAgKiAxMDAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBib25kLWVxdWl2YWxlbnQgeWllbGRcblx0ICByZXR1cm4gMTAwICogKDEgLSBkaXNjb3VudCAqIGRhdGVUaW1lLkRBWVMzNjAoc2V0dGxlbWVudCwgbWF0dXJpdHksIGZhbHNlKSAvIDM2MCk7XG5cdH07XG5cblx0ZXhwb3J0cy5UQklMTFlJRUxEID0gZnVuY3Rpb24oc2V0dGxlbWVudCwgbWF0dXJpdHksIHByaWNlKSB7XG5cdCAgc2V0dGxlbWVudCA9IHV0aWxzLnBhcnNlRGF0ZShzZXR0bGVtZW50KTtcblx0ICBtYXR1cml0eSA9IHV0aWxzLnBhcnNlRGF0ZShtYXR1cml0eSk7XG5cdCAgcHJpY2UgPSB1dGlscy5wYXJzZU51bWJlcihwcmljZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioc2V0dGxlbWVudCwgbWF0dXJpdHksIHByaWNlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBwcmljZSBpcyBsb3dlciB0aGFuIG9yIGVxdWFsIHRvIHplcm9cblx0ICBpZiAocHJpY2UgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgc2V0dGxlbWVudCBpcyBncmVhdGVyIHRoYW4gbWF0dXJpdHlcblx0ICBpZiAoc2V0dGxlbWVudCA+IG1hdHVyaXR5KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBtYXR1cml0eSBpcyBtb3JlIHRoYW4gb25lIHllYXIgYWZ0ZXIgc2V0dGxlbWVudFxuXHQgIGlmIChtYXR1cml0eSAtIHNldHRsZW1lbnQgPiAzNjUgKiAyNCAqIDYwICogNjAgKiAxMDAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBib25kLWVxdWl2YWxlbnQgeWllbGRcblx0ICByZXR1cm4gKDEwMCAtIHByaWNlKSAqIDM2MCAvIChwcmljZSAqIGRhdGVUaW1lLkRBWVMzNjAoc2V0dGxlbWVudCwgbWF0dXJpdHksIGZhbHNlKSk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlZEQiA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdWREIgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblxuXHRleHBvcnRzLlhJUlIgPSBmdW5jdGlvbih2YWx1ZXMsIGRhdGVzLCBndWVzcykge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXG5cdCAgdmFsdWVzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHZhbHVlcykpO1xuXHQgIGRhdGVzID0gdXRpbHMucGFyc2VEYXRlQXJyYXkodXRpbHMuZmxhdHRlbihkYXRlcykpO1xuXHQgIGd1ZXNzID0gdXRpbHMucGFyc2VOdW1iZXIoZ3Vlc3MpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHZhbHVlcywgZGF0ZXMsIGd1ZXNzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIENhbGN1bGF0ZXMgdGhlIHJlc3VsdGluZyBhbW91bnRcblx0ICB2YXIgaXJyUmVzdWx0ID0gZnVuY3Rpb24odmFsdWVzLCBkYXRlcywgcmF0ZSkge1xuXHQgICAgdmFyIHIgPSByYXRlICsgMTtcblx0ICAgIHZhciByZXN1bHQgPSB2YWx1ZXNbMF07XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICByZXN1bHQgKz0gdmFsdWVzW2ldIC8gTWF0aC5wb3cociwgZGF0ZVRpbWUuREFZUyhkYXRlc1tpXSwgZGF0ZXNbMF0pIC8gMzY1KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblxuXHQgIC8vIENhbGN1bGF0ZXMgdGhlIGZpcnN0IGRlcml2YXRpb25cblx0ICB2YXIgaXJyUmVzdWx0RGVyaXYgPSBmdW5jdGlvbih2YWx1ZXMsIGRhdGVzLCByYXRlKSB7XG5cdCAgICB2YXIgciA9IHJhdGUgKyAxO1xuXHQgICAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgZnJhYyA9IGRhdGVUaW1lLkRBWVMoZGF0ZXNbaV0sIGRhdGVzWzBdKSAvIDM2NTtcblx0ICAgICAgcmVzdWx0IC09IGZyYWMgKiB2YWx1ZXNbaV0gLyBNYXRoLnBvdyhyLCBmcmFjICsgMSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBDaGVjayB0aGF0IHZhbHVlcyBjb250YWlucyBhdCBsZWFzdCBvbmUgcG9zaXRpdmUgdmFsdWUgYW5kIG9uZSBuZWdhdGl2ZSB2YWx1ZVxuXHQgIHZhciBwb3NpdGl2ZSA9IGZhbHNlO1xuXHQgIHZhciBuZWdhdGl2ZSA9IGZhbHNlO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAodmFsdWVzW2ldID4gMCkge1xuXHQgICAgICBwb3NpdGl2ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWVzW2ldIDwgMCkge1xuXHQgICAgICBuZWdhdGl2ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHZhbHVlcyBkb2VzIG5vdCBjb250YWluIGF0IGxlYXN0IG9uZSBwb3NpdGl2ZSB2YWx1ZSBhbmQgb25lIG5lZ2F0aXZlIHZhbHVlXG5cdCAgaWYgKCFwb3NpdGl2ZSB8fCAhbmVnYXRpdmUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSW5pdGlhbGl6ZSBndWVzcyBhbmQgcmVzdWx0UmF0ZVxuXHQgIGd1ZXNzID0gZ3Vlc3MgfHwgMC4xO1xuXHQgIHZhciByZXN1bHRSYXRlID0gZ3Vlc3M7XG5cblx0ICAvLyBTZXQgbWF4aW11bSBlcHNpbG9uIGZvciBlbmQgb2YgaXRlcmF0aW9uXG5cdCAgdmFyIGVwc01heCA9IDFlLTEwO1xuXG5cdCAgLy8gSW1wbGVtZW50IE5ld3RvbidzIG1ldGhvZFxuXHQgIHZhciBuZXdSYXRlLCBlcHNSYXRlLCByZXN1bHRWYWx1ZTtcblx0ICB2YXIgY29udExvb3AgPSB0cnVlO1xuXHQgIGRvIHtcblx0ICAgIHJlc3VsdFZhbHVlID0gaXJyUmVzdWx0KHZhbHVlcywgZGF0ZXMsIHJlc3VsdFJhdGUpO1xuXHQgICAgbmV3UmF0ZSA9IHJlc3VsdFJhdGUgLSByZXN1bHRWYWx1ZSAvIGlyclJlc3VsdERlcml2KHZhbHVlcywgZGF0ZXMsIHJlc3VsdFJhdGUpO1xuXHQgICAgZXBzUmF0ZSA9IE1hdGguYWJzKG5ld1JhdGUgLSByZXN1bHRSYXRlKTtcblx0ICAgIHJlc3VsdFJhdGUgPSBuZXdSYXRlO1xuXHQgICAgY29udExvb3AgPSAoZXBzUmF0ZSA+IGVwc01heCkgJiYgKE1hdGguYWJzKHJlc3VsdFZhbHVlKSA+IGVwc01heCk7XG5cdCAgfSB3aGlsZSAoY29udExvb3ApO1xuXG5cdCAgLy8gUmV0dXJuIGludGVybmFsIHJhdGUgb2YgcmV0dXJuXG5cdCAgcmV0dXJuIHJlc3VsdFJhdGU7XG5cdH07XG5cblx0ZXhwb3J0cy5YTlBWID0gZnVuY3Rpb24ocmF0ZSwgdmFsdWVzLCBkYXRlcykge1xuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICB2YWx1ZXMgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4odmFsdWVzKSk7XG5cdCAgZGF0ZXMgPSB1dGlscy5wYXJzZURhdGVBcnJheSh1dGlscy5mbGF0dGVuKGRhdGVzKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgdmFsdWVzLCBkYXRlcykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IHZhbHVlc1tpXSAvIE1hdGgucG93KDEgKyByYXRlLCBkYXRlVGltZS5EQVlTKGRhdGVzW2ldLCBkYXRlc1swXSkgLyAzNjUpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5ZSUVMRCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdZSUVMRCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuWUlFTERESVNDID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1lJRUxERElTQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuWUlFTERNQVQgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignWUlFTERNQVQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXHRleHBvcnRzLk1BVENIID0gZnVuY3Rpb24obG9va3VwVmFsdWUsIGxvb2t1cEFycmF5LCBtYXRjaFR5cGUpIHtcblx0ICBpZiAoIWxvb2t1cFZhbHVlICYmICFsb29rdXBBcnJheSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG5cdCAgICBtYXRjaFR5cGUgPSAxO1xuXHQgIH1cblx0ICBpZiAoIShsb29rdXBBcnJheSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChtYXRjaFR5cGUgIT09IC0xICYmIG1hdGNoVHlwZSAhPT0gMCAmJiBtYXRjaFR5cGUgIT09IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cdCAgdmFyIGluZGV4O1xuXHQgIHZhciBpbmRleFZhbHVlO1xuXHQgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cEFycmF5Lmxlbmd0aDsgaWR4KyspIHtcblx0ICAgIGlmIChtYXRjaFR5cGUgPT09IDEpIHtcblx0ICAgICAgaWYgKGxvb2t1cEFycmF5W2lkeF0gPT09IGxvb2t1cFZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGlkeCArIDE7XG5cdCAgICAgIH0gZWxzZSBpZiAobG9va3VwQXJyYXlbaWR4XSA8IGxvb2t1cFZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCFpbmRleFZhbHVlKSB7XG5cdCAgICAgICAgICBpbmRleCA9IGlkeCArIDE7XG5cdCAgICAgICAgICBpbmRleFZhbHVlID0gbG9va3VwQXJyYXlbaWR4XTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGxvb2t1cEFycmF5W2lkeF0gPiBpbmRleFZhbHVlKSB7XG5cdCAgICAgICAgICBpbmRleCA9IGlkeCArIDE7XG5cdCAgICAgICAgICBpbmRleFZhbHVlID0gbG9va3VwQXJyYXlbaWR4XTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAobWF0Y2hUeXBlID09PSAwKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgbG9va3VwVmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgbG9va3VwVmFsdWUgPSBsb29rdXBWYWx1ZS5yZXBsYWNlKC9cXD8vZywgJy4nKTtcblx0ICAgICAgICBpZiAobG9va3VwQXJyYXlbaWR4XS50b0xvd2VyQ2FzZSgpLm1hdGNoKGxvb2t1cFZhbHVlLnRvTG93ZXJDYXNlKCkpKSB7XG5cdCAgICAgICAgICByZXR1cm4gaWR4ICsgMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKGxvb2t1cEFycmF5W2lkeF0gPT09IGxvb2t1cFZhbHVlKSB7XG5cdCAgICAgICAgICByZXR1cm4gaWR4ICsgMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAobWF0Y2hUeXBlID09PSAtMSkge1xuXHQgICAgICBpZiAobG9va3VwQXJyYXlbaWR4XSA9PT0gbG9va3VwVmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gaWR4ICsgMTtcblx0ICAgICAgfSBlbHNlIGlmIChsb29rdXBBcnJheVtpZHhdID4gbG9va3VwVmFsdWUpIHtcblx0ICAgICAgICBpZiAoIWluZGV4VmFsdWUpIHtcblx0ICAgICAgICAgIGluZGV4ID0gaWR4ICsgMTtcblx0ICAgICAgICAgIGluZGV4VmFsdWUgPSBsb29rdXBBcnJheVtpZHhdO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobG9va3VwQXJyYXlbaWR4XSA8IGluZGV4VmFsdWUpIHtcblx0ICAgICAgICAgIGluZGV4ID0gaWR4ICsgMTtcblx0ICAgICAgICAgIGluZGV4VmFsdWUgPSBsb29rdXBBcnJheVtpZHhdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBpbmRleCA/IGluZGV4IDogZXJyb3IubmE7XG5cdH07XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjsiLCJ0aGlzLmokID0gdGhpcy5qU3RhdCA9IChmdW5jdGlvbihNYXRoLCB1bmRlZmluZWQpIHtcblxuLy8gRm9yIHF1aWNrIHJlZmVyZW5jZS5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gQ2FsY3VsYXRlIGNvcnJlY3Rpb24gZm9yIElFRUUgZXJyb3Jcbi8vIFRPRE86IFRoaXMgY2FsY3VsYXRpb24gY2FuIGJlIGltcHJvdmVkLlxuZnVuY3Rpb24gY2FsY1JkeChuLCBtKSB7XG4gIHZhciB2YWwgPSBuID4gbSA/IG4gOiBtO1xuICByZXR1cm4gTWF0aC5wb3coMTAsXG4gICAgICAgICAgICAgICAgICAxNyAtIH5+KE1hdGgubG9nKCgodmFsID4gMCkgPyB2YWwgOiAtdmFsKSkgKiBNYXRoLkxPRzEwRSkpO1xufVxuXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgJiYgYXJnID09PSBhcmc7XG59XG5cblxuLy8gQ29udmVydHMgdGhlIGpTdGF0IG1hdHJpeCB0byB2ZWN0b3IuXG5mdW5jdGlvbiB0b1ZlY3RvcihhcnIpIHtcbiAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgYXJyKTtcbn1cblxuXG4vLyBUaGUgb25lIGFuZCBvbmx5IGpTdGF0IGNvbnN0cnVjdG9yLlxuZnVuY3Rpb24galN0YXQoKSB7XG4gIHJldHVybiBuZXcgalN0YXQuX2luaXQoYXJndW1lbnRzKTtcbn1cblxuXG4vLyBUT0RPOiBSZW1vdmUgYWZ0ZXIgYWxsIHJlZmVyZW5jZXMgaW4gc3JjIGZpbGVzIGhhdmUgYmVlbiByZW1vdmVkLlxualN0YXQuZm4gPSBqU3RhdC5wcm90b3R5cGU7XG5cblxuLy8gQnkgc2VwYXJhdGluZyB0aGUgaW5pdGlhbGl6ZXIgZnJvbSB0aGUgY29uc3RydWN0b3IgaXQncyBlYXNpZXIgdG8gaGFuZGxlXG4vLyBhbHdheXMgcmV0dXJuaW5nIGEgbmV3IGluc3RhbmNlIHdoZXRoZXIgXCJuZXdcIiB3YXMgdXNlZCBvciBub3QuXG5qU3RhdC5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KGFyZ3MpIHtcbiAgdmFyIGk7XG5cbiAgLy8gSWYgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXksIG11c3QgYmUgdmVjdG9yIG9yIG1hdHJpeC5cbiAgaWYgKGlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAvLyBDaGVjayBpZiBtYXRyaXguXG4gICAgaWYgKGlzQXJyYXkoYXJnc1swXVswXSkpIHtcbiAgICAgIC8vIFNlZSBpZiBhIG1hcHBpbmcgZnVuY3Rpb24gd2FzIGFsc28gcGFzc2VkLlxuICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnc1sxXSkpXG4gICAgICAgIGFyZ3NbMF0gPSBqU3RhdC5tYXAoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBpcyBmYXN0ZXIgdGhhbiB0aGlzLnB1c2guYXBwbHkodGhpcywgYXJnc1swXS5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzWzBdLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzW2ldID0gYXJnc1swXVtpXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gYXJnc1swXS5sZW5ndGg7XG5cbiAgICAvLyBPdGhlcndpc2UgbXVzdCBiZSBhIHZlY3Rvci5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1swXSA9IGlzRnVuY3Rpb24oYXJnc1sxXSkgPyBqU3RhdC5tYXAoYXJnc1swXSwgYXJnc1sxXSkgOiBhcmdzWzBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAvLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBudW1iZXIsIGFzc3VtZSBjcmVhdGlvbiBvZiBzZXF1ZW5jZS5cbiAgfSBlbHNlIGlmIChpc051bWJlcihhcmdzWzBdKSkge1xuICAgIHRoaXNbMF0gPSBqU3RhdC5zZXEuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gIC8vIEhhbmRsZSBjYXNlIHdoZW4galN0YXQgb2JqZWN0IGlzIHBhc3NlZCB0byBqU3RhdC5cbiAgfSBlbHNlIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgalN0YXQpIHtcbiAgICAvLyBEdXBsaWNhdGUgdGhlIG9iamVjdCBhbmQgcGFzcyBpdCBiYWNrLlxuICAgIHJldHVybiBqU3RhdChhcmdzWzBdLnRvQXJyYXkoKSk7XG5cbiAgLy8gVW5leHBlY3RlZCBhcmd1bWVudCB2YWx1ZSwgcmV0dXJuIGVtcHR5IGpTdGF0IG9iamVjdC5cbiAgLy8gVE9ETzogVGhpcyBpcyBzdHJhbmdlIGJlaGF2aW9yLiBTaG91bGRuJ3QgdGhpcyB0aHJvdyBvciBzb21lIHN1Y2ggdG8gbGV0XG4gIC8vIHRoZSB1c2VyIGtub3cgdGhleSBoYWQgYmFkIGFyZ3VtZW50cz9cbiAgfSBlbHNlIHtcbiAgICB0aGlzWzBdID0gW107XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xualN0YXQuX2luaXQucHJvdG90eXBlID0galN0YXQucHJvdG90eXBlO1xualN0YXQuX2luaXQuY29uc3RydWN0b3IgPSBqU3RhdDtcblxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucy5cbi8vIFRPRE86IGZvciBpbnRlcm5hbCB1c2Ugb25seT9cbmpTdGF0LnV0aWxzID0ge1xuICBjYWxjUmR4OiBjYWxjUmR4LFxuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIHRvVmVjdG9yOiB0b1ZlY3RvclxufTtcblxuXG4vLyBFYXNpbHkgZXh0ZW5kIHRoZSBqU3RhdCBvYmplY3QuXG4vLyBUT0RPOiBpcyB0aGlzIHNlcmlvdXNseSBuZWNlc3Nhcnk/XG5qU3RhdC5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gIHZhciBpLCBqO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZm9yIChqIGluIG9iailcbiAgICAgIGpTdGF0W2pdID0gb2JqW2pdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAoaiBpbiBhcmd1bWVudHNbaV0pXG4gICAgICBvYmpbal0gPSBhcmd1bWVudHNbaV1bal07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4LlxualN0YXQucm93cyA9IGZ1bmN0aW9uIHJvd3MoYXJyKSB7XG4gIHJldHVybiBhcnIubGVuZ3RoIHx8IDE7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXguXG5qU3RhdC5jb2xzID0gZnVuY3Rpb24gY29scyhhcnIpIHtcbiAgcmV0dXJuIGFyclswXS5sZW5ndGggfHwgMTtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHsgcm93czogaSwgY29sczogaiB9XG5qU3RhdC5kaW1lbnNpb25zID0gZnVuY3Rpb24gZGltZW5zaW9ucyhhcnIpIHtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiBqU3RhdC5yb3dzKGFyciksXG4gICAgY29sczogalN0YXQuY29scyhhcnIpXG4gIH07XG59O1xuXG5cbi8vIFJldHVybnMgYSBzcGVjaWZpZWQgcm93IGFzIGEgdmVjdG9yXG5qU3RhdC5yb3cgPSBmdW5jdGlvbiByb3coYXJyLCBpbmRleCkge1xuICByZXR1cm4gYXJyW2luZGV4XTtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgc3BlY2lmaWVkIGNvbHVtbiBhcyBhIHZlY3RvclxualN0YXQuY29sID0gZnVuY3Rpb24gY29scyhhcnIsIGluZGV4KSB7XG4gIHZhciBjb2x1bW4gPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKVxuICAgIGNvbHVtbltpXSA9IFthcnJbaV1baW5kZXhdXTtcbiAgcmV0dXJuIGNvbHVtbjtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgZGlhZ29uYWwgb2YgdGhlIG1hdHJpeFxualN0YXQuZGlhZyA9IGZ1bmN0aW9uIGRpYWcoYXJyKSB7XG4gIHZhciBucm93ID0galN0YXQucm93cyhhcnIpO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KG5yb3cpO1xuICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBucm93OyByb3crKylcbiAgICByZXNbcm93XSA9IFthcnJbcm93XVtyb3ddXTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgYW50aS1kaWFnb25hbCBvZiB0aGUgbWF0cml4XG5qU3RhdC5hbnRpZGlhZyA9IGZ1bmN0aW9uIGFudGlkaWFnKGFycikge1xuICB2YXIgbnJvdyA9IGpTdGF0LnJvd3MoYXJyKSAtIDE7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobnJvdyk7XG4gIGZvciAodmFyIGkgPSAwOyBucm93ID49IDA7IG5yb3ctLSwgaSsrKVxuICAgIHJlc1tpXSA9IFthcnJbaV1bbnJvd11dO1xuICByZXR1cm4gcmVzO1xufTtcblxuLy8gVHJhbnNwb3NlIGEgbWF0cml4IG9yIGFycmF5LlxualN0YXQudHJhbnNwb3NlID0gZnVuY3Rpb24gdHJhbnNwb3NlKGFycikge1xuICB2YXIgb2JqID0gW107XG4gIHZhciBvYmpBcnIsIHJvd3MsIGNvbHMsIGosIGk7XG5cbiAgLy8gTWFrZSBzdXJlIGFyciBpcyBpbiBtYXRyaXggZm9ybWF0LlxuICBpZiAoIWlzQXJyYXkoYXJyWzBdKSlcbiAgICBhcnIgPSBbYXJyXTtcblxuICByb3dzID0gYXJyLmxlbmd0aDtcbiAgY29scyA9IGFyclswXS5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGNvbHM7IGkrKykge1xuICAgIG9iakFyciA9IG5ldyBBcnJheShyb3dzKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgcm93czsgaisrKVxuICAgICAgb2JqQXJyW2pdID0gYXJyW2pdW2ldO1xuICAgIG9iai5wdXNoKG9iakFycik7XG4gIH1cblxuICAvLyBJZiBvYmogaXMgdmVjdG9yLCByZXR1cm4gb25seSBzaW5nbGUgYXJyYXkuXG4gIHJldHVybiBvYmoubGVuZ3RoID09PSAxID8gb2JqWzBdIDogb2JqO1xufTtcblxuXG4vLyBNYXAgYSBmdW5jdGlvbiB0byBhbiBhcnJheSBvciBhcnJheSBvZiBhcnJheXMuXG4vLyBcInRvQWx0ZXJcIiBpcyBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cbmpTdGF0Lm1hcCA9IGZ1bmN0aW9uIG1hcChhcnIsIGZ1bmMsIHRvQWx0ZXIpIHtcbiAgdmFyIHJvdywgbnJvdywgbmNvbCwgcmVzLCBjb2w7XG5cbiAgaWYgKCFpc0FycmF5KGFyclswXSkpXG4gICAgYXJyID0gW2Fycl07XG5cbiAgbnJvdyA9IGFyci5sZW5ndGg7XG4gIG5jb2wgPSBhcnJbMF0ubGVuZ3RoO1xuICByZXMgPSB0b0FsdGVyID8gYXJyIDogbmV3IEFycmF5KG5yb3cpO1xuXG4gIGZvciAocm93ID0gMDsgcm93IDwgbnJvdzsgcm93KyspIHtcbiAgICAvLyBpZiB0aGUgcm93IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICAgIGlmICghcmVzW3Jvd10pXG4gICAgICByZXNbcm93XSA9IG5ldyBBcnJheShuY29sKTtcbiAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IG5jb2w7IGNvbCsrKVxuICAgICAgcmVzW3Jvd11bY29sXSA9IGZ1bmMoYXJyW3Jvd11bY29sXSwgcm93LCBjb2wpO1xuICB9XG5cbiAgcmV0dXJuIHJlcy5sZW5ndGggPT09IDEgPyByZXNbMF0gOiByZXM7XG59O1xuXG5cbi8vIERlc3RydWN0aXZlbHkgYWx0ZXIgYW4gYXJyYXkuXG5qU3RhdC5hbHRlciA9IGZ1bmN0aW9uIGFsdGVyKGFyciwgZnVuYykge1xuICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuYywgdHJ1ZSk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IGFjY29yZGluZyB0byB0aGUgc3VwcGxpZWQgZnVuY3Rpb24uXG5qU3RhdC5jcmVhdGUgPSBmdW5jdGlvbiAgY3JlYXRlKHJvd3MsIGNvbHMsIGZ1bmMpIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShyb3dzKTtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGlzRnVuY3Rpb24oY29scykpIHtcbiAgICBmdW5jID0gY29scztcbiAgICBjb2xzID0gcm93cztcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICByZXNbaV0gPSBuZXcgQXJyYXkoY29scyk7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHM7IGorKylcbiAgICAgIHJlc1tpXVtqXSA9IGZ1bmMoaSwgaik7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuXG5mdW5jdGlvbiByZXRaZXJvKCkgeyByZXR1cm4gMDsgfVxuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IG9mIHplcm9zLlxualN0YXQuemVyb3MgPSBmdW5jdGlvbiB6ZXJvcyhyb3dzLCBjb2xzKSB7XG4gIGlmICghaXNOdW1iZXIoY29scykpXG4gICAgY29scyA9IHJvd3M7XG4gIHJldHVybiBqU3RhdC5jcmVhdGUocm93cywgY29scywgcmV0WmVybyk7XG59O1xuXG5cbmZ1bmN0aW9uIHJldE9uZSgpIHsgcmV0dXJuIDE7IH1cblxuXG4vLyBHZW5lcmF0ZSBhIHJvd3MgeCBjb2xzIG1hdHJpeCBvZiBvbmVzLlxualN0YXQub25lcyA9IGZ1bmN0aW9uIG9uZXMocm93cywgY29scykge1xuICBpZiAoIWlzTnVtYmVyKGNvbHMpKVxuICAgIGNvbHMgPSByb3dzO1xuICByZXR1cm4galN0YXQuY3JlYXRlKHJvd3MsIGNvbHMsIHJldE9uZSk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IG9mIHVuaWZvcm1seSByYW5kb20gbnVtYmVycy5cbmpTdGF0LnJhbmQgPSBmdW5jdGlvbiByYW5kKHJvd3MsIGNvbHMpIHtcbiAgaWYgKCFpc051bWJlcihjb2xzKSlcbiAgICBjb2xzID0gcm93cztcbiAgcmV0dXJuIGpTdGF0LmNyZWF0ZShyb3dzLCBjb2xzLCBNYXRoLnJhbmRvbSk7XG59O1xuXG5cbmZ1bmN0aW9uIHJldElkZW50KGksIGopIHsgcmV0dXJuIGkgPT09IGogPyAxIDogMDsgfVxuXG5cbi8vIEdlbmVyYXRlIGFuIGlkZW50aXR5IG1hdHJpeCBvZiBzaXplIHJvdyB4IGNvbHMuXG5qU3RhdC5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KHJvd3MsIGNvbHMpIHtcbiAgaWYgKCFpc051bWJlcihjb2xzKSlcbiAgICBjb2xzID0gcm93cztcbiAgcmV0dXJuIGpTdGF0LmNyZWF0ZShyb3dzLCBjb2xzLCByZXRJZGVudCk7XG59O1xuXG5cbi8vIFRlc3RzIHdoZXRoZXIgYSBtYXRyaXggaXMgc3ltbWV0cmljXG5qU3RhdC5zeW1tZXRyaWMgPSBmdW5jdGlvbiBzeW1tZXRyaWMoYXJyKSB7XG4gIHZhciBpc3N5bW1ldHJpYyA9IHRydWU7XG4gIHZhciBzaXplID0gYXJyLmxlbmd0aDtcbiAgdmFyIHJvdywgY29sO1xuXG4gIGlmIChhcnIubGVuZ3RoICE9PSBhcnJbMF0ubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHJvdyA9IDA7IHJvdyA8IHNpemU7IHJvdysrKSB7XG4gICAgZm9yIChjb2wgPSAwOyBjb2wgPCBzaXplOyBjb2wrKylcbiAgICAgIGlmIChhcnJbY29sXVtyb3ddICE9PSBhcnJbcm93XVtjb2xdKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gU2V0IGFsbCB2YWx1ZXMgdG8gemVyby5cbmpTdGF0LmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoYXJyKSB7XG4gIHJldHVybiBqU3RhdC5hbHRlcihhcnIsIHJldFplcm8pO1xufTtcblxuXG4vLyBHZW5lcmF0ZSBzZXF1ZW5jZS5cbmpTdGF0LnNlcSA9IGZ1bmN0aW9uIHNlcShtaW4sIG1heCwgbGVuZ3RoLCBmdW5jKSB7XG4gIGlmICghaXNGdW5jdGlvbihmdW5jKSlcbiAgICBmdW5jID0gZmFsc2U7XG5cbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGl2YWwgPSBjYWxjUmR4KG1pbiwgbWF4KTtcbiAgdmFyIHN0ZXAgPSAobWF4ICogaGl2YWwgLSBtaW4gKiBoaXZhbCkgLyAoKGxlbmd0aCAtIDEpICogaGl2YWwpO1xuICB2YXIgY3VycmVudCA9IG1pbjtcbiAgdmFyIGNudDtcblxuICAvLyBDdXJyZW50IGlzIGFzc2lnbmVkIHVzaW5nIGEgdGVjaG5pcXVlIHRvIGNvbXBlbnNhdGUgZm9yIElFRUUgZXJyb3IuXG4gIC8vIFRPRE86IE5lZWRzIGJldHRlciBpbXBsZW1lbnRhdGlvbi5cbiAgZm9yIChjbnQgPSAwO1xuICAgICAgIGN1cnJlbnQgPD0gbWF4O1xuICAgICAgIGNudCsrLCBjdXJyZW50ID0gKG1pbiAqIGhpdmFsICsgc3RlcCAqIGhpdmFsICogY250KSAvIGhpdmFsKSB7XG4gICAgYXJyLnB1c2goKGZ1bmMgPyBmdW5jKGN1cnJlbnQsIGNudCkgOiBjdXJyZW50KSk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufTtcblxuXG4vLyBUT0RPOiBHbyBvdmVyIHRoaXMgZW50aXJlIGltcGxlbWVudGF0aW9uLiBTZWVtcyBhIHRyYWdpYyB3YXN0ZSBvZiByZXNvdXJjZXNcbi8vIGRvaW5nIGFsbCB0aGlzIHdvcmsuIEluc3RlYWQsIGFuZCB3aGlsZSB1Z2x5LCB1c2UgbmV3IEZ1bmN0aW9uKCkgdG8gZ2VuZXJhdGVcbi8vIGEgY3VzdG9tIGZ1bmN0aW9uIGZvciBlYWNoIHN0YXRpYyBtZXRob2QuXG5cbi8vIFF1aWNrIHJlZmVyZW5jZS5cbnZhciBqUHJvdG8gPSBqU3RhdC5wcm90b3R5cGU7XG5cbi8vIERlZmF1bHQgbGVuZ3RoLlxualByb3RvLmxlbmd0aCA9IDA7XG5cbi8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbi8vIFRPRE86IENoZWNrIGlmIHRoZXkncmUgYWN0dWFsbHkgdXNlZCwgYW5kIGlmIHRoZXkgYXJlIHRoZW4gcmVuYW1lIHRoZW1cbi8vIHRvIF8qXG5qUHJvdG8ucHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xualByb3RvLnNvcnQgPSBBcnJheS5wcm90b3R5cGUuc29ydDtcbmpQcm90by5zcGxpY2UgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xualByb3RvLnNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5cbi8vIFJldHVybiBhIGNsZWFuIGFycmF5LlxualByb3RvLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCh0aGlzKSA6IHNsaWNlLmNhbGwodGhpcylbMF07XG59O1xuXG5cbi8vIE1hcCBhIGZ1bmN0aW9uIHRvIGEgbWF0cml4IG9yIHZlY3Rvci5cbmpQcm90by5tYXAgPSBmdW5jdGlvbiBtYXAoZnVuYywgdG9BbHRlcikge1xuICByZXR1cm4galN0YXQoalN0YXQubWFwKHRoaXMsIGZ1bmMsIHRvQWx0ZXIpKTtcbn07XG5cblxuLy8gRGVzdHJ1Y3RpdmVseSBhbHRlciBhbiBhcnJheS5cbmpQcm90by5hbHRlciA9IGZ1bmN0aW9uIGFsdGVyKGZ1bmMpIHtcbiAgalN0YXQuYWx0ZXIodGhpcywgZnVuYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBFeHRlbmQgcHJvdG90eXBlIHdpdGggbWV0aG9kcyB0aGF0IGhhdmUgbm8gYXJndW1lbnQuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalByb3RvW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHJlc3VsdHM7XG4gICAgICAvLyBDaGVjayBmb3IgY2FsbGJhY2suXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmMuY2FsbChzZWxmLCBqUHJvdG9bcGFzc2Z1bmNdLmNhbGwoc2VsZikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXN1bHRzID0galN0YXRbcGFzc2Z1bmNdKHRoaXMpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkocmVzdWx0cykgPyBqU3RhdChyZXN1bHRzKSA6IHJlc3VsdHM7XG4gICAgfTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoJ3RyYW5zcG9zZSBjbGVhciBzeW1tZXRyaWMgcm93cyBjb2xzIGRpbWVuc2lvbnMgZGlhZyBhbnRpZGlhZycuc3BsaXQoJyAnKSk7XG5cblxuLy8gRXh0ZW5kIHByb3RvdHlwZSB3aXRoIG1ldGhvZHMgdGhhdCBoYXZlIG9uZSBhcmd1bWVudC5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oaW5kZXgsIGZ1bmMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIGNoZWNrIGZvciBjYWxsYmFja1xuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jLmNhbGwoc2VsZiwgalByb3RvW3Bhc3NmdW5jXS5jYWxsKHNlbGYsIGluZGV4KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBqU3RhdChqU3RhdFtwYXNzZnVuY10odGhpcywgaW5kZXgpKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgncm93IGNvbCcuc3BsaXQoJyAnKSk7XG5cblxuLy8gRXh0ZW5kIHByb3RvdHlwZSB3aXRoIHNpbXBsZSBzaG9ydGN1dCBtZXRob2RzLlxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpQcm90b1twYXNzZnVuY10gPSBuZXcgRnVuY3Rpb24oXG4gICAgICAgICdyZXR1cm4galN0YXQoalN0YXQuJyArIHBhc3NmdW5jICsgJy5hcHBseShudWxsLCBhcmd1bWVudHMpKTsnKTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoJ2NyZWF0ZSB6ZXJvcyBvbmVzIHJhbmQgaWRlbnRpdHknLnNwbGl0KCcgJykpO1xuXG5cbi8vIEV4cG9zaW5nIGpTdGF0LlxucmV0dXJuIGpTdGF0O1xuXG59KE1hdGgpKTtcbihmdW5jdGlvbihqU3RhdCwgTWF0aCkge1xuXG52YXIgaXNGdW5jdGlvbiA9IGpTdGF0LnV0aWxzLmlzRnVuY3Rpb247XG5cbi8vIEFzY2VuZGluZyBmdW5jdGlvbnMgZm9yIHNvcnRcbmZ1bmN0aW9uIGFzY051bShhLCBiKSB7IHJldHVybiBhIC0gYjsgfVxuXG5mdW5jdGlvbiBjbGlwKGFyZywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4oYXJnLCBtYXgpKTtcbn1cblxuXG4vLyBzdW0gb2YgYW4gYXJyYXlcbmpTdGF0LnN1bSA9IGZ1bmN0aW9uIHN1bShhcnIpIHtcbiAgdmFyIHN1bSA9IDA7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgdmFyIHRtcDtcbiAgd2hpbGUgKC0taSA+PSAwKVxuICAgIHN1bSArPSBhcnJbaV07XG4gIHJldHVybiBzdW07XG59O1xuXG5cbi8vIHN1bSBzcXVhcmVkXG5qU3RhdC5zdW1zcXJkID0gZnVuY3Rpb24gc3Vtc3FyZChhcnIpIHtcbiAgdmFyIHN1bSA9IDA7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKC0taSA+PSAwKVxuICAgIHN1bSArPSBhcnJbaV0gKiBhcnJbaV07XG4gIHJldHVybiBzdW07XG59O1xuXG5cbi8vIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBvZiBwcmVkaWN0aW9uIChTU0UpXG5qU3RhdC5zdW1zcWVyciA9IGZ1bmN0aW9uIHN1bXNxZXJyKGFycikge1xuICB2YXIgbWVhbiA9IGpTdGF0Lm1lYW4oYXJyKTtcbiAgdmFyIHN1bSA9IDA7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgdmFyIHRtcDtcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgdG1wID0gYXJyW2ldIC0gbWVhbjtcbiAgICBzdW0gKz0gdG1wICogdG1wO1xuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG5cbi8vIHByb2R1Y3Qgb2YgYW4gYXJyYXlcbmpTdGF0LnByb2R1Y3QgPSBmdW5jdGlvbiBwcm9kdWN0KGFycikge1xuICB2YXIgcHJvZCA9IDE7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKC0taSA+PSAwKVxuICAgIHByb2QgKj0gYXJyW2ldO1xuICByZXR1cm4gcHJvZDtcbn07XG5cblxuLy8gbWluaW11bSB2YWx1ZSBvZiBhbiBhcnJheVxualN0YXQubWluID0gZnVuY3Rpb24gbWluKGFycikge1xuICB2YXIgbG93ID0gYXJyWzBdO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBhcnIubGVuZ3RoKVxuICAgIGlmIChhcnJbaV0gPCBsb3cpXG4gICAgICBsb3cgPSBhcnJbaV07XG4gIHJldHVybiBsb3c7XG59O1xuXG5cbi8vIG1heGltdW0gdmFsdWUgb2YgYW4gYXJyYXlcbmpTdGF0Lm1heCA9IGZ1bmN0aW9uIG1heChhcnIpIHtcbiAgdmFyIGhpZ2ggPSBhcnJbMF07XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGFyci5sZW5ndGgpXG4gICAgaWYgKGFycltpXSA+IGhpZ2gpXG4gICAgICBoaWdoID0gYXJyW2ldO1xuICByZXR1cm4gaGlnaDtcbn07XG5cblxuLy8gbWVhbiB2YWx1ZSBvZiBhbiBhcnJheVxualN0YXQubWVhbiA9IGZ1bmN0aW9uIG1lYW4oYXJyKSB7XG4gIHJldHVybiBqU3RhdC5zdW0oYXJyKSAvIGFyci5sZW5ndGg7XG59O1xuXG5cbi8vIG1lYW4gc3F1YXJlZCBlcnJvciAoTVNFKVxualN0YXQubWVhbnNxZXJyID0gZnVuY3Rpb24gbWVhbnNxZXJyKGFycikge1xuICByZXR1cm4galN0YXQuc3Vtc3FlcnIoYXJyKSAvIGFyci5sZW5ndGg7XG59O1xuXG5cbi8vIGdlb21ldHJpYyBtZWFuIG9mIGFuIGFycmF5XG5qU3RhdC5nZW9tZWFuID0gZnVuY3Rpb24gZ2VvbWVhbihhcnIpIHtcbiAgcmV0dXJuIE1hdGgucG93KGpTdGF0LnByb2R1Y3QoYXJyKSwgMSAvIGFyci5sZW5ndGgpO1xufTtcblxuXG4vLyBtZWRpYW4gb2YgYW4gYXJyYXlcbmpTdGF0Lm1lZGlhbiA9IGZ1bmN0aW9uIG1lZGlhbihhcnIpIHtcbiAgdmFyIGFycmxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBfYXJyID0gYXJyLnNsaWNlKCkuc29ydChhc2NOdW0pO1xuICAvLyBjaGVjayBpZiBhcnJheSBpcyBldmVuIG9yIG9kZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlXG4gIHJldHVybiAhKGFycmxlbiAmIDEpXG4gICAgPyAoX2FyclsoYXJybGVuIC8gMikgLSAxIF0gKyBfYXJyWyhhcnJsZW4gLyAyKV0pIC8gMlxuICAgIDogX2FyclsoYXJybGVuIC8gMikgfCAwIF07XG59O1xuXG5cbi8vIGN1bXVsYXRpdmUgc3VtIG9mIGFuIGFycmF5XG5qU3RhdC5jdW1zdW0gPSBmdW5jdGlvbiBjdW1zdW0oYXJyKSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgc3VtcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgaTtcbiAgc3Vtc1swXSA9IGFyclswXTtcbiAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgIHN1bXNbaV0gPSBzdW1zW2kgLSAxXSArIGFycltpXTtcbiAgcmV0dXJuIHN1bXM7XG59O1xuXG5cbi8vIHN1Y2Nlc3NpdmUgZGlmZmVyZW5jZXMgb2YgYSBzZXF1ZW5jZVxualN0YXQuZGlmZiA9IGZ1bmN0aW9uIGRpZmYoYXJyKSB7XG4gIHZhciBkaWZmcyA9IFtdO1xuICB2YXIgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDE7IGkgPCBhcnJMZW47IGkrKylcbiAgICBkaWZmcy5wdXNoKGFycltpXSAtIGFycltpIC0gMV0pO1xuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8vIG1vZGUgb2YgYW4gYXJyYXlcbi8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtb2RlcyBvZiBhbiBhcnJheSwgcmV0dXJuIGFsbCBvZiB0aGVtXG4vLyBpcyB0aGlzIHRoZSBhcHByb3ByaWF0ZSB3YXkgb2YgaGFuZGxpbmcgaXQ/XG5qU3RhdC5tb2RlID0gZnVuY3Rpb24gbW9kZShhcnIpIHtcbiAgdmFyIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBfYXJyID0gYXJyLnNsaWNlKCkuc29ydChhc2NOdW0pO1xuICB2YXIgY291bnQgPSAxO1xuICB2YXIgbWF4Q291bnQgPSAwO1xuICB2YXIgbnVtTWF4Q291bnQgPSAwO1xuICB2YXIgbW9kZV9hcnIgPSBbXTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGFyckxlbjsgaSsrKSB7XG4gICAgaWYgKF9hcnJbaV0gPT09IF9hcnJbaSArIDFdKSB7XG4gICAgICBjb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY291bnQgPiBtYXhDb3VudCkge1xuICAgICAgICBtb2RlX2FyciA9IFtfYXJyW2ldXTtcbiAgICAgICAgbWF4Q291bnQgPSBjb3VudDtcbiAgICAgICAgbnVtTWF4Q291bnQgPSAwO1xuICAgICAgfVxuICAgICAgLy8gYXJlIHRoZXJlIG11bHRpcGxlIG1heCBjb3VudHNcbiAgICAgIGVsc2UgaWYgKGNvdW50ID09PSBtYXhDb3VudCkge1xuICAgICAgICBtb2RlX2Fyci5wdXNoKF9hcnJbaV0pO1xuICAgICAgICBudW1NYXhDb3VudCsrO1xuICAgICAgfVxuICAgICAgLy8gcmVzZXR0aW5nIGNvdW50IGZvciBuZXcgdmFsdWUgaW4gYXJyYXlcbiAgICAgIGNvdW50ID0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVtTWF4Q291bnQgPT09IDAgPyBtb2RlX2FyclswXSA6IG1vZGVfYXJyO1xufTtcblxuXG4vLyByYW5nZSBvZiBhbiBhcnJheVxualN0YXQucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShhcnIpIHtcbiAgcmV0dXJuIGpTdGF0Lm1heChhcnIpIC0galN0YXQubWluKGFycik7XG59O1xuXG4vLyB2YXJpYW5jZSBvZiBhbiBhcnJheVxuLy8gZmxhZyBpbmRpY2F0ZXMgcG9wdWxhdGlvbiB2cyBzYW1wbGVcbmpTdGF0LnZhcmlhbmNlID0gZnVuY3Rpb24gdmFyaWFuY2UoYXJyLCBmbGFnKSB7XG4gIHJldHVybiBqU3RhdC5zdW1zcWVycihhcnIpIC8gKGFyci5sZW5ndGggLSAoZmxhZyA/IDEgOiAwKSk7XG59O1xuXG5cbi8vIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheVxuLy8gZmxhZyBpbmRpY2F0ZXMgcG9wdWxhdGlvbiB2cyBzYW1wbGVcbmpTdGF0LnN0ZGV2ID0gZnVuY3Rpb24gc3RkZXYoYXJyLCBmbGFnKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoalN0YXQudmFyaWFuY2UoYXJyLCBmbGFnKSk7XG59O1xuXG5cbi8vIG1lYW4gZGV2aWF0aW9uIChtZWFuIGFic29sdXRlIGRldmlhdGlvbikgb2YgYW4gYXJyYXlcbmpTdGF0Lm1lYW5kZXYgPSBmdW5jdGlvbiBtZWFuZGV2KGFycikge1xuICB2YXIgZGV2U3VtID0gMDtcbiAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKGFycik7XG4gIHZhciBpO1xuICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgZGV2U3VtICs9IE1hdGguYWJzKGFycltpXSAtIG1lYW4pO1xuICByZXR1cm4gZGV2U3VtIC8gYXJyLmxlbmd0aDtcbn07XG5cblxuLy8gbWVkaWFuIGRldmlhdGlvbiAobWVkaWFuIGFic29sdXRlIGRldmlhdGlvbikgb2YgYW4gYXJyYXlcbmpTdGF0Lm1lZGRldiA9IGZ1bmN0aW9uIG1lZGRldihhcnIpIHtcbiAgdmFyIGRldlN1bSA9IDA7XG4gIHZhciBtZWRpYW4gPSBqU3RhdC5tZWRpYW4oYXJyKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICBkZXZTdW0gKz0gTWF0aC5hYnMoYXJyW2ldIC0gbWVkaWFuKTtcbiAgcmV0dXJuIGRldlN1bSAvIGFyci5sZW5ndGg7XG59O1xuXG5cbi8vIGNvZWZmaWNpZW50IG9mIHZhcmlhdGlvblxualN0YXQuY29lZmZ2YXIgPSBmdW5jdGlvbiBjb2VmZnZhcihhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LnN0ZGV2KGFycikgLyBqU3RhdC5tZWFuKGFycik7XG59O1xuXG5cbi8vIHF1YXJ0aWxlcyBvZiBhbiBhcnJheVxualN0YXQucXVhcnRpbGVzID0gZnVuY3Rpb24gcXVhcnRpbGVzKGFycikge1xuICB2YXIgYXJybGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIF9hcnIgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIHJldHVybiBbXG4gICAgX2FyclsgTWF0aC5yb3VuZCgoYXJybGVuKSAvIDQpIC0gMSBdLFxuICAgIF9hcnJbIE1hdGgucm91bmQoKGFycmxlbikgLyAyKSAtIDEgXSxcbiAgICBfYXJyWyBNYXRoLnJvdW5kKChhcnJsZW4pICogMyAvIDQpIC0gMSBdXG4gIF07XG59O1xuXG5cbi8vIEFyYml0YXJ5IHF1YW50aWxlcyBvZiBhbiBhcnJheS4gRGlyZWN0IHBvcnQgb2YgdGhlIHNjaXB5LnN0YXRzXG4vLyBpbXBsZW1lbnRhdGlvbiBieSBQaWVycmUgR0YgR2VyYXJkLU1hcmNoYW50LlxualN0YXQucXVhbnRpbGVzID0gZnVuY3Rpb24gcXVhbnRpbGVzKGFyciwgcXVhbnRpbGVzQXJyYXksIGFscGhhcCwgYmV0YXApIHtcbiAgdmFyIHNvcnRlZEFycmF5ID0gYXJyLnNsaWNlKCkuc29ydChhc2NOdW0pO1xuICB2YXIgcXVhbnRpbGVWYWxzID0gW3F1YW50aWxlc0FycmF5Lmxlbmd0aF07XG4gIHZhciBuID0gYXJyLmxlbmd0aDtcbiAgdmFyIGksIHAsIG0sIGFsZXBoLCBrLCBnYW1tYTtcblxuICBpZiAodHlwZW9mIGFscGhhcCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgYWxwaGFwID0gMyAvIDg7XG4gIGlmICh0eXBlb2YgYmV0YXAgPT09ICd1bmRlZmluZWQnKVxuICAgIGJldGFwID0gMyAvIDg7XG5cbiAgZm9yIChpID0gMDsgaSA8IHF1YW50aWxlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcCA9IHF1YW50aWxlc0FycmF5W2ldO1xuICAgIG0gPSBhbHBoYXAgKyBwICogKDEgLSBhbHBoYXAgLSBiZXRhcCk7XG4gICAgYWxlcGggPSBuICogcCArIG07XG4gICAgayA9IE1hdGguZmxvb3IoY2xpcChhbGVwaCwgMSwgbiAtIDEpKTtcbiAgICBnYW1tYSA9IGNsaXAoYWxlcGggLSBrLCAwLCAxKTtcbiAgICBxdWFudGlsZVZhbHNbaV0gPSAoMSAtIGdhbW1hKSAqIHNvcnRlZEFycmF5W2sgLSAxXSArIGdhbW1hICogc29ydGVkQXJyYXlba107XG4gIH1cblxuICByZXR1cm4gcXVhbnRpbGVWYWxzO1xufTtcblxuLy8gVGhlIHBlcmNlbnRpbGUgcmFuayBvZiBzY29yZSBpbiBhIGdpdmVuIGFycmF5LiBSZXR1cm5zIHRoZSBwZXJjZW50YWdlXG4vLyBvZiBhbGwgdmFsdWVzIGluIHRoZSBpbnB1dCBhcnJheSB0aGF0IGFyZSBsZXNzIHRoYW4gKGtpbmQ9J3N0cmljdCcpIG9yXG4vLyBsZXNzIG9yIGVxdWFsIHRoYW4gKGtpbmQ9J3dlYWsnKSBzY29yZS4gRGVmYXVsdCBpcyB3ZWFrLlxualN0YXQucGVyY2VudGlsZU9mU2NvcmUgPSBmdW5jdGlvbiBwZXJjZW50aWxlT2ZTY29yZShhcnIsIHNjb3JlLCBraW5kKSB7XG4gIHZhciBjb3VudGVyID0gMDtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBzdHJpY3QgPSBmYWxzZTtcbiAgdmFyIHZhbHVlLCBpO1xuXG4gIGlmIChraW5kID09PSAnc3RyaWN0JylcbiAgICBzdHJpY3QgPSB0cnVlO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyW2ldO1xuICAgIGlmICgoc3RyaWN0ICYmIHZhbHVlIDwgc2NvcmUpIHx8XG4gICAgICAgICghc3RyaWN0ICYmIHZhbHVlIDw9IHNjb3JlKSkge1xuICAgICAgY291bnRlcisrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3VudGVyIC8gbGVuO1xufTtcblxuLy8gY292YXJpYW5jZSBvZiB0d28gYXJyYXlzXG5qU3RhdC5jb3ZhcmlhbmNlID0gZnVuY3Rpb24gY292YXJpYW5jZShhcnIxLCBhcnIyKSB7XG4gIHZhciB1ID0galN0YXQubWVhbihhcnIxKTtcbiAgdmFyIHYgPSBqU3RhdC5tZWFuKGFycjIpO1xuICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuICB2YXIgc3FfZGV2ID0gbmV3IEFycmF5KGFycjFMZW4pO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYXJyMUxlbjsgaSsrKVxuICAgIHNxX2RldltpXSA9IChhcnIxW2ldIC0gdSkgKiAoYXJyMltpXSAtIHYpO1xuXG4gIHJldHVybiBqU3RhdC5zdW0oc3FfZGV2KSAvIChhcnIxTGVuIC0gMSk7XG59O1xuXG5cbi8vIChwZWFyc29uJ3MpIHBvcHVsYXRpb24gY29ycmVsYXRpb24gY29lZmZpY2llbnQsIHJob1xualN0YXQuY29ycmNvZWZmID0gZnVuY3Rpb24gY29ycmNvZWZmKGFycjEsIGFycjIpIHtcbiAgcmV0dXJuIGpTdGF0LmNvdmFyaWFuY2UoYXJyMSwgYXJyMikgL1xuICAgICAgalN0YXQuc3RkZXYoYXJyMSwgMSkgL1xuICAgICAgalN0YXQuc3RkZXYoYXJyMiwgMSk7XG59O1xuXG5cbnZhciBqUHJvdG8gPSBqU3RhdC5wcm90b3R5cGU7XG5cblxuLy8gRXh0ZW5kIGpQcm90byB3aXRoIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgY3VtdWxhdGl2ZSBzdW1zLCBhcyBpdCBkb2VzIG5vdFxuLy8gcnVuIGFnYWluIGluIGNhc2Ugb2YgdHJ1ZS5cbi8vIElmIGEgbWF0cml4IGlzIHBhc3NlZCwgYXV0b21hdGljYWxseSBhc3N1bWUgb3BlcmF0aW9uIHNob3VsZCBiZSBkb25lIG9uIHRoZVxuLy8gY29sdW1ucy5cbmpQcm90by5jdW1zdW0gPSBmdW5jdGlvbihmdWxsYm9vbCwgZnVuYykge1xuICB2YXIgYXJyID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIHRtcHRoaXMgPSB0aGlzO1xuXG4gIC8vIEFzc2lnbm1lbnQgcmVhc3NpZ25hdGlvbiBkZXBlbmRpbmcgb24gaG93IHBhcmFtZXRlcnMgd2VyZSBwYXNzZWQgaW4uXG4gIGlmIChpc0Z1bmN0aW9uKGZ1bGxib29sKSkge1xuICAgIGZ1bmMgPSBmdWxsYm9vbDtcbiAgICBmdWxsYm9vbCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYSBjYWxsYmFjayB3YXMgcGFzc2VkIHdpdGggdGhlIGZ1bmN0aW9uLlxuICBpZiAoZnVuYykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jLmNhbGwodG1wdGhpcywgalByb3RvLmN1bXN1bS5jYWxsKHRtcHRoaXMsIGZ1bGxib29sKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBDaGVjayBpZiBtYXRyaXggYW5kIHJ1biBjYWxjdWxhdGlvbnMuXG4gIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICB0bXB0aGlzID0gZnVsbGJvb2wgPT09IHRydWUgPyB0aGlzIDogdGhpcy50cmFuc3Bvc2UoKTtcbiAgICBmb3IgKDsgaSA8IHRtcHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICBhcnJbaV0gPSBqU3RhdC5jdW1zdW0odG1wdGhpc1tpXSk7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIHJldHVybiBqU3RhdC5jdW1zdW0odGhpc1swXSwgZnVsbGJvb2wpO1xufTtcblxuXG4vLyBFeHRlbmQgalByb3RvIHdpdGggbWV0aG9kcyB3aGljaCBkb24ndCByZXF1aXJlIGFyZ3VtZW50cyBhbmQgd29yayBvbiBjb2x1bW5zLlxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIC8vIElmIGEgbWF0cml4IGlzIHBhc3NlZCwgYXV0b21hdGljYWxseSBhc3N1bWUgb3BlcmF0aW9uIHNob3VsZCBiZSBkb25lIG9uXG4gICAgLy8gdGhlIGNvbHVtbnMuXG4gICAgalByb3RvW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKGZ1bGxib29sLCBmdW5jKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgdG1wdGhpcyA9IHRoaXM7XG4gICAgICAvLyBBc3NpZ25tZW50IHJlYXNzaWduYXRpb24gZGVwZW5kaW5nIG9uIGhvdyBwYXJhbWV0ZXJzIHdlcmUgcGFzc2VkIGluLlxuICAgICAgaWYgKGlzRnVuY3Rpb24oZnVsbGJvb2wpKSB7XG4gICAgICAgIGZ1bmMgPSBmdWxsYm9vbDtcbiAgICAgICAgZnVsbGJvb2wgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGlmIGEgY2FsbGJhY2sgd2FzIHBhc3NlZCB3aXRoIHRoZSBmdW5jdGlvbi5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuYy5jYWxsKHRtcHRoaXMsIGpQcm90b1twYXNzZnVuY10uY2FsbCh0bXB0aGlzLCBmdWxsYm9vbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBtYXRyaXggYW5kIHJ1biBjYWxjdWxhdGlvbnMuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRtcHRoaXMgPSBmdWxsYm9vbCA9PT0gdHJ1ZSA/IHRoaXMgOiB0aGlzLnRyYW5zcG9zZSgpO1xuICAgICAgICBmb3IgKDsgaSA8IHRtcHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgYXJyW2ldID0galN0YXRbcGFzc2Z1bmNdKHRtcHRoaXNbaV0pO1xuICAgICAgICByZXR1cm4gZnVsbGJvb2wgPT09IHRydWVcbiAgICAgICAgICAgID8galN0YXRbcGFzc2Z1bmNdKGpTdGF0LnV0aWxzLnRvVmVjdG9yKGFycikpXG4gICAgICAgICAgICA6IGFycjtcbiAgICAgIH1cbiAgICAgIC8vIFBhc3MgZnVsbGJvb2wgaWYgb25seSB2ZWN0b3IsIG5vdCBhIG1hdHJpeC4gZm9yIHZhcmlhbmNlIGFuZCBzdGRldi5cbiAgICAgIHJldHVybiBqU3RhdFtwYXNzZnVuY10odGhpc1swXSwgZnVsbGJvb2wpO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCgnc3VtIHN1bXNxcmQgc3Vtc3FlcnIgcHJvZHVjdCBtaW4gbWF4IG1lYW4gbWVhbnNxZXJyIGdlb21lYW4gbWVkaWFuIGRpZmYgJyArXG4gICAgJ21vZGUgcmFuZ2UgdmFyaWFuY2Ugc3RkZXYgbWVhbmRldiBtZWRkZXYgY29lZmZ2YXIgcXVhcnRpbGVzJykuc3BsaXQoJyAnKSk7XG5cblxuLy8gRXh0ZW5kIGpQcm90byB3aXRoIGZ1bmN0aW9ucyB0aGF0IHRha2UgYXJndW1lbnRzLiBPcGVyYXRpb25zIG9uIG1hdHJpY2VzIGFyZVxuLy8gZG9uZSBvbiBjb2x1bW5zLlxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB0bXB0aGlzID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgYSBmdW5jdGlvbiwgd2UgYXNzdW1lIGl0J3MgYSBjYWxsYmFjazsgd2VcbiAgICAgIC8vIHN0cmlwIHRoZSBjYWxsYmFjayBvdXQgYW5kIGNhbGwgdGhlIGZ1bmN0aW9uIGFnYWluLlxuICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICB2YXIgY2FsbGJhY2tGdW5jdGlvbiA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGFyZ3NUb1Bhc3MgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYWxsYmFja0Z1bmN0aW9uLmNhbGwodG1wdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalByb3RvW3Bhc3NmdW5jXS5hcHBseSh0bXB0aGlzLCBhcmdzVG9QYXNzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gT3RoZXJ3aXNlIHdlIGN1cnJ5IHRoZSBmdW5jdGlvbiBhcmdzIGFuZCBjYWxsIG5vcm1hbGx5LlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjdXJyaWVkRnVuY3Rpb24gPSBmdW5jdGlvbiBjdXJyaWVkRnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W3Bhc3NmdW5jXS5hcHBseSh0bXB0aGlzLCBbdmVjdG9yXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBtYXRyaXgsIHJ1biBjb2x1bW4tYnktY29sdW1uLlxuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0bXB0aGlzID0gdG1wdGhpcy50cmFuc3Bvc2UoKTtcbiAgICAgICAgZm9yICg7IGkgPCB0bXB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIGFycltpXSA9IGN1cnJpZWRGdW5jdGlvbih0bXB0aGlzW2ldKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlIHJ1biBvbiB0aGUgdmVjdG9yLlxuICAgICAgcmV0dXJuIGN1cnJpZWRGdW5jdGlvbih0aGlzWzBdKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgncXVhbnRpbGVzIHBlcmNlbnRpbGVPZlNjb3JlJy5zcGxpdCgnICcpKTtcblxufSh0aGlzLmpTdGF0LCBNYXRoKSk7XG4vLyBTcGVjaWFsIGZ1bmN0aW9ucyAvL1xuKGZ1bmN0aW9uKGpTdGF0LCBNYXRoKSB7XG5cbi8vIExvZy1nYW1tYSBmdW5jdGlvblxualN0YXQuZ2FtbWFsbiA9IGZ1bmN0aW9uIGdhbW1hbG4oeCkge1xuICB2YXIgaiA9IDA7XG4gIHZhciBjb2YgPSBbXG4gICAgNzYuMTgwMDkxNzI5NDcxNDYsIC04Ni41MDUzMjAzMjk0MTY3NywgMjQuMDE0MDk4MjQwODMwOTEsXG4gICAgLTEuMjMxNzM5NTcyNDUwMTU1LCAwLjEyMDg2NTA5NzM4NjYxNzllLTIsIC0wLjUzOTUyMzkzODQ5NTNlLTVcbiAgXTtcbiAgdmFyIHNlciA9IDEuMDAwMDAwMDAwMTkwMDE1O1xuICB2YXIgeHgsIHksIHRtcDtcbiAgdG1wID0gKHkgPSB4eCA9IHgpICsgNS41O1xuICB0bXAgLT0gKHh4ICsgMC41KSAqIE1hdGgubG9nKHRtcCk7XG4gIGZvciAoOyBqIDwgNjsgaisrKVxuICAgIHNlciArPSBjb2Zbal0gLyArK3k7XG4gIHJldHVybiBNYXRoLmxvZygyLjUwNjYyODI3NDYzMTAwMDUgKiBzZXIgLyB4eCkgLSB0bXA7XG59O1xuXG5cbi8vIGdhbW1hIG9mIHhcbmpTdGF0LmdhbW1hZm4gPSBmdW5jdGlvbiBnYW1tYWZuKHgpIHtcbiAgdmFyIHAgPSBbLTEuNzE2MTg1MTM4ODY1NDk1LCAyNC43NjU2NTA4MDU1NzU5MiwgLTM3OS44MDQyNTY0NzA5NDU2MyxcbiAgICAgICAgICAgNjI5LjMzMTE1NTMxMjgxODQsIDg2Ni45NjYyMDI3OTA0MTMzLCAtMzE0NTEuMjcyOTY4ODQ4MzY3LFxuICAgICAgICAgICAtMzYxNDQuNDEzNDE4NjkxMTc2LCA2NjQ1Ni4xNDM4MjAyNDA1NFxuICBdO1xuICB2YXIgcSA9IFstMzAuODQwMjMwMDExOTczOSwgMzE1LjM1MDYyNjk3OTYwNDE2LCAtMTAxNS4xNTYzNjc0OTAyMTkyLFxuICAgICAgICAgICAtMzEwNy43NzE2NzE1NzIzMTEsIDIyNTM4LjExODQyMDk4MDE1MSwgNDc1NS44NDYyNzc1Mjc4ODExLFxuICAgICAgICAgICAtMTM0NjU5Ljk1OTg2NDk2OTMsIC0xMTUxMzIuMjU5Njc1NTUzNV07XG4gIHZhciBmYWN0ID0gZmFsc2U7XG4gIHZhciBuID0gMDtcbiAgdmFyIHhkZW4gPSAwO1xuICB2YXIgeG51bSA9IDA7XG4gIHZhciB5ID0geDtcbiAgdmFyIGksIHosIHlpLCByZXMsIHN1bSwgeXNxO1xuICBpZiAoeSA8PSAwKSB7XG4gICAgcmVzID0geSAlIDEgKyAzLjZlLTE2O1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGZhY3QgPSAoISh5ICYgMSkgPyAxIDogLTEpICogTWF0aC5QSSAvIE1hdGguc2luKE1hdGguUEkgKiByZXMpO1xuICAgICAgeSA9IDEgLSB5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICB9XG4gIHlpID0geTtcbiAgaWYgKHkgPCAxKSB7XG4gICAgeiA9IHkrKztcbiAgfSBlbHNlIHtcbiAgICB6ID0gKHkgLT0gbiA9ICh5IHwgMCkgLSAxKSAtIDE7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xuICAgIHhudW0gPSAoeG51bSArIHBbaV0pICogejtcbiAgICB4ZGVuID0geGRlbiAqIHogKyBxW2ldO1xuICB9XG4gIHJlcyA9IHhudW0gLyB4ZGVuICsgMTtcbiAgaWYgKHlpIDwgeSkge1xuICAgIHJlcyAvPSB5aTtcbiAgfSBlbHNlIGlmICh5aSA+IHkpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICByZXMgKj0geTtcbiAgICAgIHkrKztcbiAgICB9XG4gIH1cbiAgaWYgKGZhY3QpIHtcbiAgICByZXMgPSBmYWN0IC8gcmVzO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5cbi8vIGxvd2VyIGluY29tcGxldGUgZ2FtbWEgZnVuY3Rpb24gUChhLHgpXG5qU3RhdC5nYW1tYXAgPSBmdW5jdGlvbiBnYW1tYXAoYSwgeCkge1xuICB2YXIgYWxuID0galN0YXQuZ2FtbWFsbihhKTtcbiAgdmFyIGFwID0gYTtcbiAgdmFyIHN1bSA9IDEgLyBhO1xuICB2YXIgZGVsID0gc3VtO1xuICB2YXIgYiA9IHggKyAxIC0gYTtcbiAgdmFyIGMgPSAxIC8gMS4wZS0zMDtcbiAgdmFyIGQgPSAxIC8gYjtcbiAgdmFyIGggPSBkO1xuICB2YXIgaSA9IDE7XG4gIC8vIGNhbGN1bGF0ZSBtYXhpbXVtIG51bWJlciBvZiBpdHRlcmF0aW9ucyByZXF1aXJlZCBmb3IgYVxuICB2YXIgSVRNQVggPSAtfihNYXRoLmxvZygoYSA+PSAxKSA/IGEgOiAxIC8gYSkgKiA4LjUgKyBhICogMC40ICsgMTcpO1xuICB2YXIgYW4sIGVuZHZhbDtcblxuICBpZiAoeCA8IDAgfHwgYSA8PSAwKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfSBlbHNlIGlmICh4IDwgYSArIDEpIHtcbiAgICBmb3IgKDsgaSA8PSBJVE1BWDsgaSsrKSB7XG4gICAgICBzdW0gKz0gZGVsICo9IHggLyArK2FwO1xuICAgIH1cbiAgICByZXR1cm4gc3VtICogTWF0aC5leHAoLXggKyBhICogTWF0aC5sb2coeCkgLSAoYWxuKSk7XG4gIH1cblxuICBmb3IgKDsgaSA8PSBJVE1BWDsgaSsrKSB7XG4gICAgYW4gPSAtaSAqIChpIC0gYSk7XG4gICAgYiArPSAyO1xuICAgIGQgPSBhbiAqIGQgKyBiO1xuICAgIGMgPSBiICsgYW4gLyBjO1xuICAgIGQgPSAxIC8gZDtcbiAgICBoICo9IGQgKiBjO1xuICB9XG5cbiAgcmV0dXJuIDEgLSBoICogTWF0aC5leHAoLXggKyBhICogTWF0aC5sb2coeCkgLSAoYWxuKSk7XG59O1xuXG5cbi8vIG5hdHVyYWwgbG9nIGZhY3RvcmlhbCBvZiBuXG5qU3RhdC5mYWN0b3JpYWxsbiA9IGZ1bmN0aW9uIGZhY3RvcmlhbGxuKG4pIHtcbiAgcmV0dXJuIG4gPCAwID8gTmFOIDogalN0YXQuZ2FtbWFsbihuICsgMSk7XG59O1xuXG4vLyBmYWN0b3JpYWwgb2YgblxualN0YXQuZmFjdG9yaWFsID0gZnVuY3Rpb24gZmFjdG9yaWFsKG4pIHtcbiAgcmV0dXJuIG4gPCAwID8gTmFOIDogalN0YXQuZ2FtbWFmbihuICsgMSk7XG59O1xuXG4vLyBjb21iaW5hdGlvbnMgb2YgbiwgbVxualN0YXQuY29tYmluYXRpb24gPSBmdW5jdGlvbiBjb21iaW5hdGlvbihuLCBtKSB7XG4gIC8vIG1ha2Ugc3VyZSBuIG9yIG0gZG9uJ3QgZXhjZWVkIHRoZSB1cHBlciBsaW1pdCBvZiB1c2FibGUgdmFsdWVzXG4gIHJldHVybiAobiA+IDE3MCB8fCBtID4gMTcwKVxuICAgICAgPyBNYXRoLmV4cChqU3RhdC5jb21iaW5hdGlvbmxuKG4sIG0pKVxuICAgICAgOiAoalN0YXQuZmFjdG9yaWFsKG4pIC8galN0YXQuZmFjdG9yaWFsKG0pKSAvIGpTdGF0LmZhY3RvcmlhbChuIC0gbSk7XG59O1xuXG5cbmpTdGF0LmNvbWJpbmF0aW9ubG4gPSBmdW5jdGlvbiBjb21iaW5hdGlvbmxuKG4sIG0pe1xuICByZXR1cm4galN0YXQuZmFjdG9yaWFsbG4obikgLSBqU3RhdC5mYWN0b3JpYWxsbihtKSAtIGpTdGF0LmZhY3RvcmlhbGxuKG4gLSBtKTtcbn07XG5cblxuLy8gcGVybXV0YXRpb25zIG9mIG4sIG1cbmpTdGF0LnBlcm11dGF0aW9uID0gZnVuY3Rpb24gcGVybXV0YXRpb24obiwgbSkge1xuICByZXR1cm4galN0YXQuZmFjdG9yaWFsKG4pIC8galN0YXQuZmFjdG9yaWFsKG4gLSBtKTtcbn07XG5cblxuLy8gYmV0YSBmdW5jdGlvblxualN0YXQuYmV0YWZuID0gZnVuY3Rpb24gYmV0YWZuKHgsIHkpIHtcbiAgLy8gZW5zdXJlIGFyZ3VtZW50cyBhcmUgcG9zaXRpdmVcbiAgaWYgKHggPD0gMCB8fCB5IDw9IDApXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgLy8gbWFrZSBzdXJlIHggKyB5IGRvZXNuJ3QgZXhjZWVkIHRoZSB1cHBlciBsaW1pdCBvZiB1c2FibGUgdmFsdWVzXG4gIHJldHVybiAoeCArIHkgPiAxNzApXG4gICAgICA/IE1hdGguZXhwKGpTdGF0LmJldGFsbih4LCB5KSlcbiAgICAgIDogalN0YXQuZ2FtbWFmbih4KSAqIGpTdGF0LmdhbW1hZm4oeSkgLyBqU3RhdC5nYW1tYWZuKHggKyB5KTtcbn07XG5cblxuLy8gbmF0dXJhbCBsb2dhcml0aG0gb2YgYmV0YSBmdW5jdGlvblxualN0YXQuYmV0YWxuID0gZnVuY3Rpb24gYmV0YWxuKHgsIHkpIHtcbiAgcmV0dXJuIGpTdGF0LmdhbW1hbG4oeCkgKyBqU3RhdC5nYW1tYWxuKHkpIC0galN0YXQuZ2FtbWFsbih4ICsgeSk7XG59O1xuXG5cbi8vIEV2YWx1YXRlcyB0aGUgY29udGludWVkIGZyYWN0aW9uIGZvciBpbmNvbXBsZXRlIGJldGEgZnVuY3Rpb24gYnkgbW9kaWZpZWRcbi8vIExlbnR6J3MgbWV0aG9kLlxualN0YXQuYmV0YWNmID0gZnVuY3Rpb24gYmV0YWNmKHgsIGEsIGIpIHtcbiAgdmFyIGZwbWluID0gMWUtMzA7XG4gIHZhciBtID0gMTtcbiAgdmFyIHFhYiA9IGEgKyBiO1xuICB2YXIgcWFwID0gYSArIDE7XG4gIHZhciBxYW0gPSBhIC0gMTtcbiAgdmFyIGMgPSAxO1xuICB2YXIgZCA9IDEgLSBxYWIgKiB4IC8gcWFwO1xuICB2YXIgbTIsIGFhLCBkZWwsIGg7XG5cbiAgLy8gVGhlc2UgcSdzIHdpbGwgYmUgdXNlZCBpbiBmYWN0b3JzIHRoYXQgb2NjdXIgaW4gdGhlIGNvZWZmaWNpZW50c1xuICBpZiAoTWF0aC5hYnMoZCkgPCBmcG1pbilcbiAgICBkID0gZnBtaW47XG4gIGQgPSAxIC8gZDtcbiAgaCA9IGQ7XG5cbiAgZm9yICg7IG0gPD0gMTAwOyBtKyspIHtcbiAgICBtMiA9IDIgKiBtO1xuICAgIGFhID0gbSAqIChiIC0gbSkgKiB4IC8gKChxYW0gKyBtMikgKiAoYSArIG0yKSk7XG4gICAgLy8gT25lIHN0ZXAgKHRoZSBldmVuIG9uZSkgb2YgdGhlIHJlY3VycmVuY2VcbiAgICBkID0gMSArIGFhICogZDtcbiAgICBpZiAoTWF0aC5hYnMoZCkgPCBmcG1pbilcbiAgICAgIGQgPSBmcG1pbjtcbiAgICBjID0gMSArIGFhIC8gYztcbiAgICBpZiAoTWF0aC5hYnMoYykgPCBmcG1pbilcbiAgICAgIGMgPSBmcG1pbjtcbiAgICBkID0gMSAvIGQ7XG4gICAgaCAqPSBkICogYztcbiAgICBhYSA9IC0oYSArIG0pICogKHFhYiArIG0pICogeCAvICgoYSArIG0yKSAqIChxYXAgKyBtMikpO1xuICAgIC8vIE5leHQgc3RlcCBvZiB0aGUgcmVjdXJyZW5jZSAodGhlIG9kZCBvbmUpXG4gICAgZCA9IDEgKyBhYSAqIGQ7XG4gICAgaWYgKE1hdGguYWJzKGQpIDwgZnBtaW4pXG4gICAgICBkID0gZnBtaW47XG4gICAgYyA9IDEgKyBhYSAvIGM7XG4gICAgaWYgKE1hdGguYWJzKGMpIDwgZnBtaW4pXG4gICAgICBjID0gZnBtaW47XG4gICAgZCA9IDEgLyBkO1xuICAgIGRlbCA9IGQgKiBjO1xuICAgIGggKj0gZGVsO1xuICAgIGlmIChNYXRoLmFicyhkZWwgLSAxLjApIDwgM2UtNylcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGg7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGludmVyc2UgaW5jb21wbHRlIGdhbW1hIGZ1bmN0aW9uXG5qU3RhdC5nYW1tYXBpbnYgPSBmdW5jdGlvbiBnYW1tYXBpbnYocCwgYSkge1xuICB2YXIgaiA9IDA7XG4gIHZhciBhMSA9IGEgLSAxO1xuICB2YXIgRVBTID0gMWUtODtcbiAgdmFyIGdsbiA9IGpTdGF0LmdhbW1hbG4oYSk7XG4gIHZhciB4LCBlcnIsIHQsIHUsIHBwLCBsbmExLCBhZmFjO1xuXG4gIGlmIChwID49IDEpXG4gICAgcmV0dXJuIE1hdGgubWF4KDEwMCwgYSArIDEwMCAqIE1hdGguc3FydChhKSk7XG4gIGlmIChwIDw9IDApXG4gICAgcmV0dXJuIDA7XG4gIGlmIChhID4gMSkge1xuICAgIGxuYTEgPSBNYXRoLmxvZyhhMSk7XG4gICAgYWZhYyA9IE1hdGguZXhwKGExICogKGxuYTEgLSAxKSAtIGdsbik7XG4gICAgcHAgPSAocCA8IDAuNSkgPyBwIDogMSAtIHA7XG4gICAgdCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHBwKSk7XG4gICAgeCA9ICgyLjMwNzUzICsgdCAqIDAuMjcwNjEpIC8gKDEgKyB0ICogKDAuOTkyMjkgKyB0ICogMC4wNDQ4MSkpIC0gdDtcbiAgICBpZiAocCA8IDAuNSlcbiAgICAgIHggPSAteDtcbiAgICB4ID0gTWF0aC5tYXgoMWUtMyxcbiAgICAgICAgICAgICAgICAgYSAqIE1hdGgucG93KDEgLSAxIC8gKDkgKiBhKSAtIHggLyAoMyAqIE1hdGguc3FydChhKSksIDMpKTtcbiAgfSBlbHNlIHtcbiAgICB0ID0gMSAtIGEgKiAoMC4yNTMgKyBhICogMC4xMik7XG4gICAgaWYgKHAgPCB0KVxuICAgICAgeCA9IE1hdGgucG93KHAgLyB0LCAxIC8gYSk7XG4gICAgZWxzZVxuICAgICAgeCA9IDEgLSBNYXRoLmxvZygxIC0gKHAgLSB0KSAvICgxIC0gdCkpO1xuICB9XG5cbiAgZm9yKDsgaiA8IDEyOyBqKyspIHtcbiAgICBpZiAoeCA8PSAwKVxuICAgICAgcmV0dXJuIDA7XG4gICAgZXJyID0galN0YXQuZ2FtbWFwKGEsIHgpIC0gcDtcbiAgICBpZiAoYSA+IDEpXG4gICAgICB0ID0gYWZhYyAqIE1hdGguZXhwKC0oeCAtIGExKSArIGExICogKE1hdGgubG9nKHgpIC0gbG5hMSkpO1xuICAgIGVsc2VcbiAgICAgIHQgPSBNYXRoLmV4cCgteCArIGExICogTWF0aC5sb2coeCkgLSBnbG4pO1xuICAgIHUgPSBlcnIgLyB0O1xuICAgIHggLT0gKHQgPSB1IC8gKDEgLSAwLjUgKiBNYXRoLm1pbigxLCB1ICogKChhIC0gMSkgLyB4IC0gMSkpKSk7XG4gICAgaWYgKHggPD0gMClcbiAgICAgIHggPSAwLjUgKiAoeCArIHQpO1xuICAgIGlmIChNYXRoLmFicyh0KSA8IEVQUyAqIHgpXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB4O1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBlcnJvciBmdW5jdGlvbiBlcmYoeClcbmpTdGF0LmVyZiA9IGZ1bmN0aW9uIGVyZih4KSB7XG4gIHZhciBjb2YgPSBbLTEuMzAyNjUzNzE5NzgxNzA5NCwgNi40MTk2OTc5MjM1NjQ5MDI2ZS0xLCAxLjk0NzY0NzMyMDQxODU4MzZlLTIsXG4gICAgICAgICAgICAgLTkuNTYxNTE0Nzg2ODA4NjMxZS0zLCAtOS40NjU5NTM0NDQ4MjAzNmUtNCwgMy42NjgzOTQ5Nzg1Mjc2MWUtNCxcbiAgICAgICAgICAgICA0LjI1MjMzMjQ4MDY5MDdlLTUsIC0yLjAyNzg1NzgxMTI1MzRlLTUsIC0xLjYyNDI5MDAwNDY0N2UtNixcbiAgICAgICAgICAgICAxLjMwMzY1NTgzNTU4MGUtNiwgMS41NjI2NDQxNzIyZS04LCAtOC41MjM4MDk1OTE1ZS04LFxuICAgICAgICAgICAgIDYuNTI5MDU0NDM5ZS05LCA1LjA1OTM0MzQ5NWUtOSwgLTkuOTEzNjQxNTZlLTEwLFxuICAgICAgICAgICAgIC0yLjI3MzY1MTIyZS0xMCwgOS42NDY3OTExZS0xMSwgMi4zOTQwMzhlLTEyLFxuICAgICAgICAgICAgIC02Ljg4NjAyN2UtMTIsIDguOTQ0ODdlLTEzLCAzLjEzMDkyZS0xMyxcbiAgICAgICAgICAgICAtMS4xMjcwOGUtMTMsIDMuODFlLTE2LCA3LjEwNmUtMTUsXG4gICAgICAgICAgICAgLTEuNTIzZS0xNSwgLTkuNGUtMTcsIDEuMjFlLTE2LFxuICAgICAgICAgICAgIC0yLjhlLTE3XTtcbiAgdmFyIGogPSBjb2YubGVuZ3RoIC0gMTtcbiAgdmFyIGlzbmVnID0gZmFsc2U7XG4gIHZhciBkID0gMDtcbiAgdmFyIGRkID0gMDtcbiAgdmFyIHQsIHR5LCB0bXAsIHJlcztcblxuICBpZiAoeCA8IDApIHtcbiAgICB4ID0gLXg7XG4gICAgaXNuZWcgPSB0cnVlO1xuICB9XG5cbiAgdCA9IDIgLyAoMiArIHgpO1xuICB0eSA9IDQgKiB0IC0gMjtcblxuICBmb3IoOyBqID4gMDsgai0tKSB7XG4gICAgdG1wID0gZDtcbiAgICBkID0gdHkgKiBkIC0gZGQgKyBjb2Zbal07XG4gICAgZGQgPSB0bXA7XG4gIH1cblxuICByZXMgPSB0ICogTWF0aC5leHAoLXggKiB4ICsgMC41ICogKGNvZlswXSArIHR5ICogZCkgLSBkZCk7XG4gIHJldHVybiBpc25lZyA/IHJlcyAtIDEgOiAxIC0gcmVzO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBjb21wbG1lbnRhcnkgZXJyb3IgZnVuY3Rpb24gZXJmYyh4KVxualN0YXQuZXJmYyA9IGZ1bmN0aW9uIGVyZmMoeCkge1xuICByZXR1cm4gMSAtIGpTdGF0LmVyZih4KTtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcGxlbWVudGFyeSBlcnJvciBmdW5jdGlvblxualN0YXQuZXJmY2ludiA9IGZ1bmN0aW9uIGVyZmNpbnYocCkge1xuICB2YXIgaiA9IDA7XG4gIHZhciB4LCBlcnIsIHQsIHBwO1xuICBpZiAocCA+PSAyKVxuICAgIHJldHVybiAtMTAwO1xuICBpZiAocCA8PSAwKVxuICAgIHJldHVybiAxMDA7XG4gIHBwID0gKHAgPCAxKSA/IHAgOiAyIC0gcDtcbiAgdCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHBwIC8gMikpO1xuICB4ID0gLTAuNzA3MTEgKiAoKDIuMzA3NTMgKyB0ICogMC4yNzA2MSkgL1xuICAgICAgICAgICAgICAgICAgKDEgKyB0ICogKDAuOTkyMjkgKyB0ICogMC4wNDQ4MSkpIC0gdCk7XG4gIGZvciAoOyBqIDwgMjsgaisrKSB7XG4gICAgZXJyID0galN0YXQuZXJmYyh4KSAtIHBwO1xuICAgIHggKz0gZXJyIC8gKDEuMTI4Mzc5MTY3MDk1NTEyNTcgKiBNYXRoLmV4cCgteCAqIHgpIC0geCAqIGVycik7XG4gIH1cbiAgcmV0dXJuIChwIDwgMSkgPyB4IDogLXg7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGluY29tcGxldGUgYmV0YSBmdW5jdGlvblxualN0YXQuaWJldGFpbnYgPSBmdW5jdGlvbiBpYmV0YWludihwLCBhLCBiKSB7XG4gIHZhciBFUFMgPSAxZS04O1xuICB2YXIgYTEgPSBhIC0gMTtcbiAgdmFyIGIxID0gYiAtIDE7XG4gIHZhciBqID0gMDtcbiAgdmFyIGxuYSwgbG5iLCBwcCwgdCwgdSwgZXJyLCB4LCBhbCwgaCwgdywgYWZhYztcbiAgaWYgKHAgPD0gMClcbiAgICByZXR1cm4gMDtcbiAgaWYgKHAgPj0gMSlcbiAgICByZXR1cm4gMTtcbiAgaWYgKGEgPj0gMSAmJiBiID49IDEpIHtcbiAgICBwcCA9IChwIDwgMC41KSA/IHAgOiAxIC0gcDtcbiAgICB0ID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocHApKTtcbiAgICB4ID0gKDIuMzA3NTMgKyB0ICogMC4yNzA2MSkgLyAoMSArIHQqICgwLjk5MjI5ICsgdCAqIDAuMDQ0ODEpKSAtIHQ7XG4gICAgaWYgKHAgPCAwLjUpXG4gICAgICB4ID0gLXg7XG4gICAgYWwgPSAoeCAqIHggLSAzKSAvIDY7XG4gICAgaCA9IDIgLyAoMSAvICgyICogYSAtIDEpICArIDEgLyAoMiAqIGIgLSAxKSk7XG4gICAgdyA9ICh4ICogTWF0aC5zcXJ0KGFsICsgaCkgLyBoKSAtICgxIC8gKDIgKiBiIC0gMSkgLSAxIC8gKDIgKiBhIC0gMSkpICpcbiAgICAgICAgKGFsICsgNSAvIDYgLSAyIC8gKDMgKiBoKSk7XG4gICAgeCA9IGEgLyAoYSArIGIgKiBNYXRoLmV4cCgyICogdykpO1xuICB9IGVsc2Uge1xuICAgIGxuYSA9IE1hdGgubG9nKGEgLyAoYSArIGIpKTtcbiAgICBsbmIgPSBNYXRoLmxvZyhiIC8gKGEgKyBiKSk7XG4gICAgdCA9IE1hdGguZXhwKGEgKiBsbmEpIC8gYTtcbiAgICB1ID0gTWF0aC5leHAoYiAqIGxuYikgLyBiO1xuICAgIHcgPSB0ICsgdTtcbiAgICBpZiAocCA8IHQgLyB3KVxuICAgICAgeCA9IE1hdGgucG93KGEgKiB3ICogcCwgMSAvIGEpO1xuICAgIGVsc2VcbiAgICAgIHggPSAxIC0gTWF0aC5wb3coYiAqIHcgKiAoMSAtIHApLCAxIC8gYik7XG4gIH1cbiAgYWZhYyA9IC1qU3RhdC5nYW1tYWxuKGEpIC0galN0YXQuZ2FtbWFsbihiKSArIGpTdGF0LmdhbW1hbG4oYSArIGIpO1xuICBmb3IoOyBqIDwgMTA7IGorKykge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IDEpXG4gICAgICByZXR1cm4geDtcbiAgICBlcnIgPSBqU3RhdC5pYmV0YSh4LCBhLCBiKSAtIHA7XG4gICAgdCA9IE1hdGguZXhwKGExICogTWF0aC5sb2coeCkgKyBiMSAqIE1hdGgubG9nKDEgLSB4KSArIGFmYWMpO1xuICAgIHUgPSBlcnIgLyB0O1xuICAgIHggLT0gKHQgPSB1IC8gKDEgLSAwLjUgKiBNYXRoLm1pbigxLCB1ICogKGExIC8geCAtIGIxIC8gKDEgLSB4KSkpKSk7XG4gICAgaWYgKHggPD0gMClcbiAgICAgIHggPSAwLjUgKiAoeCArIHQpO1xuICAgIGlmICh4ID49IDEpXG4gICAgICB4ID0gMC41ICogKHggKyB0ICsgMSk7XG4gICAgaWYgKE1hdGguYWJzKHQpIDwgRVBTICogeCAmJiBqID4gMClcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB4O1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbmNvbXBsZXRlIGJldGEgZnVuY3Rpb24gSV94KGEsYilcbmpTdGF0LmliZXRhID0gZnVuY3Rpb24gaWJldGEoeCwgYSwgYikge1xuICAvLyBGYWN0b3JzIGluIGZyb250IG9mIHRoZSBjb250aW51ZWQgZnJhY3Rpb24uXG4gIHZhciBidCA9ICh4ID09PSAwIHx8IHggPT09IDEpID8gIDAgOlxuICAgIE1hdGguZXhwKGpTdGF0LmdhbW1hbG4oYSArIGIpIC0galN0YXQuZ2FtbWFsbihhKSAtXG4gICAgICAgICAgICAgalN0YXQuZ2FtbWFsbihiKSArIGEgKiBNYXRoLmxvZyh4KSArIGIgKlxuICAgICAgICAgICAgIE1hdGgubG9nKDEgLSB4KSk7XG4gIGlmICh4IDwgMCB8fCB4ID4gMSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh4IDwgKGEgKyAxKSAvIChhICsgYiArIDIpKVxuICAgIC8vIFVzZSBjb250aW51ZWQgZnJhY3Rpb24gZGlyZWN0bHkuXG4gICAgcmV0dXJuIGJ0ICogalN0YXQuYmV0YWNmKHgsIGEsIGIpIC8gYTtcbiAgLy8gZWxzZSB1c2UgY29udGludWVkIGZyYWN0aW9uIGFmdGVyIG1ha2luZyB0aGUgc3ltbWV0cnkgdHJhbnNmb3JtYXRpb24uXG4gIHJldHVybiAxIC0gYnQgKiBqU3RhdC5iZXRhY2YoMSAtIHgsIGIsIGEpIC8gYjtcbn07XG5cblxuLy8gUmV0dXJucyBhIG5vcm1hbCBkZXZpYXRlIChtdT0wLCBzaWdtYT0xKS5cbi8vIElmIG4gYW5kIG0gYXJlIHNwZWNpZmllZCBpdCByZXR1cm5zIGEgb2JqZWN0IG9mIG5vcm1hbCBkZXZpYXRlcy5cbmpTdGF0LnJhbmRuID0gZnVuY3Rpb24gcmFuZG4obiwgbSkge1xuICB2YXIgdSwgdiwgeCwgeSwgcSwgbWF0O1xuICBpZiAoIW0pXG4gICAgbSA9IG47XG4gIGlmIChuKVxuICAgIHJldHVybiBqU3RhdC5jcmVhdGUobiwgbSwgZnVuY3Rpb24oKSB7IHJldHVybiBqU3RhdC5yYW5kbigpOyB9KTtcbiAgZG8ge1xuICAgIHUgPSBNYXRoLnJhbmRvbSgpO1xuICAgIHYgPSAxLjcxNTYgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgeCA9IHUgLSAwLjQ0OTg3MTtcbiAgICB5ID0gTWF0aC5hYnModikgKyAwLjM4NjU5NTtcbiAgICBxID0geCAqIHggKyB5ICogKDAuMTk2MDAgKiB5IC0gMC4yNTQ3MiAqIHgpO1xuICB9IHdoaWxlIChxID4gMC4yNzU5NyAmJiAocSA+IDAuMjc4NDYgfHwgdiAqIHYgPiAtNCAqIE1hdGgubG9nKHUpICogdSAqIHUpKTtcbiAgcmV0dXJuIHYgLyB1O1xufTtcblxuXG4vLyBSZXR1cm5zIGEgZ2FtbWEgZGV2aWF0ZSBieSB0aGUgbWV0aG9kIG9mIE1hcnNhZ2xpYSBhbmQgVHNhbmcuXG5qU3RhdC5yYW5kZyA9IGZ1bmN0aW9uIHJhbmRnKHNoYXBlLCBuLCBtKSB7XG4gIHZhciBvYWxwaCA9IHNoYXBlO1xuICB2YXIgYTEsIGEyLCB1LCB2LCB4LCBtYXQ7XG4gIGlmICghbSlcbiAgICBtID0gbjtcbiAgaWYgKCFzaGFwZSlcbiAgICBzaGFwZSA9IDE7XG4gIGlmIChuKSB7XG4gICAgbWF0ID0galN0YXQuemVyb3MobixtKTtcbiAgICBtYXQuYWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiBqU3RhdC5yYW5kZyhzaGFwZSk7IH0pO1xuICAgIHJldHVybiBtYXQ7XG4gIH1cbiAgaWYgKHNoYXBlIDwgMSlcbiAgICBzaGFwZSArPSAxO1xuICBhMSA9IHNoYXBlIC0gMSAvIDM7XG4gIGEyID0gMSAvIE1hdGguc3FydCg5ICogYTEpO1xuICBkbyB7XG4gICAgZG8ge1xuICAgICAgeCA9IGpTdGF0LnJhbmRuKCk7XG4gICAgICB2ID0gMSArIGEyICogeDtcbiAgICB9IHdoaWxlKHYgPD0gMCk7XG4gICAgdiA9IHYgKiB2ICogdjtcbiAgICB1ID0gTWF0aC5yYW5kb20oKTtcbiAgfSB3aGlsZSh1ID4gMSAtIDAuMzMxICogTWF0aC5wb3coeCwgNCkgJiZcbiAgICAgICAgICBNYXRoLmxvZyh1KSA+IDAuNSAqIHgqeCArIGExICogKDEgLSB2ICsgTWF0aC5sb2codikpKTtcbiAgLy8gYWxwaGEgPiAxXG4gIGlmIChzaGFwZSA9PSBvYWxwaClcbiAgICByZXR1cm4gYTEgKiB2O1xuICAvLyBhbHBoYSA8IDFcbiAgZG8ge1xuICAgIHUgPSBNYXRoLnJhbmRvbSgpO1xuICB9IHdoaWxlKHUgPT09IDApO1xuICByZXR1cm4gTWF0aC5wb3codSwgMSAvIG9hbHBoKSAqIGExICogdjtcbn07XG5cblxuLy8gbWFraW5nIHVzZSBvZiBzdGF0aWMgbWV0aG9kcyBvbiB0aGUgaW5zdGFuY2VcbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqU3RhdC5mbltwYXNzZnVuY10gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBqU3RhdChcbiAgICAgICAgICBqU3RhdC5tYXAodGhpcywgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGpTdGF0W3Bhc3NmdW5jXSh2YWx1ZSk7IH0pKTtcbiAgICB9XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCdnYW1tYWxuIGdhbW1hZm4gZmFjdG9yaWFsIGZhY3RvcmlhbGxuJy5zcGxpdCgnICcpKTtcblxuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalN0YXQuZm5bcGFzc2Z1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4galN0YXQoalN0YXRbcGFzc2Z1bmNdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCdyYW5kbicuc3BsaXQoJyAnKSk7XG5cbn0odGhpcy5qU3RhdCwgTWF0aCkpO1xuKGZ1bmN0aW9uKGpTdGF0LCBNYXRoKSB7XG5cbi8vIGdlbmVyYXRlIGFsbCBkaXN0cmlidXRpb24gaW5zdGFuY2UgbWV0aG9kc1xuKGZ1bmN0aW9uKGxpc3QpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24oZnVuYykge1xuICAgIC8vIGRpc3RyaWJ1dGlvbiBpbnN0YW5jZSBtZXRob2RcbiAgICBqU3RhdFtmdW5jXSA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBhcmd1bWVudHMuY2FsbGVlKSlcbiAgICAgICAgcmV0dXJuIG5ldyBhcmd1bWVudHMuY2FsbGVlKGEsIGIsIGMpO1xuICAgICAgdGhpcy5fYSA9IGE7XG4gICAgICB0aGlzLl9iID0gYjtcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBkaXN0cmlidXRpb24gbWV0aG9kIHRvIGJlIHVzZWQgb24gYSBqU3RhdCBpbnN0YW5jZVxuICAgIGpTdGF0LmZuW2Z1bmNdID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgdmFyIG5ld3RoaXMgPSBqU3RhdFtmdW5jXShhLCBiLCBjKTtcbiAgICAgIG5ld3RoaXMuZGF0YSA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3dGhpcztcbiAgICB9O1xuICAgIC8vIHNhbXBsZSBpbnN0YW5jZSBtZXRob2RcbiAgICBqU3RhdFtmdW5jXS5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuX2E7XG4gICAgICB2YXIgYiA9IHRoaXMuX2I7XG4gICAgICB2YXIgYyA9IHRoaXMuX2M7XG4gICAgICBpZiAoYXJyKVxuICAgICAgICByZXR1cm4galN0YXQuYWx0ZXIoYXJyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4galN0YXRbZnVuY10uc2FtcGxlKGEsIGIsIGMpO1xuICAgICAgICB9KTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdLnNhbXBsZShhLCBiLCBjKTtcbiAgICB9O1xuICAgIC8vIGdlbmVyYXRlIHRoZSBwZGYsIGNkZiBhbmQgaW52IGluc3RhbmNlIG1ldGhvZHNcbiAgICAoZnVuY3Rpb24odmFscykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24oZm5mdW5jKSB7XG4gICAgICAgIGpTdGF0W2Z1bmNdLnByb3RvdHlwZVtmbmZ1bmNdID0gZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHZhciBhID0gdGhpcy5fYTtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMuX2I7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLl9jO1xuICAgICAgICAgIGlmICgheCAmJiB4ICE9PSAwKVxuICAgICAgICAgICAgeCA9IHRoaXMuZGF0YTtcbiAgICAgICAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4galN0YXQuZm4ubWFwLmNhbGwoeCwgZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICByZXR1cm4galN0YXRbZnVuY11bZm5mdW5jXSh4LCBhLCBiLCBjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4galN0YXRbZnVuY11bZm5mdW5jXSh4LCBhLCBiLCBjKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHZhbHNbaV0pO1xuICAgIH0pKCdwZGYgY2RmIGludicuc3BsaXQoJyAnKSk7XG4gICAgLy8gZ2VuZXJhdGUgdGhlIG1lYW4sIG1lZGlhbiwgbW9kZSBhbmQgdmFyaWFuY2UgaW5zdGFuY2UgbWV0aG9kc1xuICAgIChmdW5jdGlvbih2YWxzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIChmdW5jdGlvbihmbmZ1bmMpIHtcbiAgICAgICAgalN0YXRbZnVuY10ucHJvdG90eXBlW2ZuZnVuY10gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4galN0YXRbZnVuY11bZm5mdW5jXSh0aGlzLl9hLCB0aGlzLl9iLCB0aGlzLl9jKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHZhbHNbaV0pO1xuICAgIH0pKCdtZWFuIG1lZGlhbiBtb2RlIHZhcmlhbmNlJy5zcGxpdCgnICcpKTtcbiAgfSkobGlzdFtpXSk7XG59KSgoXG4gICdiZXRhIGNlbnRyYWxGIGNhdWNoeSBjaGlzcXVhcmUgZXhwb25lbnRpYWwgZ2FtbWEgaW52Z2FtbWEga3VtYXJhc3dhbXkgJyArXG4gICdsb2dub3JtYWwgbm9ybWFsIHBhcmV0byBzdHVkZW50dCB3ZWlidWxsIHVuaWZvcm0gIGJpbm9taWFsIG5lZ2JpbiBoeXBnZW9tICcgK1xuICAncG9pc3NvbiB0cmlhbmd1bGFyJ1xuKS5zcGxpdCgnICcpKTtcblxuXG5cbi8vIGV4dGVuZCBiZXRhIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5iZXRhLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGFscGhhLCBiZXRhKSB7XG4gICAgLy8gUERGIGlzIHplcm8gb3V0c2lkZSB0aGUgc3VwcG9ydFxuICAgIGlmICh4ID4gMSB8fCB4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIC8vIFBERiBpcyBvbmUgZm9yIHRoZSB1bmlmb3JtIGNhc2VcbiAgICBpZiAoYWxwaGEgPT0gMSAmJiBiZXRhID09IDEpXG4gICAgICByZXR1cm4gMTtcblxuICAgIGlmIChhbHBoYSA8IDUxMiB8fCBiZXRhIDwgNTEyKSB7XG4gICAgICByZXR1cm4gKE1hdGgucG93KHgsIGFscGhhIC0gMSkgKiBNYXRoLnBvdygxIC0geCwgYmV0YSAtIDEpKSAvXG4gICAgICAgICAgalN0YXQuYmV0YWZuKGFscGhhLCBiZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguZXhwKChhbHBoYSAtIDEpICogTWF0aC5sb2coeCkgK1xuICAgICAgICAgICAgICAgICAgICAgIChiZXRhIC0gMSkgKiBNYXRoLmxvZygxIC0geCkgLVxuICAgICAgICAgICAgICAgICAgICAgIGpTdGF0LmJldGFsbihhbHBoYSwgYmV0YSkpO1xuICAgIH1cbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoeCA+IDEgfHwgeCA8IDApID8gKHggPiAxKSAqIDEgOiBqU3RhdC5pYmV0YSh4LCBhbHBoYSwgYmV0YSk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbiBpbnYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4galN0YXQuaWJldGFpbnYoeCwgYWxwaGEsIGJldGEpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gYWxwaGEgLyAoYWxwaGEgKyBiZXRhKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihhbHBoYSwgYmV0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVkaWFuIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIChhbHBoYSAqIGJldGEpIC8gKE1hdGgucG93KGFscGhhICsgYmV0YSwgMikgKiAoYWxwaGEgKyBiZXRhICsgMSkpO1xuICB9LFxuXG4gIC8vIHJldHVybiBhIHJhbmRvbSBzYW1wbGVcbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoYWxwaGEsIGJldGEpIHtcbiAgICB2YXIgdSA9IGpTdGF0LnJhbmRnKGFscGhhKTtcbiAgICByZXR1cm4gdSAvICh1ICsgalN0YXQucmFuZGcoYmV0YSkpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYWxwaGEgKiBiZXRhKSAvIChNYXRoLnBvdyhhbHBoYSArIGJldGEsIDIpICogKGFscGhhICsgYmV0YSArIDEpKTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCBGIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5jZW50cmFsRiwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkZjEsIGRmMikge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoTWF0aC5wb3coZGYxICogeCwgZGYxKSAqIE1hdGgucG93KGRmMiwgZGYyKSkgL1xuICAgICAgICAgICAgICAgICAgICAgKE1hdGgucG93KGRmMSAqIHggKyBkZjIsIGRmMSArIGRmMikpKSAvXG4gICAgICAgICAgICAgICAgICAgICAoeCAqIGpTdGF0LmJldGFmbihkZjEvMiwgZGYyLzIpKTtcblxuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGRmMSwgZGYyKSB7XG4gICAgcmV0dXJuIGpTdGF0LmliZXRhKChkZjEgKiB4KSAvIChkZjEgKiB4ICsgZGYyKSwgZGYxIC8gMiwgZGYyIC8gMik7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbiBpbnYoeCwgZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gZGYyIC8gKGRmMSAqICgxIC8galN0YXQuaWJldGFpbnYoeCwgZGYxIC8gMiwgZGYyIC8gMikgLSAxKSk7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihkZjEsIGRmMikge1xuICAgIHJldHVybiAoZGYyID4gMikgPyBkZjIgLyAoZGYyIC0gMikgOiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShkZjEsIGRmMikge1xuICAgIHJldHVybiAoZGYxID4gMikgPyAoZGYyICogKGRmMSAtIDIpKSAvIChkZjEgKiAoZGYyICsgMikpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8vIHJldHVybiBhIHJhbmRvbSBzYW1wbGVcbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoZGYxLCBkZjIpIHtcbiAgICB2YXIgeDEgPSBqU3RhdC5yYW5kZyhkZjEgLyAyKSAqIDI7XG4gICAgdmFyIHgyID0galN0YXQucmFuZGcoZGYyIC8gMikgKiAyO1xuICAgIHJldHVybiAoeDEgLyBkZjEpIC8gKHgyIC8gZGYyKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoZGYxLCBkZjIpIHtcbiAgICBpZiAoZGYyIDw9IDQpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiAyICogZGYyICogZGYyICogKGRmMSArIGRmMiAtIDIpIC9cbiAgICAgICAgKGRmMSAqIChkZjIgLSAyKSAqIChkZjIgLSAyKSAqIChkZjIgLSA0KSk7XG4gIH1cbn0pO1xuXG5cbi8vIGV4dGVuZCBjYXVjaHkgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmNhdWNoeSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4gKHNjYWxlIC8gKE1hdGgucG93KHggLSBsb2NhbCwgMikgKyBNYXRoLnBvdyhzY2FsZSwgMikpKSAvIE1hdGguUEk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbigoeCAtIGxvY2FsKSAvIHNjYWxlKSAvIE1hdGguUEkgKyAwLjU7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWwgKyBzY2FsZSAqIE1hdGgudGFuKE1hdGguUEkgKiAocCAtIDAuNSkpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGxvY2FsLCBzY2FsZSkge1xuICAgIHJldHVybiBsb2NhbDtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGxvY2FsLCBzY2FsZSkge1xuICAgIHJldHVybiBsb2NhbDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4galN0YXQucmFuZG4oKSAqXG4gICAgICAgIE1hdGguc3FydCgxIC8gKDIgKiBqU3RhdC5yYW5kZygwLjUpKSkgKiBzY2FsZSArIGxvY2FsO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBjaGlzcXVhcmUgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmNoaXNxdWFyZSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkb2YpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoKGRvZiAvIDIgLSAxKSAqIE1hdGgubG9nKHgpIC0geCAvIDIgLSAoZG9mIC8gMikgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLmxvZygyKSAtIGpTdGF0LmdhbW1hbG4oZG9mIC8gMikpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGRvZikge1xuICAgIHJldHVybiBqU3RhdC5nYW1tYXAoZG9mIC8gMiwgeCAvIDIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgZG9mKSB7XG4gICAgcmV0dXJuIDIgKiBqU3RhdC5nYW1tYXBpbnYocCwgMC41ICogZG9mKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oZG9mKSB7XG4gICAgcmV0dXJuIGRvZjtcbiAgfSxcblxuICAvLyBUT0RPOiB0aGlzIGlzIGFuIGFwcHJveGltYXRpb24gKGlzIHRoZXJlIGEgYmV0dGVyIHdheT8pXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGRvZikge1xuICAgIHJldHVybiBkb2YgKiBNYXRoLnBvdygxIC0gKDIgLyAoOSAqIGRvZikpLCAzKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGRvZikge1xuICAgIHJldHVybiAoZG9mIC0gMiA+IDApID8gZG9mIC0gMiA6IDA7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoZG9mKSB7XG4gICAgcmV0dXJuIGpTdGF0LnJhbmRnKGRvZiAvIDIpICogMjtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoZG9mKSB7XG4gICAgcmV0dXJuIDIgKiBkb2Y7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIGV4cG9uZW50aWFsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5leHBvbmVudGlhbCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCByYXRlKSB7XG4gICAgcmV0dXJuIHggPCAwID8gMCA6IHJhdGUgKiBNYXRoLmV4cCgtcmF0ZSAqIHgpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHJhdGUpIHtcbiAgICByZXR1cm4geCA8IDAgPyAwIDogMSAtIE1hdGguZXhwKC1yYXRlICogeCk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCByYXRlKSB7XG4gICAgcmV0dXJuIC1NYXRoLmxvZygxIC0gcCkgLyByYXRlO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihyYXRlKSB7XG4gICAgcmV0dXJuIDEgLyByYXRlO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gKHJhdGUpIHtcbiAgICByZXR1cm4gKDEgLyByYXRlKSAqIE1hdGgubG9nKDIpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUocmF0ZSkge1xuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKHJhdGUpIHtcbiAgICByZXR1cm4gLTEgLyByYXRlICogTWF0aC5sb2coTWF0aC5yYW5kb20oKSk7XG4gIH0sXG5cbiAgdmFyaWFuY2UgOiBmdW5jdGlvbihyYXRlKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHJhdGUsIC0yKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgZ2FtbWEgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmdhbW1hLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBNYXRoLmV4cCgoc2hhcGUgLSAxKSAqIE1hdGgubG9nKHgpIC0geCAvIHNjYWxlIC1cbiAgICAgICAgICAgICAgICAgICAgalN0YXQuZ2FtbWFsbihzaGFwZSkgLSBzaGFwZSAqIE1hdGgubG9nKHNjYWxlKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGpTdGF0LmdhbW1hcChzaGFwZSwgeCAvIHNjYWxlKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBqU3RhdC5nYW1tYXBpbnYocCwgc2hhcGUpICogc2NhbGU7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzaGFwZSAqIHNjYWxlO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYoc2hhcGUgPiAxKSByZXR1cm4gKHNoYXBlIC0gMSkgKiBzY2FsZTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBqU3RhdC5yYW5kZyhzaGFwZSkgKiBzY2FsZTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIHNoYXBlICogc2NhbGUgKiBzY2FsZTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCBpbnZlcnNlIGdhbW1hIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5pbnZnYW1tYSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoLShzaGFwZSArIDEpICogTWF0aC5sb2coeCkgLSBzY2FsZSAvIHggLVxuICAgICAgICAgICAgICAgICAgICBqU3RhdC5nYW1tYWxuKHNoYXBlKSArIHNoYXBlICogTWF0aC5sb2coc2NhbGUpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gMSAtIGpTdGF0LmdhbW1hcChzaGFwZSwgc2NhbGUgLyB4KTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSAvIGpTdGF0LmdhbW1hcGludigxIC0gcCwgc2hhcGUpO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gKHNoYXBlID4gMSkgPyBzY2FsZSAvIChzaGFwZSAtIDEpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlIC8gKHNoYXBlICsgMSk7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlIC8galN0YXQucmFuZGcoc2hhcGUpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShzaGFwZSwgc2NhbGUpIHtcbiAgICBpZiAoc2hhcGUgPD0gMilcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHNjYWxlICogc2NhbGUgLyAoKHNoYXBlIC0gMSkgKiAoc2hhcGUgLSAxKSAqIChzaGFwZSAtIDIpKTtcbiAgfVxufSk7XG5cblxuLy8gZXh0ZW5kIGt1bWFyYXN3YW15IGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5rdW1hcmFzd2FteSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiBNYXRoLmV4cChNYXRoLmxvZyhhbHBoYSkgKyBNYXRoLmxvZyhiZXRhKSArIChhbHBoYSAtIDEpICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coeCkgKyAoYmV0YSAtIDEpICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coMSAtIE1hdGgucG93KHgsIGFscGhhKSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuICgxIC0gTWF0aC5wb3coMSAtIE1hdGgucG93KHgsIGFscGhhKSwgYmV0YSkpO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYmV0YSAqIGpTdGF0LmdhbW1hZm4oMSArIDEgLyBhbHBoYSkgKlxuICAgICAgICAgICAgalN0YXQuZ2FtbWFmbihiZXRhKSkgLyAoalN0YXQuZ2FtbWFmbigxICsgMSAvIGFscGhhICsgYmV0YSkpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSBNYXRoLnBvdygyLCAtMSAvIGJldGEpLCAxIC8gYWxwaGEpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoYWxwaGEsIGJldGEpIHtcbiAgICBpZiAoIShhbHBoYSA+PSAxICYmIGJldGEgPj0gMSAmJiAoYWxwaGEgIT09IDEgJiYgYmV0YSAhPT0gMSkpKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gTWF0aC5wb3coKGFscGhhIC0gMSkgLyAoYWxwaGEgKiBiZXRhIC0gMSksIDEgLyBhbHBoYSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGFscGhhLCBiZXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW5jZSBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgLy8gVE9ETzogY29tcGxldGUgdGhpc1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBsb2dub3JtYWwgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmxvZ25vcm1hbCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoLU1hdGgubG9nKHgpIC0gMC41ICogTWF0aC5sb2coMiAqIE1hdGguUEkpIC1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coc2lnbWEpIC0gTWF0aC5wb3coTWF0aC5sb2coeCkgLSBtdSwgMikgL1xuICAgICAgICAgICAgICAgICAgICAoMiAqIHNpZ21hICogc2lnbWEpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gMC41ICtcbiAgICAgICAgKDAuNSAqIGpTdGF0LmVyZigoTWF0aC5sb2coeCkgLSBtdSkgLyBNYXRoLnNxcnQoMiAqIHNpZ21hICogc2lnbWEpKSk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoLTEuNDE0MjEzNTYyMzczMDk1MDUgKiBzaWdtYSAqIGpTdGF0LmVyZmNpbnYoMiAqIHApICsgbXUpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4obXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKG11ICsgc2lnbWEgKiBzaWdtYSAvIDIpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKG11LCBzaWdtYSkge1xuICAgIHJldHVybiBNYXRoLmV4cChtdSk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAobXUgLSBzaWdtYSAqIHNpZ21hKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoalN0YXQucmFuZG4oKSAqIHNpZ21hICsgbXUpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gKE1hdGguZXhwKHNpZ21hICogc2lnbWEpIC0gMSkgKiBNYXRoLmV4cCgyICogbXUgKyBzaWdtYSAqIHNpZ21hKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgbm9ybWFsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5ub3JtYWwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0wLjUgKiBNYXRoLmxvZygyICogTWF0aC5QSSkgLVxuICAgICAgICAgICAgICAgICAgICBNYXRoLmxvZyhzdGQpIC0gTWF0aC5wb3coeCAtIG1lYW4sIDIpIC8gKDIgKiBzdGQgKiBzdGQpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBtZWFuLCBzdGQpIHtcbiAgICByZXR1cm4gMC41ICogKDEgKyBqU3RhdC5lcmYoKHggLSBtZWFuKSAvIE1hdGguc3FydCgyICogc3RkICogc3RkKSkpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgbWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIC0xLjQxNDIxMzU2MjM3MzA5NTA1ICogc3RkICogalN0YXQuZXJmY2ludigyICogcCkgKyBtZWFuO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihtZWFuLCBzdGQpIHtcbiAgICByZXR1cm4gbWVhbjtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihtZWFuLCBzdGQpIHtcbiAgICByZXR1cm4gbWVhbjtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiAobWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIG1lYW47XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUobWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIGpTdGF0LnJhbmRuKCkgKiBzdGQgKyBtZWFuO1xuICB9LFxuXG4gIHZhcmlhbmNlIDogZnVuY3Rpb24obWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIHN0ZCAqIHN0ZDtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgcGFyZXRvIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5wYXJldG8sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHggPD0gc2NhbGUpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiAoc2hhcGUgKiBNYXRoLnBvdyhzY2FsZSwgc2hhcGUpKSAvIE1hdGgucG93KHgsIHNoYXBlICsgMSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdyhzY2FsZSAvIHgsIHNoYXBlKTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKHNjYWxlLCBzaGFwZSkge1xuICAgIGlmIChzaGFwZSA8PSAxKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKHNoYXBlICogTWF0aC5wb3coc2NhbGUsIHNoYXBlKSkgLyAoc2hhcGUgLSAxKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiAoc2hhcGUgKiBNYXRoLlNRUlQyKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZTtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKHNjYWxlLCBzaGFwZSkge1xuICAgIGlmIChzaGFwZSA8PSAyKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKHNjYWxlKnNjYWxlICogc2hhcGUpIC8gKE1hdGgucG93KHNoYXBlIC0gMSwgMikgKiAoc2hhcGUgLSAyKSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHN0dWRlbnR0IGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5zdHVkZW50dCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkb2YpIHtcbiAgICByZXR1cm4gKGpTdGF0LmdhbW1hZm4oKGRvZiArIDEpIC8gMikgLyAoTWF0aC5zcXJ0KGRvZiAqIE1hdGguUEkpICpcbiAgICAgICAgalN0YXQuZ2FtbWFmbihkb2YgLyAyKSkpICpcbiAgICAgICAgTWF0aC5wb3coMSArICgoeCAqIHgpIC8gZG9mKSwgLSgoZG9mICsgMSkgLyAyKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgZG9mKSB7XG4gICAgdmFyIGRvZjIgPSBkb2YgLyAyO1xuICAgIHJldHVybiBqU3RhdC5pYmV0YSgoeCArIE1hdGguc3FydCh4ICogeCArIGRvZikpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgKDIgKiBNYXRoLnNxcnQoeCAqIHggKyBkb2YpKSwgZG9mMiwgZG9mMik7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBkb2YpIHtcbiAgICB2YXIgeCA9IGpTdGF0LmliZXRhaW52KDIgKiBNYXRoLm1pbihwLCAxIC0gcCksIDAuNSAqIGRvZiwgMC41KTtcbiAgICB4ID0gTWF0aC5zcXJ0KGRvZiAqICgxIC0geCkgLyB4KTtcbiAgICByZXR1cm4gKHAgPiAwLjUpID8geCA6IC14O1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oZG9mKSB7XG4gICAgcmV0dXJuIChkb2YgPiAxKSA/IDAgOiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oZG9mKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShkb2YpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShkb2YpIHtcbiAgICByZXR1cm4galN0YXQucmFuZG4oKSAqIE1hdGguc3FydChkb2YgLyAoMiAqIGpTdGF0LnJhbmRnKGRvZiAvIDIpKSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGRvZikge1xuICAgIHJldHVybiAoZG9mICA+IDIpID8gZG9mIC8gKGRvZiAtIDIpIDogKGRvZiA+IDEpID8gSW5maW5pdHkgOiB1bmRlZmluZWQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHdlaWJ1bGwgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LndlaWJ1bGwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHggPCAwKVxuICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChzaGFwZSAvIHNjYWxlKSAqIE1hdGgucG93KCh4IC8gc2NhbGUpLCAoc2hhcGUgLSAxKSkgKlxuICAgICAgICBNYXRoLmV4cCgtKE1hdGgucG93KCh4IC8gc2NhbGUpLCBzaGFwZSkpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4geCA8IDAgPyAwIDogMSAtIE1hdGguZXhwKC1NYXRoLnBvdygoeCAvIHNjYWxlKSwgc2hhcGUpKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAqIE1hdGgucG93KC1NYXRoLmxvZygxIC0gcCksIDEgLyBzaGFwZSk7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAqIGpTdGF0LmdhbW1hZm4oMSArIDEgLyBzaGFwZSk7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogTWF0aC5wb3coTWF0aC5sb2coMiksIDEgLyBzaGFwZSk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShzY2FsZSwgc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUgPD0gMSlcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHNjYWxlICogTWF0aC5wb3coKHNoYXBlIC0gMSkgLyBzaGFwZSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBNYXRoLnBvdygtTWF0aC5sb2coTWF0aC5yYW5kb20oKSksIDEgLyBzaGFwZSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAqIHNjYWxlICogalN0YXQuZ2FtbWFmbigxICsgMiAvIHNoYXBlKSAtXG4gICAgICAgIE1hdGgucG93KHRoaXMubWVhbihzY2FsZSwgc2hhcGUpLCAyKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgdW5pZm9ybSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQudW5pZm9ybSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhLCBiKSB7XG4gICAgcmV0dXJuICh4IDwgYSB8fCB4ID4gYikgPyAwIDogMSAvIChiIC0gYSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYSwgYikge1xuICAgIGlmICh4IDwgYSlcbiAgICAgIHJldHVybiAwO1xuICAgIGVsc2UgaWYgKHggPCBiKVxuICAgICAgcmV0dXJuICh4IC0gYSkgLyAoYiAtIGEpO1xuICAgIHJldHVybiAxO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oYSwgYikge1xuICAgIHJldHVybiAwLjUgKiAoYSArIGIpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGEsIGIpIHtcbiAgICByZXR1cm4galN0YXQubWVhbihhLCBiKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGEsIGIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgLyAyICsgYiAvIDIpICsgKGIgLyAyIC0gYSAvIDIpICogKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYiAtIGEsIDIpIC8gMTI7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmJpbm9taWFsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIG4sIHApIHtcbiAgICByZXR1cm4gKHAgPT09IDAgfHwgcCA9PT0gMSkgP1xuICAgICAgKChuICogcCkgPT09IGsgPyAxIDogMCkgOlxuICAgICAgalN0YXQuY29tYmluYXRpb24obiwgaykgKiBNYXRoLnBvdyhwLCBrKSAqIE1hdGgucG93KDEgLSBwLCBuIC0gayk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbiwgcCkge1xuICAgIHZhciBiaW5vbWFyciA9IFtdLFxuICAgIGsgPSAwO1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh4IDwgbikge1xuICAgICAgZm9yICg7IGsgPD0geDsgaysrKSB7XG4gICAgICAgIGJpbm9tYXJyWyBrIF0gPSBqU3RhdC5iaW5vbWlhbC5wZGYoaywgbiwgcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4galN0YXQuc3VtKGJpbm9tYXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0Lm5lZ2Jpbiwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZihrLCByLCBwKSB7XG4gICAgcmV0dXJuIGsgIT09IGsgfCAwXG4gICAgICA/IGZhbHNlXG4gICAgICA6IGsgPCAwXG4gICAgICAgID8gMFxuICAgICAgICA6IGpTdGF0LmNvbWJpbmF0aW9uKGsgKyByIC0gMSwgciAtIDEpICogTWF0aC5wb3coMSAtIHAsIGspICogTWF0aC5wb3cocCwgcik7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgciwgcCkge1xuICAgIHZhciBzdW0gPSAwLFxuICAgIGsgPSAwO1xuICAgIGlmICh4IDwgMCkgcmV0dXJuIDA7XG4gICAgZm9yICg7IGsgPD0geDsgaysrKSB7XG4gICAgICBzdW0gKz0galN0YXQubmVnYmluLnBkZihrLCByLCBwKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgdW5pZm9ybSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuaHlwZ2VvbSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZihrLCBOLCBtLCBuKSB7XG4gICAgLy8gSHlwZXJnZW9tZXRyaWMgUERGLlxuXG4gICAgLy8gQSBzaW1wbGlmaWNhdGlvbiBvZiB0aGUgQ0RGIGFsZ29yaXRobSBiZWxvdy5cblxuICAgIC8vIGsgPSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGRyYXduXG4gICAgLy8gTiA9IHBvcHVsYXRpb24gc2l6ZVxuICAgIC8vIG0gPSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGluIHBvcHVsYXRpb25cbiAgICAvLyBuID0gbnVtYmVyIG9mIGl0ZW1zIGRyYXduIGZyb20gcG9wdWxhdGlvblxuXG4gICAgaWYoayAhPT0gayB8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYoayA8IDAgfHwgayA8IG0gLSAoTiAtIG4pKSB7XG4gICAgICAvLyBJdCdzIGltcG9zc2libGUgdG8gaGF2ZSB0aGlzIGZldyBzdWNjZXNzZXMgZHJhd24uXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYoayA+IG4gfHwgayA+IG0pIHtcbiAgICAgIC8vIEl0J3MgaW1wb3NzaWJsZSB0byBoYXZlIHRoaXMgbWFueSBzdWNjZXNzZXMgZHJhd24uXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKG0gKiAyID4gTikge1xuICAgICAgLy8gTW9yZSB0aGFuIGhhbGYgdGhlIHBvcHVsYXRpb24gaXMgc3VjY2Vzc2VzLlxuXG4gICAgICBpZihuICogMiA+IE4pIHtcbiAgICAgICAgLy8gTW9yZSB0aGFuIGhhbGYgdGhlIHBvcHVsYXRpb24gaXMgc2FtcGxlZC5cblxuICAgICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5wZGYoTiAtIG0gLSBuICsgaywgTiwgTiAtIG0sIE4gLSBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFsZiBvciBsZXNzIG9mIHRoZSBwb3B1bGF0aW9uIGlzIHNhbXBsZWQuXG5cbiAgICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20ucGRmKG4gLSBrLCBOLCBOIC0gbSwgbik7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYobiAqIDIgPiBOKSB7XG4gICAgICAvLyBIYWxmIG9yIGxlc3MgaXMgc3VjY2Vzc2VzLlxuXG4gICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5wZGYobSAtIGssIE4sIG0sIE4gLSBuKTtcblxuICAgIH0gZWxzZSBpZihtIDwgbikge1xuICAgICAgLy8gV2Ugd2FudCB0byBoYXZlIHRoZSBudW1iZXIgb2YgdGhpbmdzIHNhbXBsZWQgdG8gYmUgbGVzcyB0aGFuIHRoZVxuICAgICAgLy8gc3VjY2Vzc2VzIGF2YWlsYWJsZS4gU28gc3dhcCB0aGUgZGVmaW5pdGlvbnMgb2Ygc3VjY2Vzc2Z1bCBhbmQgc2FtcGxlZC5cbiAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLnBkZihrLCBOLCBuLCBtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIGhhbGYgb3IgbGVzcyBvZiB0aGUgcG9wdWxhdGlvbiB3YXMgc2FtcGxlZCwgaGFsZiBvclxuICAgICAgLy8gbGVzcyBvZiBpdCB3YXMgc3VjY2Vzc2VzLCBhbmQgd2UgaGFkIGZld2VyIHNhbXBsZWQgdGhpbmdzIHRoYW5cbiAgICAgIC8vIHN1Y2Nlc3Nlcy4gTm93IHdlIGNhbiBkbyB0aGlzIGNvbXBsaWNhdGVkIGl0ZXJhdGl2ZSBhbGdvcml0aG0gaW4gYW5cbiAgICAgIC8vIGVmZmljaWVudCB3YXkuXG5cbiAgICAgIC8vIFRoZSBiYXNpYyBwcmVtaXNlIG9mIHRoZSBhbGdvcml0aG0gaXMgdGhhdCB3ZSBwYXJ0aWFsbHkgbm9ybWFsaXplIG91clxuICAgICAgLy8gaW50ZXJtZWRpYXRlIHByb2R1Y3QgdG8ga2VlcCBpdCBpbiBhIG51bWVyaWNhbGx5IGdvb2QgcmVnaW9uLCBhbmQgdGhlblxuICAgICAgLy8gZmluaXNoIHRoZSBub3JtYWxpemF0aW9uIGF0IHRoZSBlbmQuXG5cbiAgICAgIC8vIFRoaXMgdmFyaWFibGUgaG9sZHMgdGhlIHNjYWxlZCBwcm9iYWJpbGl0eSBvZiB0aGUgY3VycmVudCBudW1iZXIgb2ZcbiAgICAgIC8vIHN1Y2Nlc3Nlcy5cbiAgICAgIHZhciBzY2FsZWRQREYgPSAxO1xuXG4gICAgICAvLyBUaGlzIGtlZXBzIHRyYWNrIG9mIGhvdyBtdWNoIHdlIGhhdmUgbm9ybWFsaXplZC5cbiAgICAgIHZhciBzYW1wbGVzRG9uZSA9IDA7XG5cbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgLy8gRm9yIGV2ZXJ5IHBvc3NpYmxlIG51bWJlciBvZiBzdWNjZXNzZXMgdXAgdG8gdGhhdCBvYnNlcnZlZC4uLlxuXG4gICAgICAgIHdoaWxlKHNjYWxlZFBERiA+IDEgJiYgc2FtcGxlc0RvbmUgPCBuKSB7XG4gICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIHJlc3VsdCBpcyBncm93aW5nIHRvbyBiaWcuIEFwcGx5IHNvbWUgb2YgdGhlXG4gICAgICAgICAgLy8gbm9ybWFsaXphdGlvbiB0byBzaHJpbmsgZXZlcnl0aGluZy5cblxuICAgICAgICAgIHNjYWxlZFBERiAqPSAxIC0gKG0gLyAoTiAtIHNhbXBsZXNEb25lKSk7XG5cbiAgICAgICAgICAvLyBTYXkgd2UndmUgbm9ybWFsaXplZCBieSB0aGlzIHNhbXBsZSBhbHJlYWR5LlxuICAgICAgICAgIHNhbXBsZXNEb25lKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXb3JrIG91dCB0aGUgcGFydGlhbGx5LW5vcm1hbGl6ZWQgaHlwZXJnZW9tZXRyaWMgUERGIGZvciB0aGUgbmV4dFxuICAgICAgICAvLyBudW1iZXIgb2Ygc3VjY2Vzc2VzXG4gICAgICAgIHNjYWxlZFBERiAqPSAobiAtIGkpICogKG0gLSBpKSAvICgoaSArIDEpICogKE4gLSBtIC0gbiArIGkgKyAxKSk7XG4gICAgICB9XG5cbiAgICAgIGZvcig7IHNhbXBsZXNEb25lIDwgbjsgc2FtcGxlc0RvbmUrKykge1xuICAgICAgICAvLyBBcHBseSBhbGwgdGhlIHJlc3Qgb2YgdGhlIG5vcm1hbGl6YXRpb25cbiAgICAgICAgc2NhbGVkUERGICo9IDEgLSAobSAvIChOIC0gc2FtcGxlc0RvbmUpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQm91bmQgYW5zd2VyIHNhbmVseSBiZWZvcmUgcmV0dXJuaW5nLlxuICAgICAgcmV0dXJuIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHNjYWxlZFBERikpO1xuICAgIH1cbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBOLCBtLCBuKSB7XG4gICAgLy8gSHlwZXJnZW9tZXRyaWMgQ0RGLlxuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gaXMgZHVlIHRvIFByb2YuIFRob21hcyBTLiBGZXJndXNvbiwgPHRvbUBtYXRoLnVjbGEuZWR1PixcbiAgICAvLyBhbmQgY29tZXMgZnJvbSBoaXMgaHlwZXJnZW9tZXRyaWMgdGVzdCBjYWxjdWxhdG9yIGF0XG4gICAgLy8gPGh0dHA6Ly93d3cubWF0aC51Y2xhLmVkdS9+dG9tL2Rpc3RyaWJ1dGlvbnMvSHlwZXJnZW9tZXRyaWMuaHRtbD4uXG5cbiAgICAvLyB4ID0gbnVtYmVyIG9mIHN1Y2Nlc3NlcyBkcmF3blxuICAgIC8vIE4gPSBwb3B1bGF0aW9uIHNpemVcbiAgICAvLyBtID0gbnVtYmVyIG9mIHN1Y2Nlc3NlcyBpbiBwb3B1bGF0aW9uXG4gICAgLy8gbiA9IG51bWJlciBvZiBpdGVtcyBkcmF3biBmcm9tIHBvcHVsYXRpb25cblxuICAgIGlmKHggPCAwIHx8IHggPCBtIC0gKE4gLSBuKSkge1xuICAgICAgLy8gSXQncyBpbXBvc3NpYmxlIHRvIGhhdmUgdGhpcyBmZXcgc3VjY2Vzc2VzIGRyYXduIG9yIGZld2VyLlxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmKHggPj0gbiB8fCB4ID49IG0pIHtcbiAgICAgIC8vIFdlIHdpbGwgYWx3YXlzIGhhdmUgdGhpcyBtYW55IHN1Y2Nlc3NlcyBvciBmZXdlci5cbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAobSAqIDIgPiBOKSB7XG4gICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzdWNjZXNzZXMuXG5cbiAgICAgIGlmKG4gKiAyID4gTikge1xuICAgICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuXG4gICAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLmNkZihOIC0gbSAtIG4gKyB4LCBOLCBOIC0gbSwgTiAtIG4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gaXMgc2FtcGxlZC5cblxuICAgICAgICByZXR1cm4gMSAtIGpTdGF0Lmh5cGdlb20uY2RmKG4gLSB4IC0gMSwgTiwgTiAtIG0sIG4pO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKG4gKiAyID4gTikge1xuICAgICAgLy8gSGFsZiBvciBsZXNzIGlzIHN1Y2Nlc3Nlcy5cblxuICAgICAgcmV0dXJuIDEgLSBqU3RhdC5oeXBnZW9tLmNkZihtIC0geCAtIDEsIE4sIG0sIE4gLSBuKTtcblxuICAgIH0gZWxzZSBpZihtIDwgbikge1xuICAgICAgLy8gV2Ugd2FudCB0byBoYXZlIHRoZSBudW1iZXIgb2YgdGhpbmdzIHNhbXBsZWQgdG8gYmUgbGVzcyB0aGFuIHRoZVxuICAgICAgLy8gc3VjY2Vzc2VzIGF2YWlsYWJsZS4gU28gc3dhcCB0aGUgZGVmaW5pdGlvbnMgb2Ygc3VjY2Vzc2Z1bCBhbmQgc2FtcGxlZC5cbiAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLmNkZih4LCBOLCBuLCBtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIGhhbGYgb3IgbGVzcyBvZiB0aGUgcG9wdWxhdGlvbiB3YXMgc2FtcGxlZCwgaGFsZiBvclxuICAgICAgLy8gbGVzcyBvZiBpdCB3YXMgc3VjY2Vzc2VzLCBhbmQgd2UgaGFkIGZld2VyIHNhbXBsZWQgdGhpbmdzIHRoYW5cbiAgICAgIC8vIHN1Y2Nlc3Nlcy4gTm93IHdlIGNhbiBkbyB0aGlzIGNvbXBsaWNhdGVkIGl0ZXJhdGl2ZSBhbGdvcml0aG0gaW4gYW5cbiAgICAgIC8vIGVmZmljaWVudCB3YXkuXG5cbiAgICAgIC8vIFRoZSBiYXNpYyBwcmVtaXNlIG9mIHRoZSBhbGdvcml0aG0gaXMgdGhhdCB3ZSBwYXJ0aWFsbHkgbm9ybWFsaXplIG91clxuICAgICAgLy8gaW50ZXJtZWRpYXRlIHN1bSB0byBrZWVwIGl0IGluIGEgbnVtZXJpY2FsbHkgZ29vZCByZWdpb24sIGFuZCB0aGVuXG4gICAgICAvLyBmaW5pc2ggdGhlIG5vcm1hbGl6YXRpb24gYXQgdGhlIGVuZC5cblxuICAgICAgLy8gSG9sZHMgdGhlIGludGVybWVkaWF0ZSwgc2NhbGVkIHRvdGFsIENERi5cbiAgICAgIHZhciBzY2FsZWRDREYgPSAxO1xuXG4gICAgICAvLyBUaGlzIHZhcmlhYmxlIGhvbGRzIHRoZSBzY2FsZWQgcHJvYmFiaWxpdHkgb2YgdGhlIGN1cnJlbnQgbnVtYmVyIG9mXG4gICAgICAvLyBzdWNjZXNzZXMuXG4gICAgICB2YXIgc2NhbGVkUERGID0gMTtcblxuICAgICAgLy8gVGhpcyBrZWVwcyB0cmFjayBvZiBob3cgbXVjaCB3ZSBoYXZlIG5vcm1hbGl6ZWQuXG4gICAgICB2YXIgc2FtcGxlc0RvbmUgPSAwO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgeDsgaSsrKSB7XG4gICAgICAgIC8vIEZvciBldmVyeSBwb3NzaWJsZSBudW1iZXIgb2Ygc3VjY2Vzc2VzIHVwIHRvIHRoYXQgb2JzZXJ2ZWQuLi5cblxuICAgICAgICB3aGlsZShzY2FsZWRDREYgPiAxICYmIHNhbXBsZXNEb25lIDwgbikge1xuICAgICAgICAgIC8vIEludGVybWVkaWF0ZSByZXN1bHQgaXMgZ3Jvd2luZyB0b28gYmlnLiBBcHBseSBzb21lIG9mIHRoZVxuICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24gdG8gc2hyaW5rIGV2ZXJ5dGhpbmcuXG5cbiAgICAgICAgICB2YXIgZmFjdG9yID0gMSAtIChtIC8gKE4gLSBzYW1wbGVzRG9uZSkpO1xuXG4gICAgICAgICAgc2NhbGVkUERGICo9IGZhY3RvcjtcbiAgICAgICAgICBzY2FsZWRDREYgKj0gZmFjdG9yO1xuXG4gICAgICAgICAgLy8gU2F5IHdlJ3ZlIG5vcm1hbGl6ZWQgYnkgdGhpcyBzYW1wbGUgYWxyZWFkeS5cbiAgICAgICAgICBzYW1wbGVzRG9uZSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV29yayBvdXQgdGhlIHBhcnRpYWxseS1ub3JtYWxpemVkIGh5cGVyZ2VvbWV0cmljIFBERiBmb3IgdGhlIG5leHRcbiAgICAgICAgLy8gbnVtYmVyIG9mIHN1Y2Nlc3Nlc1xuICAgICAgICBzY2FsZWRQREYgKj0gKG4gLSBpKSAqIChtIC0gaSkgLyAoKGkgKyAxKSAqIChOIC0gbSAtIG4gKyBpICsgMSkpO1xuXG4gICAgICAgIC8vIEFkZCB0byB0aGUgQ0RGIGFuc3dlci5cbiAgICAgICAgc2NhbGVkQ0RGICs9IHNjYWxlZFBERjtcbiAgICAgIH1cblxuICAgICAgZm9yKDsgc2FtcGxlc0RvbmUgPCBuOyBzYW1wbGVzRG9uZSsrKSB7XG4gICAgICAgIC8vIEFwcGx5IGFsbCB0aGUgcmVzdCBvZiB0aGUgbm9ybWFsaXphdGlvblxuICAgICAgICBzY2FsZWRDREYgKj0gMSAtIChtIC8gKE4gLSBzYW1wbGVzRG9uZSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBCb3VuZCBhbnN3ZXIgc2FuZWx5IGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgc2NhbGVkQ0RGKSk7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5wb2lzc29uLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIGwpIHtcbiAgICByZXR1cm4gTWF0aC5wb3cobCwgaykgKiBNYXRoLmV4cCgtbCkgLyBqU3RhdC5mYWN0b3JpYWwoayk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbCkge1xuICAgIHZhciBzdW1hcnIgPSBbXSxcbiAgICBrID0gMDtcbiAgICBpZiAoeCA8IDApIHJldHVybiAwO1xuICAgIGZvciAoOyBrIDw9IHg7IGsrKykge1xuICAgICAgc3VtYXJyLnB1c2goalN0YXQucG9pc3Nvbi5wZGYoaywgbCkpO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQuc3VtKHN1bWFycik7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gbDtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gbDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShsKSB7XG4gICAgdmFyIHAgPSAxLCBrID0gMCwgTCA9IE1hdGguZXhwKC1sKTtcbiAgICBkbyB7XG4gICAgICBrKys7XG4gICAgICBwICo9IE1hdGgucmFuZG9tKCk7XG4gICAgfSB3aGlsZSAocCA+IEwpO1xuICAgIHJldHVybiBrIC0gMTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCB0cmlhbmd1bGFyIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC50cmlhbmd1bGFyLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGIgPD0gYSB8fCBjIDwgYSB8fCBjID4gYilcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6ICh4IDwgYSB8fCB4ID4gYilcbiAgICAgICAgPyAwXG4gICAgICAgIDogKHggPD0gYylcbiAgICAgICAgICA/ICgyICogKHggLSBhKSkgLyAoKGIgLSBhKSAqIChjIC0gYSkpXG4gICAgICAgICAgOiAoMiAqIChiIC0geCkpIC8gKChiIC0gYSkgKiAoYiAtIGMpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhLCBiLCBjKSB7XG4gICAgaWYgKGIgPD0gYSB8fCBjIDwgYSB8fCBjID4gYilcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHggPCBhKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHggPD0gYylcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHggLSBhLCAyKSAvICgoYiAtIGEpICogKGMgLSBhKSk7XG4gICAgICByZXR1cm4gMSAtIE1hdGgucG93KGIgLSB4LCAyKSAvICgoYiAtIGEpICogKGIgLSBjKSk7XG4gICAgfVxuICAgIC8vIG5ldmVyIHJlYWNoIHRoaXNcbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgKyBiICsgYykgLyAzO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGEsIGIsIGMpIHtcbiAgICBpZiAoYyA8PSAoYSArIGIpIC8gMikge1xuICAgICAgcmV0dXJuIGIgLSBNYXRoLnNxcnQoKGIgLSBhKSAqIChiIC0gYykpIC8gTWF0aC5zcXJ0KDIpO1xuICAgIH0gZWxzZSBpZiAoYyA+IChhICsgYikgLyAyKSB7XG4gICAgICByZXR1cm4gYSArIE1hdGguc3FydCgoYiAtIGEpICogKGMgLSBhKSkgLyBNYXRoLnNxcnQoMik7XG4gICAgfVxuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoYSwgYiwgYykge1xuICAgIHJldHVybiBjO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGEsIGIsIGMpIHtcbiAgICB2YXIgdSA9IE1hdGgucmFuZG9tKCk7XG4gICAgaWYgKHUgPCAoKGMgLSBhKSAvIChiIC0gYSkpKVxuICAgICAgcmV0dXJuIGEgKyBNYXRoLnNxcnQodSAqIChiIC0gYSkgKiAoYyAtIGEpKVxuICAgIHJldHVybiBiIC0gTWF0aC5zcXJ0KCgxIC0gdSkgKiAoYiAtIGEpICogKGIgLSBjKSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgKiBhICsgYiAqIGIgKyBjICogYyAtIGEgKiBiIC0gYSAqIGMgLSBiICogYykgLyAxODtcbiAgfVxufSk7XG5cbn0odGhpcy5qU3RhdCwgTWF0aCkpO1xuLyogUHJvdmlkZXMgZnVuY3Rpb25zIGZvciB0aGUgc29sdXRpb24gb2YgbGluZWFyIHN5c3RlbSBvZiBlcXVhdGlvbnMsIGludGVncmF0aW9uLCBleHRyYXBvbGF0aW9uLFxuICogaW50ZXJwb2xhdGlvbiwgZWlnZW52YWx1ZSBwcm9ibGVtcywgZGlmZmVyZW50aWFsIGVxdWF0aW9ucyBhbmQgUENBIGFuYWx5c2lzLiAqL1xuXG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxudmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbnZhciBpc0FycmF5ID0galN0YXQudXRpbHMuaXNBcnJheTtcblxualN0YXQuZXh0ZW5kKHtcblxuICAvLyBhZGQgYSB2ZWN0b3IvbWF0cml4IHRvIGEgdmVjdG9yL21hdHJpeCBvciBzY2FsYXJcbiAgYWRkOiBmdW5jdGlvbiBhZGQoYXJyLCBhcmcpIHtcbiAgICAvLyBjaGVjayBpZiBhcmcgaXMgYSB2ZWN0b3Igb3Igc2NhbGFyXG4gICAgaWYgKGlzQXJyYXkoYXJnKSkge1xuICAgICAgaWYgKCFpc0FycmF5KGFyZ1swXSkpIGFyZyA9IFsgYXJnIF07XG4gICAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUsIHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIGFyZ1tyb3ddW2NvbF07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZSArIGFyZzsgfSk7XG4gIH0sXG5cbiAgLy8gc3VidHJhY3QgYSB2ZWN0b3Igb3Igc2NhbGFyIGZyb20gdGhlIHZlY3RvclxuICBzdWJ0cmFjdDogZnVuY3Rpb24gc3VidHJhY3QoYXJyLCBhcmcpIHtcbiAgICAvLyBjaGVjayBpZiBhcmcgaXMgYSB2ZWN0b3Igb3Igc2NhbGFyXG4gICAgaWYgKGlzQXJyYXkoYXJnKSkge1xuICAgICAgaWYgKCFpc0FycmF5KGFyZ1swXSkpIGFyZyA9IFsgYXJnIF07XG4gICAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUsIHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAtIGFyZ1tyb3ddW2NvbF0gfHwgMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlIC0gYXJnOyB9KTtcbiAgfSxcblxuICAvLyBtYXRyaXggZGl2aXNpb25cbiAgZGl2aWRlOiBmdW5jdGlvbiBkaXZpZGUoYXJyLCBhcmcpIHtcbiAgICBpZiAoaXNBcnJheShhcmcpKSB7XG4gICAgICBpZiAoIWlzQXJyYXkoYXJnWzBdKSkgYXJnID0gWyBhcmcgXTtcbiAgICAgIHJldHVybiBqU3RhdC5tdWx0aXBseShhcnIsIGpTdGF0LmludihhcmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAvIGFyZzsgfSk7XG4gIH0sXG5cbiAgLy8gbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG11bHRpcGx5OiBmdW5jdGlvbiBtdWx0aXBseShhcnIsIGFyZykge1xuICAgIHZhciByb3csIGNvbCwgbnJlc2NvbHMsIHN1bSxcbiAgICBucm93ID0gYXJyLmxlbmd0aCxcbiAgICBuY29sID0gYXJyWzBdLmxlbmd0aCxcbiAgICByZXMgPSBqU3RhdC56ZXJvcyhucm93LCBucmVzY29scyA9IChpc0FycmF5KGFyZykpID8gYXJnWzBdLmxlbmd0aCA6IG5jb2wpLFxuICAgIHJlc2NvbHMgPSAwO1xuICAgIGlmIChpc0FycmF5KGFyZykpIHtcbiAgICAgIGZvciAoOyByZXNjb2xzIDwgbnJlc2NvbHM7IHJlc2NvbHMrKykge1xuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IG5yb3c7IHJvdysrKSB7XG4gICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IG5jb2w7IGNvbCsrKVxuICAgICAgICAgIHN1bSArPSBhcnJbcm93XVtjb2xdICogYXJnW2NvbF1bcmVzY29sc107XG4gICAgICAgICAgcmVzW3Jvd11bcmVzY29sc10gPSBzdW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAobnJvdyA9PT0gMSAmJiByZXNjb2xzID09PSAxKSA/IHJlc1swXVswXSA6IHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAqIGFyZzsgfSk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIG1hdHJpY2llc1xuICBkb3Q6IGZ1bmN0aW9uIGRvdChhcnIsIGFyZykge1xuICAgIGlmICghaXNBcnJheShhcnJbMF0pKSBhcnIgPSBbIGFyciBdO1xuICAgIGlmICghaXNBcnJheShhcmdbMF0pKSBhcmcgPSBbIGFyZyBdO1xuICAgIC8vIGNvbnZlcnQgY29sdW1uIHRvIHJvdyB2ZWN0b3JcbiAgICB2YXIgbGVmdCA9IChhcnJbMF0ubGVuZ3RoID09PSAxICYmIGFyci5sZW5ndGggIT09IDEpID8galN0YXQudHJhbnNwb3NlKGFycikgOiBhcnIsXG4gICAgcmlnaHQgPSAoYXJnWzBdLmxlbmd0aCA9PT0gMSAmJiBhcmcubGVuZ3RoICE9PSAxKSA/IGpTdGF0LnRyYW5zcG9zZShhcmcpIDogYXJnLFxuICAgIHJlcyA9IFtdLFxuICAgIHJvdyA9IDAsXG4gICAgbnJvdyA9IGxlZnQubGVuZ3RoLFxuICAgIG5jb2wgPSBsZWZ0WzBdLmxlbmd0aCxcbiAgICBzdW0sIGNvbDtcbiAgICBmb3IgKDsgcm93IDwgbnJvdzsgcm93KyspIHtcbiAgICAgIHJlc1tyb3ddID0gW107XG4gICAgICBzdW0gPSAwO1xuICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBuY29sOyBjb2wrKylcbiAgICAgIHN1bSArPSBsZWZ0W3Jvd11bY29sXSAqIHJpZ2h0W3Jvd11bY29sXTtcbiAgICAgIHJlc1tyb3ddID0gc3VtO1xuICAgIH1cbiAgICByZXR1cm4gKHJlcy5sZW5ndGggPT09IDEpID8gcmVzWzBdIDogcmVzO1xuICB9LFxuXG4gIC8vIHJhaXNlIGV2ZXJ5IGVsZW1lbnQgYnkgYSBzY2FsYXJcbiAgcG93OiBmdW5jdGlvbiBwb3coYXJyLCBhcmcpIHtcbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIE1hdGgucG93KHZhbHVlLCBhcmcpOyB9KTtcbiAgfSxcblxuICAvLyBnZW5lcmF0ZSB0aGUgYWJzb2x1dGUgdmFsdWVzIG9mIHRoZSB2ZWN0b3JcbiAgYWJzOiBmdW5jdGlvbiBhYnMoYXJyKSB7XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBNYXRoLmFicyh2YWx1ZSk7IH0pO1xuICB9LFxuXG4gIC8vIGNvbXB1dGVzIHRoZSBwLW5vcm0gb2YgdGhlIHZlY3RvclxuICAvLyBJbiB0aGUgY2FzZSB0aGF0IGEgbWF0cml4IGlzIHBhc3NlZCwgdXNlcyB0aGUgZmlyc3Qgcm93IGFzIHRoZSB2ZWN0b3JcbiAgbm9ybTogZnVuY3Rpb24gbm9ybShhcnIsIHApIHtcbiAgICB2YXIgbm5vcm0gPSAwLFxuICAgIGkgPSAwO1xuICAgIC8vIGNoZWNrIHRoZSBwLXZhbHVlIG9mIHRoZSBub3JtLCBhbmQgc2V0IGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gICAgaWYgKGlzTmFOKHApKSBwID0gMjtcbiAgICAvLyBjaGVjayBpZiBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSwgYW5kIG1ha2UgdmVjdG9yIGNvcnJlY3Rpb25cbiAgICBpZiAoaXNBcnJheShhcnJbMF0pKSBhcnIgPSBhcnJbMF07XG4gICAgLy8gdmVjdG9yIG5vcm1cbiAgICBmb3IgKDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgbm5vcm0gKz0gTWF0aC5wb3coTWF0aC5hYnMoYXJyW2ldKSwgcCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnBvdyhubm9ybSwgMSAvIHApO1xuICB9LFxuXG4gIC8vIFRPRE86IG1ha2UgY29tcGF0aWJsZSB3aXRoIG1hdHJpY2VzXG4gIC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIGluIHJhZHNcbiAgYW5nbGU6IGZ1bmN0aW9uIGFuZ2xlKGFyciwgYXJnKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhqU3RhdC5kb3QoYXJyLCBhcmcpIC8gKGpTdGF0Lm5vcm0oYXJyKSAqIGpTdGF0Lm5vcm0oYXJnKSkpO1xuICB9LFxuXG4gIC8vIGF1Z21lbnQgb25lIG1hdHJpeCBieSBhbm90aGVyXG4gIGF1ZzogZnVuY3Rpb24gYXVnKGEsIGIpIHtcbiAgICB2YXIgbmV3YXJyID0gYS5zbGljZSgpLFxuICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbmV3YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwdXNoLmFwcGx5KG5ld2FycltpXSwgYltpXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdhcnI7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbiBpbnYoYSkge1xuICAgIHZhciByb3dzID0gYS5sZW5ndGgsXG4gICAgY29scyA9IGFbMF0ubGVuZ3RoLFxuICAgIGIgPSBqU3RhdC5pZGVudGl0eShyb3dzLCBjb2xzKSxcbiAgICBjID0galN0YXQuZ2F1c3Nfam9yZGFuKGEsIGIpLFxuICAgIG9iaiA9IFtdLFxuICAgIGkgPSAwLFxuICAgIGo7XG4gICAgZm9yICg7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgIG9ialtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gY29scyAtIDE7IGogPCBjWzBdLmxlbmd0aDsgaisrKVxuICAgICAgb2JqW2ldW2ogLSBjb2xzXSA9IGNbaV1bal07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxuICBkZXQ6IGZ1bmN0aW9uIGRldChhKSB7XG4gICAgdmFyIGFsZW4gPSBhLmxlbmd0aCxcbiAgICBhbGVuZCA9IGFsZW4gKiAyLFxuICAgIHZhbHMgPSBuZXcgQXJyYXkoYWxlbmQpLFxuICAgIHJvd3NoaWZ0ID0gYWxlbiAtIDEsXG4gICAgY29sc2hpZnQgPSBhbGVuZCAtIDEsXG4gICAgbXJvdyA9IHJvd3NoaWZ0IC0gYWxlbiArIDEsXG4gICAgbWNvbCA9IGNvbHNoaWZ0LFxuICAgIGkgPSAwLFxuICAgIHJlc3VsdCA9IDAsXG4gICAgajtcbiAgICAvLyBjaGVjayBmb3Igc3BlY2lhbCAyeDIgY2FzZVxuICAgIGlmIChhbGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gYVswXVswXSAqIGFbMV1bMV0gLSBhWzBdWzFdICogYVsxXVswXTtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBhbGVuZDsgaSsrKSB7XG4gICAgICB2YWxzW2ldID0gMTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFsZW47IGkrKykge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGFsZW47IGorKykge1xuICAgICAgICB2YWxzWyhtcm93IDwgMCkgPyBtcm93ICsgYWxlbiA6IG1yb3cgXSAqPSBhW2ldW2pdO1xuICAgICAgICB2YWxzWyhtY29sIDwgYWxlbikgPyBtY29sICsgYWxlbiA6IG1jb2wgXSAqPSBhW2ldW2pdO1xuICAgICAgICBtcm93Kys7XG4gICAgICAgIG1jb2wtLTtcbiAgICAgIH1cbiAgICAgIG1yb3cgPSAtLXJvd3NoaWZ0IC0gYWxlbiArIDE7XG4gICAgICBtY29sID0gLS1jb2xzaGlmdDtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFsZW47IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHZhbHNbaV07XG4gICAgfVxuICAgIGZvciAoOyBpIDwgYWxlbmQ7IGkrKykge1xuICAgICAgcmVzdWx0IC09IHZhbHNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgZ2F1c3NfZWxpbWluYXRpb246IGZ1bmN0aW9uIGdhdXNzX2VsaW1pbmF0aW9uKGEsIGIpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgaiA9IDAsXG4gICAgbiA9IGEubGVuZ3RoLFxuICAgIG0gPSBhWzBdLmxlbmd0aCxcbiAgICBmYWN0b3IgPSAxLFxuICAgIHN1bSA9IDAsXG4gICAgeCA9IFtdLFxuICAgIG1hdWcsIHBpdm90LCB0ZW1wLCBrO1xuICAgIGEgPSBqU3RhdC5hdWcoYSwgYik7XG4gICAgbWF1ZyA9IGFbMF0ubGVuZ3RoO1xuICAgIGZvcig7IGkgPCBuOyBpKyspIHtcbiAgICAgIHBpdm90ID0gYVtpXVtpXTtcbiAgICAgIGogPSBpO1xuICAgICAgZm9yIChrID0gaSArIDE7IGsgPCBtOyBrKyspIHtcbiAgICAgICAgaWYgKHBpdm90IDwgTWF0aC5hYnMoYVtrXVtpXSkpIHtcbiAgICAgICAgICBwaXZvdCA9IGFba11baV07XG4gICAgICAgICAgaiA9IGs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChqICE9IGkpIHtcbiAgICAgICAgZm9yKGsgPSAwOyBrIDwgbWF1ZzsgaysrKSB7XG4gICAgICAgICAgdGVtcCA9IGFbaV1ba107XG4gICAgICAgICAgYVtpXVtrXSA9IGFbal1ba107XG4gICAgICAgICAgYVtqXVtrXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGZhY3RvciA9IGFbal1baV0gLyBhW2ldW2ldO1xuICAgICAgICBmb3IoayA9IGk7IGsgPCBtYXVnOyBrKyspIHtcbiAgICAgICAgICBhW2pdW2tdID0gYVtqXVtrXSAtIGZhY3RvciAqIGFbaV1ba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBzdW0gPSAwO1xuICAgICAgZm9yIChqID0gaSArIDE7IGo8PSBuIC0gMTsgaisrKSB7XG4gICAgICAgIHN1bSA9IHhbal0gKiBhW2ldW2pdO1xuICAgICAgfVxuICAgICAgeFtpXSA9KGFbaV1bbWF1ZyAtIDFdIC0gc3VtKSAvIGFbaV1baV07XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9LFxuXG4gIGdhdXNzX2pvcmRhbjogZnVuY3Rpb24gZ2F1c3Nfam9yZGFuKGEsIGIpIHtcbiAgICB2YXIgbSA9IGpTdGF0LmF1ZyhhLCBiKSxcbiAgICBoID0gbS5sZW5ndGgsXG4gICAgdyA9IG1bMF0ubGVuZ3RoO1xuICAgIC8vIGZpbmQgbWF4IHBpdm90XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICAgIHZhciBtYXhyb3cgPSB5O1xuICAgICAgZm9yICh2YXIgeTIgPSB5KzE7IHkyIDwgaDsgeTIrKykge1xuICAgICAgICBpZiAoTWF0aC5hYnMobVt5Ml1beV0pID4gTWF0aC5hYnMobVttYXhyb3ddW3ldKSlcbiAgICAgICAgICBtYXhyb3cgPSB5MjtcbiAgICAgIH1cbiAgICAgIHZhciB0bXAgPSBtW3ldO1xuICAgICAgbVt5XSA9IG1bbWF4cm93XTtcbiAgICAgIG1bbWF4cm93XSA9IHRtcFxuICAgICAgZm9yICh2YXIgeTIgPSB5KzE7IHkyIDwgaDsgeTIrKykge1xuICAgICAgICBjID0gbVt5Ml1beV0gLyBtW3ldW3ldO1xuICAgICAgICBmb3IgKHZhciB4ID0geTsgeCA8IHc7IHgrKykge1xuICAgICAgICAgIG1beTJdW3hdIC09IG1beV1beF0gKiBjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGJhY2tzdWJzdGl0dXRlXG4gICAgZm9yICh2YXIgeSA9IGgtMTsgeSA+PSAwOyB5LS0pIHtcbiAgICAgIGMgPSBtW3ldW3ldO1xuICAgICAgZm9yICh2YXIgeTIgPSAwOyB5MiA8IHk7IHkyKyspIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IHctMTsgeCA+IHktMTsgeC0tKSB7XG4gICAgICAgICAgbVt5Ml1beF0gLT0gbVt5XVt4XSAqIG1beTJdW3ldIC8gYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbVt5XVt5XSAvPSBjO1xuICAgICAgZm9yICh2YXIgeCA9IGg7IHggPCB3OyB4KyspIHtcbiAgICAgICAgbVt5XVt4XSAvPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfSxcblxuICBsdTogZnVuY3Rpb24gbHUoYSwgYikge1xuICAgIHRocm93IG5ldyBFcnJvcignbHUgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9LFxuXG4gIGNob2xlc2t5OiBmdW5jdGlvbiBjaG9sZXNreShhLCBiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjaG9sZXNreSBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG5cbiAgZ2F1c3NfamFjb2JpOiBmdW5jdGlvbiBnYXVzc19qYWNvYmkoYSwgYiwgeCwgcikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgeHYsIGMsIGgsIHhrO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gW107XG4gICAgICB1W2ldID0gW107XG4gICAgICBkW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIGxbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIHVbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgIHVbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gdVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaCA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihkKSwgalN0YXQuYWRkKGwsIHUpKSwgLTEpO1xuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoZCksIGIpO1xuICAgIHh2ID0geDtcbiAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4KSwgYyk7XG4gICAgaSA9IDI7XG4gICAgd2hpbGUgKE1hdGguYWJzKGpTdGF0Lm5vcm0oalN0YXQuc3VidHJhY3QoeGsseHYpKSkgPiByKSB7XG4gICAgICB4diA9IHhrO1xuICAgICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeHYpLCBjKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHhrO1xuICB9LFxuXG4gIGdhdXNzX3NlaWRlbDogZnVuY3Rpb24gZ2F1c3Nfc2VpZGVsKGEsIGIsIHgsIHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgaiwgeHYsIGMsIGgsIHhrO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gW107XG4gICAgICB1W2ldID0gW107XG4gICAgICBkW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIGxbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIHVbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgIHVbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gdVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaCA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihqU3RhdC5hZGQoZCwgbCkpLCB1KSwgLTEpO1xuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsIGwpKSwgYik7XG4gICAgeHYgPSB4O1xuICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHgpLCBjKTtcbiAgICBpID0gMjtcbiAgICB3aGlsZSAoTWF0aC5hYnMoalN0YXQubm9ybShqU3RhdC5zdWJ0cmFjdCh4aywgeHYpKSkgPiByKSB7XG4gICAgICB4diA9IHhrO1xuICAgICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeHYpLCBjKTtcbiAgICAgIGkgPSBpICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHhrO1xuICB9LFxuXG4gIFNPUjogZnVuY3Rpb24gU09SKGEsIGIsIHgsIHIsIHcpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgaiwgeHYsIGMsIGgsIHhrO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gW107XG4gICAgICB1W2ldID0gW107XG4gICAgICBkW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIGxbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIHVbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgIHVbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gdVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaCA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihqU3RhdC5hZGQoZCwgalN0YXQubXVsdGlwbHkobCwgdykpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgalN0YXQuc3VidHJhY3QoalN0YXQubXVsdGlwbHkoZCwgMSAtIHcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5tdWx0aXBseSh1LCB3KSkpO1xuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsXG4gICAgICAgIGpTdGF0Lm11bHRpcGx5KGwsIHcpKSksIGIpLCB3KTtcbiAgICB4diA9IHg7XG4gICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeCksIGMpO1xuICAgIGkgPSAyO1xuICAgIHdoaWxlIChNYXRoLmFicyhqU3RhdC5ub3JtKGpTdGF0LnN1YnRyYWN0KHhrLCB4dikpKSA+IHIpIHtcbiAgICAgIHh2ID0geGs7XG4gICAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4diksIGMpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4geGs7XG4gIH0sXG5cbiAgaG91c2Vob2xkZXI6IGZ1bmN0aW9uIGhvdXNlaG9sZGVyKGEpIHtcbiAgICB2YXIgbSA9IGEubGVuZ3RoO1xuICAgIHZhciBuID0gYVswXS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciB3ID0gW107XG4gICAgdmFyIHAgPSBbXTtcbiAgICB2YXIgYWxwaGEsIHIsIGssIGosIGZhY3RvcjtcbiAgICBmb3IgKDsgaSA8IG0gLSAxOyBpKyspIHtcbiAgICAgIGFscGhhID0gMDtcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgaisrKVxuICAgICAgYWxwaGEgKz0gKGFbal1baV0gKiBhW2pdW2ldKTtcbiAgICAgIGZhY3RvciA9IChhW2kgKyAxXVtpXSA+IDApID8gLTEgOiAxO1xuICAgICAgYWxwaGEgPSBmYWN0b3IgKiBNYXRoLnNxcnQoYWxwaGEpO1xuICAgICAgciA9IE1hdGguc3FydCgoKChhbHBoYSAqIGFscGhhKSAtIGFbaSArIDFdW2ldICogYWxwaGEpIC8gMikpO1xuICAgICAgdyA9IGpTdGF0Lnplcm9zKG0sIDEpO1xuICAgICAgd1tpICsgMV1bMF0gPSAoYVtpICsgMV1baV0gLSBhbHBoYSkgLyAoMiAqIHIpO1xuICAgICAgZm9yIChrID0gaSArIDI7IGsgPCBtOyBrKyspIHdba11bMF0gPSBhW2tdW2ldIC8gKDIgKiByKTtcbiAgICAgIHAgPSBqU3RhdC5zdWJ0cmFjdChqU3RhdC5pZGVudGl0eShtLCBuKSxcbiAgICAgICAgICBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseSh3LCBqU3RhdC50cmFuc3Bvc2UodykpLCAyKSk7XG4gICAgICBhID0galN0YXQubXVsdGlwbHkocCwgalN0YXQubXVsdGlwbHkoYSwgcCkpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfSxcblxuICAvLyBUT0RPOiBub3Qgd29ya2luZyBwcm9wZXJseS5cbiAgUVI6IGZ1bmN0aW9uIFFSKGEsIGIpIHtcbiAgICB2YXIgbSA9IGEubGVuZ3RoO1xuICAgIHZhciBuID0gYVswXS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciB3ID0gW107XG4gICAgdmFyIHAgPSBbXTtcbiAgICB2YXIgeCA9IFtdO1xuICAgIHZhciBqLCBhbHBoYSwgciwgaywgZmFjdG9yLCBzdW07XG4gICAgZm9yICg7IGkgPCBtIC0gMTsgaSsrKSB7XG4gICAgICBhbHBoYSA9IDA7XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKylcbiAgICAgICAgYWxwaGEgKz0gKGFbal1baV0gKiBhW2pdW2ldKTtcbiAgICAgIGZhY3RvciA9IChhW2kgKyAxXVtpXSA+IDApID8gLTEgOiAxO1xuICAgICAgYWxwaGEgPSBmYWN0b3IgKiBNYXRoLnNxcnQoYWxwaGEpO1xuICAgICAgciA9IE1hdGguc3FydCgoKChhbHBoYSAqIGFscGhhKSAtIGFbaSArIDFdW2ldICogYWxwaGEpIC8gMikpO1xuICAgICAgdyA9IGpTdGF0Lnplcm9zKG0sIDEpO1xuICAgICAgd1tpICsgMV1bMF0gPSAoYVtpICsgMV1baV0gLSBhbHBoYSkgLyAoMiAqIHIpO1xuICAgICAgZm9yIChrID0gaSArIDI7IGsgPCBtOyBrKyspXG4gICAgICAgIHdba11bMF0gPSBhW2tdW2ldIC8gKDIgKiByKTtcbiAgICAgIHAgPSBqU3RhdC5zdWJ0cmFjdChqU3RhdC5pZGVudGl0eShtLCBuKSxcbiAgICAgICAgICBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseSh3LCBqU3RhdC50cmFuc3Bvc2UodykpLCAyKSk7XG4gICAgICBhID0galN0YXQubXVsdGlwbHkocCwgYSk7XG4gICAgICBiID0galN0YXQubXVsdGlwbHkocCwgYik7XG4gICAgfVxuICAgIGZvciAoaSA9IG0gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgc3VtID0gMDtcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDw9IG4gLSAxOyBqKyspXG4gICAgICBzdW0gPSB4W2pdICogYVtpXVtqXTtcbiAgICAgIHhbaV0gPSBiW2ldWzBdIC8gYVtpXVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG4gIH0sXG5cbiAgamFjb2JpOiBmdW5jdGlvbiBqYWNvYmkoYSkge1xuICAgIHZhciBjb25kaXRpb24gPSAxO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgZSA9IGpTdGF0LmlkZW50aXR5KG4sIG4pO1xuICAgIHZhciBldiA9IFtdO1xuICAgIHZhciBiLCBpLCBqLCBwLCBxLCBtYXhpbSwgdGhldGEsIHM7XG4gICAgLy8gY29uZGl0aW9uID09PSAxIG9ubHkgaWYgdG9sZXJhbmNlIGlzIG5vdCByZWFjaGVkXG4gICAgd2hpbGUgKGNvbmRpdGlvbiA9PT0gMSkge1xuICAgICAgY291bnQrKztcbiAgICAgIG1heGltID0gYVswXVsxXTtcbiAgICAgIHAgPSAwO1xuICAgICAgcSA9IDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSAhPSBqKSB7XG4gICAgICAgICAgICBpZiAobWF4aW0gPCBNYXRoLmFicyhhW2ldW2pdKSkge1xuICAgICAgICAgICAgICBtYXhpbSA9IE1hdGguYWJzKGFbaV1bal0pO1xuICAgICAgICAgICAgICBwID0gaTtcbiAgICAgICAgICAgICAgcSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYVtwXVtwXSA9PT0gYVtxXVtxXSlcbiAgICAgICAgdGhldGEgPSAoYVtwXVtxXSA+IDApID8gTWF0aC5QSSAvIDQgOiAtTWF0aC5QSSAvIDQ7XG4gICAgICBlbHNlXG4gICAgICAgIHRoZXRhID0gTWF0aC5hdGFuKDIgKiBhW3BdW3FdIC8gKGFbcF1bcF0gLSBhW3FdW3FdKSkgLyAyO1xuICAgICAgcyA9IGpTdGF0LmlkZW50aXR5KG4sIG4pO1xuICAgICAgc1twXVtwXSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHNbcF1bcV0gPSAtTWF0aC5zaW4odGhldGEpO1xuICAgICAgc1txXVtwXSA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgIHNbcV1bcV0gPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAvLyBlaWdlbiB2ZWN0b3IgbWF0cml4XG4gICAgICBlID0galN0YXQubXVsdGlwbHkoZSwgcyk7XG4gICAgICBiID0galN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkoalN0YXQuaW52KHMpLCBhKSwgcyk7XG4gICAgICBhID0gYjtcbiAgICAgIGNvbmRpdGlvbiA9IDA7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSAhPSBqICYmIE1hdGguYWJzKGFbaV1bal0pID4gMC4wMDEpIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbiA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGV2LnB1c2goYVtpXVtpXSk7XG4gICAgLy9yZXR1cm5zIGJvdGggdGhlIGVpZ2VudmFsdWUgYW5kIGVpZ2VubWF0cml4XG4gICAgcmV0dXJuIFtlLCBldl07XG4gIH0sXG5cbiAgcnVuZ2VrdXR0YTogZnVuY3Rpb24gcnVuZ2VrdXR0YShmLCBoLCBwLCB0X2osIHVfaiwgb3JkZXIpIHtcbiAgICB2YXIgazEsIGsyLCB1X2oxLCBrMywgazQ7XG4gICAgaWYgKG9yZGVyID09PSAyKSB7XG4gICAgICB3aGlsZSAodF9qIDw9IHApIHtcbiAgICAgICAgazEgPSBoICogZih0X2osIHVfaik7XG4gICAgICAgIGsyID0gaCAqIGYodF9qICsgaCwgdV9qICsgazEpO1xuICAgICAgICB1X2oxID0gdV9qICsgKGsxICsgazIpIC8gMjtcbiAgICAgICAgdV9qID0gdV9qMTtcbiAgICAgICAgdF9qID0gdF9qICsgaDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yZGVyID09PSA0KSB7XG4gICAgICB3aGlsZSAodF9qIDw9IHApIHtcbiAgICAgICAgazEgPSBoICogZih0X2osIHVfaik7XG4gICAgICAgIGsyID0gaCAqIGYodF9qICsgaCAvIDIsIHVfaiArIGsxIC8gMik7XG4gICAgICAgIGszID0gaCAqIGYodF9qICsgaCAvIDIsIHVfaiArIGsyIC8gMik7XG4gICAgICAgIGs0ID0gaCAqIGYodF9qICtoLCB1X2ogKyBrMyk7XG4gICAgICAgIHVfajEgPSB1X2ogKyAoazEgKyAyICogazIgKyAyICogazMgKyBrNCkgLyA2O1xuICAgICAgICB1X2ogPSB1X2oxO1xuICAgICAgICB0X2ogPSB0X2ogKyBoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdV9qO1xuICB9LFxuXG4gIHJvbWJlcmc6IGZ1bmN0aW9uIHJvbWJlcmcoZiwgYSwgYiwgb3JkZXIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGggPSAoYiAtIGEpIC8gMjtcbiAgICB2YXIgeCA9IFtdO1xuICAgIHZhciBoMSA9IFtdO1xuICAgIHZhciBnID0gW107XG4gICAgdmFyIG0sIGExLCBqLCBrLCBJLCBkO1xuICAgIHdoaWxlIChpIDwgb3JkZXIgLyAyKSB7XG4gICAgICBJID0gZihhKTtcbiAgICAgIGZvciAoaiA9IGEsIGsgPSAwOyBqIDw9IGI7IGogPSBqICsgaCwgaysrKSB4W2tdID0gajtcbiAgICAgIG0gPSB4Lmxlbmd0aDtcbiAgICAgIGZvciAoaiA9IDE7IGogPCBtIC0gMTsgaisrKSB7XG4gICAgICAgIEkgKz0gKCgoaiAlIDIpICE9PSAwKSA/IDQgOiAyKSAqIGYoeFtqXSk7XG4gICAgICB9XG4gICAgICBJID0gKGggLyAzKSAqIChJICsgZihiKSk7XG4gICAgICBnW2ldID0gSTtcbiAgICAgIGggLz0gMjtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgYTEgPSBnLmxlbmd0aDtcbiAgICBtID0gMTtcbiAgICB3aGlsZSAoYTEgIT09IDEpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhMSAtIDE7IGorKylcbiAgICAgIGgxW2pdID0gKChNYXRoLnBvdyg0LCBtKSkgKiBnW2ogKyAxXSAtIGdbal0pIC8gKE1hdGgucG93KDQsIG0pIC0gMSk7XG4gICAgICBhMSA9IGgxLmxlbmd0aDtcbiAgICAgIGcgPSBoMTtcbiAgICAgIGgxID0gW107XG4gICAgICBtKys7XG4gICAgfVxuICAgIHJldHVybiBnO1xuICB9LFxuXG4gIHJpY2hhcmRzb246IGZ1bmN0aW9uIHJpY2hhcmRzb24oWCwgZiwgeCwgaCkge1xuICAgIGZ1bmN0aW9uIHBvcyhYLCB4KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgICAgdmFyIHA7XG4gICAgICBmb3IgKDsgaSA8IG47IGkrKylcbiAgICAgICAgaWYgKFhbaV0gPT09IHgpIHAgPSBpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHZhciBuID0gWC5sZW5ndGgsXG4gICAgaF9taW4gPSBNYXRoLmFicyh4IC0gWFtwb3MoWCwgeCkgKyAxXSksXG4gICAgaSA9IDAsXG4gICAgZyA9IFtdLFxuICAgIGgxID0gW10sXG4gICAgeTEsIHkyLCBtLCBhLCBqO1xuICAgIHdoaWxlIChoID49IGhfbWluKSB7XG4gICAgICB5MSA9IHBvcyhYLCB4ICsgaCk7XG4gICAgICB5MiA9IHBvcyhYLCB4KTtcbiAgICAgIGdbaV0gPSAoZlt5MV0gLSAyICogZlt5Ml0gKyBmWzIgKiB5MiAtIHkxXSkgLyAoaCAqIGgpO1xuICAgICAgaCAvPSAyO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBhID0gZy5sZW5ndGg7XG4gICAgbSA9IDE7XG4gICAgd2hpbGUgKGEgIT0gMSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGEgLSAxOyBqKyspXG4gICAgICBoMVtqXSA9ICgoTWF0aC5wb3coNCwgbSkpICogZ1tqICsgMV0gLSBnW2pdKSAvIChNYXRoLnBvdyg0LCBtKSAtIDEpO1xuICAgICAgYSA9IGgxLmxlbmd0aDtcbiAgICAgIGcgPSBoMTtcbiAgICAgIGgxID0gW107XG4gICAgICBtKys7XG4gICAgfVxuICAgIHJldHVybiBnO1xuICB9LFxuXG4gIHNpbXBzb246IGZ1bmN0aW9uIHNpbXBzb24oZiwgYSwgYiwgbikge1xuICAgIHZhciBoID0gKGIgLSBhKSAvIG47XG4gICAgdmFyIEkgPSBmKGEpO1xuICAgIHZhciB4ID0gW107XG4gICAgdmFyIGogPSBhO1xuICAgIHZhciBrID0gMDtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIG07XG4gICAgZm9yICg7IGogPD0gYjsgaiA9IGogKyBoLCBrKyspXG4gICAgICB4W2tdID0gajtcbiAgICBtID0geC5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBtIC0gMTsgaSsrKSB7XG4gICAgICBJICs9ICgoaSAlIDIgIT09IDApID8gNCA6IDIpICogZih4W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIChoIC8gMykgKiAoSSArIGYoYikpO1xuICB9LFxuXG4gIGhlcm1pdGU6IGZ1bmN0aW9uIGhlcm1pdGUoWCwgRiwgZEYsIHZhbHVlKSB7XG4gICAgdmFyIG4gPSBYLmxlbmd0aDtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsID0gW107XG4gICAgdmFyIGRsID0gW107XG4gICAgdmFyIEEgPSBbXTtcbiAgICB2YXIgQiA9IFtdO1xuICAgIHZhciBqO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gMTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGkgIT0gaikgbFtpXSAqPSAodmFsdWUgLSBYW2pdKSAvIChYW2ldIC0gWFtqXSk7XG4gICAgICB9XG4gICAgICBkbFtpXSA9IDA7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpICE9IGopIGRsW2ldICs9IDEgLyAoWCBbaV0gLSBYW2pdKTtcbiAgICAgIH1cbiAgICAgIEFbaV0gPSAoMSAtIDIgKiAodmFsdWUgLSBYW2ldKSAqIGRsW2ldKSAqIChsW2ldICogbFtpXSk7XG4gICAgICBCW2ldID0gKHZhbHVlIC0gWFtpXSkgKiAobFtpXSAqIGxbaV0pO1xuICAgICAgcCArPSAoQVtpXSAqIEZbaV0gKyBCW2ldICogZEZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICBsYWdyYW5nZTogZnVuY3Rpb24gbGFncmFuZ2UoWCwgRiwgdmFsdWUpIHtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqLCBsO1xuICAgIHZhciBuID0gWC5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGwgPSBGW2ldO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAvLyBjYWxjdWxhdGluZyB0aGUgbGFncmFuZ2UgcG9seW5vbWlhbCBMX2lcbiAgICAgICAgaWYgKGkgIT0gaikgbCAqPSAodmFsdWUgLSBYW2pdKSAvIChYW2ldIC0gWFtqXSk7XG4gICAgICB9XG4gICAgICAvLyBhZGRpbmcgdGhlIGxhZ3JhbmdlIHBvbHlub21pYWxzIGZvdW5kIGFib3ZlXG4gICAgICBwICs9IGw7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIGN1YmljX3NwbGluZTogZnVuY3Rpb24gY3ViaWNfc3BsaW5lKFgsIEYsIHZhbHVlKSB7XG4gICAgdmFyIG4gPSBYLmxlbmd0aDtcbiAgICB2YXIgaSA9IDAsIGo7XG4gICAgdmFyIEEgPSBbXTtcbiAgICB2YXIgQiA9IFtdO1xuICAgIHZhciBhbHBoYSA9IFtdO1xuICAgIHZhciBjID0gW107XG4gICAgdmFyIGggPSBbXTtcbiAgICB2YXIgYiA9IFtdO1xuICAgIHZhciBkID0gW107XG4gICAgZm9yICg7IGkgPCBuIC0gMTsgaSsrKVxuICAgICAgaFtpXSA9IFhbaSArIDFdIC0gWFtpXTtcbiAgICBhbHBoYVswXSA9IDA7XG4gICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIGFscGhhW2ldID0gKDMgLyBoW2ldKSAqIChGW2kgKyAxXSAtIEZbaV0pIC1cbiAgICAgICAgICAoMyAvIGhbaS0xXSkgKiAoRltpXSAtIEZbaS0xXSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICBBW2ldID0gW107XG4gICAgICBCW2ldID0gW107XG4gICAgICBBW2ldW2ktMV0gPSBoW2ktMV07XG4gICAgICBBW2ldW2ldID0gMiAqIChoW2kgLSAxXSArIGhbaV0pO1xuICAgICAgQVtpXVtpKzFdID0gaFtpXTtcbiAgICAgIEJbaV1bMF0gPSBhbHBoYVtpXTtcbiAgICB9XG4gICAgYyA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihBKSwgQik7XG4gICAgZm9yIChqID0gMDsgaiA8IG4gLSAxOyBqKyspIHtcbiAgICAgIGJbal0gPSAoRltqICsgMV0gLSBGW2pdKSAvIGhbal0gLSBoW2pdICogKGNbaiArIDFdWzBdICsgMiAqIGNbal1bMF0pIC8gMztcbiAgICAgIGRbal0gPSAoY1tqICsgMV1bMF0gLSBjW2pdWzBdKSAvICgzICogaFtqXSk7XG4gICAgfVxuICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIGlmIChYW2pdID4gdmFsdWUpIGJyZWFrO1xuICAgIH1cbiAgICBqIC09IDE7XG4gICAgcmV0dXJuIEZbal0gKyAodmFsdWUgLSBYW2pdKSAqIGJbal0gKyBqU3RhdC5zcSh2YWx1ZS1YW2pdKSAqXG4gICAgICAgIGNbal0gKyAodmFsdWUgLSBYW2pdKSAqIGpTdGF0LnNxKHZhbHVlIC0gWFtqXSkgKiBkW2pdO1xuICB9LFxuXG4gIGdhdXNzX3F1YWRyYXR1cmU6IGZ1bmN0aW9uIGdhdXNzX3F1YWRyYXR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnYXVzc19xdWFkcmF0dXJlIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcblxuICBQQ0E6IGZ1bmN0aW9uIFBDQShYKSB7XG4gICAgdmFyIG0gPSBYLmxlbmd0aDtcbiAgICB2YXIgbiA9IFhbMF0ubGVuZ3RoO1xuICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqLCB0ZW1wMTtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBEID0gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciB0ZW1wMiA9IFtdO1xuICAgIHZhciBZID0gW107XG4gICAgdmFyIEJ0ID0gW107XG4gICAgdmFyIEIgPSBbXTtcbiAgICB2YXIgQyA9IFtdO1xuICAgIHZhciBWID0gW107XG4gICAgdmFyIFZ0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgdVtpXSA9IGpTdGF0LnN1bShYW2ldKSAvIG47XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIEJbaV0gPSBbXTtcbiAgICAgIGZvcihqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICBCW2ldW2pdID0gWFtqXVtpXSAtIHVbal07XG4gICAgICB9XG4gICAgfVxuICAgIEIgPSBqU3RhdC50cmFuc3Bvc2UoQik7XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgQ1tpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICBDW2ldW2pdID0gKGpTdGF0LmRvdChbQltpXV0sIFtCW2pdXSkpIC8gKG4gLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ID0galN0YXQuamFjb2JpKEMpO1xuICAgIFYgPSByZXN1bHRbMF07XG4gICAgRCA9IHJlc3VsdFsxXTtcbiAgICBWdCA9IGpTdGF0LnRyYW5zcG9zZShWKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgRC5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChqID0gaTsgaiA8IEQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYoRFtpXSA8IERbal0pICB7XG4gICAgICAgICAgdGVtcDEgPSBEW2ldO1xuICAgICAgICAgIERbaV0gPSBEW2pdO1xuICAgICAgICAgIERbal0gPSB0ZW1wMTtcbiAgICAgICAgICB0ZW1wMiA9IFZ0W2ldO1xuICAgICAgICAgIFZ0W2ldID0gVnRbal07XG4gICAgICAgICAgVnRbal0gPSB0ZW1wMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBCdCA9IGpTdGF0LnRyYW5zcG9zZShCKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICBZW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgQnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgWVtpXVtqXSA9IGpTdGF0LmRvdChbVnRbaV1dLCBbQnRbal1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtYLCBELCBWdCwgWV07XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQgalN0YXQuZm4gd2l0aCBtZXRob2RzIHRoYXQgcmVxdWlyZSBvbmUgYXJndW1lbnRcbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqU3RhdC5mbltwYXNzZnVuY10gPSBmdW5jdGlvbihhcmcsIGZ1bmMpIHtcbiAgICAgIHZhciB0bXB0aGlzID0gdGhpcztcbiAgICAgIC8vIGNoZWNrIGZvciBjYWxsYmFja1xuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jLmNhbGwodG1wdGhpcywgalN0YXQuZm5bcGFzc2Z1bmNdLmNhbGwodG1wdGhpcywgYXJnKSk7XG4gICAgICAgIH0sIDE1KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBhcmcpID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBhcmcpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4galN0YXQoalN0YXRbcGFzc2Z1bmNdKHRoaXMsIGFyZykpO1xuICAgIH07XG4gIH0oZnVuY3NbaV0pKTtcbn0oJ2FkZCBkaXZpZGUgbXVsdGlwbHkgc3VidHJhY3QgZG90IHBvdyBhYnMgbm9ybSBhbmdsZScuc3BsaXQoJyAnKSkpO1xuXG59KHRoaXMualN0YXQsIE1hdGgpKTtcbihmdW5jdGlvbihqU3RhdCwgTWF0aCkge1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBpc051bWJlciA9IGpTdGF0LnV0aWxzLmlzTnVtYmVyO1xuXG4vLyBmbGFnPT10cnVlIGRlbm90ZXMgdXNlIG9mIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb25cbi8vIFogU3RhdGlzdGljc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW1ldGVyIGxpc3RzOlxuICAvLyAodmFsdWUsIG1lYW4sIHNkKVxuICAvLyAodmFsdWUsIGFycmF5LCBmbGFnKVxuICB6c2NvcmU6IGZ1bmN0aW9uIHpzY29yZSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoaXNOdW1iZXIoYXJnc1sxXSkpIHtcbiAgICAgIHJldHVybiAoYXJnc1swXSAtIGFyZ3NbMV0pIC8gYXJnc1syXTtcbiAgICB9XG4gICAgcmV0dXJuIChhcmdzWzBdIC0galN0YXQubWVhbihhcmdzWzFdKSkgLyBqU3RhdC5zdGRldihhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfSxcblxuICAvLyAzIGRpZmZlcmVudCBwYXJhbXRlciBsaXN0czpcbiAgLy8gKHZhbHVlLCBtZWFuLCBzZCwgc2lkZXMpXG4gIC8vICh6c2NvcmUsIHNpZGVzKVxuICAvLyAodmFsdWUsIGFycmF5LCBzaWRlcywgZmxhZylcbiAgenRlc3Q6IGZ1bmN0aW9uIHp0ZXN0KCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgaWYoaXNOdW1iZXIoYXJnc1sxXSkpIHtcbiAgICAgICAgdmFyIHogPSBqU3RhdC56c2NvcmUoYXJnc1swXSxhcmdzWzFdLGFyZ3NbMl0pXG4gICAgICAgIHJldHVybiAoYXJnc1szXSA9PT0gMSkgP1xuICAgICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKSA6XG4gICAgICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLDAsMSkqIDIpO1xuICAgICAgfVxuICAgICAgdmFyIHogPSBhcmdzWzBdXG4gICAgICByZXR1cm4gKGFyZ3NbMl0gPT09IDEpID9cbiAgICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLDAsMSkpIDpcbiAgICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLDAsMSkqMik7XG4gICAgfVxuICAgIHZhciB6ID0galN0YXQuenNjb3JlKGFyZ3NbMF0sYXJnc1sxXSxhcmdzWzNdKVxuICAgIHJldHVybiAoYXJnc1sxXSA9PT0gMSkgP1xuICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLCAwLCAxKSkgOlxuICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLCAwLCAxKSoyKTtcbiAgfVxufSk7XG5cbmpTdGF0LmV4dGVuZChqU3RhdC5mbiwge1xuICB6c2NvcmU6IGZ1bmN0aW9uIHpzY29yZSh2YWx1ZSwgZmxhZykge1xuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1lYW4oKSkgLyB0aGlzLnN0ZGV2KGZsYWcpO1xuICB9LFxuXG4gIHp0ZXN0OiBmdW5jdGlvbiB6dGVzdCh2YWx1ZSwgc2lkZXMsIGZsYWcpIHtcbiAgICB2YXIgenNjb3JlID0gTWF0aC5hYnModGhpcy56c2NvcmUodmFsdWUsIGZsYWcpKTtcbiAgICByZXR1cm4gKHNpZGVzID09PSAxKSA/XG4gICAgICAoalN0YXQubm9ybWFsLmNkZigtenNjb3JlLCAwLCAxKSkgOlxuICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLXpzY29yZSwgMCwgMSkgKiAyKTtcbiAgfVxufSk7XG5cbi8vIFQgU3RhdGlzdGljc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gMiBwYXJhbWV0ZXIgbGlzdHNcbiAgLy8gKHZhbHVlLCBtZWFuLCBzZCwgbilcbiAgLy8gKHZhbHVlLCBhcnJheSlcbiAgdHNjb3JlOiBmdW5jdGlvbiB0c2NvcmUoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIChhcmdzLmxlbmd0aCA9PT0gNCkgP1xuICAgICAgKChhcmdzWzBdIC0gYXJnc1sxXSkgLyAoYXJnc1syXSAvIE1hdGguc3FydChhcmdzWzNdKSkpIDpcbiAgICAgICgoYXJnc1swXSAtIGpTdGF0Lm1lYW4oYXJnc1sxXSkpIC9cbiAgICAgICAoalN0YXQuc3RkZXYoYXJnc1sxXSwgdHJ1ZSkgLyBNYXRoLnNxcnQoYXJnc1sxXS5sZW5ndGgpKSk7XG4gIH0sXG5cbiAgLy8gMyBkaWZmZXJlbnQgcGFyYW10ZXIgbGlzdHM6XG4gIC8vICh2YWx1ZSwgbWVhbiwgc2QsIG4sIHNpZGVzKVxuICAvLyAodHNjb3JlLCBuLCBzaWRlcylcbiAgLy8gKHZhbHVlLCBhcnJheSwgc2lkZXMpXG4gIHR0ZXN0OiBmdW5jdGlvbiB0dGVzdCgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgdHNjb3JlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgdHNjb3JlID0gTWF0aC5hYnMoalN0YXQudHNjb3JlKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pKTtcbiAgICAgIHJldHVybiAoYXJnc1s0XSA9PT0gMSkgP1xuICAgICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbM10tMSkpIDpcbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzNdLTEpKjIpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoYXJnc1sxXSkpIHtcbiAgICAgIHRzY29yZSA9IE1hdGguYWJzKGFyZ3NbMF0pXG4gICAgICByZXR1cm4gKGFyZ3NbMl0gPT0gMSkgP1xuICAgICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbMV0tMSkpIDpcbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLTEpICogMik7XG4gICAgfVxuICAgIHRzY29yZSA9IE1hdGguYWJzKGpTdGF0LnRzY29yZShhcmdzWzBdLCBhcmdzWzFdKSlcbiAgICByZXR1cm4gKGFyZ3NbMl0gPT0gMSkgP1xuICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLmxlbmd0aC0xKSkgOlxuICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLmxlbmd0aC0xKSAqIDIpO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIHRzY29yZTogZnVuY3Rpb24gdHNjb3JlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWVhbigpKSAvICh0aGlzLnN0ZGV2KHRydWUpIC8gTWF0aC5zcXJ0KHRoaXMuY29scygpKSk7XG4gIH0sXG5cbiAgdHRlc3Q6IGZ1bmN0aW9uIHR0ZXN0KHZhbHVlLCBzaWRlcykge1xuICAgIHJldHVybiAoc2lkZXMgPT09IDEpID9cbiAgICAgICgxIC0galN0YXQuc3R1ZGVudHQuY2RmKE1hdGguYWJzKHRoaXMudHNjb3JlKHZhbHVlKSksIHRoaXMuY29scygpLTEpKSA6XG4gICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC1NYXRoLmFicyh0aGlzLnRzY29yZSh2YWx1ZSkpLCB0aGlzLmNvbHMoKS0xKSoyKTtcbiAgfVxufSk7XG5cbi8vIEYgU3RhdGlzdGljc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gUGFyYW10ZXIgbGlzdCBpcyBhcyBmb2xsb3dzOlxuICAvLyAoYXJyYXkxLCBhcnJheTIsIGFycmF5MywgLi4uKVxuICAvLyBvciBpdCBpcyBhbiBhcnJheSBvZiBhcnJheXNcbiAgLy8gYXJyYXkgb2YgYXJyYXlzIGNvbnZlcnNpb25cbiAgYW5vdmFmc2NvcmU6IGZ1bmN0aW9uIGFub3ZhZnNjb3JlKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGV4cFZhciwgc2FtcGxlLCBzYW1wTWVhbiwgc2FtcFNhbXBNZWFuLCB0bXBhcmdzLCB1bmV4cFZhciwgaSwgajtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRtcGFyZ3MgPSBuZXcgQXJyYXkoYXJnc1swXS5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3NbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG1wYXJnc1tpXSA9IGFyZ3NbMF1baV07XG4gICAgICB9XG4gICAgICBhcmdzID0gdG1wYXJncztcbiAgICB9XG4gICAgLy8gMiBzYW1wbGUgY2FzZVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIGpTdGF0LnZhcmlhbmNlKGFyZ3NbMF0pIC8galN0YXQudmFyaWFuY2UoYXJnc1sxXSk7XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBzYW1wbGUgYXJyYXlcbiAgICBzYW1wbGUgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgc2FtcGxlID0gc2FtcGxlLmNvbmNhdChhcmdzW2ldKTtcbiAgICB9XG4gICAgc2FtcE1lYW4gPSBqU3RhdC5tZWFuKHNhbXBsZSk7XG4gICAgLy8gQ29tcHV0ZXMgdGhlIGV4cGxhaW5lZCB2YXJpYW5jZVxuICAgIGV4cFZhciA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cFZhciA9IGV4cFZhciArIGFyZ3NbaV0ubGVuZ3RoICogTWF0aC5wb3coalN0YXQubWVhbihhcmdzW2ldKSAtIHNhbXBNZWFuLCAyKTtcbiAgICB9XG4gICAgZXhwVmFyIC89IChhcmdzLmxlbmd0aCAtIDEpO1xuICAgIC8vIENvbXB1dGVzIHVuZXhwbGFpbmVkIHZhcmlhbmNlXG4gICAgdW5leHBWYXIgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzYW1wU2FtcE1lYW4gPSBqU3RhdC5tZWFuKGFyZ3NbaV0pO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGFyZ3NbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdW5leHBWYXIgKz0gTWF0aC5wb3coYXJnc1tpXVtqXSAtIHNhbXBTYW1wTWVhbiwgMik7XG4gICAgICB9XG4gICAgfVxuICAgIHVuZXhwVmFyIC89IChzYW1wbGUubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHJldHVybiBleHBWYXIgLyB1bmV4cFZhcjtcbiAgfSxcblxuICAvLyAyIGRpZmZlcmVudCBwYXJhbXRlciBzZXR1cHNcbiAgLy8gKGFycmF5MSwgYXJyYXkyLCBhcnJheTMsIC4uLilcbiAgLy8gKGFub3ZhZnNjb3JlLCBkZjEsIGRmMilcbiAgYW5vdmFmdGVzdDogZnVuY3Rpb24gYW5vdmFmdGVzdCgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICBkZjEsIGRmMiwgbiwgaTtcbiAgICBpZiAoaXNOdW1iZXIoYXJnc1swXSkpIHtcbiAgICAgIHJldHVybiAxIC0galN0YXQuY2VudHJhbEYuY2RmKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICBhbm92YWZzY29yZSA9IGpTdGF0LmFub3ZhZnNjb3JlKGFyZ3MpO1xuICAgIGRmMSA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICBuID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgbiA9IG4gKyBhcmdzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgZGYyID0gbiAtIGRmMSAtIDE7XG4gICAgcmV0dXJuIDEgLSBqU3RhdC5jZW50cmFsRi5jZGYoYW5vdmFmc2NvcmUsIGRmMSwgZGYyKTtcbiAgfSxcblxuICBmdGVzdDogZnVuY3Rpb24gZnRlc3QoZnNjb3JlLCBkZjEsIGRmMikge1xuICAgIHJldHVybiAxIC0galN0YXQuY2VudHJhbEYuY2RmKGZzY29yZSwgZGYxLCBkZjIpO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIGFub3ZhZnNjb3JlOiBmdW5jdGlvbiBhbm92YWZzY29yZSgpIHtcbiAgICByZXR1cm4galN0YXQuYW5vdmFmc2NvcmUodGhpcy50b0FycmF5KCkpO1xuICB9LFxuXG4gIGFub3ZhZnRlczogZnVuY3Rpb24gYW5vdmFmdGVzKCkge1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgbiA9IG4gKyB0aGlzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0LmZ0ZXN0KHRoaXMuYW5vdmFmc2NvcmUoKSwgdGhpcy5sZW5ndGggLSAxLCBuIC0gdGhpcy5sZW5ndGgpO1xuICB9XG59KTtcblxuLy8gRXJyb3IgQm91bmRzXG5qU3RhdC5leHRlbmQoe1xuICAvLyAyIGRpZmZlcmVudCBwYXJhbWV0ZXIgc2V0dXBzXG4gIC8vICh2YWx1ZSwgYWxwaGEsIHNkLCBuKVxuICAvLyAodmFsdWUsIGFscGhhLCBhcnJheSlcbiAgbm9ybWFsY2k6IGZ1bmN0aW9uIG5vcm1hbGNpKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGFucyA9IG5ldyBBcnJheSgyKSxcbiAgICBjaGFuZ2U7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICBjaGFuZ2UgPSBNYXRoLmFicyhqU3RhdC5ub3JtYWwuaW52KGFyZ3NbMV0gLyAyLCAwLCAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzJdIC8gTWF0aC5zcXJ0KGFyZ3NbM10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQubm9ybWFsLmludihhcmdzWzFdIC8gMiwgMCwgMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgalN0YXQuc3RkZXYoYXJnc1syXSkgLyBNYXRoLnNxcnQoYXJnc1syXS5sZW5ndGgpKTtcbiAgICB9XG4gICAgYW5zWzBdID0gYXJnc1swXSAtIGNoYW5nZTtcbiAgICBhbnNbMV0gPSBhcmdzWzBdICsgY2hhbmdlO1xuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW1ldGVyIHNldHVwc1xuICAvLyAodmFsdWUsIGFscGhhLCBzZCwgbilcbiAgLy8gKHZhbHVlLCBhbHBoYSwgYXJyYXkpXG4gIHRjaTogZnVuY3Rpb24gdGNpKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGFucyA9IG5ldyBBcnJheSgyKSxcbiAgICBjaGFuZ2U7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICBjaGFuZ2UgPSBNYXRoLmFicyhqU3RhdC5zdHVkZW50dC5pbnYoYXJnc1sxXSAvIDIsIGFyZ3NbM10gLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzJdIC8gTWF0aC5zcXJ0KGFyZ3NbM10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQuc3R1ZGVudHQuaW52KGFyZ3NbMV0gLyAyLCBhcmdzWzJdLmxlbmd0aCAtIDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpTdGF0LnN0ZGV2KGFyZ3NbMl0sIHRydWUpIC8gTWF0aC5zcXJ0KGFyZ3NbMl0ubGVuZ3RoKSk7XG4gICAgfVxuICAgIGFuc1swXSA9IGFyZ3NbMF0gLSBjaGFuZ2U7XG4gICAgYW5zWzFdID0gYXJnc1swXSArIGNoYW5nZTtcbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIHNpZ25pZmljYW50OiBmdW5jdGlvbiBzaWduaWZpY2FudChwdmFsdWUsIGFscGhhKSB7XG4gICAgcmV0dXJuIHB2YWx1ZSA8IGFscGhhO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIG5vcm1hbGNpOiBmdW5jdGlvbiBub3JtYWxjaSh2YWx1ZSwgYWxwaGEpIHtcbiAgICByZXR1cm4galN0YXQubm9ybWFsY2kodmFsdWUsIGFscGhhLCB0aGlzLnRvQXJyYXkoKSk7XG4gIH0sXG5cbiAgdGNpOiBmdW5jdGlvbiB0Y2kodmFsdWUsIGFscGhhKSB7XG4gICAgcmV0dXJuIGpTdGF0LnRjaSh2YWx1ZSwgYWxwaGEsIHRoaXMudG9BcnJheSgpKTtcbiAgfVxufSk7XG5cbn0odGhpcy5qU3RhdCwgTWF0aCkpO1xuIiwiLyohXG4gKiBudW1lcmFsLmpzXG4gKiB2ZXJzaW9uIDogMS41LjNcbiAqIGF1dGhvciA6IEFkYW0gRHJhcGVyXG4gKiBsaWNlbnNlIDogTUlUXG4gKiBodHRwOi8vYWRhbXdkcmFwZXIuZ2l0aHViLmNvbS9OdW1lcmFsLWpzL1xuICovXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0YW50c1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBudW1lcmFsLFxuICAgICAgICBWRVJTSU9OID0gJzEuNS4zJyxcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbGFuZ3VhZ2UgY29uZmlnIGZpbGVzXG4gICAgICAgIGxhbmd1YWdlcyA9IHt9LFxuICAgICAgICBjdXJyZW50TGFuZ3VhZ2UgPSAnZW4nLFxuICAgICAgICB6ZXJvRm9ybWF0ID0gbnVsbCxcbiAgICAgICAgZGVmYXVsdEZvcm1hdCA9ICcwLDAnLFxuICAgICAgICAvLyBjaGVjayBmb3Igbm9kZUpTXG4gICAgICAgIGhhc01vZHVsZSA9ICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyk7XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RydWN0b3JzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBOdW1lcmFsIHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBOdW1lcmFsIChudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50YXRpb24gb2YgdG9GaXhlZCgpIHRoYXQgdHJlYXRzIGZsb2F0cyBtb3JlIGxpa2UgZGVjaW1hbHNcbiAgICAgKlxuICAgICAqIEZpeGVzIGJpbmFyeSByb3VuZGluZyBpc3N1ZXMgKGVnLiAoMC42MTUpLnRvRml4ZWQoMikgPT09ICcwLjYxJykgdGhhdCBwcmVzZW50XG4gICAgICogcHJvYmxlbXMgZm9yIGFjY291bnRpbmctIGFuZCBmaW5hbmNlLXJlbGF0ZWQgc29mdHdhcmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaXhlZCAodmFsdWUsIHByZWNpc2lvbiwgcm91bmRpbmdGdW5jdGlvbiwgb3B0aW9uYWxzKSB7XG4gICAgICAgIHZhciBwb3dlciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pLFxuICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwLFxuICAgICAgICAgICAgb3V0cHV0O1xuICAgICAgICAgICAgXG4gICAgICAgIC8vcm91bmRpbmdGdW5jdGlvbiA9IChyb3VuZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQgPyByb3VuZGluZ0Z1bmN0aW9uIDogTWF0aC5yb3VuZCk7XG4gICAgICAgIC8vIE11bHRpcGx5IHVwIGJ5IHByZWNpc2lvbiwgcm91bmQgYWNjdXJhdGVseSwgdGhlbiBkaXZpZGUgYW5kIHVzZSBuYXRpdmUgdG9GaXhlZCgpOlxuICAgICAgICBvdXRwdXQgPSAocm91bmRpbmdGdW5jdGlvbih2YWx1ZSAqIHBvd2VyKSAvIHBvd2VyKS50b0ZpeGVkKHByZWNpc2lvbik7XG5cbiAgICAgICAgaWYgKG9wdGlvbmFscykge1xuICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwID0gbmV3IFJlZ0V4cCgnMHsxLCcgKyBvcHRpb25hbHMgKyAnfSQnKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKG9wdGlvbmFsc1JlZ0V4cCwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEZvcm1hdHRpbmdcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBkZXRlcm1pbmUgd2hhdCB0eXBlIG9mIGZvcm1hdHRpbmcgd2UgbmVlZCB0byBkb1xuICAgIGZ1bmN0aW9uIGZvcm1hdE51bWVyYWwgKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgb3V0cHV0O1xuXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgd2hhdCBraW5kIG9mIGZvcm1hdCB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignJCcpID4gLTEpIHsgLy8gY3VycmVuY3khISEhIVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0Q3VycmVuY3kobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignJScpID4gLTEpIHsgLy8gcGVyY2VudGFnZVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0UGVyY2VudGFnZShuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCc6JykgPiAtMSkgeyAvLyB0aW1lXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXRUaW1lKG4sIGZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHBsYWluIG9sJyBudW1iZXJzIG9yIGJ5dGVzXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIobi5fdmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gc3RyaW5nXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJ0IHRvIG51bWJlclxuICAgIGZ1bmN0aW9uIHVuZm9ybWF0TnVtZXJhbCAobiwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBzdHJpbmdPcmlnaW5hbCA9IHN0cmluZyxcbiAgICAgICAgICAgIHRob3VzYW5kUmVnRXhwLFxuICAgICAgICAgICAgbWlsbGlvblJlZ0V4cCxcbiAgICAgICAgICAgIGJpbGxpb25SZWdFeHAsXG4gICAgICAgICAgICB0cmlsbGlvblJlZ0V4cCxcbiAgICAgICAgICAgIHN1ZmZpeGVzID0gWydLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddLFxuICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyID0gZmFsc2UsXG4gICAgICAgICAgICBwb3dlcjtcblxuICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJzonKSA+IC0xKSB7XG4gICAgICAgICAgICBuLl92YWx1ZSA9IHVuZm9ybWF0VGltZShzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gemVyb0Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIG4uX3ZhbHVlID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMuZGVjaW1hbCAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXC4vZywnJykucmVwbGFjZShsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwsICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIGFiYnJldmlhdGlvbnMgYXJlIHRoZXJlIHNvIHRoYXQgd2UgY2FuIG11bHRpcGx5IHRvIHRoZSBjb3JyZWN0IG51bWJlclxuICAgICAgICAgICAgICAgIHRob3VzYW5kUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudGhvdXNhbmQgKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuICAgICAgICAgICAgICAgIG1pbGxpb25SZWdFeHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy5taWxsaW9uICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcbiAgICAgICAgICAgICAgICBiaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMuYmlsbGlvbiArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG4gICAgICAgICAgICAgICAgdHJpbGxpb25SZWdFeHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy50cmlsbGlvbiArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZWUgaWYgYnl0ZXMgYXJlIHRoZXJlIHNvIHRoYXQgd2UgY2FuIG11bHRpcGx5IHRvIHRoZSBjb3JyZWN0IG51bWJlclxuICAgICAgICAgICAgICAgIGZvciAocG93ZXIgPSAwOyBwb3dlciA8PSBzdWZmaXhlcy5sZW5ndGg7IHBvd2VyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyID0gKHN0cmluZy5pbmRleE9mKHN1ZmZpeGVzW3Bvd2VyXSkgPiAtMSkgPyBNYXRoLnBvdygxMDI0LCBwb3dlciArIDEpIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzTXVsdGlwbGllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkbyBzb21lIG1hdGggdG8gY3JlYXRlIG91ciBudW1iZXJcbiAgICAgICAgICAgICAgICBuLl92YWx1ZSA9ICgoYnl0ZXNNdWx0aXBsaWVyKSA/IGJ5dGVzTXVsdGlwbGllciA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaCh0aG91c2FuZFJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDMpIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKG1pbGxpb25SZWdFeHApKSA/IE1hdGgucG93KDEwLCA2KSA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaChiaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgOSkgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2godHJpbGxpb25SZWdFeHApKSA/IE1hdGgucG93KDEwLCAxMikgOiAxKSAqICgoc3RyaW5nLmluZGV4T2YoJyUnKSA+IC0xKSA/IDAuMDEgOiAxKSAqICgoKHN0cmluZy5zcGxpdCgnLScpLmxlbmd0aCArIE1hdGgubWluKHN0cmluZy5zcGxpdCgnKCcpLmxlbmd0aC0xLCBzdHJpbmcuc3BsaXQoJyknKS5sZW5ndGgtMSkpICUgMik/IDE6IC0xKSAqIE51bWJlcihzdHJpbmcucmVwbGFjZSgvW14wLTlcXC5dKy9nLCAnJykpO1xuXG4gICAgICAgICAgICAgICAgLy8gcm91bmQgaWYgd2UgYXJlIHRhbGtpbmcgYWJvdXQgYnl0ZXNcbiAgICAgICAgICAgICAgICBuLl92YWx1ZSA9IChieXRlc011bHRpcGxpZXIpID8gTWF0aC5jZWlsKG4uX3ZhbHVlKSA6IG4uX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuLl92YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRDdXJyZW5jeSAobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBzeW1ib2xJbmRleCA9IGZvcm1hdC5pbmRleE9mKCckJyksXG4gICAgICAgICAgICBvcGVuUGFyZW5JbmRleCA9IGZvcm1hdC5pbmRleE9mKCcoJyksXG4gICAgICAgICAgICBtaW51c1NpZ25JbmRleCA9IGZvcm1hdC5pbmRleE9mKCctJyksXG4gICAgICAgICAgICBzcGFjZSA9ICcnLFxuICAgICAgICAgICAgc3BsaWNlSW5kZXgsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBvciBhZnRlciBjdXJyZW5jeVxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyAkJykgPiAtMSkge1xuICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnICQnLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJyQgJykgPiAtMSkge1xuICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJCAnLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJCcsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvcm1hdCB0aGUgbnVtYmVyXG4gICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcihuLl92YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAvLyBwb3NpdGlvbiB0aGUgc3ltYm9sXG4gICAgICAgIGlmIChzeW1ib2xJbmRleCA8PSAxKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJygnKSA+IC0xIHx8IG91dHB1dC5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSAxO1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2xJbmRleCA8IG9wZW5QYXJlbkluZGV4IHx8IHN5bWJvbEluZGV4IDwgbWludXNTaWduSW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3ltYm9sIGFwcGVhcnMgYmVmb3JlIHRoZSBcIihcIiBvciBcIi1cIlxuICAgICAgICAgICAgICAgICAgICBzcGxpY2VJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2Uoc3BsaWNlSW5kZXgsIDAsIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArIHNwYWNlICsgb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcpJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZSgtMSwgMCwgc3BhY2UgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgc3BhY2UgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFBlcmNlbnRhZ2UgKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgc3BhY2UgPSAnJyxcbiAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgIHZhbHVlID0gbi5fdmFsdWUgKiAxMDA7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSAlXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignICUnKSA+IC0xKSB7XG4gICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgJScsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCclJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICBcbiAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcpJykgPiAtMSApIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICBvdXRwdXQuc3BsaWNlKC0xLCAwLCBzcGFjZSArICclJyk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArICclJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VGltZSAobikge1xuICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKG4uX3ZhbHVlLzYwLzYwKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmZsb29yKChuLl92YWx1ZSAtIChob3VycyAqIDYwICogNjApKS82MCksXG4gICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5yb3VuZChuLl92YWx1ZSAtIChob3VycyAqIDYwICogNjApIC0gKG1pbnV0ZXMgKiA2MCkpO1xuICAgICAgICByZXR1cm4gaG91cnMgKyAnOicgKyAoKG1pbnV0ZXMgPCAxMCkgPyAnMCcgKyBtaW51dGVzIDogbWludXRlcykgKyAnOicgKyAoKHNlY29uZHMgPCAxMCkgPyAnMCcgKyBzZWNvbmRzIDogc2Vjb25kcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5mb3JtYXRUaW1lIChzdHJpbmcpIHtcbiAgICAgICAgdmFyIHRpbWVBcnJheSA9IHN0cmluZy5zcGxpdCgnOicpLFxuICAgICAgICAgICAgc2Vjb25kcyA9IDA7XG4gICAgICAgIC8vIHR1cm4gaG91cnMgYW5kIG1pbnV0ZXMgaW50byBzZWNvbmRzIGFuZCBhZGQgdGhlbSBhbGwgdXBcbiAgICAgICAgaWYgKHRpbWVBcnJheS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIC8vIGhvdXJzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwICogNjApO1xuICAgICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyAoTnVtYmVyKHRpbWVBcnJheVsxXSkgKiA2MCk7XG4gICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIE51bWJlcih0aW1lQXJyYXlbMl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVBcnJheS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMF0pICogNjApO1xuICAgICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyKHNlY29uZHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdE51bWJlciAodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgbmVnUCA9IGZhbHNlLFxuICAgICAgICAgICAgc2lnbmVkID0gZmFsc2UsXG4gICAgICAgICAgICBvcHREZWMgPSBmYWxzZSxcbiAgICAgICAgICAgIGFiYnIgPSAnJyxcbiAgICAgICAgICAgIGFiYnJLID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byB0aG91c2FuZHNcbiAgICAgICAgICAgIGFiYnJNID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byBtaWxsaW9uc1xuICAgICAgICAgICAgYWJickIgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIGJpbGxpb25zXG4gICAgICAgICAgICBhYmJyVCA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gdHJpbGxpb25zXG4gICAgICAgICAgICBhYmJyRm9yY2UgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICBieXRlcyA9ICcnLFxuICAgICAgICAgICAgb3JkID0gJycsXG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyh2YWx1ZSksXG4gICAgICAgICAgICBzdWZmaXhlcyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddLFxuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICB3LFxuICAgICAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICAgICAgdGhvdXNhbmRzLFxuICAgICAgICAgICAgZCA9ICcnLFxuICAgICAgICAgICAgbmVnID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgbnVtYmVyIGlzIHplcm8gYW5kIGEgY3VzdG9tIHplcm8gZm9ybWF0IGhhcyBiZWVuIHNldFxuICAgICAgICBpZiAodmFsdWUgPT09IDAgJiYgemVyb0Zvcm1hdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9Gb3JtYXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzZWUgaWYgd2Ugc2hvdWxkIHVzZSBwYXJlbnRoZXNlcyBmb3IgbmVnYXRpdmUgbnVtYmVyIG9yIGlmIHdlIHNob3VsZCBwcmVmaXggd2l0aCBhIHNpZ25cbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXJlIHByZXNlbnQgd2UgZGVmYXVsdCB0byBwYXJlbnRoZXNlc1xuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcoJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG5lZ1AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCcrJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1xcKy9nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb24gaXMgd2FudGVkXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ2EnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgYWJicmV2aWF0aW9uIGlzIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIGFiYnJLID0gZm9ybWF0LmluZGV4T2YoJ2FLJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyTSA9IGZvcm1hdC5pbmRleE9mKCdhTScpID49IDA7XG4gICAgICAgICAgICAgICAgYWJickIgPSBmb3JtYXQuaW5kZXhPZignYUInKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJUID0gZm9ybWF0LmluZGV4T2YoJ2FUJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyRm9yY2UgPSBhYmJySyB8fCBhYmJyTSB8fCBhYmJyQiB8fCBhYmJyVDtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgYScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBhJywgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdhJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhYnMgPj0gTWF0aC5wb3coMTAsIDEyKSAmJiAhYWJickZvcmNlIHx8IGFiYnJUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy50cmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCAxMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgMTIpICYmIGFicyA+PSBNYXRoLnBvdygxMCwgOSkgJiYgIWFiYnJGb3JjZSB8fCBhYmJyQikge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy5iaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgTWF0aC5wb3coMTAsIDkpICYmIGFicyA+PSBNYXRoLnBvdygxMCwgNikgJiYgIWFiYnJGb3JjZSB8fCBhYmJyTSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy5taWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgTWF0aC5wb3coMTAsIDYpICYmIGFicyA+PSBNYXRoLnBvdygxMCwgMykgJiYgIWFiYnJGb3JjZSB8fCBhYmJySykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aG91c2FuZFxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudGhvdXNhbmQ7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWUgaWYgd2UgYXJlIGZvcm1hdHRpbmcgYnl0ZXNcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignYicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgYicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgYicsICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnYicsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgucG93KDEwMjQsIHBvd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5wb3coMTAyNCwgcG93ZXIrMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcyArIHN1ZmZpeGVzW3Bvd2VyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWUgaWYgb3JkaW5hbCBpcyB3YW50ZWRcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignbycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgbycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIG8nLCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ28nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3JkID0gb3JkICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0ub3JkaW5hbCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignWy5dJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG9wdERlYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ1suXScsICcuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHcgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJylbMF07XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBmb3JtYXQuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgICAgIHRob3VzYW5kcyA9IGZvcm1hdC5pbmRleE9mKCcsJyk7XG5cbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uLmluZGV4T2YoJ1snKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbi5yZXBsYWNlKCddJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24uc3BsaXQoJ1snKTtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHRvRml4ZWQodmFsdWUsIChwcmVjaXNpb25bMF0ubGVuZ3RoICsgcHJlY2lzaW9uWzFdLmxlbmd0aCksIHJvdW5kaW5nRnVuY3Rpb24sIHByZWNpc2lvblsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB0b0ZpeGVkKHZhbHVlLCBwcmVjaXNpb24ubGVuZ3RoLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3ID0gZC5zcGxpdCgnLicpWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGQuc3BsaXQoJy4nKVsxXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMuZGVjaW1hbCArIGQuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdERlYyAmJiBOdW1iZXIoZC5zbGljZSgxKSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IHRvRml4ZWQodmFsdWUsIG51bGwsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmb3JtYXQgbnVtYmVyXG4gICAgICAgICAgICBpZiAody5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHcgPSB3LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIG5lZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aG91c2FuZHMgPiAtMSkge1xuICAgICAgICAgICAgICAgIHcgPSB3LnRvU3RyaW5nKCkucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnJDEnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy50aG91c2FuZHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHcgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICgobmVnUCAmJiBuZWcpID8gJygnIDogJycpICsgKCghbmVnUCAmJiBuZWcpID8gJy0nIDogJycpICsgKCghbmVnICYmIHNpZ25lZCkgPyAnKycgOiAnJykgKyB3ICsgZCArICgob3JkKSA/IG9yZCA6ICcnKSArICgoYWJicikgPyBhYmJyIDogJycpICsgKChieXRlcykgPyBieXRlcyA6ICcnKSArICgobmVnUCAmJiBuZWcpID8gJyknIDogJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBUb3AgTGV2ZWwgRnVuY3Rpb25zXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgbnVtZXJhbCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAobnVtZXJhbC5pc051bWVyYWwoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IDAgfHwgdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaW5wdXQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKCFOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IG51bWVyYWwuZm4udW5mb3JtYXQoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmFsKE51bWJlcihpbnB1dCkpO1xuICAgIH07XG5cbiAgICAvLyB2ZXJzaW9uIG51bWJlclxuICAgIG51bWVyYWwudmVyc2lvbiA9IFZFUlNJT047XG5cbiAgICAvLyBjb21wYXJlIG51bWVyYWwgb2JqZWN0XG4gICAgbnVtZXJhbC5pc051bWVyYWwgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW1lcmFsO1xuICAgIH07XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsYW5ndWFnZXMgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbGFuZ3VhZ2UuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbGFuZ3VhZ2Uga2V5LlxuICAgIG51bWVyYWwubGFuZ3VhZ2UgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50TGFuZ3VhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ICYmICF2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZSA6ICcgKyBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudExhbmd1YWdlID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcyB8fCAhbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgIGxvYWRMYW5ndWFnZShrZXksIHZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtZXJhbDtcbiAgICB9O1xuICAgIFxuICAgIC8vIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBsb2FkZWQgbGFuZ3VhZ2UgZGF0YS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudFxuICAgIC8vIGdsb2JhbCBsYW5ndWFnZSBvYmplY3QuXG4gICAgbnVtZXJhbC5sYW5ndWFnZURhdGEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZSA6ICcgKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2tleV07XG4gICAgfTtcblxuICAgIG51bWVyYWwubGFuZ3VhZ2UoJ2VuJywge1xuICAgICAgICBkZWxpbWl0ZXJzOiB7XG4gICAgICAgICAgICB0aG91c2FuZHM6ICcsJyxcbiAgICAgICAgICAgIGRlY2ltYWw6ICcuJ1xuICAgICAgICB9LFxuICAgICAgICBhYmJyZXZpYXRpb25zOiB7XG4gICAgICAgICAgICB0aG91c2FuZDogJ2snLFxuICAgICAgICAgICAgbWlsbGlvbjogJ20nLFxuICAgICAgICAgICAgYmlsbGlvbjogJ2InLFxuICAgICAgICAgICAgdHJpbGxpb246ICd0J1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwO1xuICAgICAgICAgICAgcmV0dXJuICh+fiAobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgc3ltYm9sOiAnJCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbnVtZXJhbC56ZXJvRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICB6ZXJvRm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogbnVsbDtcbiAgICB9O1xuXG4gICAgbnVtZXJhbC5kZWZhdWx0Rm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBkZWZhdWx0Rm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogJzAuMCc7XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgSGVscGVyc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIGxvYWRMYW5ndWFnZShrZXksIHZhbHVlcykge1xuICAgICAgICBsYW5ndWFnZXNba2V5XSA9IHZhbHVlcztcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEZsb2F0aW5nLXBvaW50IGhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBUaGUgZmxvYXRpbmctcG9pbnQgaGVscGVyIGZ1bmN0aW9ucyBhbmQgaW1wbGVtZW50YXRpb25cbiAgICAvLyBib3Jyb3dzIGhlYXZpbHkgZnJvbSBzaW5mdWwuanM6IGh0dHA6Ly9ndWlwbi5naXRodWIuaW8vc2luZnVsLmpzL1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkucHJvdG90eXBlLnJlZHVjZSBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0XG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvUmVkdWNlI0NvbXBhdGliaWxpdHlcbiAgICAgKi9cbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2luaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gdGhpcyB8fCAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGUgbW9tZW50IGFsbCBtb2Rlcm4gYnJvd3NlcnMsIHRoYXQgc3VwcG9ydCBzdHJpY3QgbW9kZSwgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBBcnJheS5wcm90b3R5cGUucmVkdWNlLiBGb3IgaW5zdGFuY2UsIElFOFxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IHN1cHBvcnQgc3RyaWN0IG1vZGUsIHNvIHRoaXMgY2hlY2sgaXMgYWN0dWFsbHkgdXNlbGVzcy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUucmVkdWNlIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgICAgIGlzVmFsdWVTZXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvcHRfaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgbGVuZ3RoID4gaW5kZXg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUsIHRoaXNbaW5kZXhdLCBpbmRleCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZVNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNWYWx1ZVNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIFxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtdWx0aXBsaWVyIG5lY2Vzc2FyeSB0byBtYWtlIHggPj0gMSxcbiAgICAgKiBlZmZlY3RpdmVseSBlbGltaW5hdGluZyBtaXNjYWxjdWxhdGlvbnMgY2F1c2VkIGJ5XG4gICAgICogZmluaXRlIHByZWNpc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtdWx0aXBsaWVyKHgpIHtcbiAgICAgICAgdmFyIHBhcnRzID0geC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsIHBhcnRzWzFdLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZXR1cm5zIHRoZSBtYXhpbXVtXG4gICAgICogbXVsdGlwbGllciB0aGF0IG11c3QgYmUgdXNlZCB0byBub3JtYWxpemUgYW4gb3BlcmF0aW9uIGludm9sdmluZ1xuICAgICAqIGFsbCBvZiB0aGVtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3Rpb25GYWN0b3IoKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgICAgICAgICB2YXIgbXAgPSBtdWx0aXBsaWVyKHByZXYpLFxuICAgICAgICAgICAgICAgIG1uID0gbXVsdGlwbGllcihuZXh0KTtcbiAgICAgICAgcmV0dXJuIG1wID4gbW4gPyBtcCA6IG1uO1xuICAgICAgICB9LCAtSW5maW5pdHkpO1xuICAgIH0gICAgICAgIFxuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIE51bWVyYWwgUHJvdG90eXBlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBudW1lcmFsLmZuID0gTnVtZXJhbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY2xvbmUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtZXJhbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXQgOiBmdW5jdGlvbiAoaW5wdXRTdHJpbmcsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1lcmFsKHRoaXMsIFxuICAgICAgICAgICAgICAgICAgaW5wdXRTdHJpbmcgPyBpbnB1dFN0cmluZyA6IGRlZmF1bHRGb3JtYXQsIFxuICAgICAgICAgICAgICAgICAgKHJvdW5kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkgPyByb3VuZGluZ0Z1bmN0aW9uIDogTWF0aC5yb3VuZFxuICAgICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuZm9ybWF0IDogZnVuY3Rpb24gKGlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0U3RyaW5nKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0U3RyaW5nOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmZvcm1hdE51bWVyYWwodGhpcywgaW5wdXRTdHJpbmcgPyBpbnB1dFN0cmluZyA6IGRlZmF1bHRGb3JtYXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3Rvci5jYWxsKG51bGwsIHRoaXMuX3ZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyBjb3JyRmFjdG9yICogY3VycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3RoaXMuX3ZhbHVlLCB2YWx1ZV0ucmVkdWNlKGNiYWNrLCAwKSAvIGNvcnJGYWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzdWJ0cmFjdCA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBjb3JyZWN0aW9uRmFjdG9yLmNhbGwobnVsbCwgdGhpcy5fdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSAtIGNvcnJGYWN0b3IgKiBjdXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbdmFsdWVdLnJlZHVjZShjYmFjaywgdGhpcy5fdmFsdWUgKiBjb3JyRmFjdG9yKSAvIGNvcnJGYWN0b3I7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBtdWx0aXBseSA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBjb3JyZWN0aW9uRmFjdG9yKGFjY3VtLCBjdXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjY3VtICogY29yckZhY3RvcikgKiAoY3VyciAqIGNvcnJGYWN0b3IpIC9cbiAgICAgICAgICAgICAgICAgICAgKGNvcnJGYWN0b3IgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3RoaXMuX3ZhbHVlLCB2YWx1ZV0ucmVkdWNlKGNiYWNrLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpdmlkZSA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBjb3JyZWN0aW9uRmFjdG9yKGFjY3VtLCBjdXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjY3VtICogY29yckZhY3RvcikgLyAoY3VyciAqIGNvcnJGYWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbdGhpcy5fdmFsdWUsIHZhbHVlXS5yZWR1Y2UoY2JhY2spOyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlmZmVyZW5jZSA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG51bWVyYWwodGhpcy5fdmFsdWUpLnN1YnRyYWN0KHZhbHVlKS52YWx1ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRXhwb3NpbmcgTnVtZXJhbFxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8vIENvbW1vbkpTIG1vZHVsZSBpcyBkZWZpbmVkXG4gICAgaWYgKGhhc01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG51bWVyYWw7XG4gICAgfVxuXG4gICAgLypnbG9iYWwgZW5kZXI6ZmFsc2UgKi9cbiAgICBpZiAodHlwZW9mIGVuZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBoZXJlLCBgdGhpc2AgbWVhbnMgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBnbG9iYWxgIG9uIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gYWRkIGBudW1lcmFsYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gICAgICAgIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyICdhZHZhbmNlZCcgbW9kZVxuICAgICAgICB0aGlzWydudW1lcmFsJ10gPSBudW1lcmFsO1xuICAgIH1cblxuICAgIC8qZ2xvYmFsIGRlZmluZTpmYWxzZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtZXJhbDtcbiAgICAgICAgfSk7XG4gICAgfVxufSkuY2FsbCh0aGlzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbnVtZXJpYyA9ICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIik/KGZ1bmN0aW9uIG51bWVyaWMoKSB7fSk6KGV4cG9ydHMpO1xuaWYodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikgeyBnbG9iYWwubnVtZXJpYyA9IG51bWVyaWM7IH1cblxubnVtZXJpYy52ZXJzaW9uID0gXCIxLjIuNlwiO1xuXG4vLyAxLiBVdGlsaXR5IGZ1bmN0aW9uc1xubnVtZXJpYy5iZW5jaCA9IGZ1bmN0aW9uIGJlbmNoIChmLGludGVydmFsKSB7XG4gICAgdmFyIHQxLHQyLG4saTtcbiAgICBpZih0eXBlb2YgaW50ZXJ2YWwgPT09IFwidW5kZWZpbmVkXCIpIHsgaW50ZXJ2YWwgPSAxNTsgfVxuICAgIG4gPSAwLjU7XG4gICAgdDEgPSBuZXcgRGF0ZSgpO1xuICAgIHdoaWxlKDEpIHtcbiAgICAgICAgbio9MjtcbiAgICAgICAgZm9yKGk9bjtpPjM7aS09NCkgeyBmKCk7IGYoKTsgZigpOyBmKCk7IH1cbiAgICAgICAgd2hpbGUoaT4wKSB7IGYoKTsgaS0tOyB9XG4gICAgICAgIHQyID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYodDItdDEgPiBpbnRlcnZhbCkgYnJlYWs7XG4gICAgfVxuICAgIGZvcihpPW47aT4zO2ktPTQpIHsgZigpOyBmKCk7IGYoKTsgZigpOyB9XG4gICAgd2hpbGUoaT4wKSB7IGYoKTsgaS0tOyB9XG4gICAgdDIgPSBuZXcgRGF0ZSgpO1xuICAgIHJldHVybiAxMDAwKigzKm4tMSkvKHQyLXQxKTtcbn1cblxubnVtZXJpYy5fbXlJbmRleE9mID0gKGZ1bmN0aW9uIF9teUluZGV4T2Yodykge1xuICAgIHZhciBuID0gdGhpcy5sZW5ndGgsaztcbiAgICBmb3Ioaz0wO2s8bjsrK2spIGlmKHRoaXNba109PT13KSByZXR1cm4gaztcbiAgICByZXR1cm4gLTE7XG59KTtcbm51bWVyaWMubXlJbmRleE9mID0gKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKT9BcnJheS5wcm90b3R5cGUuaW5kZXhPZjpudW1lcmljLl9teUluZGV4T2Y7XG5cbm51bWVyaWMuRnVuY3Rpb24gPSBGdW5jdGlvbjtcbm51bWVyaWMucHJlY2lzaW9uID0gNDtcbm51bWVyaWMubGFyZ2VBcnJheSA9IDUwO1xuXG5udW1lcmljLnByZXR0eVByaW50ID0gZnVuY3Rpb24gcHJldHR5UHJpbnQoeCkge1xuICAgIGZ1bmN0aW9uIGZtdG51bSh4KSB7XG4gICAgICAgIGlmKHggPT09IDApIHsgcmV0dXJuICcwJzsgfVxuICAgICAgICBpZihpc05hTih4KSkgeyByZXR1cm4gJ05hTic7IH1cbiAgICAgICAgaWYoeDwwKSB7IHJldHVybiAnLScrZm10bnVtKC14KTsgfVxuICAgICAgICBpZihpc0Zpbml0ZSh4KSkge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh4KSAvIE1hdGgubG9nKDEwKSk7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IHggLyBNYXRoLnBvdygxMCxzY2FsZSk7XG4gICAgICAgICAgICB2YXIgYmFzaWMgPSBub3JtYWxpemVkLnRvUHJlY2lzaW9uKG51bWVyaWMucHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGlmKHBhcnNlRmxvYXQoYmFzaWMpID09PSAxMCkgeyBzY2FsZSsrOyBub3JtYWxpemVkID0gMTsgYmFzaWMgPSBub3JtYWxpemVkLnRvUHJlY2lzaW9uKG51bWVyaWMucHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYmFzaWMpLnRvU3RyaW5nKCkrJ2UnK3NjYWxlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdJbmZpbml0eSc7XG4gICAgfVxuICAgIHZhciByZXQgPSBbXTtcbiAgICBmdW5jdGlvbiBmb28oeCkge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgaWYodHlwZW9mIHggPT09IFwidW5kZWZpbmVkXCIpIHsgcmV0LnB1c2goQXJyYXkobnVtZXJpYy5wcmVjaXNpb24rOCkuam9pbignICcpKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGlmKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSB7IHJldC5wdXNoKCdcIicreCsnXCInKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGlmKHR5cGVvZiB4ID09PSBcImJvb2xlYW5cIikgeyByZXQucHVzaCh4LnRvU3RyaW5nKCkpOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgaWYodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhciBhID0gZm10bnVtKHgpO1xuICAgICAgICAgICAgdmFyIGIgPSB4LnRvUHJlY2lzaW9uKG51bWVyaWMucHJlY2lzaW9uKTtcbiAgICAgICAgICAgIHZhciBjID0gcGFyc2VGbG9hdCh4LnRvU3RyaW5nKCkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgZCA9IFthLGIsYyxwYXJzZUZsb2F0KGIpLnRvU3RyaW5nKCkscGFyc2VGbG9hdChjKS50b1N0cmluZygpXTtcbiAgICAgICAgICAgIGZvcihrPTE7azxkLmxlbmd0aDtrKyspIHsgaWYoZFtrXS5sZW5ndGggPCBhLmxlbmd0aCkgYSA9IGRba107IH1cbiAgICAgICAgICAgIHJldC5wdXNoKEFycmF5KG51bWVyaWMucHJlY2lzaW9uKzgtYS5sZW5ndGgpLmpvaW4oJyAnKSthKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZih4ID09PSBudWxsKSB7IHJldC5wdXNoKFwibnVsbFwiKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGlmKHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIpIHsgXG4gICAgICAgICAgICByZXQucHVzaCh4LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcihrIGluIHgpIHsgaWYoeC5oYXNPd25Qcm9wZXJ0eShrKSkgeyBcbiAgICAgICAgICAgICAgICBpZihmbGFnKSByZXQucHVzaCgnLFxcbicpO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0LnB1c2goJ1xcbnsnKTtcbiAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTsgXG4gICAgICAgICAgICAgICAgcmV0LnB1c2goayk7IFxuICAgICAgICAgICAgICAgIHJldC5wdXNoKCc6IFxcbicpOyBcbiAgICAgICAgICAgICAgICBmb28oeFtrXSk7IFxuICAgICAgICAgICAgfSB9XG4gICAgICAgICAgICBpZihmbGFnKSByZXQucHVzaCgnfVxcbicpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZih4Lmxlbmd0aCA+IG51bWVyaWMubGFyZ2VBcnJheSkgeyByZXQucHVzaCgnLi4uTGFyZ2UgQXJyYXkuLi4nKTsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICByZXQucHVzaCgnWycpO1xuICAgICAgICAgICAgZm9yKGs9MDtrPHgubGVuZ3RoO2srKykgeyBpZihrPjApIHsgcmV0LnB1c2goJywnKTsgaWYoZmxhZykgcmV0LnB1c2goJ1xcbiAnKTsgfSBmbGFnID0gZm9vKHhba10pOyB9XG4gICAgICAgICAgICByZXQucHVzaCgnXScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0LnB1c2goJ3snKTtcbiAgICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgZm9yKGsgaW4geCkgeyBpZih4Lmhhc093blByb3BlcnR5KGspKSB7IGlmKGZsYWcpIHJldC5wdXNoKCcsXFxuJyk7IGZsYWcgPSB0cnVlOyByZXQucHVzaChrKTsgcmV0LnB1c2goJzogXFxuJyk7IGZvbyh4W2tdKTsgfSB9XG4gICAgICAgIHJldC5wdXNoKCd9Jyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb28oeCk7XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbn1cblxubnVtZXJpYy5wYXJzZURhdGUgPSBmdW5jdGlvbiBwYXJzZURhdGUoZCkge1xuICAgIGZ1bmN0aW9uIGZvbyhkKSB7XG4gICAgICAgIGlmKHR5cGVvZiBkID09PSAnc3RyaW5nJykgeyByZXR1cm4gRGF0ZS5wYXJzZShkLnJlcGxhY2UoLy0vZywnLycpKTsgfVxuICAgICAgICBpZighKGQgaW5zdGFuY2VvZiBBcnJheSkpIHsgdGhyb3cgbmV3IEVycm9yKFwicGFyc2VEYXRlOiBwYXJhbWV0ZXIgbXVzdCBiZSBhcnJheXMgb2Ygc3RyaW5nc1wiKTsgfVxuICAgICAgICB2YXIgcmV0ID0gW10saztcbiAgICAgICAgZm9yKGs9MDtrPGQubGVuZ3RoO2srKykgeyByZXRba10gPSBmb28oZFtrXSk7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIGZvbyhkKTtcbn1cblxubnVtZXJpYy5wYXJzZUZsb2F0ID0gZnVuY3Rpb24gcGFyc2VGbG9hdF8oZCkge1xuICAgIGZ1bmN0aW9uIGZvbyhkKSB7XG4gICAgICAgIGlmKHR5cGVvZiBkID09PSAnc3RyaW5nJykgeyByZXR1cm4gcGFyc2VGbG9hdChkKTsgfVxuICAgICAgICBpZighKGQgaW5zdGFuY2VvZiBBcnJheSkpIHsgdGhyb3cgbmV3IEVycm9yKFwicGFyc2VGbG9hdDogcGFyYW1ldGVyIG11c3QgYmUgYXJyYXlzIG9mIHN0cmluZ3NcIik7IH1cbiAgICAgICAgdmFyIHJldCA9IFtdLGs7XG4gICAgICAgIGZvcihrPTA7azxkLmxlbmd0aDtrKyspIHsgcmV0W2tdID0gZm9vKGRba10pOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBmb28oZCk7XG59XG5cbm51bWVyaWMucGFyc2VDU1YgPSBmdW5jdGlvbiBwYXJzZUNTVih0KSB7XG4gICAgdmFyIGZvbyA9IHQuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBqLGs7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciBwYXQgPSAvKChbXidcIixdKil8KCdbXiddKicpfChcIlteXCJdKlwiKSksL2c7XG4gICAgdmFyIHBhdG51bSA9IC9eXFxzKigoWystXT9bMC05XSsoXFwuWzAtOV0qKT8oZVsrLV0/WzAtOV0rKT8pfChbKy1dP1swLTldKihcXC5bMC05XSspPyhlWystXT9bMC05XSspPykpXFxzKiQvO1xuICAgIHZhciBzdHJpcHBlciA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uc3Vic3RyKDAsbi5sZW5ndGgtMSk7IH1cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGZvcihrPTA7azxmb28ubGVuZ3RoO2srKykge1xuICAgICAgdmFyIGJhciA9IChmb29ba10rXCIsXCIpLm1hdGNoKHBhdCksYmF6O1xuICAgICAgaWYoYmFyLmxlbmd0aD4wKSB7XG4gICAgICAgICAgcmV0W2NvdW50XSA9IFtdO1xuICAgICAgICAgIGZvcihqPTA7ajxiYXIubGVuZ3RoO2orKykge1xuICAgICAgICAgICAgICBiYXogPSBzdHJpcHBlcihiYXJbal0pO1xuICAgICAgICAgICAgICBpZihwYXRudW0udGVzdChiYXopKSB7IHJldFtjb3VudF1bal0gPSBwYXJzZUZsb2F0KGJheik7IH1cbiAgICAgICAgICAgICAgZWxzZSByZXRbY291bnRdW2pdID0gYmF6O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnRvQ1NWID0gZnVuY3Rpb24gdG9DU1YoQSkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oQSk7XG4gICAgdmFyIGksaixtLG4scm93LHJldDtcbiAgICBtID0gc1swXTtcbiAgICBuID0gc1sxXTtcbiAgICByZXQgPSBbXTtcbiAgICBmb3IoaT0wO2k8bTtpKyspIHtcbiAgICAgICAgcm93ID0gW107XG4gICAgICAgIGZvcihqPTA7ajxtO2orKykgeyByb3dbal0gPSBBW2ldW2pdLnRvU3RyaW5nKCk7IH1cbiAgICAgICAgcmV0W2ldID0gcm93LmpvaW4oJywgJyk7XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignXFxuJykrJ1xcbic7XG59XG5cbm51bWVyaWMuZ2V0VVJMID0gZnVuY3Rpb24gZ2V0VVJMKHVybCkge1xuICAgIHZhciBjbGllbnQgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjbGllbnQub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7XG4gICAgY2xpZW50LnNlbmQoKTtcbiAgICByZXR1cm4gY2xpZW50O1xufVxuXG5udW1lcmljLmltYWdlVVJMID0gZnVuY3Rpb24gaW1hZ2VVUkwoaW1nKSB7XG4gICAgZnVuY3Rpb24gYmFzZTY0KEEpIHtcbiAgICAgICAgdmFyIG4gPSBBLmxlbmd0aCwgaSx4LHkseixwLHEscixzO1xuICAgICAgICB2YXIga2V5ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgICAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICAgICAgZm9yKGk9MDtpPG47aSs9Mykge1xuICAgICAgICAgICAgeCA9IEFbaV07XG4gICAgICAgICAgICB5ID0gQVtpKzFdO1xuICAgICAgICAgICAgeiA9IEFbaSsyXTtcbiAgICAgICAgICAgIHAgPSB4ID4+IDI7XG4gICAgICAgICAgICBxID0gKCh4ICYgMykgPDwgNCkgKyAoeSA+PiA0KTtcbiAgICAgICAgICAgIHIgPSAoKHkgJiAxNSkgPDwgMikgKyAoeiA+PiA2KTtcbiAgICAgICAgICAgIHMgPSB6ICYgNjM7XG4gICAgICAgICAgICBpZihpKzE+PW4pIHsgciA9IHMgPSA2NDsgfVxuICAgICAgICAgICAgZWxzZSBpZihpKzI+PW4pIHsgcyA9IDY0OyB9XG4gICAgICAgICAgICByZXQgKz0ga2V5LmNoYXJBdChwKSArIGtleS5jaGFyQXQocSkgKyBrZXkuY2hhckF0KHIpICsga2V5LmNoYXJBdChzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JjMzJBcnJheSAoYSxmcm9tLHRvKSB7XG4gICAgICAgIGlmKHR5cGVvZiBmcm9tID09PSBcInVuZGVmaW5lZFwiKSB7IGZyb20gPSAwOyB9XG4gICAgICAgIGlmKHR5cGVvZiB0byA9PT0gXCJ1bmRlZmluZWRcIikgeyB0byA9IGEubGVuZ3RoOyB9XG4gICAgICAgIHZhciB0YWJsZSA9IFsweDAwMDAwMDAwLCAweDc3MDczMDk2LCAweEVFMEU2MTJDLCAweDk5MDk1MUJBLCAweDA3NkRDNDE5LCAweDcwNkFGNDhGLCAweEU5NjNBNTM1LCAweDlFNjQ5NUEzLFxuICAgICAgICAgICAgICAgICAgICAgMHgwRURCODgzMiwgMHg3OURDQjhBNCwgMHhFMEQ1RTkxRSwgMHg5N0QyRDk4OCwgMHgwOUI2NEMyQiwgMHg3RUIxN0NCRCwgMHhFN0I4MkQwNywgMHg5MEJGMUQ5MSwgXG4gICAgICAgICAgICAgICAgICAgICAweDFEQjcxMDY0LCAweDZBQjAyMEYyLCAweEYzQjk3MTQ4LCAweDg0QkU0MURFLCAweDFBREFENDdELCAweDZERERFNEVCLCAweEY0RDRCNTUxLCAweDgzRDM4NUM3LFxuICAgICAgICAgICAgICAgICAgICAgMHgxMzZDOTg1NiwgMHg2NDZCQThDMCwgMHhGRDYyRjk3QSwgMHg4QTY1QzlFQywgMHgxNDAxNUM0RiwgMHg2MzA2NkNEOSwgMHhGQTBGM0Q2MywgMHg4RDA4MERGNSwgXG4gICAgICAgICAgICAgICAgICAgICAweDNCNkUyMEM4LCAweDRDNjkxMDVFLCAweEQ1NjA0MUU0LCAweEEyNjc3MTcyLCAweDNDMDNFNEQxLCAweDRCMDRENDQ3LCAweEQyMEQ4NUZELCAweEE1MEFCNTZCLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4MzVCNUE4RkEsIDB4NDJCMjk4NkMsIDB4REJCQkM5RDYsIDB4QUNCQ0Y5NDAsIDB4MzJEODZDRTMsIDB4NDVERjVDNzUsIDB4RENENjBEQ0YsIDB4QUJEMTNENTksIFxuICAgICAgICAgICAgICAgICAgICAgMHgyNkQ5MzBBQywgMHg1MURFMDAzQSwgMHhDOEQ3NTE4MCwgMHhCRkQwNjExNiwgMHgyMUI0RjRCNSwgMHg1NkIzQzQyMywgMHhDRkJBOTU5OSwgMHhCOEJEQTUwRixcbiAgICAgICAgICAgICAgICAgICAgIDB4MjgwMkI4OUUsIDB4NUYwNTg4MDgsIDB4QzYwQ0Q5QjIsIDB4QjEwQkU5MjQsIDB4MkY2RjdDODcsIDB4NTg2ODRDMTEsIDB4QzE2MTFEQUIsIDB4QjY2NjJEM0QsXG4gICAgICAgICAgICAgICAgICAgICAweDc2REM0MTkwLCAweDAxREI3MTA2LCAweDk4RDIyMEJDLCAweEVGRDUxMDJBLCAweDcxQjE4NTg5LCAweDA2QjZCNTFGLCAweDlGQkZFNEE1LCAweEU4QjhENDMzLFxuICAgICAgICAgICAgICAgICAgICAgMHg3ODA3QzlBMiwgMHgwRjAwRjkzNCwgMHg5NjA5QTg4RSwgMHhFMTBFOTgxOCwgMHg3RjZBMERCQiwgMHgwODZEM0QyRCwgMHg5MTY0NkM5NywgMHhFNjYzNUMwMSwgXG4gICAgICAgICAgICAgICAgICAgICAweDZCNkI1MUY0LCAweDFDNkM2MTYyLCAweDg1NjUzMEQ4LCAweEYyNjIwMDRFLCAweDZDMDY5NUVELCAweDFCMDFBNTdCLCAweDgyMDhGNEMxLCAweEY1MEZDNDU3LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NjVCMEQ5QzYsIDB4MTJCN0U5NTAsIDB4OEJCRUI4RUEsIDB4RkNCOTg4N0MsIDB4NjJERDFEREYsIDB4MTVEQTJENDksIDB4OENEMzdDRjMsIDB4RkJENDRDNjUsIFxuICAgICAgICAgICAgICAgICAgICAgMHg0REIyNjE1OCwgMHgzQUI1NTFDRSwgMHhBM0JDMDA3NCwgMHhENEJCMzBFMiwgMHg0QURGQTU0MSwgMHgzREQ4OTVENywgMHhBNEQxQzQ2RCwgMHhEM0Q2RjRGQiwgXG4gICAgICAgICAgICAgICAgICAgICAweDQzNjlFOTZBLCAweDM0NkVEOUZDLCAweEFENjc4ODQ2LCAweERBNjBCOEQwLCAweDQ0MDQyRDczLCAweDMzMDMxREU1LCAweEFBMEE0QzVGLCAweEREMEQ3Q0M5LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NTAwNTcxM0MsIDB4MjcwMjQxQUEsIDB4QkUwQjEwMTAsIDB4QzkwQzIwODYsIDB4NTc2OEI1MjUsIDB4MjA2Rjg1QjMsIDB4Qjk2NkQ0MDksIDB4Q0U2MUU0OUYsIFxuICAgICAgICAgICAgICAgICAgICAgMHg1RURFRjkwRSwgMHgyOUQ5Qzk5OCwgMHhCMEQwOTgyMiwgMHhDN0Q3QThCNCwgMHg1OUIzM0QxNywgMHgyRUI0MEQ4MSwgMHhCN0JENUMzQiwgMHhDMEJBNkNBRCwgXG4gICAgICAgICAgICAgICAgICAgICAweEVEQjg4MzIwLCAweDlBQkZCM0I2LCAweDAzQjZFMjBDLCAweDc0QjFEMjlBLCAweEVBRDU0NzM5LCAweDlERDI3N0FGLCAweDA0REIyNjE1LCAweDczREMxNjgzLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RTM2MzBCMTIsIDB4OTQ2NDNCODQsIDB4MEQ2RDZBM0UsIDB4N0E2QTVBQTgsIDB4RTQwRUNGMEIsIDB4OTMwOUZGOUQsIDB4MEEwMEFFMjcsIDB4N0QwNzlFQjEsIFxuICAgICAgICAgICAgICAgICAgICAgMHhGMDBGOTM0NCwgMHg4NzA4QTNEMiwgMHgxRTAxRjI2OCwgMHg2OTA2QzJGRSwgMHhGNzYyNTc1RCwgMHg4MDY1NjdDQiwgMHgxOTZDMzY3MSwgMHg2RTZCMDZFNywgXG4gICAgICAgICAgICAgICAgICAgICAweEZFRDQxQjc2LCAweDg5RDMyQkUwLCAweDEwREE3QTVBLCAweDY3REQ0QUNDLCAweEY5QjlERjZGLCAweDhFQkVFRkY5LCAweDE3QjdCRTQzLCAweDYwQjA4RUQ1LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RDZENkEzRTgsIDB4QTFEMTkzN0UsIDB4MzhEOEMyQzQsIDB4NEZERkYyNTIsIDB4RDFCQjY3RjEsIDB4QTZCQzU3NjcsIDB4M0ZCNTA2REQsIDB4NDhCMjM2NEIsIFxuICAgICAgICAgICAgICAgICAgICAgMHhEODBEMkJEQSwgMHhBRjBBMUI0QywgMHgzNjAzNEFGNiwgMHg0MTA0N0E2MCwgMHhERjYwRUZDMywgMHhBODY3REY1NSwgMHgzMTZFOEVFRiwgMHg0NjY5QkU3OSwgXG4gICAgICAgICAgICAgICAgICAgICAweENCNjFCMzhDLCAweEJDNjY4MzFBLCAweDI1NkZEMkEwLCAweDUyNjhFMjM2LCAweENDMEM3Nzk1LCAweEJCMEI0NzAzLCAweDIyMDIxNkI5LCAweDU1MDUyNjJGLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4QzVCQTNCQkUsIDB4QjJCRDBCMjgsIDB4MkJCNDVBOTIsIDB4NUNCMzZBMDQsIDB4QzJEN0ZGQTcsIDB4QjVEMENGMzEsIDB4MkNEOTlFOEIsIDB4NUJERUFFMUQsIFxuICAgICAgICAgICAgICAgICAgICAgMHg5QjY0QzJCMCwgMHhFQzYzRjIyNiwgMHg3NTZBQTM5QywgMHgwMjZEOTMwQSwgMHg5QzA5MDZBOSwgMHhFQjBFMzYzRiwgMHg3MjA3Njc4NSwgMHgwNTAwNTcxMywgXG4gICAgICAgICAgICAgICAgICAgICAweDk1QkY0QTgyLCAweEUyQjg3QTE0LCAweDdCQjEyQkFFLCAweDBDQjYxQjM4LCAweDkyRDI4RTlCLCAweEU1RDVCRTBELCAweDdDRENFRkI3LCAweDBCREJERjIxLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4ODZEM0QyRDQsIDB4RjFENEUyNDIsIDB4NjhEREIzRjgsIDB4MUZEQTgzNkUsIDB4ODFCRTE2Q0QsIDB4RjZCOTI2NUIsIDB4NkZCMDc3RTEsIDB4MThCNzQ3NzcsIFxuICAgICAgICAgICAgICAgICAgICAgMHg4ODA4NUFFNiwgMHhGRjBGNkE3MCwgMHg2NjA2M0JDQSwgMHgxMTAxMEI1QywgMHg4RjY1OUVGRiwgMHhGODYyQUU2OSwgMHg2MTZCRkZEMywgMHgxNjZDQ0Y0NSwgXG4gICAgICAgICAgICAgICAgICAgICAweEEwMEFFMjc4LCAweEQ3MEREMkVFLCAweDRFMDQ4MzU0LCAweDM5MDNCM0MyLCAweEE3NjcyNjYxLCAweEQwNjAxNkY3LCAweDQ5Njk0NzRELCAweDNFNkU3N0RCLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4QUVEMTZBNEEsIDB4RDlENjVBREMsIDB4NDBERjBCNjYsIDB4MzdEODNCRjAsIDB4QTlCQ0FFNTMsIDB4REVCQjlFQzUsIDB4NDdCMkNGN0YsIDB4MzBCNUZGRTksIFxuICAgICAgICAgICAgICAgICAgICAgMHhCREJERjIxQywgMHhDQUJBQzI4QSwgMHg1M0IzOTMzMCwgMHgyNEI0QTNBNiwgMHhCQUQwMzYwNSwgMHhDREQ3MDY5MywgMHg1NERFNTcyOSwgMHgyM0Q5NjdCRiwgXG4gICAgICAgICAgICAgICAgICAgICAweEIzNjY3QTJFLCAweEM0NjE0QUI4LCAweDVENjgxQjAyLCAweDJBNkYyQjk0LCAweEI0MEJCRTM3LCAweEMzMEM4RUExLCAweDVBMDVERjFCLCAweDJEMDJFRjhEXTtcbiAgICAgXG4gICAgICAgIHZhciBjcmMgPSAtMSwgeSA9IDAsIG4gPSBhLmxlbmd0aCxpO1xuXG4gICAgICAgIGZvciAoaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICB5ID0gKGNyYyBeIGFbaV0pICYgMHhGRjtcbiAgICAgICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGFibGVbeV07XG4gICAgICAgIH1cbiAgICAgXG4gICAgICAgIHJldHVybiBjcmMgXiAoLTEpO1xuICAgIH1cblxuICAgIHZhciBoID0gaW1nWzBdLmxlbmd0aCwgdyA9IGltZ1swXVswXS5sZW5ndGgsIHMxLCBzMiwgbmV4dCxrLGxlbmd0aCxhLGIsaSxqLGFkbGVyMzIsY3JjMzI7XG4gICAgdmFyIHN0cmVhbSA9IFtcbiAgICAgICAgICAgICAgICAgIDEzNywgODAsIDc4LCA3MSwgMTMsIDEwLCAyNiwgMTAsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDA6IFBORyBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgIDAsMCwwLDEzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDg6IElIRFIgQ2h1bmsgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICA3MywgNzIsIDY4LCA4MiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEyOiBcIklIRFJcIiBcbiAgICAgICAgICAgICAgICAgICh3ID4+IDI0KSAmIDI1NSwgKHcgPj4gMTYpICYgMjU1LCAodyA+PiA4KSAmIDI1NSwgdyYyNTUsICAgLy8gMTY6IFdpZHRoXG4gICAgICAgICAgICAgICAgICAoaCA+PiAyNCkgJiAyNTUsIChoID4+IDE2KSAmIDI1NSwgKGggPj4gOCkgJiAyNTUsIGgmMjU1LCAgIC8vIDIwOiBIZWlnaHRcbiAgICAgICAgICAgICAgICAgIDgsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjQ6IGJpdCBkZXB0aFxuICAgICAgICAgICAgICAgICAgMiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNTogUkdCXG4gICAgICAgICAgICAgICAgICAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI2OiBkZWZsYXRlXG4gICAgICAgICAgICAgICAgICAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI3OiBubyBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgIDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjg6IG5vIGludGVybGFjZVxuICAgICAgICAgICAgICAgICAgLTEsLTIsLTMsLTQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyOTogQ1JDXG4gICAgICAgICAgICAgICAgICAtNSwtNiwtNywtOCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMzOiBJREFUIENodW5rIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgNzMsIDY4LCA2NSwgODQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzNzogXCJJREFUXCJcbiAgICAgICAgICAgICAgICAgIC8vIFJGQyAxOTUwIGhlYWRlciBzdGFydHMgaGVyZVxuICAgICAgICAgICAgICAgICAgOCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA0MTogUkZDMTk1MCBDTUZcbiAgICAgICAgICAgICAgICAgIDI5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDI6IFJGQzE5NTAgRkxHXG4gICAgICAgICAgICAgICAgICBdO1xuICAgIGNyYzMyID0gY3JjMzJBcnJheShzdHJlYW0sMTIsMjkpO1xuICAgIHN0cmVhbVsyOV0gPSAoY3JjMzI+PjI0KSYyNTU7XG4gICAgc3RyZWFtWzMwXSA9IChjcmMzMj4+MTYpJjI1NTtcbiAgICBzdHJlYW1bMzFdID0gKGNyYzMyPj44KSYyNTU7XG4gICAgc3RyZWFtWzMyXSA9IChjcmMzMikmMjU1O1xuICAgIHMxID0gMTtcbiAgICBzMiA9IDA7XG4gICAgZm9yKGk9MDtpPGg7aSsrKSB7XG4gICAgICAgIGlmKGk8aC0xKSB7IHN0cmVhbS5wdXNoKDApOyB9XG4gICAgICAgIGVsc2UgeyBzdHJlYW0ucHVzaCgxKTsgfVxuICAgICAgICBhID0gKDMqdysxKyhpPT09MCkpJjI1NTsgYiA9ICgoMyp3KzErKGk9PT0wKSk+PjgpJjI1NTtcbiAgICAgICAgc3RyZWFtLnB1c2goYSk7IHN0cmVhbS5wdXNoKGIpO1xuICAgICAgICBzdHJlYW0ucHVzaCgofmEpJjI1NSk7IHN0cmVhbS5wdXNoKCh+YikmMjU1KTtcbiAgICAgICAgaWYoaT09PTApIHN0cmVhbS5wdXNoKDApO1xuICAgICAgICBmb3Ioaj0wO2o8dztqKyspIHtcbiAgICAgICAgICAgIGZvcihrPTA7azwzO2srKykge1xuICAgICAgICAgICAgICAgIGEgPSBpbWdba11baV1bal07XG4gICAgICAgICAgICAgICAgaWYoYT4yNTUpIGEgPSAyNTU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhPDApIGE9MDtcbiAgICAgICAgICAgICAgICBlbHNlIGEgPSBNYXRoLnJvdW5kKGEpO1xuICAgICAgICAgICAgICAgIHMxID0gKHMxICsgYSApJTY1NTIxO1xuICAgICAgICAgICAgICAgIHMyID0gKHMyICsgczEpJTY1NTIxO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wdXNoKDApO1xuICAgIH1cbiAgICBhZGxlcjMyID0gKHMyPDwxNikrczE7XG4gICAgc3RyZWFtLnB1c2goKGFkbGVyMzI+PjI0KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChhZGxlcjMyPj4xNikmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoYWRsZXIzMj4+OCkmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoYWRsZXIzMikmMjU1KTtcbiAgICBsZW5ndGggPSBzdHJlYW0ubGVuZ3RoIC0gNDE7XG4gICAgc3RyZWFtWzMzXSA9IChsZW5ndGg+PjI0KSYyNTU7XG4gICAgc3RyZWFtWzM0XSA9IChsZW5ndGg+PjE2KSYyNTU7XG4gICAgc3RyZWFtWzM1XSA9IChsZW5ndGg+PjgpJjI1NTtcbiAgICBzdHJlYW1bMzZdID0gKGxlbmd0aCkmMjU1O1xuICAgIGNyYzMyID0gY3JjMzJBcnJheShzdHJlYW0sMzcpO1xuICAgIHN0cmVhbS5wdXNoKChjcmMzMj4+MjQpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGNyYzMyPj4xNikmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoY3JjMzI+PjgpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGNyYzMyKSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKDApO1xuICAgIHN0cmVhbS5wdXNoKDApO1xuICAgIHN0cmVhbS5wdXNoKDApO1xuICAgIHN0cmVhbS5wdXNoKDApO1xuLy8gICAgYSA9IHN0cmVhbS5sZW5ndGg7XG4gICAgc3RyZWFtLnB1c2goNzMpOyAgLy8gSVxuICAgIHN0cmVhbS5wdXNoKDY5KTsgIC8vIEVcbiAgICBzdHJlYW0ucHVzaCg3OCk7ICAvLyBOXG4gICAgc3RyZWFtLnB1c2goNjgpOyAgLy8gRFxuICAgIHN0cmVhbS5wdXNoKDE3NCk7IC8vIENSQzFcbiAgICBzdHJlYW0ucHVzaCg2Nik7ICAvLyBDUkMyXG4gICAgc3RyZWFtLnB1c2goOTYpOyAgLy8gQ1JDM1xuICAgIHN0cmVhbS5wdXNoKDEzMCk7IC8vIENSQzRcbiAgICByZXR1cm4gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwnK2Jhc2U2NChzdHJlYW0pO1xufVxuXG4vLyAyLiBMaW5lYXIgYWxnZWJyYSB3aXRoIEFycmF5cy5cbm51bWVyaWMuX2RpbSA9IGZ1bmN0aW9uIF9kaW0oeCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB3aGlsZSh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikgeyByZXQucHVzaCh4Lmxlbmd0aCk7IHggPSB4WzBdOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5kaW0gPSBmdW5jdGlvbiBkaW0oeCkge1xuICAgIHZhciB5LHo7XG4gICAgaWYodHlwZW9mIHggPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgeSA9IHhbMF07XG4gICAgICAgIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB6ID0geVswXTtcbiAgICAgICAgICAgIGlmKHR5cGVvZiB6ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWVyaWMuX2RpbSh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbeC5sZW5ndGgseS5sZW5ndGhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeC5sZW5ndGhdO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbm51bWVyaWMubWFwcmVkdWNlID0gZnVuY3Rpb24gbWFwcmVkdWNlKGJvZHksaW5pdCkge1xuICAgIHJldHVybiBGdW5jdGlvbigneCcsJ2FjY3VtJywnX3MnLCdfaycsXG4gICAgICAgICAgICAnaWYodHlwZW9mIGFjY3VtID09PSBcInVuZGVmaW5lZFwiKSBhY2N1bSA9ICcraW5pdCsnO1xcbicrXG4gICAgICAgICAgICAnaWYodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHsgdmFyIHhpID0geDsgJytib2R5Kyc7IHJldHVybiBhY2N1bTsgfVxcbicrXG4gICAgICAgICAgICAnaWYodHlwZW9mIF9zID09PSBcInVuZGVmaW5lZFwiKSBfcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAnaWYodHlwZW9mIF9rID09PSBcInVuZGVmaW5lZFwiKSBfayA9IDA7XFxuJytcbiAgICAgICAgICAgICd2YXIgX24gPSBfc1tfa107XFxuJytcbiAgICAgICAgICAgICd2YXIgaSx4aTtcXG4nK1xuICAgICAgICAgICAgJ2lmKF9rIDwgX3MubGVuZ3RoLTEpIHtcXG4nK1xuICAgICAgICAgICAgJyAgICBmb3IoaT1fbi0xO2k+PTA7aS0tKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgICAgIGFjY3VtID0gYXJndW1lbnRzLmNhbGxlZSh4W2ldLGFjY3VtLF9zLF9rKzEpO1xcbicrXG4gICAgICAgICAgICAnICAgIH0nK1xuICAgICAgICAgICAgJyAgICByZXR1cm4gYWNjdW07XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdmb3IoaT1fbi0xO2k+PTE7aS09MikgeyBcXG4nK1xuICAgICAgICAgICAgJyAgICB4aSA9IHhbaV07XFxuJytcbiAgICAgICAgICAgICcgICAgJytib2R5Kyc7XFxuJytcbiAgICAgICAgICAgICcgICAgeGkgPSB4W2ktMV07XFxuJytcbiAgICAgICAgICAgICcgICAgJytib2R5Kyc7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdpZihpID09PSAwKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgeGkgPSB4W2ldO1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnXFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gYWNjdW07J1xuICAgICAgICAgICAgKTtcbn1cbm51bWVyaWMubWFwcmVkdWNlMiA9IGZ1bmN0aW9uIG1hcHJlZHVjZTIoYm9keSxzZXR1cCkge1xuICAgIHJldHVybiBGdW5jdGlvbigneCcsXG4gICAgICAgICAgICAndmFyIG4gPSB4Lmxlbmd0aDtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBpLHhpO1xcbicrc2V0dXArJztcXG4nK1xuICAgICAgICAgICAgJ2ZvcihpPW4tMTtpIT09LTE7LS1pKSB7IFxcbicrXG4gICAgICAgICAgICAnICAgIHhpID0geFtpXTtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJztcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiBhY2N1bTsnXG4gICAgICAgICAgICApO1xufVxuXG5cbm51bWVyaWMuc2FtZSA9IGZ1bmN0aW9uIHNhbWUoeCx5KSB7XG4gICAgdmFyIGksbjtcbiAgICBpZighKHggaW5zdGFuY2VvZiBBcnJheSkgfHwgISh5IGluc3RhbmNlb2YgQXJyYXkpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG4gPSB4Lmxlbmd0aDtcbiAgICBpZihuICE9PSB5Lmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IoaT0wO2k8bjtpKyspIHtcbiAgICAgICAgaWYoeFtpXSA9PT0geVtpXSkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZih0eXBlb2YgeFtpXSA9PT0gXCJvYmplY3RcIikgeyBpZighc2FtZSh4W2ldLHlbaV0pKSByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxubnVtZXJpYy5yZXAgPSBmdW5jdGlvbiByZXAocyx2LGspIHtcbiAgICBpZih0eXBlb2YgayA9PT0gXCJ1bmRlZmluZWRcIikgeyBrPTA7IH1cbiAgICB2YXIgbiA9IHNba10sIHJldCA9IEFycmF5KG4pLCBpO1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHtcbiAgICAgICAgZm9yKGk9bi0yO2k+PTA7aS09MikgeyByZXRbaSsxXSA9IHY7IHJldFtpXSA9IHY7IH1cbiAgICAgICAgaWYoaT09PS0xKSB7IHJldFswXSA9IHY7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7IHJldFtpXSA9IG51bWVyaWMucmVwKHMsdixrKzEpOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuXG5udW1lcmljLmRvdE1Nc21hbGwgPSBmdW5jdGlvbiBkb3RNTXNtYWxsKHgseSkge1xuICAgIHZhciBpLGosayxwLHEscixyZXQsZm9vLGJhcix3b28saTAsazAscDAscjA7XG4gICAgcCA9IHgubGVuZ3RoOyBxID0geS5sZW5ndGg7IHIgPSB5WzBdLmxlbmd0aDtcbiAgICByZXQgPSBBcnJheShwKTtcbiAgICBmb3IoaT1wLTE7aT49MDtpLS0pIHtcbiAgICAgICAgZm9vID0gQXJyYXkocik7XG4gICAgICAgIGJhciA9IHhbaV07XG4gICAgICAgIGZvcihrPXItMTtrPj0wO2stLSkge1xuICAgICAgICAgICAgd29vID0gYmFyW3EtMV0qeVtxLTFdW2tdO1xuICAgICAgICAgICAgZm9yKGo9cS0yO2o+PTE7ai09Mikge1xuICAgICAgICAgICAgICAgIGkwID0gai0xO1xuICAgICAgICAgICAgICAgIHdvbyArPSBiYXJbal0qeVtqXVtrXSArIGJhcltpMF0qeVtpMF1ba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihqPT09MCkgeyB3b28gKz0gYmFyWzBdKnlbMF1ba107IH1cbiAgICAgICAgICAgIGZvb1trXSA9IHdvbztcbiAgICAgICAgfVxuICAgICAgICByZXRbaV0gPSBmb287XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5udW1lcmljLl9nZXRDb2wgPSBmdW5jdGlvbiBfZ2V0Q29sKEEsaix4KSB7XG4gICAgdmFyIG4gPSBBLmxlbmd0aCwgaTtcbiAgICBmb3IoaT1uLTE7aT4wOy0taSkge1xuICAgICAgICB4W2ldID0gQVtpXVtqXTtcbiAgICAgICAgLS1pO1xuICAgICAgICB4W2ldID0gQVtpXVtqXTtcbiAgICB9XG4gICAgaWYoaT09PTApIHhbMF0gPSBBWzBdW2pdO1xufVxubnVtZXJpYy5kb3RNTWJpZyA9IGZ1bmN0aW9uIGRvdE1NYmlnKHgseSl7XG4gICAgdmFyIGdjID0gbnVtZXJpYy5fZ2V0Q29sLCBwID0geS5sZW5ndGgsIHYgPSBBcnJheShwKTtcbiAgICB2YXIgbSA9IHgubGVuZ3RoLCBuID0geVswXS5sZW5ndGgsIEEgPSBuZXcgQXJyYXkobSksIHhqO1xuICAgIHZhciBWViA9IG51bWVyaWMuZG90VlY7XG4gICAgdmFyIGksaixrLHo7XG4gICAgLS1wO1xuICAgIC0tbTtcbiAgICBmb3IoaT1tO2khPT0tMTstLWkpIEFbaV0gPSBBcnJheShuKTtcbiAgICAtLW47XG4gICAgZm9yKGk9bjtpIT09LTE7LS1pKSB7XG4gICAgICAgIGdjKHksaSx2KTtcbiAgICAgICAgZm9yKGo9bTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICB6PTA7XG4gICAgICAgICAgICB4aiA9IHhbal07XG4gICAgICAgICAgICBBW2pdW2ldID0gVlYoeGosdik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEE7XG59XG5cbm51bWVyaWMuZG90TVYgPSBmdW5jdGlvbiBkb3RNVih4LHkpIHtcbiAgICB2YXIgcCA9IHgubGVuZ3RoLCBxID0geS5sZW5ndGgsaTtcbiAgICB2YXIgcmV0ID0gQXJyYXkocCksIGRvdFZWID0gbnVtZXJpYy5kb3RWVjtcbiAgICBmb3IoaT1wLTE7aT49MDtpLS0pIHsgcmV0W2ldID0gZG90VlYoeFtpXSx5KTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZG90Vk0gPSBmdW5jdGlvbiBkb3RWTSh4LHkpIHtcbiAgICB2YXIgaSxqLGsscCxxLHIscmV0LGZvbyxiYXIsd29vLGkwLGswLHAwLHIwLHMxLHMyLHMzLGJheixhY2N1bTtcbiAgICBwID0geC5sZW5ndGg7IHEgPSB5WzBdLmxlbmd0aDtcbiAgICByZXQgPSBBcnJheShxKTtcbiAgICBmb3Ioaz1xLTE7az49MDtrLS0pIHtcbiAgICAgICAgd29vID0geFtwLTFdKnlbcC0xXVtrXTtcbiAgICAgICAgZm9yKGo9cC0yO2o+PTE7ai09Mikge1xuICAgICAgICAgICAgaTAgPSBqLTE7XG4gICAgICAgICAgICB3b28gKz0geFtqXSp5W2pdW2tdICsgeFtpMF0qeVtpMF1ba107XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHsgd29vICs9IHhbMF0qeVswXVtrXTsgfVxuICAgICAgICByZXRba10gPSB3b287XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZG90VlYgPSBmdW5jdGlvbiBkb3RWVih4LHkpIHtcbiAgICB2YXIgaSxuPXgubGVuZ3RoLGkxLHJldCA9IHhbbi0xXSp5W24tMV07XG4gICAgZm9yKGk9bi0yO2k+PTE7aS09Mikge1xuICAgICAgICBpMSA9IGktMTtcbiAgICAgICAgcmV0ICs9IHhbaV0qeVtpXSArIHhbaTFdKnlbaTFdO1xuICAgIH1cbiAgICBpZihpPT09MCkgeyByZXQgKz0geFswXSp5WzBdOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5kb3QgPSBmdW5jdGlvbiBkb3QoeCx5KSB7XG4gICAgdmFyIGQgPSBudW1lcmljLmRpbTtcbiAgICBzd2l0Y2goZCh4KS5sZW5ndGgqMTAwMCtkKHkpLmxlbmd0aCkge1xuICAgIGNhc2UgMjAwMjpcbiAgICAgICAgaWYoeS5sZW5ndGggPCAxMCkgcmV0dXJuIG51bWVyaWMuZG90TU1zbWFsbCh4LHkpO1xuICAgICAgICBlbHNlIHJldHVybiBudW1lcmljLmRvdE1NYmlnKHgseSk7XG4gICAgY2FzZSAyMDAxOiByZXR1cm4gbnVtZXJpYy5kb3RNVih4LHkpO1xuICAgIGNhc2UgMTAwMjogcmV0dXJuIG51bWVyaWMuZG90Vk0oeCx5KTtcbiAgICBjYXNlIDEwMDE6IHJldHVybiBudW1lcmljLmRvdFZWKHgseSk7XG4gICAgY2FzZSAxMDAwOiByZXR1cm4gbnVtZXJpYy5tdWxWUyh4LHkpO1xuICAgIGNhc2UgMTogcmV0dXJuIG51bWVyaWMubXVsU1YoeCx5KTtcbiAgICBjYXNlIDA6IHJldHVybiB4Knk7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdudW1lcmljLmRvdCBvbmx5IHdvcmtzIG9uIHZlY3RvcnMgYW5kIG1hdHJpY2VzJyk7XG4gICAgfVxufVxuXG5udW1lcmljLmRpYWcgPSBmdW5jdGlvbiBkaWFnKGQpIHtcbiAgICB2YXIgaSxpMSxqLG4gPSBkLmxlbmd0aCwgQSA9IEFycmF5KG4pLCBBaTtcbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHtcbiAgICAgICAgQWkgPSBBcnJheShuKTtcbiAgICAgICAgaTEgPSBpKzI7XG4gICAgICAgIGZvcihqPW4tMTtqPj1pMTtqLT0yKSB7XG4gICAgICAgICAgICBBaVtqXSA9IDA7XG4gICAgICAgICAgICBBaVtqLTFdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZihqPmkpIHsgQWlbal0gPSAwOyB9XG4gICAgICAgIEFpW2ldID0gZFtpXTtcbiAgICAgICAgZm9yKGo9aS0xO2o+PTE7ai09Mikge1xuICAgICAgICAgICAgQWlbal0gPSAwO1xuICAgICAgICAgICAgQWlbai0xXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHsgQWlbMF0gPSAwOyB9XG4gICAgICAgIEFbaV0gPSBBaTtcbiAgICB9XG4gICAgcmV0dXJuIEE7XG59XG5udW1lcmljLmdldERpYWcgPSBmdW5jdGlvbihBKSB7XG4gICAgdmFyIG4gPSBNYXRoLm1pbihBLmxlbmd0aCxBWzBdLmxlbmd0aCksaSxyZXQgPSBBcnJheShuKTtcbiAgICBmb3IoaT1uLTE7aT49MTstLWkpIHtcbiAgICAgICAgcmV0W2ldID0gQVtpXVtpXTtcbiAgICAgICAgLS1pO1xuICAgICAgICByZXRbaV0gPSBBW2ldW2ldO1xuICAgIH1cbiAgICBpZihpPT09MCkge1xuICAgICAgICByZXRbMF0gPSBBWzBdWzBdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkobikgeyByZXR1cm4gbnVtZXJpYy5kaWFnKG51bWVyaWMucmVwKFtuXSwxKSk7IH1cbm51bWVyaWMucG9pbnR3aXNlID0gZnVuY3Rpb24gcG9pbnR3aXNlKHBhcmFtcyxib2R5LHNldHVwKSB7XG4gICAgaWYodHlwZW9mIHNldHVwID09PSBcInVuZGVmaW5lZFwiKSB7IHNldHVwID0gXCJcIjsgfVxuICAgIHZhciBmdW4gPSBbXTtcbiAgICB2YXIgaztcbiAgICB2YXIgYXZlYyA9IC9cXFtpXFxdJC8scCx0aGV2ZWMgPSAnJztcbiAgICB2YXIgaGF2ZXJldCA9IGZhbHNlO1xuICAgIGZvcihrPTA7azxwYXJhbXMubGVuZ3RoO2srKykge1xuICAgICAgICBpZihhdmVjLnRlc3QocGFyYW1zW2tdKSkge1xuICAgICAgICAgICAgcCA9IHBhcmFtc1trXS5zdWJzdHJpbmcoMCxwYXJhbXNba10ubGVuZ3RoLTMpO1xuICAgICAgICAgICAgdGhldmVjID0gcDtcbiAgICAgICAgfSBlbHNlIHsgcCA9IHBhcmFtc1trXTsgfVxuICAgICAgICBpZihwPT09J3JldCcpIGhhdmVyZXQgPSB0cnVlO1xuICAgICAgICBmdW4ucHVzaChwKTtcbiAgICB9XG4gICAgZnVuW3BhcmFtcy5sZW5ndGhdID0gJ19zJztcbiAgICBmdW5bcGFyYW1zLmxlbmd0aCsxXSA9ICdfayc7XG4gICAgZnVuW3BhcmFtcy5sZW5ndGgrMl0gPSAoXG4gICAgICAgICAgICAnaWYodHlwZW9mIF9zID09PSBcInVuZGVmaW5lZFwiKSBfcyA9IG51bWVyaWMuZGltKCcrdGhldmVjKycpO1xcbicrXG4gICAgICAgICAgICAnaWYodHlwZW9mIF9rID09PSBcInVuZGVmaW5lZFwiKSBfayA9IDA7XFxuJytcbiAgICAgICAgICAgICd2YXIgX24gPSBfc1tfa107XFxuJytcbiAgICAgICAgICAgICd2YXIgaScrKGhhdmVyZXQ/Jyc6JywgcmV0ID0gQXJyYXkoX24pJykrJztcXG4nK1xuICAgICAgICAgICAgJ2lmKF9rIDwgX3MubGVuZ3RoLTEpIHtcXG4nK1xuICAgICAgICAgICAgJyAgICBmb3IoaT1fbi0xO2k+PTA7aS0tKSByZXRbaV0gPSBhcmd1bWVudHMuY2FsbGVlKCcrcGFyYW1zLmpvaW4oJywnKSsnLF9zLF9rKzEpO1xcbicrXG4gICAgICAgICAgICAnICAgIHJldHVybiByZXQ7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgIHNldHVwKydcXG4nK1xuICAgICAgICAgICAgJ2ZvcihpPV9uLTE7aSE9PS0xOy0taSkge1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnXFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gcmV0OydcbiAgICAgICAgICAgICk7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KG51bGwsZnVuKTtcbn1cbm51bWVyaWMucG9pbnR3aXNlMiA9IGZ1bmN0aW9uIHBvaW50d2lzZTIocGFyYW1zLGJvZHksc2V0dXApIHtcbiAgICBpZih0eXBlb2Ygc2V0dXAgPT09IFwidW5kZWZpbmVkXCIpIHsgc2V0dXAgPSBcIlwiOyB9XG4gICAgdmFyIGZ1biA9IFtdO1xuICAgIHZhciBrO1xuICAgIHZhciBhdmVjID0gL1xcW2lcXF0kLyxwLHRoZXZlYyA9ICcnO1xuICAgIHZhciBoYXZlcmV0ID0gZmFsc2U7XG4gICAgZm9yKGs9MDtrPHBhcmFtcy5sZW5ndGg7aysrKSB7XG4gICAgICAgIGlmKGF2ZWMudGVzdChwYXJhbXNba10pKSB7XG4gICAgICAgICAgICBwID0gcGFyYW1zW2tdLnN1YnN0cmluZygwLHBhcmFtc1trXS5sZW5ndGgtMyk7XG4gICAgICAgICAgICB0aGV2ZWMgPSBwO1xuICAgICAgICB9IGVsc2UgeyBwID0gcGFyYW1zW2tdOyB9XG4gICAgICAgIGlmKHA9PT0ncmV0JykgaGF2ZXJldCA9IHRydWU7XG4gICAgICAgIGZ1bi5wdXNoKHApO1xuICAgIH1cbiAgICBmdW5bcGFyYW1zLmxlbmd0aF0gPSAoXG4gICAgICAgICAgICAndmFyIF9uID0gJyt0aGV2ZWMrJy5sZW5ndGg7XFxuJytcbiAgICAgICAgICAgICd2YXIgaScrKGhhdmVyZXQ/Jyc6JywgcmV0ID0gQXJyYXkoX24pJykrJztcXG4nK1xuICAgICAgICAgICAgc2V0dXArJ1xcbicrXG4gICAgICAgICAgICAnZm9yKGk9X24tMTtpIT09LTE7LS1pKSB7XFxuJytcbiAgICAgICAgICAgIGJvZHkrJ1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIHJldDsnXG4gICAgICAgICAgICApO1xuICAgIHJldHVybiBGdW5jdGlvbi5hcHBseShudWxsLGZ1bik7XG59XG5udW1lcmljLl9iaWZvcmVhY2ggPSAoZnVuY3Rpb24gX2JpZm9yZWFjaCh4LHkscyxrLGYpIHtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7IGYoeCx5KTsgcmV0dXJuOyB9XG4gICAgdmFyIGksbj1zW2tdO1xuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgeyBfYmlmb3JlYWNoKHR5cGVvZiB4PT09XCJvYmplY3RcIj94W2ldOngsdHlwZW9mIHk9PT1cIm9iamVjdFwiP3lbaV06eSxzLGsrMSxmKTsgfVxufSk7XG5udW1lcmljLl9iaWZvcmVhY2gyID0gKGZ1bmN0aW9uIF9iaWZvcmVhY2gyKHgseSxzLGssZikge1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgcmV0dXJuIGYoeCx5KTsgfVxuICAgIHZhciBpLG49c1trXSxyZXQgPSBBcnJheShuKTtcbiAgICBmb3IoaT1uLTE7aT49MDstLWkpIHsgcmV0W2ldID0gX2JpZm9yZWFjaDIodHlwZW9mIHg9PT1cIm9iamVjdFwiP3hbaV06eCx0eXBlb2YgeT09PVwib2JqZWN0XCI/eVtpXTp5LHMsaysxLGYpOyB9XG4gICAgcmV0dXJuIHJldDtcbn0pO1xubnVtZXJpYy5fZm9yZWFjaCA9IChmdW5jdGlvbiBfZm9yZWFjaCh4LHMsayxmKSB7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyBmKHgpOyByZXR1cm47IH1cbiAgICB2YXIgaSxuPXNba107XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7IF9mb3JlYWNoKHhbaV0scyxrKzEsZik7IH1cbn0pO1xubnVtZXJpYy5fZm9yZWFjaDIgPSAoZnVuY3Rpb24gX2ZvcmVhY2gyKHgscyxrLGYpIHtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7IHJldHVybiBmKHgpOyB9XG4gICAgdmFyIGksbj1zW2tdLCByZXQgPSBBcnJheShuKTtcbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHsgcmV0W2ldID0gX2ZvcmVhY2gyKHhbaV0scyxrKzEsZik7IH1cbiAgICByZXR1cm4gcmV0O1xufSk7XG5cbi8qbnVtZXJpYy5hbnlWID0gbnVtZXJpYy5tYXByZWR1Y2UoJ2lmKHhpKSByZXR1cm4gdHJ1ZTsnLCdmYWxzZScpO1xubnVtZXJpYy5hbGxWID0gbnVtZXJpYy5tYXByZWR1Y2UoJ2lmKCF4aSkgcmV0dXJuIGZhbHNlOycsJ3RydWUnKTtcbm51bWVyaWMuYW55ID0gZnVuY3Rpb24oeCkgeyBpZih0eXBlb2YgeC5sZW5ndGggPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB4OyByZXR1cm4gbnVtZXJpYy5hbnlWKHgpOyB9XG5udW1lcmljLmFsbCA9IGZ1bmN0aW9uKHgpIHsgaWYodHlwZW9mIHgubGVuZ3RoID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4geDsgcmV0dXJuIG51bWVyaWMuYWxsVih4KTsgfSovXG5cbm51bWVyaWMub3BzMiA9IHtcbiAgICAgICAgYWRkOiAnKycsXG4gICAgICAgIHN1YjogJy0nLFxuICAgICAgICBtdWw6ICcqJyxcbiAgICAgICAgZGl2OiAnLycsXG4gICAgICAgIG1vZDogJyUnLFxuICAgICAgICBhbmQ6ICcmJicsXG4gICAgICAgIG9yOiAgJ3x8JyxcbiAgICAgICAgZXE6ICAnPT09JyxcbiAgICAgICAgbmVxOiAnIT09JyxcbiAgICAgICAgbHQ6ICAnPCcsXG4gICAgICAgIGd0OiAgJz4nLFxuICAgICAgICBsZXE6ICc8PScsXG4gICAgICAgIGdlcTogJz49JyxcbiAgICAgICAgYmFuZDogJyYnLFxuICAgICAgICBib3I6ICd8JyxcbiAgICAgICAgYnhvcjogJ14nLFxuICAgICAgICBsc2hpZnQ6ICc8PCcsXG4gICAgICAgIHJzaGlmdDogJz4+JyxcbiAgICAgICAgcnJzaGlmdDogJz4+Pidcbn07XG5udW1lcmljLm9wc2VxID0ge1xuICAgICAgICBhZGRlcTogJys9JyxcbiAgICAgICAgc3ViZXE6ICctPScsXG4gICAgICAgIG11bGVxOiAnKj0nLFxuICAgICAgICBkaXZlcTogJy89JyxcbiAgICAgICAgbW9kZXE6ICclPScsXG4gICAgICAgIGxzaGlmdGVxOiAnPDw9JyxcbiAgICAgICAgcnNoaWZ0ZXE6ICc+Pj0nLFxuICAgICAgICBycnNoaWZ0ZXE6ICc+Pj49JyxcbiAgICAgICAgYmFuZGVxOiAnJj0nLFxuICAgICAgICBib3JlcTogJ3w9JyxcbiAgICAgICAgYnhvcmVxOiAnXj0nXG59O1xubnVtZXJpYy5tYXRoZnVucyA9IFsnYWJzJywnYWNvcycsJ2FzaW4nLCdhdGFuJywnY2VpbCcsJ2NvcycsXG4gICAgICAgICAgICAgICAgICAgICdleHAnLCdmbG9vcicsJ2xvZycsJ3JvdW5kJywnc2luJywnc3FydCcsJ3RhbicsXG4gICAgICAgICAgICAgICAgICAgICdpc05hTicsJ2lzRmluaXRlJ107XG5udW1lcmljLm1hdGhmdW5zMiA9IFsnYXRhbjInLCdwb3cnLCdtYXgnLCdtaW4nXTtcbm51bWVyaWMub3BzMSA9IHtcbiAgICAgICAgbmVnOiAnLScsXG4gICAgICAgIG5vdDogJyEnLFxuICAgICAgICBibm90OiAnficsXG4gICAgICAgIGNsb25lOiAnJ1xufTtcbm51bWVyaWMubWFwcmVkdWNlcnMgPSB7XG4gICAgICAgIGFueTogWydpZih4aSkgcmV0dXJuIHRydWU7JywndmFyIGFjY3VtID0gZmFsc2U7J10sXG4gICAgICAgIGFsbDogWydpZigheGkpIHJldHVybiBmYWxzZTsnLCd2YXIgYWNjdW0gPSB0cnVlOyddLFxuICAgICAgICBzdW06IFsnYWNjdW0gKz0geGk7JywndmFyIGFjY3VtID0gMDsnXSxcbiAgICAgICAgcHJvZDogWydhY2N1bSAqPSB4aTsnLCd2YXIgYWNjdW0gPSAxOyddLFxuICAgICAgICBub3JtMlNxdWFyZWQ6IFsnYWNjdW0gKz0geGkqeGk7JywndmFyIGFjY3VtID0gMDsnXSxcbiAgICAgICAgbm9ybWluZjogWydhY2N1bSA9IG1heChhY2N1bSxhYnMoeGkpKTsnLCd2YXIgYWNjdW0gPSAwLCBtYXggPSBNYXRoLm1heCwgYWJzID0gTWF0aC5hYnM7J10sXG4gICAgICAgIG5vcm0xOiBbJ2FjY3VtICs9IGFicyh4aSknLCd2YXIgYWNjdW0gPSAwLCBhYnMgPSBNYXRoLmFiczsnXSxcbiAgICAgICAgc3VwOiBbJ2FjY3VtID0gbWF4KGFjY3VtLHhpKTsnLCd2YXIgYWNjdW0gPSAtSW5maW5pdHksIG1heCA9IE1hdGgubWF4OyddLFxuICAgICAgICBpbmY6IFsnYWNjdW0gPSBtaW4oYWNjdW0seGkpOycsJ3ZhciBhY2N1bSA9IEluZmluaXR5LCBtaW4gPSBNYXRoLm1pbjsnXVxufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSxvO1xuICAgIGZvcihpPTA7aTxudW1lcmljLm1hdGhmdW5zMi5sZW5ndGg7KytpKSB7XG4gICAgICAgIG8gPSBudW1lcmljLm1hdGhmdW5zMltpXTtcbiAgICAgICAgbnVtZXJpYy5vcHMyW29dID0gbztcbiAgICB9XG4gICAgZm9yKGkgaW4gbnVtZXJpYy5vcHMyKSB7XG4gICAgICAgIGlmKG51bWVyaWMub3BzMi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgbyA9IG51bWVyaWMub3BzMltpXTtcbiAgICAgICAgICAgIHZhciBjb2RlLCBjb2RlZXEsIHNldHVwID0gJyc7XG4gICAgICAgICAgICBpZihudW1lcmljLm15SW5kZXhPZi5jYWxsKG51bWVyaWMubWF0aGZ1bnMyLGkpIT09LTEpIHtcbiAgICAgICAgICAgICAgICBzZXR1cCA9ICd2YXIgJytvKycgPSBNYXRoLicrbysnO1xcbic7XG4gICAgICAgICAgICAgICAgY29kZSA9IGZ1bmN0aW9uKHIseCx5KSB7IHJldHVybiByKycgPSAnK28rJygnK3grJywnK3krJyknOyB9O1xuICAgICAgICAgICAgICAgIGNvZGVlcSA9IGZ1bmN0aW9uKHgseSkgeyByZXR1cm4geCsnID0gJytvKycoJyt4KycsJyt5KycpJzsgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGZ1bmN0aW9uKHIseCx5KSB7IHJldHVybiByKycgPSAnK3grJyAnK28rJyAnK3k7IH07XG4gICAgICAgICAgICAgICAgaWYobnVtZXJpYy5vcHNlcS5oYXNPd25Qcm9wZXJ0eShpKydlcScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVlcSA9IGZ1bmN0aW9uKHgseSkgeyByZXR1cm4geCsnICcrbysnPSAnK3k7IH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZWVxID0gZnVuY3Rpb24oeCx5KSB7IHJldHVybiB4KycgPSAnK3grJyAnK28rJyAnK3k7IH07ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1lcmljW2krJ1ZWJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWyd4W2ldJywneVtpXSddLGNvZGUoJ3JldFtpXScsJ3hbaV0nLCd5W2ldJyksc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydTViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsneCcsJ3lbaV0nXSxjb2RlKCdyZXRbaV0nLCd4JywneVtpXScpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnVlMnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3hbaV0nLCd5J10sY29kZSgncmV0W2ldJywneFtpXScsJ3knKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2ldID0gRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICd2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGksIHggPSBhcmd1bWVudHNbMF0sIHk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBWViA9IG51bWVyaWMuJytpKydWViwgVlMgPSBudW1lcmljLicraSsnVlMsIFNWID0gbnVtZXJpYy4nK2krJ1NWO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgZGltID0gbnVtZXJpYy5kaW07XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ2ZvcihpPTE7aSE9PW47KytpKSB7IFxcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIHkgPSBhcmd1bWVudHNbaV07XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgaWYodHlwZW9mIHggPT09IFwib2JqZWN0XCIpIHtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICAgICAgaWYodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIHggPSBudW1lcmljLl9iaWZvcmVhY2gyKHgseSxkaW0oeCksMCxWVik7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgICAgIGVsc2UgeCA9IG51bWVyaWMuX2JpZm9yZWFjaDIoeCx5LGRpbSh4KSwwLFZTKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICB9IGVsc2UgaWYodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIHggPSBudW1lcmljLl9iaWZvcmVhY2gyKHgseSxkaW0oeSksMCxTVik7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgZWxzZSAnK2NvZGVlcSgneCcsJ3knKSsnXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ31cXG5yZXR1cm4geDtcXG4nKTtcbiAgICAgICAgICAgIG51bWVyaWNbb10gPSBudW1lcmljW2ldO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydlcVYnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3JldFtpXScsJ3hbaV0nXSwgY29kZWVxKCdyZXRbaV0nLCd4W2ldJyksc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydlcVMnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3JldFtpXScsJ3gnXSwgY29kZWVxKCdyZXRbaV0nLCd4Jyksc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydlcSddID0gRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICd2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGksIHggPSBhcmd1bWVudHNbMF0sIHk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBWID0gbnVtZXJpYy4nK2krJ2VxViwgUyA9IG51bWVyaWMuJytpKydlcVNcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIHMgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnZm9yKGk9MTtpIT09bjsrK2kpIHsgXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgeSA9IGFyZ3VtZW50c1tpXTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgbnVtZXJpYy5fYmlmb3JlYWNoKHgseSxzLDAsVik7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgZWxzZSBudW1lcmljLl9iaWZvcmVhY2goeCx5LHMsMCxTKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnfVxcbnJldHVybiB4O1xcbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihpPTA7aTxudW1lcmljLm1hdGhmdW5zMi5sZW5ndGg7KytpKSB7XG4gICAgICAgIG8gPSBudW1lcmljLm1hdGhmdW5zMltpXTtcbiAgICAgICAgZGVsZXRlIG51bWVyaWMub3BzMltvXTtcbiAgICB9XG4gICAgZm9yKGk9MDtpPG51bWVyaWMubWF0aGZ1bnMubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuc1tpXTtcbiAgICAgICAgbnVtZXJpYy5vcHMxW29dID0gbztcbiAgICB9XG4gICAgZm9yKGkgaW4gbnVtZXJpYy5vcHMxKSB7XG4gICAgICAgIGlmKG51bWVyaWMub3BzMS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgc2V0dXAgPSAnJztcbiAgICAgICAgICAgIG8gPSBudW1lcmljLm9wczFbaV07XG4gICAgICAgICAgICBpZihudW1lcmljLm15SW5kZXhPZi5jYWxsKG51bWVyaWMubWF0aGZ1bnMsaSkhPT0tMSkge1xuICAgICAgICAgICAgICAgIGlmKE1hdGguaGFzT3duUHJvcGVydHkobykpIHNldHVwID0gJ3ZhciAnK28rJyA9IE1hdGguJytvKyc7XFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXFWJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWydyZXRbaV0nXSwncmV0W2ldID0gJytvKycocmV0W2ldKTsnLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXEnXSA9IEZ1bmN0aW9uKCd4JyxcbiAgICAgICAgICAgICAgICAgICAgJ2lmKHR5cGVvZiB4ICE9PSBcIm9iamVjdFwiKSByZXR1cm4gJytvKyd4XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgViA9IG51bWVyaWMuJytpKydlcVY7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBzID0gbnVtZXJpYy5kaW0oeCk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ251bWVyaWMuX2ZvcmVhY2goeCxzLDAsVik7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybiB4O1xcbicpO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydWJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWyd4W2ldJ10sJ3JldFtpXSA9ICcrbysnKHhbaV0pOycsc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpXSA9IEZ1bmN0aW9uKCd4JyxcbiAgICAgICAgICAgICAgICAgICAgJ2lmKHR5cGVvZiB4ICE9PSBcIm9iamVjdFwiKSByZXR1cm4gJytvKycoeClcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIGk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBWID0gbnVtZXJpYy4nK2krJ1Y7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBzID0gbnVtZXJpYy5kaW0oeCk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybiBudW1lcmljLl9mb3JlYWNoMih4LHMsMCxWKTtcXG4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IoaT0wO2k8bnVtZXJpYy5tYXRoZnVucy5sZW5ndGg7KytpKSB7XG4gICAgICAgIG8gPSBudW1lcmljLm1hdGhmdW5zW2ldO1xuICAgICAgICBkZWxldGUgbnVtZXJpYy5vcHMxW29dO1xuICAgIH1cbiAgICBmb3IoaSBpbiBudW1lcmljLm1hcHJlZHVjZXJzKSB7XG4gICAgICAgIGlmKG51bWVyaWMubWFwcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIG8gPSBudW1lcmljLm1hcHJlZHVjZXJzW2ldO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydWJ10gPSBudW1lcmljLm1hcHJlZHVjZTIob1swXSxvWzFdKTtcbiAgICAgICAgICAgIG51bWVyaWNbaV0gPSBGdW5jdGlvbigneCcsJ3MnLCdrJyxcbiAgICAgICAgICAgICAgICAgICAgb1sxXStcbiAgICAgICAgICAgICAgICAgICAgJ2lmKHR5cGVvZiB4ICE9PSBcIm9iamVjdFwiKSB7JytcbiAgICAgICAgICAgICAgICAgICAgJyAgICB4aSA9IHg7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgb1swXSsnO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgICAgcmV0dXJuIGFjY3VtO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd9JytcbiAgICAgICAgICAgICAgICAgICAgJ2lmKHR5cGVvZiBzID09PSBcInVuZGVmaW5lZFwiKSBzID0gbnVtZXJpYy5kaW0oeCk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ2lmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSBrID0gMDtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnaWYoayA9PT0gcy5sZW5ndGgtMSkgcmV0dXJuIG51bWVyaWMuJytpKydWKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgeGk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBuID0geC5sZW5ndGgsIGk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ2ZvcihpPW4tMTtpIT09LTE7LS1pKSB7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgIHhpID0gYXJndW1lbnRzLmNhbGxlZSh4W2ldKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICBvWzBdKyc7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgICAgICAgICAncmV0dXJuIGFjY3VtO1xcbicpO1xuICAgICAgICB9XG4gICAgfVxufSgpKTtcblxubnVtZXJpYy50cnVuY1ZWID0gbnVtZXJpYy5wb2ludHdpc2UoWyd4W2ldJywneVtpXSddLCdyZXRbaV0gPSByb3VuZCh4W2ldL3lbaV0pKnlbaV07JywndmFyIHJvdW5kID0gTWF0aC5yb3VuZDsnKTtcbm51bWVyaWMudHJ1bmNWUyA9IG51bWVyaWMucG9pbnR3aXNlKFsneFtpXScsJ3knXSwncmV0W2ldID0gcm91bmQoeFtpXS95KSp5OycsJ3ZhciByb3VuZCA9IE1hdGgucm91bmQ7Jyk7XG5udW1lcmljLnRydW5jU1YgPSBudW1lcmljLnBvaW50d2lzZShbJ3gnLCd5W2ldJ10sJ3JldFtpXSA9IHJvdW5kKHgveVtpXSkqeVtpXTsnLCd2YXIgcm91bmQgPSBNYXRoLnJvdW5kOycpO1xubnVtZXJpYy50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKHgseSkge1xuICAgIGlmKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSByZXR1cm4gbnVtZXJpYy50cnVuY1ZWKHgseSk7XG4gICAgICAgIHJldHVybiBudW1lcmljLnRydW5jVlMoeCx5KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSByZXR1cm4gbnVtZXJpYy50cnVuY1NWKHgseSk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoeC95KSp5O1xufVxuXG5udW1lcmljLmludiA9IGZ1bmN0aW9uIGludih4KSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbSh4KSwgYWJzID0gTWF0aC5hYnMsIG0gPSBzWzBdLCBuID0gc1sxXTtcbiAgICB2YXIgQSA9IG51bWVyaWMuY2xvbmUoeCksIEFpLCBBajtcbiAgICB2YXIgSSA9IG51bWVyaWMuaWRlbnRpdHkobSksIElpLCBJajtcbiAgICB2YXIgaSxqLGsseDtcbiAgICBmb3Ioaj0wO2o8bjsrK2opIHtcbiAgICAgICAgdmFyIGkwID0gLTE7XG4gICAgICAgIHZhciB2MCA9IC0xO1xuICAgICAgICBmb3IoaT1qO2khPT1tOysraSkgeyBrID0gYWJzKEFbaV1bal0pOyBpZihrPnYwKSB7IGkwID0gaTsgdjAgPSBrOyB9IH1cbiAgICAgICAgQWogPSBBW2kwXTsgQVtpMF0gPSBBW2pdOyBBW2pdID0gQWo7XG4gICAgICAgIElqID0gSVtpMF07IElbaTBdID0gSVtqXTsgSVtqXSA9IElqO1xuICAgICAgICB4ID0gQWpbal07XG4gICAgICAgIGZvcihrPWo7ayE9PW47KytrKSAgICBBaltrXSAvPSB4OyBcbiAgICAgICAgZm9yKGs9bi0xO2shPT0tMTstLWspIElqW2tdIC89IHg7XG4gICAgICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgICAgICBpZihpIT09aikge1xuICAgICAgICAgICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgICAgICAgICBJaSA9IElbaV07XG4gICAgICAgICAgICAgICAgeCA9IEFpW2pdO1xuICAgICAgICAgICAgICAgIGZvcihrPWorMTtrIT09bjsrK2spICBBaVtrXSAtPSBBaltrXSp4O1xuICAgICAgICAgICAgICAgIGZvcihrPW4tMTtrPjA7LS1rKSB7IElpW2tdIC09IElqW2tdKng7IC0tazsgSWlba10gLT0gSWpba10qeDsgfVxuICAgICAgICAgICAgICAgIGlmKGs9PT0wKSBJaVswXSAtPSBJalswXSp4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJO1xufVxuXG5udW1lcmljLmRldCA9IGZ1bmN0aW9uIGRldCh4KSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbSh4KTtcbiAgICBpZihzLmxlbmd0aCAhPT0gMiB8fCBzWzBdICE9PSBzWzFdKSB7IHRocm93IG5ldyBFcnJvcignbnVtZXJpYzogZGV0KCkgb25seSB3b3JrcyBvbiBzcXVhcmUgbWF0cmljZXMnKTsgfVxuICAgIHZhciBuID0gc1swXSwgcmV0ID0gMSxpLGosayxBID0gbnVtZXJpYy5jbG9uZSh4KSxBaixBaSxhbHBoYSx0ZW1wLGsxLGsyLGszO1xuICAgIGZvcihqPTA7ajxuLTE7aisrKSB7XG4gICAgICAgIGs9ajtcbiAgICAgICAgZm9yKGk9aisxO2k8bjtpKyspIHsgaWYoTWF0aC5hYnMoQVtpXVtqXSkgPiBNYXRoLmFicyhBW2tdW2pdKSkgeyBrID0gaTsgfSB9XG4gICAgICAgIGlmKGsgIT09IGopIHtcbiAgICAgICAgICAgIHRlbXAgPSBBW2tdOyBBW2tdID0gQVtqXTsgQVtqXSA9IHRlbXA7XG4gICAgICAgICAgICByZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgQWogPSBBW2pdO1xuICAgICAgICBmb3IoaT1qKzE7aTxuO2krKykge1xuICAgICAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICAgICAgYWxwaGEgPSBBaVtqXS9BaltqXTtcbiAgICAgICAgICAgIGZvcihrPWorMTtrPG4tMTtrKz0yKSB7XG4gICAgICAgICAgICAgICAgazEgPSBrKzE7XG4gICAgICAgICAgICAgICAgQWlba10gLT0gQWpba10qYWxwaGE7XG4gICAgICAgICAgICAgICAgQWlbazFdIC09IEFqW2sxXSphbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGshPT1uKSB7IEFpW2tdIC09IEFqW2tdKmFscGhhOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoQWpbal0gPT09IDApIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0ICo9IEFqW2pdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0KkFbal1bal07XG59XG5cbm51bWVyaWMudHJhbnNwb3NlID0gZnVuY3Rpb24gdHJhbnNwb3NlKHgpIHtcbiAgICB2YXIgaSxqLG0gPSB4Lmxlbmd0aCxuID0geFswXS5sZW5ndGgsIHJldD1BcnJheShuKSxBMCxBMSxCajtcbiAgICBmb3Ioaj0wO2o8bjtqKyspIHJldFtqXSA9IEFycmF5KG0pO1xuICAgIGZvcihpPW0tMTtpPj0xO2ktPTIpIHtcbiAgICAgICAgQTEgPSB4W2ldO1xuICAgICAgICBBMCA9IHhbaS0xXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTE7LS1qKSB7XG4gICAgICAgICAgICBCaiA9IHJldFtqXTsgQmpbaV0gPSBBMVtqXTsgQmpbaS0xXSA9IEEwW2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgQmogPSByZXRbal07IEJqW2ldID0gQTFbal07IEJqW2ktMV0gPSBBMFtqXTtcbiAgICAgICAgfVxuICAgICAgICBpZihqPT09MCkge1xuICAgICAgICAgICAgQmogPSByZXRbMF07IEJqW2ldID0gQTFbMF07IEJqW2ktMV0gPSBBMFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihpPT09MCkge1xuICAgICAgICBBMCA9IHhbMF07XG4gICAgICAgIGZvcihqPW4tMTtqPj0xOy0taikge1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gQTBbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICByZXRbal1bMF0gPSBBMFtqXTtcbiAgICAgICAgfVxuICAgICAgICBpZihqPT09MCkgeyByZXRbMF1bMF0gPSBBMFswXTsgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5uZWd0cmFuc3Bvc2UgPSBmdW5jdGlvbiBuZWd0cmFuc3Bvc2UoeCkge1xuICAgIHZhciBpLGosbSA9IHgubGVuZ3RoLG4gPSB4WzBdLmxlbmd0aCwgcmV0PUFycmF5KG4pLEEwLEExLEJqO1xuICAgIGZvcihqPTA7ajxuO2orKykgcmV0W2pdID0gQXJyYXkobSk7XG4gICAgZm9yKGk9bS0xO2k+PTE7aS09Mikge1xuICAgICAgICBBMSA9IHhbaV07XG4gICAgICAgIEEwID0geFtpLTFdO1xuICAgICAgICBmb3Ioaj1uLTE7aj49MTstLWopIHtcbiAgICAgICAgICAgIEJqID0gcmV0W2pdOyBCaltpXSA9IC1BMVtqXTsgQmpbaS0xXSA9IC1BMFtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEJqID0gcmV0W2pdOyBCaltpXSA9IC1BMVtqXTsgQmpbaS0xXSA9IC1BMFtqXTtcbiAgICAgICAgfVxuICAgICAgICBpZihqPT09MCkge1xuICAgICAgICAgICAgQmogPSByZXRbMF07IEJqW2ldID0gLUExWzBdOyBCaltpLTFdID0gLUEwWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmKGk9PT0wKSB7XG4gICAgICAgIEEwID0geFswXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTE7LS1qKSB7XG4gICAgICAgICAgICByZXRbal1bMF0gPSAtQTBbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICByZXRbal1bMF0gPSAtQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHsgcmV0WzBdWzBdID0gLUEwWzBdOyB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuX3JhbmRvbSA9IGZ1bmN0aW9uIF9yYW5kb20ocyxrKSB7XG4gICAgdmFyIGksbj1zW2tdLHJldD1BcnJheShuKSwgcm5kO1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHtcbiAgICAgICAgcm5kID0gTWF0aC5yYW5kb207XG4gICAgICAgIGZvcihpPW4tMTtpPj0xO2ktPTIpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHJuZCgpO1xuICAgICAgICAgICAgcmV0W2ktMV0gPSBybmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihpPT09MCkgeyByZXRbMF0gPSBybmQoKTsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHJldFtpXSA9IF9yYW5kb20ocyxrKzEpO1xuICAgIHJldHVybiByZXQ7XG59XG5udW1lcmljLnJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbShzKSB7IHJldHVybiBudW1lcmljLl9yYW5kb20ocywwKTsgfVxuXG5udW1lcmljLm5vcm0yID0gZnVuY3Rpb24gbm9ybTIoeCkgeyByZXR1cm4gTWF0aC5zcXJ0KG51bWVyaWMubm9ybTJTcXVhcmVkKHgpKTsgfVxuXG5udW1lcmljLmxpbnNwYWNlID0gZnVuY3Rpb24gbGluc3BhY2UoYSxiLG4pIHtcbiAgICBpZih0eXBlb2YgbiA9PT0gXCJ1bmRlZmluZWRcIikgbiA9IE1hdGgubWF4KE1hdGgucm91bmQoYi1hKSsxLDEpO1xuICAgIGlmKG48MikgeyByZXR1cm4gbj09PTE/W2FdOltdOyB9XG4gICAgdmFyIGkscmV0ID0gQXJyYXkobik7XG4gICAgbi0tO1xuICAgIGZvcihpPW47aT49MDtpLS0pIHsgcmV0W2ldID0gKGkqYisobi1pKSphKS9uOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5nZXRCbG9jayA9IGZ1bmN0aW9uIGdldEJsb2NrKHgsZnJvbSx0bykge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oeCk7XG4gICAgZnVuY3Rpb24gZm9vKHgsaykge1xuICAgICAgICB2YXIgaSxhID0gZnJvbVtrXSwgbiA9IHRvW2tdLWEsIHJldCA9IEFycmF5KG4pO1xuICAgICAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7XG4gICAgICAgICAgICBmb3IoaT1uO2k+PTA7aS0tKSB7IHJldFtpXSA9IHhbaSthXTsgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaT1uO2k+PTA7aS0tKSB7IHJldFtpXSA9IGZvbyh4W2krYV0saysxKTsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gZm9vKHgsMCk7XG59XG5cbm51bWVyaWMuc2V0QmxvY2sgPSBmdW5jdGlvbiBzZXRCbG9jayh4LGZyb20sdG8sQikge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oeCk7XG4gICAgZnVuY3Rpb24gZm9vKHgseSxrKSB7XG4gICAgICAgIHZhciBpLGEgPSBmcm9tW2tdLCBuID0gdG9ba10tYTtcbiAgICAgICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyBmb3IoaT1uO2k+PTA7aS0tKSB7IHhbaSthXSA9IHlbaV07IH0gfVxuICAgICAgICBmb3IoaT1uO2k+PTA7aS0tKSB7IGZvbyh4W2krYV0seVtpXSxrKzEpOyB9XG4gICAgfVxuICAgIGZvbyh4LEIsMCk7XG4gICAgcmV0dXJuIHg7XG59XG5cbm51bWVyaWMuZ2V0UmFuZ2UgPSBmdW5jdGlvbiBnZXRSYW5nZShBLEksSikge1xuICAgIHZhciBtID0gSS5sZW5ndGgsIG4gPSBKLmxlbmd0aDtcbiAgICB2YXIgaSxqO1xuICAgIHZhciBCID0gQXJyYXkobSksIEJpLCBBSTtcbiAgICBmb3IoaT1tLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBCW2ldID0gQXJyYXkobik7XG4gICAgICAgIEJpID0gQltpXTtcbiAgICAgICAgQUkgPSBBW0lbaV1dO1xuICAgICAgICBmb3Ioaj1uLTE7aiE9PS0xOy0taikgQmlbal0gPSBBSVtKW2pdXTtcbiAgICB9XG4gICAgcmV0dXJuIEI7XG59XG5cbm51bWVyaWMuYmxvY2tNYXRyaXggPSBmdW5jdGlvbiBibG9ja01hdHJpeChYKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbShYKTtcbiAgICBpZihzLmxlbmd0aDw0KSByZXR1cm4gbnVtZXJpYy5ibG9ja01hdHJpeChbWF0pO1xuICAgIHZhciBtPXNbMF0sbj1zWzFdLE0sTixpLGosWGlqO1xuICAgIE0gPSAwOyBOID0gMDtcbiAgICBmb3IoaT0wO2k8bTsrK2kpIE0rPVhbaV1bMF0ubGVuZ3RoO1xuICAgIGZvcihqPTA7ajxuOysraikgTis9WFswXVtqXVswXS5sZW5ndGg7XG4gICAgdmFyIFogPSBBcnJheShNKTtcbiAgICBmb3IoaT0wO2k8TTsrK2kpIFpbaV0gPSBBcnJheShOKTtcbiAgICB2YXIgST0wLEosWkksayxsLFhpams7XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIEo9TjtcbiAgICAgICAgZm9yKGo9bi0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIFhpaiA9IFhbaV1bal07XG4gICAgICAgICAgICBKIC09IFhpalswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3Ioaz1YaWoubGVuZ3RoLTE7ayE9PS0xOy0taykge1xuICAgICAgICAgICAgICAgIFhpamsgPSBYaWpba107XG4gICAgICAgICAgICAgICAgWkkgPSBaW0kra107XG4gICAgICAgICAgICAgICAgZm9yKGwgPSBYaWprLmxlbmd0aC0xO2whPT0tMTstLWwpIFpJW0orbF0gPSBYaWprW2xdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEkgKz0gWFtpXVswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBaO1xufVxuXG5udW1lcmljLnRlbnNvciA9IGZ1bmN0aW9uIHRlbnNvcih4LHkpIHtcbiAgICBpZih0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIG51bWVyaWMubXVsKHgseSk7XG4gICAgdmFyIHMxID0gbnVtZXJpYy5kaW0oeCksIHMyID0gbnVtZXJpYy5kaW0oeSk7XG4gICAgaWYoczEubGVuZ3RoICE9PSAxIHx8IHMyLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWM6IHRlbnNvciBwcm9kdWN0IGlzIG9ubHkgZGVmaW5lZCBmb3IgdmVjdG9ycycpO1xuICAgIH1cbiAgICB2YXIgbSA9IHMxWzBdLCBuID0gczJbMF0sIEEgPSBBcnJheShtKSwgQWksIGksaix4aTtcbiAgICBmb3IoaT1tLTE7aT49MDtpLS0pIHtcbiAgICAgICAgQWkgPSBBcnJheShuKTtcbiAgICAgICAgeGkgPSB4W2ldO1xuICAgICAgICBmb3Ioaj1uLTE7aj49MzstLWopIHtcbiAgICAgICAgICAgIEFpW2pdID0geGkgKiB5W2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgQWlbal0gPSB4aSAqIHlbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBBaVtqXSA9IHhpICogeVtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEFpW2pdID0geGkgKiB5W2pdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKGo+PTApIHsgQWlbal0gPSB4aSAqIHlbal07IC0tajsgfVxuICAgICAgICBBW2ldID0gQWk7XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuXG4vLyAzLiBUaGUgVGVuc29yIHR5cGUgVFxubnVtZXJpYy5UID0gZnVuY3Rpb24gVCh4LHkpIHsgdGhpcy54ID0geDsgdGhpcy55ID0geTsgfVxubnVtZXJpYy50ID0gZnVuY3Rpb24gdCh4LHkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQoeCx5KTsgfVxuXG5udW1lcmljLlRiaW5vcCA9IGZ1bmN0aW9uIFRiaW5vcChycixyYyxjcixjYyxzZXR1cCkge1xuICAgIHZhciBpbyA9IG51bWVyaWMuaW5kZXhPZjtcbiAgICBpZih0eXBlb2Ygc2V0dXAgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIHNldHVwID0gJyc7XG4gICAgICAgIGZvcihrIGluIG51bWVyaWMpIHtcbiAgICAgICAgICAgIGlmKG51bWVyaWMuaGFzT3duUHJvcGVydHkoaykgJiYgKHJyLmluZGV4T2Yoayk+PTAgfHwgcmMuaW5kZXhPZihrKT49MCB8fCBjci5pbmRleE9mKGspPj0wIHx8IGNjLmluZGV4T2Yoayk+PTApICYmIGsubGVuZ3RoPjEpIHtcbiAgICAgICAgICAgICAgICBzZXR1cCArPSAndmFyICcraysnID0gbnVtZXJpYy4nK2srJztcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBGdW5jdGlvbihbJ3knXSxcbiAgICAgICAgICAgICd2YXIgeCA9IHRoaXM7XFxuJytcbiAgICAgICAgICAgICdpZighKHkgaW5zdGFuY2VvZiBudW1lcmljLlQpKSB7IHkgPSBuZXcgbnVtZXJpYy5UKHkpOyB9XFxuJytcbiAgICAgICAgICAgIHNldHVwKydcXG4nK1xuICAgICAgICAgICAgJ2lmKHgueSkgeycrXG4gICAgICAgICAgICAnICBpZih5LnkpIHsnK1xuICAgICAgICAgICAgJyAgICByZXR1cm4gbmV3IG51bWVyaWMuVCgnK2NjKycpO1xcbicrXG4gICAgICAgICAgICAnICB9XFxuJytcbiAgICAgICAgICAgICcgIHJldHVybiBuZXcgbnVtZXJpYy5UKCcrY3IrJyk7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdpZih5LnkpIHtcXG4nK1xuICAgICAgICAgICAgJyAgcmV0dXJuIG5ldyBudW1lcmljLlQoJytyYysnKTtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKCcrcnIrJyk7XFxuJ1xuICAgICk7XG59XG5cbm51bWVyaWMuVC5wcm90b3R5cGUuYWRkID0gbnVtZXJpYy5UYmlub3AoXG4gICAgICAgICdhZGQoeC54LHkueCknLFxuICAgICAgICAnYWRkKHgueCx5LngpLHkueScsXG4gICAgICAgICdhZGQoeC54LHkueCkseC55JyxcbiAgICAgICAgJ2FkZCh4LngseS54KSxhZGQoeC55LHkueSknKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuc3ViID0gbnVtZXJpYy5UYmlub3AoXG4gICAgICAgICdzdWIoeC54LHkueCknLFxuICAgICAgICAnc3ViKHgueCx5LngpLG5lZyh5LnkpJyxcbiAgICAgICAgJ3N1Yih4LngseS54KSx4LnknLFxuICAgICAgICAnc3ViKHgueCx5LngpLHN1Yih4LnkseS55KScpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5tdWwgPSBudW1lcmljLlRiaW5vcChcbiAgICAgICAgJ211bCh4LngseS54KScsXG4gICAgICAgICdtdWwoeC54LHkueCksbXVsKHgueCx5LnkpJyxcbiAgICAgICAgJ211bCh4LngseS54KSxtdWwoeC55LHkueCknLFxuICAgICAgICAnc3ViKG11bCh4LngseS54KSxtdWwoeC55LHkueSkpLGFkZChtdWwoeC54LHkueSksbXVsKHgueSx5LngpKScpO1xuXG5udW1lcmljLlQucHJvdG90eXBlLnJlY2lwcm9jYWwgPSBmdW5jdGlvbiByZWNpcHJvY2FsKCkge1xuICAgIHZhciBtdWwgPSBudW1lcmljLm11bCwgZGl2ID0gbnVtZXJpYy5kaXY7XG4gICAgaWYodGhpcy55KSB7XG4gICAgICAgIHZhciBkID0gbnVtZXJpYy5hZGQobXVsKHRoaXMueCx0aGlzLngpLG11bCh0aGlzLnksdGhpcy55KSk7XG4gICAgICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKGRpdih0aGlzLngsZCksZGl2KG51bWVyaWMubmVnKHRoaXMueSksZCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFQoZGl2KDEsdGhpcy54KSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdih5KSB7XG4gICAgaWYoISh5IGluc3RhbmNlb2YgbnVtZXJpYy5UKSkgeSA9IG5ldyBudW1lcmljLlQoeSk7XG4gICAgaWYoeS55KSB7IHJldHVybiB0aGlzLm11bCh5LnJlY2lwcm9jYWwoKSk7IH1cbiAgICB2YXIgZGl2ID0gbnVtZXJpYy5kaXY7XG4gICAgaWYodGhpcy55KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKGRpdih0aGlzLngseS54KSxkaXYodGhpcy55LHkueCkpOyB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoZGl2KHRoaXMueCx5LngpKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZG90ID0gbnVtZXJpYy5UYmlub3AoXG4gICAgICAgICdkb3QoeC54LHkueCknLFxuICAgICAgICAnZG90KHgueCx5LngpLGRvdCh4LngseS55KScsXG4gICAgICAgICdkb3QoeC54LHkueCksZG90KHgueSx5LngpJyxcbiAgICAgICAgJ3N1Yihkb3QoeC54LHkueCksZG90KHgueSx5LnkpKSxhZGQoZG90KHgueCx5LnkpLGRvdCh4LnkseS54KSknXG4gICAgICAgICk7XG5udW1lcmljLlQucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZSgpIHtcbiAgICB2YXIgdCA9IG51bWVyaWMudHJhbnNwb3NlLCB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIGlmKHkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQodCh4KSx0KHkpKTsgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHQoeCkpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS50cmFuc2p1Z2F0ZSA9IGZ1bmN0aW9uIHRyYW5zanVnYXRlKCkge1xuICAgIHZhciB0ID0gbnVtZXJpYy50cmFuc3Bvc2UsIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgaWYoeSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVCh0KHgpLG51bWVyaWMubmVndHJhbnNwb3NlKHkpKTsgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHQoeCkpO1xufVxubnVtZXJpYy5UdW5vcCA9IGZ1bmN0aW9uIFR1bm9wKHIsYyxzKSB7XG4gICAgaWYodHlwZW9mIHMgIT09IFwic3RyaW5nXCIpIHsgcyA9ICcnOyB9XG4gICAgcmV0dXJuIEZ1bmN0aW9uKFxuICAgICAgICAgICAgJ3ZhciB4ID0gdGhpcztcXG4nK1xuICAgICAgICAgICAgcysnXFxuJytcbiAgICAgICAgICAgICdpZih4LnkpIHsnK1xuICAgICAgICAgICAgJyAgJytjKyc7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgIHIrJztcXG4nXG4gICAgKTtcbn1cblxubnVtZXJpYy5ULnByb3RvdHlwZS5leHAgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQoZXgpJyxcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG11bChjb3MoeC55KSxleCksbXVsKHNpbih4LnkpLGV4KSknLFxuICAgICAgICAndmFyIGV4ID0gbnVtZXJpYy5leHAoeC54KSwgY29zID0gbnVtZXJpYy5jb3MsIHNpbiA9IG51bWVyaWMuc2luLCBtdWwgPSBudW1lcmljLm11bDsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuY29uaiA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVCh4LngpOycsXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVCh4LngsbnVtZXJpYy5uZWcoeC55KSk7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLm5lZyA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChuZWcoeC54KSk7JyxcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG5lZyh4LngpLG5lZyh4LnkpKTsnLFxuICAgICAgICAndmFyIG5lZyA9IG51bWVyaWMubmVnOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5zaW4gPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5zaW4oeC54KSknLFxuICAgICAgICAncmV0dXJuIHguZXhwKCkuc3ViKHgubmVnKCkuZXhwKCkpLmRpdihuZXcgbnVtZXJpYy5UKDAsMikpOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5jb3MgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5jb3MoeC54KSknLFxuICAgICAgICAncmV0dXJuIHguZXhwKCkuYWRkKHgubmVnKCkuZXhwKCkpLmRpdigyKTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuYWJzID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuYWJzKHgueCkpOycsXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLnNxcnQobnVtZXJpYy5hZGQobXVsKHgueCx4LngpLG11bCh4LnkseC55KSkpKTsnLFxuICAgICAgICAndmFyIG11bCA9IG51bWVyaWMubXVsOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5sb2cgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5sb2coeC54KSk7JyxcbiAgICAgICAgJ3ZhciB0aGV0YSA9IG5ldyBudW1lcmljLlQobnVtZXJpYy5hdGFuMih4LnkseC54KSksIHIgPSB4LmFicygpO1xcbicrXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmxvZyhyLngpLHRoZXRhLngpOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5ub3JtMiA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbnVtZXJpYy5ub3JtMih4LngpOycsXG4gICAgICAgICd2YXIgZiA9IG51bWVyaWMubm9ybTJTcXVhcmVkO1xcbicrXG4gICAgICAgICdyZXR1cm4gTWF0aC5zcXJ0KGYoeC54KStmKHgueSkpOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5pbnYgPSBmdW5jdGlvbiBpbnYoKSB7XG4gICAgdmFyIEEgPSB0aGlzO1xuICAgIGlmKHR5cGVvZiBBLnkgPT09IFwidW5kZWZpbmVkXCIpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5pbnYoQS54KSk7IH1cbiAgICB2YXIgbiA9IEEueC5sZW5ndGgsIGksIGosIGs7XG4gICAgdmFyIFJ4ID0gbnVtZXJpYy5pZGVudGl0eShuKSxSeSA9IG51bWVyaWMucmVwKFtuLG5dLDApO1xuICAgIHZhciBBeCA9IG51bWVyaWMuY2xvbmUoQS54KSwgQXkgPSBudW1lcmljLmNsb25lKEEueSk7XG4gICAgdmFyIEFpeCwgQWl5LCBBangsIEFqeSwgUml4LCBSaXksIFJqeCwgUmp5O1xuICAgIHZhciBpLGosayxkLGQxLGF4LGF5LGJ4LGJ5LHRlbXA7XG4gICAgZm9yKGk9MDtpPG47aSsrKSB7XG4gICAgICAgIGF4ID0gQXhbaV1baV07IGF5ID0gQXlbaV1baV07XG4gICAgICAgIGQgPSBheCpheCtheSpheTtcbiAgICAgICAgayA9IGk7XG4gICAgICAgIGZvcihqPWkrMTtqPG47aisrKSB7XG4gICAgICAgICAgICBheCA9IEF4W2pdW2ldOyBheSA9IEF5W2pdW2ldO1xuICAgICAgICAgICAgZDEgPSBheCpheCtheSpheTtcbiAgICAgICAgICAgIGlmKGQxID4gZCkgeyBrPWo7IGQgPSBkMTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGshPT1pKSB7XG4gICAgICAgICAgICB0ZW1wID0gQXhbaV07IEF4W2ldID0gQXhba107IEF4W2tdID0gdGVtcDtcbiAgICAgICAgICAgIHRlbXAgPSBBeVtpXTsgQXlbaV0gPSBBeVtrXTsgQXlba10gPSB0ZW1wO1xuICAgICAgICAgICAgdGVtcCA9IFJ4W2ldOyBSeFtpXSA9IFJ4W2tdOyBSeFtrXSA9IHRlbXA7XG4gICAgICAgICAgICB0ZW1wID0gUnlbaV07IFJ5W2ldID0gUnlba107IFJ5W2tdID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBBaXggPSBBeFtpXTsgQWl5ID0gQXlbaV07XG4gICAgICAgIFJpeCA9IFJ4W2ldOyBSaXkgPSBSeVtpXTtcbiAgICAgICAgYXggPSBBaXhbaV07IGF5ID0gQWl5W2ldO1xuICAgICAgICBmb3Ioaj1pKzE7ajxuO2orKykge1xuICAgICAgICAgICAgYnggPSBBaXhbal07IGJ5ID0gQWl5W2pdO1xuICAgICAgICAgICAgQWl4W2pdID0gKGJ4KmF4K2J5KmF5KS9kO1xuICAgICAgICAgICAgQWl5W2pdID0gKGJ5KmF4LWJ4KmF5KS9kO1xuICAgICAgICB9XG4gICAgICAgIGZvcihqPTA7ajxuO2orKykge1xuICAgICAgICAgICAgYnggPSBSaXhbal07IGJ5ID0gUml5W2pdO1xuICAgICAgICAgICAgUml4W2pdID0gKGJ4KmF4K2J5KmF5KS9kO1xuICAgICAgICAgICAgUml5W2pdID0gKGJ5KmF4LWJ4KmF5KS9kO1xuICAgICAgICB9XG4gICAgICAgIGZvcihqPWkrMTtqPG47aisrKSB7XG4gICAgICAgICAgICBBanggPSBBeFtqXTsgQWp5ID0gQXlbal07XG4gICAgICAgICAgICBSanggPSBSeFtqXTsgUmp5ID0gUnlbal07XG4gICAgICAgICAgICBheCA9IEFqeFtpXTsgYXkgPSBBanlbaV07XG4gICAgICAgICAgICBmb3Ioaz1pKzE7azxuO2srKykge1xuICAgICAgICAgICAgICAgIGJ4ID0gQWl4W2tdOyBieSA9IEFpeVtrXTtcbiAgICAgICAgICAgICAgICBBanhba10gLT0gYngqYXgtYnkqYXk7XG4gICAgICAgICAgICAgICAgQWp5W2tdIC09IGJ5KmF4K2J4KmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKGs9MDtrPG47aysrKSB7XG4gICAgICAgICAgICAgICAgYnggPSBSaXhba107IGJ5ID0gUml5W2tdO1xuICAgICAgICAgICAgICAgIFJqeFtrXSAtPSBieCpheC1ieSpheTtcbiAgICAgICAgICAgICAgICBSanlba10gLT0gYnkqYXgrYngqYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGk9bi0xO2k+MDtpLS0pIHtcbiAgICAgICAgUml4ID0gUnhbaV07IFJpeSA9IFJ5W2ldO1xuICAgICAgICBmb3Ioaj1pLTE7aj49MDtqLS0pIHtcbiAgICAgICAgICAgIFJqeCA9IFJ4W2pdOyBSankgPSBSeVtqXTtcbiAgICAgICAgICAgIGF4ID0gQXhbal1baV07IGF5ID0gQXlbal1baV07XG4gICAgICAgICAgICBmb3Ioaz1uLTE7az49MDtrLS0pIHtcbiAgICAgICAgICAgICAgICBieCA9IFJpeFtrXTsgYnkgPSBSaXlba107XG4gICAgICAgICAgICAgICAgUmp4W2tdIC09IGF4KmJ4IC0gYXkqYnk7XG4gICAgICAgICAgICAgICAgUmp5W2tdIC09IGF4KmJ5ICsgYXkqYng7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoUngsUnkpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCBrID0gMCwgaWssIG4gPSBpLmxlbmd0aDtcbiAgICBpZih5KSB7XG4gICAgICAgIHdoaWxlKGs8bikge1xuICAgICAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICAgICAgeSA9IHlbaWtdO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHgseSk7XG4gICAgfVxuICAgIHdoaWxlKGs8bikge1xuICAgICAgICBpayA9IGlba107XG4gICAgICAgIHggPSB4W2lrXTtcbiAgICAgICAgaysrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh4KTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGksdikge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCBrID0gMCwgaWssIG4gPSBpLmxlbmd0aCwgdnggPSB2LngsIHZ5ID0gdi55O1xuICAgIGlmKG49PT0wKSB7XG4gICAgICAgIGlmKHZ5KSB7IHRoaXMueSA9IHZ5OyB9XG4gICAgICAgIGVsc2UgaWYoeSkgeyB0aGlzLnkgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmKHZ5KSB7XG4gICAgICAgIGlmKHkpIHsgLyogb2sgKi8gfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHkgPSBudW1lcmljLnJlcChudW1lcmljLmRpbSh4KSwwKTtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoazxuLTEpIHtcbiAgICAgICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgICAgIHggPSB4W2lrXTtcbiAgICAgICAgICAgIHkgPSB5W2lrXTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICBpayA9IGlba107XG4gICAgICAgIHhbaWtdID0gdng7XG4gICAgICAgIHlbaWtdID0gdnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZih5KSB7XG4gICAgICAgIHdoaWxlKGs8bi0xKSB7XG4gICAgICAgICAgICBpayA9IGlba107XG4gICAgICAgICAgICB4ID0geFtpa107XG4gICAgICAgICAgICB5ID0geVtpa107XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4W2lrXSA9IHZ4O1xuICAgICAgICBpZih2eCBpbnN0YW5jZW9mIEFycmF5KSB5W2lrXSA9IG51bWVyaWMucmVwKG51bWVyaWMuZGltKHZ4KSwwKTtcbiAgICAgICAgZWxzZSB5W2lrXSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aGlsZShrPG4tMSkge1xuICAgICAgICBpayA9IGlba107XG4gICAgICAgIHggPSB4W2lrXTtcbiAgICAgICAgaysrO1xuICAgIH1cbiAgICBpayA9IGlba107XG4gICAgeFtpa10gPSB2eDtcbiAgICByZXR1cm4gdGhpcztcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0Um93cyA9IGZ1bmN0aW9uIGdldFJvd3MoaTAsaTEpIHtcbiAgICB2YXIgbiA9IGkxLWkwKzEsIGo7XG4gICAgdmFyIHJ4ID0gQXJyYXkobiksIHJ5LCB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIGZvcihqPWkwO2o8PWkxO2orKykgeyByeFtqLWkwXSA9IHhbal07IH1cbiAgICBpZih5KSB7XG4gICAgICAgIHJ5ID0gQXJyYXkobik7XG4gICAgICAgIGZvcihqPWkwO2o8PWkxO2orKykgeyByeVtqLWkwXSA9IHlbal07IH1cbiAgICAgICAgcmV0dXJuIG5ldyBudW1lcmljLlQocngscnkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVChyeCk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLnNldFJvd3MgPSBmdW5jdGlvbiBzZXRSb3dzKGkwLGkxLEEpIHtcbiAgICB2YXIgajtcbiAgICB2YXIgcnggPSB0aGlzLngsIHJ5ID0gdGhpcy55LCB4ID0gQS54LCB5ID0gQS55O1xuICAgIGZvcihqPWkwO2o8PWkxO2orKykgeyByeFtqXSA9IHhbai1pMF07IH1cbiAgICBpZih5KSB7XG4gICAgICAgIGlmKCFyeSkgeyByeSA9IG51bWVyaWMucmVwKG51bWVyaWMuZGltKHJ4KSwwKTsgdGhpcy55ID0gcnk7IH1cbiAgICAgICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ5W2pdID0geVtqLWkwXTsgfVxuICAgIH0gZWxzZSBpZihyeSkge1xuICAgICAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnlbal0gPSBudW1lcmljLnJlcChbeFtqLWkwXS5sZW5ndGhdLDApOyB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiBnZXRSb3coaykge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIGlmKHkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQoeFtrXSx5W2tdKTsgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHhba10pO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5zZXRSb3cgPSBmdW5jdGlvbiBzZXRSb3coaSx2KSB7XG4gICAgdmFyIHJ4ID0gdGhpcy54LCByeSA9IHRoaXMueSwgeCA9IHYueCwgeSA9IHYueTtcbiAgICByeFtpXSA9IHg7XG4gICAgaWYoeSkge1xuICAgICAgICBpZighcnkpIHsgcnkgPSBudW1lcmljLnJlcChudW1lcmljLmRpbShyeCksMCk7IHRoaXMueSA9IHJ5OyB9XG4gICAgICAgIHJ5W2ldID0geTtcbiAgICB9IGVsc2UgaWYocnkpIHtcbiAgICAgICAgcnkgPSBudW1lcmljLnJlcChbeC5sZW5ndGhdLDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxubnVtZXJpYy5ULnByb3RvdHlwZS5nZXRCbG9jayA9IGZ1bmN0aW9uIGdldEJsb2NrKGZyb20sdG8pIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgYiA9IG51bWVyaWMuZ2V0QmxvY2s7XG4gICAgaWYoeSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVChiKHgsZnJvbSx0byksYih5LGZyb20sdG8pKTsgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKGIoeCxmcm9tLHRvKSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLnNldEJsb2NrID0gZnVuY3Rpb24gc2V0QmxvY2soZnJvbSx0byxBKSB7XG4gICAgaWYoIShBIGluc3RhbmNlb2YgbnVtZXJpYy5UKSkgQSA9IG5ldyBudW1lcmljLlQoQSk7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIGIgPSBudW1lcmljLnNldEJsb2NrLCBBeCA9IEEueCwgQXkgPSBBLnk7XG4gICAgaWYoQXkpIHtcbiAgICAgICAgaWYoIXkpIHsgdGhpcy55ID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0odGhpcyksMCk7IHkgPSB0aGlzLnk7IH1cbiAgICAgICAgYih4LGZyb20sdG8sQXgpO1xuICAgICAgICBiKHksZnJvbSx0byxBeSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBiKHgsZnJvbSx0byxBeCk7XG4gICAgaWYoeSkgYih5LGZyb20sdG8sbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0oQXgpLDApKTtcbn1cbm51bWVyaWMuVC5yZXAgPSBmdW5jdGlvbiByZXAocyx2KSB7XG4gICAgdmFyIFQgPSBudW1lcmljLlQ7XG4gICAgaWYoISh2IGluc3RhbmNlb2YgVCkpIHYgPSBuZXcgVCh2KTtcbiAgICB2YXIgeCA9IHYueCwgeSA9IHYueSwgciA9IG51bWVyaWMucmVwO1xuICAgIGlmKHkpIHJldHVybiBuZXcgVChyKHMseCkscihzLHkpKTtcbiAgICByZXR1cm4gbmV3IFQocihzLHgpKTtcbn1cbm51bWVyaWMuVC5kaWFnID0gZnVuY3Rpb24gZGlhZyhkKSB7XG4gICAgaWYoIShkIGluc3RhbmNlb2YgbnVtZXJpYy5UKSkgZCA9IG5ldyBudW1lcmljLlQoZCk7XG4gICAgdmFyIHggPSBkLngsIHkgPSBkLnksIGRpYWcgPSBudW1lcmljLmRpYWc7XG4gICAgaWYoeSkgcmV0dXJuIG5ldyBudW1lcmljLlQoZGlhZyh4KSxkaWFnKHkpKTtcbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVChkaWFnKHgpKTtcbn1cbm51bWVyaWMuVC5laWcgPSBmdW5jdGlvbiBlaWcoKSB7XG4gICAgaWYodGhpcy55KSB7IHRocm93IG5ldyBFcnJvcignZWlnOiBub3QgaW1wbGVtZW50ZWQgZm9yIGNvbXBsZXggbWF0cmljZXMuJyk7IH1cbiAgICByZXR1cm4gbnVtZXJpYy5laWcodGhpcy54KTtcbn1cbm51bWVyaWMuVC5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KG4pIHsgcmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5pZGVudGl0eShuKSk7IH1cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0RGlhZyA9IGZ1bmN0aW9uIGdldERpYWcoKSB7XG4gICAgdmFyIG4gPSBudW1lcmljO1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIGlmKHkpIHsgcmV0dXJuIG5ldyBuLlQobi5nZXREaWFnKHgpLG4uZ2V0RGlhZyh5KSk7IH1cbiAgICByZXR1cm4gbmV3IG4uVChuLmdldERpYWcoeCkpO1xufVxuXG4vLyA0LiBFaWdlbnZhbHVlcyBvZiByZWFsIG1hdHJpY2VzXG5cbm51bWVyaWMuaG91c2UgPSBmdW5jdGlvbiBob3VzZSh4KSB7XG4gICAgdmFyIHYgPSBudW1lcmljLmNsb25lKHgpO1xuICAgIHZhciBzID0geFswXSA+PSAwID8gMSA6IC0xO1xuICAgIHZhciBhbHBoYSA9IHMqbnVtZXJpYy5ub3JtMih4KTtcbiAgICB2WzBdICs9IGFscGhhO1xuICAgIHZhciBmb28gPSBudW1lcmljLm5vcm0yKHYpO1xuICAgIGlmKGZvbyA9PT0gMCkgeyAvKiB0aGlzIHNob3VsZCBub3QgaGFwcGVuICovIHRocm93IG5ldyBFcnJvcignZWlnOiBpbnRlcm5hbCBlcnJvcicpOyB9XG4gICAgcmV0dXJuIG51bWVyaWMuZGl2KHYsZm9vKTtcbn1cblxubnVtZXJpYy50b1VwcGVySGVzc2VuYmVyZyA9IGZ1bmN0aW9uIHRvVXBwZXJIZXNzZW5iZXJnKG1lKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbShtZSk7XG4gICAgaWYocy5sZW5ndGggIT09IDIgfHwgc1swXSAhPT0gc1sxXSkgeyB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWM6IHRvVXBwZXJIZXNzZW5iZXJnKCkgb25seSB3b3JrcyBvbiBzcXVhcmUgbWF0cmljZXMnKTsgfVxuICAgIHZhciBtID0gc1swXSwgaSxqLGsseCx2LEEgPSBudW1lcmljLmNsb25lKG1lKSxCLEMsQWksQ2ksUSA9IG51bWVyaWMuaWRlbnRpdHkobSksUWk7XG4gICAgZm9yKGo9MDtqPG0tMjtqKyspIHtcbiAgICAgICAgeCA9IEFycmF5KG0tai0xKTtcbiAgICAgICAgZm9yKGk9aisxO2k8bTtpKyspIHsgeFtpLWotMV0gPSBBW2ldW2pdOyB9XG4gICAgICAgIGlmKG51bWVyaWMubm9ybTIoeCk+MCkge1xuICAgICAgICAgICAgdiA9IG51bWVyaWMuaG91c2UoeCk7XG4gICAgICAgICAgICBCID0gbnVtZXJpYy5nZXRCbG9jayhBLFtqKzEsal0sW20tMSxtLTFdKTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcih2LG51bWVyaWMuZG90KHYsQikpO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8bTtpKyspIHsgQWkgPSBBW2ldOyBDaSA9IENbaS1qLTFdOyBmb3Ioaz1qO2s8bTtrKyspIEFpW2tdIC09IDIqQ2lbay1qXTsgfVxuICAgICAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soQSxbMCxqKzFdLFttLTEsbS0xXSk7XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IobnVtZXJpYy5kb3QoQix2KSx2KTtcbiAgICAgICAgICAgIGZvcihpPTA7aTxtO2krKykgeyBBaSA9IEFbaV07IENpID0gQ1tpXTsgZm9yKGs9aisxO2s8bTtrKyspIEFpW2tdIC09IDIqQ2lbay1qLTFdOyB9XG4gICAgICAgICAgICBCID0gQXJyYXkobS1qLTEpO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8bTtpKyspIEJbaS1qLTFdID0gUVtpXTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcih2LG51bWVyaWMuZG90KHYsQikpO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8bTtpKyspIHsgUWkgPSBRW2ldOyBDaSA9IENbaS1qLTFdOyBmb3Ioaz0wO2s8bTtrKyspIFFpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge0g6QSwgUTpRfTtcbn1cblxubnVtZXJpYy5lcHNpbG9uID0gMi4yMjA0NDYwNDkyNTAzMTNlLTE2O1xuXG5udW1lcmljLlFSRnJhbmNpcyA9IGZ1bmN0aW9uKEgsbWF4aXRlcikge1xuICAgIGlmKHR5cGVvZiBtYXhpdGVyID09PSBcInVuZGVmaW5lZFwiKSB7IG1heGl0ZXIgPSAxMDAwMDsgfVxuICAgIEggPSBudW1lcmljLmNsb25lKEgpO1xuICAgIHZhciBIMCA9IG51bWVyaWMuY2xvbmUoSCk7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbShIKSxtPXNbMF0seCx2LGEsYixjLGQsZGV0LHRyLCBIbG9jLCBRID0gbnVtZXJpYy5pZGVudGl0eShtKSwgUWksIEhpLCBCLCBDLCBDaSxpLGosayxpdGVyO1xuICAgIGlmKG08MykgeyByZXR1cm4ge1E6USwgQjpbIFswLG0tMV0gXX07IH1cbiAgICB2YXIgZXBzaWxvbiA9IG51bWVyaWMuZXBzaWxvbjtcbiAgICBmb3IoaXRlcj0wO2l0ZXI8bWF4aXRlcjtpdGVyKyspIHtcbiAgICAgICAgZm9yKGo9MDtqPG0tMTtqKyspIHtcbiAgICAgICAgICAgIGlmKE1hdGguYWJzKEhbaisxXVtqXSkgPCBlcHNpbG9uKihNYXRoLmFicyhIW2pdW2pdKStNYXRoLmFicyhIW2orMV1baisxXSkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIFFIMSA9IG51bWVyaWMuUVJGcmFuY2lzKG51bWVyaWMuZ2V0QmxvY2soSCxbMCwwXSxbaixqXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgdmFyIFFIMiA9IG51bWVyaWMuUVJGcmFuY2lzKG51bWVyaWMuZ2V0QmxvY2soSCxbaisxLGorMV0sW20tMSxtLTFdKSxtYXhpdGVyKTtcbiAgICAgICAgICAgICAgICBCID0gQXJyYXkoaisxKTtcbiAgICAgICAgICAgICAgICBmb3IoaT0wO2k8PWo7aSsrKSB7IEJbaV0gPSBRW2ldOyB9XG4gICAgICAgICAgICAgICAgQyA9IG51bWVyaWMuZG90KFFIMS5RLEIpO1xuICAgICAgICAgICAgICAgIGZvcihpPTA7aTw9ajtpKyspIHsgUVtpXSA9IENbaV07IH1cbiAgICAgICAgICAgICAgICBCID0gQXJyYXkobS1qLTEpO1xuICAgICAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IEJbaS1qLTFdID0gUVtpXTsgfVxuICAgICAgICAgICAgICAgIEMgPSBudW1lcmljLmRvdChRSDIuUSxCKTtcbiAgICAgICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyBRW2ldID0gQ1tpLWotMV07IH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1E6USxCOlFIMS5CLmNvbmNhdChudW1lcmljLmFkZChRSDIuQixqKzEpKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYSA9IEhbbS0yXVttLTJdOyBiID0gSFttLTJdW20tMV07XG4gICAgICAgIGMgPSBIW20tMV1bbS0yXTsgZCA9IEhbbS0xXVttLTFdO1xuICAgICAgICB0ciA9IGErZDtcbiAgICAgICAgZGV0ID0gKGEqZC1iKmMpO1xuICAgICAgICBIbG9jID0gbnVtZXJpYy5nZXRCbG9jayhILCBbMCwwXSwgWzIsMl0pO1xuICAgICAgICBpZih0cip0cj49NCpkZXQpIHtcbiAgICAgICAgICAgIHZhciBzMSxzMjtcbiAgICAgICAgICAgIHMxID0gMC41Kih0citNYXRoLnNxcnQodHIqdHItNCpkZXQpKTtcbiAgICAgICAgICAgIHMyID0gMC41Kih0ci1NYXRoLnNxcnQodHIqdHItNCpkZXQpKTtcbiAgICAgICAgICAgIEhsb2MgPSBudW1lcmljLmFkZChudW1lcmljLnN1YihudW1lcmljLmRvdChIbG9jLEhsb2MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMubXVsKEhsb2MsczErczIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljLmRpYWcobnVtZXJpYy5yZXAoWzNdLHMxKnMyKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgSGxvYyA9IG51bWVyaWMuYWRkKG51bWVyaWMuc3ViKG51bWVyaWMuZG90KEhsb2MsSGxvYyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYy5tdWwoSGxvYyx0cikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMuZGlhZyhudW1lcmljLnJlcChbM10sZGV0KSkpO1xuICAgICAgICB9XG4gICAgICAgIHggPSBbSGxvY1swXVswXSxIbG9jWzFdWzBdLEhsb2NbMl1bMF1dO1xuICAgICAgICB2ID0gbnVtZXJpYy5ob3VzZSh4KTtcbiAgICAgICAgQiA9IFtIWzBdLEhbMV0sSFsyXV07XG4gICAgICAgIEMgPSBudW1lcmljLnRlbnNvcih2LG51bWVyaWMuZG90KHYsQikpO1xuICAgICAgICBmb3IoaT0wO2k8MztpKyspIHsgSGkgPSBIW2ldOyBDaSA9IENbaV07IGZvcihrPTA7azxtO2srKykgSGlba10gLT0gMipDaVtrXTsgfVxuICAgICAgICBCID0gbnVtZXJpYy5nZXRCbG9jayhILCBbMCwwXSxbbS0xLDJdKTtcbiAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKG51bWVyaWMuZG90KEIsdiksdik7XG4gICAgICAgIGZvcihpPTA7aTxtO2krKykgeyBIaSA9IEhbaV07IENpID0gQ1tpXTsgZm9yKGs9MDtrPDM7aysrKSBIaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIEIgPSBbUVswXSxRWzFdLFFbMl1dO1xuICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgZm9yKGk9MDtpPDM7aSsrKSB7IFFpID0gUVtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz0wO2s8bTtrKyspIFFpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgdmFyIEo7XG4gICAgICAgIGZvcihqPTA7ajxtLTI7aisrKSB7XG4gICAgICAgICAgICBmb3Ioaz1qO2s8PWorMTtrKyspIHtcbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhIW2srMV1ba10pIDwgZXBzaWxvbiooTWF0aC5hYnMoSFtrXVtrXSkrTWF0aC5hYnMoSFtrKzFdW2srMV0pKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgUUgxID0gbnVtZXJpYy5RUkZyYW5jaXMobnVtZXJpYy5nZXRCbG9jayhILFswLDBdLFtrLGtdKSxtYXhpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFFIMiA9IG51bWVyaWMuUVJGcmFuY2lzKG51bWVyaWMuZ2V0QmxvY2soSCxbaysxLGsrMV0sW20tMSxtLTFdKSxtYXhpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgQiA9IEFycmF5KGsrMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcihpPTA7aTw9aztpKyspIHsgQltpXSA9IFFbaV07IH1cbiAgICAgICAgICAgICAgICAgICAgQyA9IG51bWVyaWMuZG90KFFIMS5RLEIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wO2k8PWs7aSsrKSB7IFFbaV0gPSBDW2ldOyB9XG4gICAgICAgICAgICAgICAgICAgIEIgPSBBcnJheShtLWstMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcihpPWsrMTtpPG07aSsrKSB7IEJbaS1rLTFdID0gUVtpXTsgfVxuICAgICAgICAgICAgICAgICAgICBDID0gbnVtZXJpYy5kb3QoUUgyLlEsQik7XG4gICAgICAgICAgICAgICAgICAgIGZvcihpPWsrMTtpPG07aSsrKSB7IFFbaV0gPSBDW2ktay0xXTsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1E6USxCOlFIMS5CLmNvbmNhdChudW1lcmljLmFkZChRSDIuQixrKzEpKX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSiA9IE1hdGgubWluKG0tMSxqKzMpO1xuICAgICAgICAgICAgeCA9IEFycmF5KEotaik7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTw9SjtpKyspIHsgeFtpLWotMV0gPSBIW2ldW2pdOyB9XG4gICAgICAgICAgICB2ID0gbnVtZXJpYy5ob3VzZSh4KTtcbiAgICAgICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEgsIFtqKzEsal0sW0osbS0xXSk7XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPD1KO2krKykgeyBIaSA9IEhbaV07IENpID0gQ1tpLWotMV07IGZvcihrPWo7azxtO2srKykgSGlba10gLT0gMipDaVtrLWpdOyB9XG4gICAgICAgICAgICBCID0gbnVtZXJpYy5nZXRCbG9jayhILCBbMCxqKzFdLFttLTEsSl0pO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKG51bWVyaWMuZG90KEIsdiksdik7XG4gICAgICAgICAgICBmb3IoaT0wO2k8bTtpKyspIHsgSGkgPSBIW2ldOyBDaSA9IENbaV07IGZvcihrPWorMTtrPD1KO2srKykgSGlba10gLT0gMipDaVtrLWotMV07IH1cbiAgICAgICAgICAgIEIgPSBBcnJheShKLWopO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8PUo7aSsrKSBCW2ktai0xXSA9IFFbaV07XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPD1KO2krKykgeyBRaSA9IFFbaV07IENpID0gQ1tpLWotMV07IGZvcihrPTA7azxtO2srKykgUWlba10gLT0gMipDaVtrXTsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignbnVtZXJpYzogZWlnZW52YWx1ZSBpdGVyYXRpb24gZG9lcyBub3QgY29udmVyZ2UgLS0gaW5jcmVhc2UgbWF4aXRlcj8nKTtcbn1cblxubnVtZXJpYy5laWcgPSBmdW5jdGlvbiBlaWcoQSxtYXhpdGVyKSB7XG4gICAgdmFyIFFIID0gbnVtZXJpYy50b1VwcGVySGVzc2VuYmVyZyhBKTtcbiAgICB2YXIgUUIgPSBudW1lcmljLlFSRnJhbmNpcyhRSC5ILG1heGl0ZXIpO1xuICAgIHZhciBUID0gbnVtZXJpYy5UO1xuICAgIHZhciBuID0gQS5sZW5ndGgsaSxrLGZsYWcgPSBmYWxzZSxCID0gUUIuQixIID0gbnVtZXJpYy5kb3QoUUIuUSxudW1lcmljLmRvdChRSC5ILG51bWVyaWMudHJhbnNwb3NlKFFCLlEpKSk7XG4gICAgdmFyIFEgPSBuZXcgVChudW1lcmljLmRvdChRQi5RLFFILlEpKSxRMDtcbiAgICB2YXIgbSA9IEIubGVuZ3RoLGo7XG4gICAgdmFyIGEsYixjLGQscDEscDIsZGlzYyx4LHkscCxxLG4xLG4yO1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIGZvcihrPTA7azxtO2srKykge1xuICAgICAgICBpID0gQltrXVswXTtcbiAgICAgICAgaWYoaSA9PT0gQltrXVsxXSkge1xuICAgICAgICAgICAgLy8gbm90aGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaiA9IGkrMTtcbiAgICAgICAgICAgIGEgPSBIW2ldW2ldO1xuICAgICAgICAgICAgYiA9IEhbaV1bal07XG4gICAgICAgICAgICBjID0gSFtqXVtpXTtcbiAgICAgICAgICAgIGQgPSBIW2pdW2pdO1xuICAgICAgICAgICAgaWYoYiA9PT0gMCAmJiBjID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIHAxID0gLWEtZDtcbiAgICAgICAgICAgIHAyID0gYSpkLWIqYztcbiAgICAgICAgICAgIGRpc2MgPSBwMSpwMS00KnAyO1xuICAgICAgICAgICAgaWYoZGlzYz49MCkge1xuICAgICAgICAgICAgICAgIGlmKHAxPDApIHggPSAtMC41KihwMS1zcXJ0KGRpc2MpKTtcbiAgICAgICAgICAgICAgICBlbHNlICAgICB4ID0gLTAuNSoocDErc3FydChkaXNjKSk7XG4gICAgICAgICAgICAgICAgbjEgPSAoYS14KSooYS14KStiKmI7XG4gICAgICAgICAgICAgICAgbjIgPSBjKmMrKGQteCkqKGQteCk7XG4gICAgICAgICAgICAgICAgaWYobjE+bjIpIHtcbiAgICAgICAgICAgICAgICAgICAgbjEgPSBzcXJ0KG4xKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IChhLXgpL24xO1xuICAgICAgICAgICAgICAgICAgICBxID0gYi9uMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuMiA9IHNxcnQobjIpO1xuICAgICAgICAgICAgICAgICAgICBwID0gYy9uMjtcbiAgICAgICAgICAgICAgICAgICAgcSA9IChkLXgpL24yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBRMCA9IG5ldyBUKFtbcSwtcF0sW3AscV1dKTtcbiAgICAgICAgICAgICAgICBRLnNldFJvd3MoaSxqLFEwLmRvdChRLmdldFJvd3MoaSxqKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gLTAuNSpwMTtcbiAgICAgICAgICAgICAgICB5ID0gMC41KnNxcnQoLWRpc2MpO1xuICAgICAgICAgICAgICAgIG4xID0gKGEteCkqKGEteCkrYipiO1xuICAgICAgICAgICAgICAgIG4yID0gYypjKyhkLXgpKihkLXgpO1xuICAgICAgICAgICAgICAgIGlmKG4xPm4yKSB7XG4gICAgICAgICAgICAgICAgICAgIG4xID0gc3FydChuMSt5KnkpO1xuICAgICAgICAgICAgICAgICAgICBwID0gKGEteCkvbjE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBiL24xO1xuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgeSAvPSBuMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuMiA9IHNxcnQobjIreSp5KTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGMvbjI7XG4gICAgICAgICAgICAgICAgICAgIHEgPSAoZC14KS9uMjtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHkvbjI7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBRMCA9IG5ldyBUKFtbcSwtcF0sW3AscV1dLFtbeCx5XSxbeSwteF1dKTtcbiAgICAgICAgICAgICAgICBRLnNldFJvd3MoaSxqLFEwLmRvdChRLmdldFJvd3MoaSxqKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBSID0gUS5kb3QoQSkuZG90KFEudHJhbnNqdWdhdGUoKSksIG4gPSBBLmxlbmd0aCwgRSA9IG51bWVyaWMuVC5pZGVudGl0eShuKTtcbiAgICBmb3Ioaj0wO2o8bjtqKyspIHtcbiAgICAgICAgaWYoaj4wKSB7XG4gICAgICAgICAgICBmb3Ioaz1qLTE7az49MDtrLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgUmsgPSBSLmdldChbayxrXSksIFJqID0gUi5nZXQoW2osal0pO1xuICAgICAgICAgICAgICAgIGlmKG51bWVyaWMubmVxKFJrLngsUmoueCkgfHwgbnVtZXJpYy5uZXEoUmsueSxSai55KSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gUi5nZXRSb3coaykuZ2V0QmxvY2soW2tdLFtqLTFdKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IEUuZ2V0Um93KGopLmdldEJsb2NrKFtrXSxbai0xXSk7XG4gICAgICAgICAgICAgICAgICAgIEUuc2V0KFtqLGtdLChSLmdldChbayxqXSkubmVnKCkuc3ViKHguZG90KHkpKSkuZGl2KFJrLnN1YihSaikpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBFLnNldFJvdyhqLEUuZ2V0Um93KGspKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihqPTA7ajxuO2orKykge1xuICAgICAgICB4ID0gRS5nZXRSb3coaik7XG4gICAgICAgIEUuc2V0Um93KGoseC5kaXYoeC5ub3JtMigpKSk7XG4gICAgfVxuICAgIEUgPSBFLnRyYW5zcG9zZSgpO1xuICAgIEUgPSBRLnRyYW5zanVnYXRlKCkuZG90KEUpO1xuICAgIHJldHVybiB7IGxhbWJkYTpSLmdldERpYWcoKSwgRTpFIH07XG59O1xuXG4vLyA1LiBDb21wcmVzc2VkIENvbHVtbiBTdG9yYWdlIG1hdHJpY2VzXG5udW1lcmljLmNjc1NwYXJzZSA9IGZ1bmN0aW9uIGNjc1NwYXJzZShBKSB7XG4gICAgdmFyIG0gPSBBLmxlbmd0aCxuLGZvbywgaSxqLCBjb3VudHMgPSBbXTtcbiAgICBmb3IoaT1tLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBmb28gPSBBW2ldO1xuICAgICAgICBmb3IoaiBpbiBmb28pIHtcbiAgICAgICAgICAgIGogPSBwYXJzZUludChqKTtcbiAgICAgICAgICAgIHdoaWxlKGo+PWNvdW50cy5sZW5ndGgpIGNvdW50c1tjb3VudHMubGVuZ3RoXSA9IDA7XG4gICAgICAgICAgICBpZihmb29bal0hPT0wKSBjb3VudHNbal0rKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbiA9IGNvdW50cy5sZW5ndGg7XG4gICAgdmFyIEFpID0gQXJyYXkobisxKTtcbiAgICBBaVswXSA9IDA7XG4gICAgZm9yKGk9MDtpPG47KytpKSBBaVtpKzFdID0gQWlbaV0gKyBjb3VudHNbaV07XG4gICAgdmFyIEFqID0gQXJyYXkoQWlbbl0pLCBBdiA9IEFycmF5KEFpW25dKTtcbiAgICBmb3IoaT1tLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBmb28gPSBBW2ldO1xuICAgICAgICBmb3IoaiBpbiBmb28pIHtcbiAgICAgICAgICAgIGlmKGZvb1tqXSE9PTApIHtcbiAgICAgICAgICAgICAgICBjb3VudHNbal0tLTtcbiAgICAgICAgICAgICAgICBBaltBaVtqXStjb3VudHNbal1dID0gaTtcbiAgICAgICAgICAgICAgICBBdltBaVtqXStjb3VudHNbal1dID0gZm9vW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbQWksQWosQXZdO1xufVxubnVtZXJpYy5jY3NGdWxsID0gZnVuY3Rpb24gY2NzRnVsbChBKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl0sIHMgPSBudW1lcmljLmNjc0RpbShBKSwgbSA9IHNbMF0sIG4gPSBzWzFdLCBpLGosajAsajEsaztcbiAgICB2YXIgQiA9IG51bWVyaWMucmVwKFttLG5dLDApO1xuICAgIGZvcihpPTA7aTxuO2krKykge1xuICAgICAgICBqMCA9IEFpW2ldO1xuICAgICAgICBqMSA9IEFpW2krMV07XG4gICAgICAgIGZvcihqPWowO2o8ajE7KytqKSB7IEJbQWpbal1dW2ldID0gQXZbal07IH1cbiAgICB9XG4gICAgcmV0dXJuIEI7XG59XG5udW1lcmljLmNjc1RTb2x2ZSA9IGZ1bmN0aW9uIGNjc1RTb2x2ZShBLGIseCxiaix4aikge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdLG0gPSBBaS5sZW5ndGgtMSwgbWF4ID0gTWF0aC5tYXgsbj0wO1xuICAgIGlmKHR5cGVvZiBiaiA9PT0gXCJ1bmRlZmluZWRcIikgeCA9IG51bWVyaWMucmVwKFttXSwwKTtcbiAgICBpZih0eXBlb2YgYmogPT09IFwidW5kZWZpbmVkXCIpIGJqID0gbnVtZXJpYy5saW5zcGFjZSgwLHgubGVuZ3RoLTEpO1xuICAgIGlmKHR5cGVvZiB4aiA9PT0gXCJ1bmRlZmluZWRcIikgeGogPSBbXTtcbiAgICBmdW5jdGlvbiBkZnMoaikge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgaWYoeFtqXSAhPT0gMCkgcmV0dXJuO1xuICAgICAgICB4W2pdID0gMTtcbiAgICAgICAgZm9yKGs9QWlbal07azxBaVtqKzFdOysraykgZGZzKEFqW2tdKTtcbiAgICAgICAgeGpbbl0gPSBqO1xuICAgICAgICArK247XG4gICAgfVxuICAgIHZhciBpLGosajAsajEsayxsLGwwLGwxLGE7XG4gICAgZm9yKGk9YmoubGVuZ3RoLTE7aSE9PS0xOy0taSkgeyBkZnMoYmpbaV0pOyB9XG4gICAgeGoubGVuZ3RoID0gbjtcbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IHhbeGpbaV1dID0gMDsgfVxuICAgIGZvcihpPWJqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgaiA9IGJqW2ldOyB4W2pdID0gYltqXTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgaiA9IHhqW2ldO1xuICAgICAgICBqMCA9IEFpW2pdO1xuICAgICAgICBqMSA9IG1heChBaVtqKzFdLGowKTtcbiAgICAgICAgZm9yKGs9ajA7ayE9PWoxOysraykgeyBpZihBaltrXSA9PT0gaikgeyB4W2pdIC89IEF2W2tdOyBicmVhazsgfSB9XG4gICAgICAgIGEgPSB4W2pdO1xuICAgICAgICBmb3Ioaz1qMDtrIT09ajE7KytrKSB7XG4gICAgICAgICAgICBsID0gQWpba107XG4gICAgICAgICAgICBpZihsICE9PSBqKSB4W2xdIC09IGEqQXZba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5udW1lcmljLmNjc0RGUyA9IGZ1bmN0aW9uIGNjc0RGUyhuKSB7XG4gICAgdGhpcy5rID0gQXJyYXkobik7XG4gICAgdGhpcy5rMSA9IEFycmF5KG4pO1xuICAgIHRoaXMuaiA9IEFycmF5KG4pO1xufVxubnVtZXJpYy5jY3NERlMucHJvdG90eXBlLmRmcyA9IGZ1bmN0aW9uIGRmcyhKLEFpLEFqLHgseGosUGludikge1xuICAgIHZhciBtID0gMCxmb28sbj14ai5sZW5ndGg7XG4gICAgdmFyIGsgPSB0aGlzLmssIGsxID0gdGhpcy5rMSwgaiA9IHRoaXMuaixrbSxrMTE7XG4gICAgaWYoeFtKXSE9PTApIHJldHVybjtcbiAgICB4W0pdID0gMTtcbiAgICBqWzBdID0gSjtcbiAgICBrWzBdID0ga20gPSBBaVtKXTtcbiAgICBrMVswXSA9IGsxMSA9IEFpW0orMV07XG4gICAgd2hpbGUoMSkge1xuICAgICAgICBpZihrbSA+PSBrMTEpIHtcbiAgICAgICAgICAgIHhqW25dID0galttXTtcbiAgICAgICAgICAgIGlmKG09PT0wKSByZXR1cm47XG4gICAgICAgICAgICArK247XG4gICAgICAgICAgICAtLW07XG4gICAgICAgICAgICBrbSA9IGtbbV07XG4gICAgICAgICAgICBrMTEgPSBrMVttXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvbyA9IFBpbnZbQWpba21dXTtcbiAgICAgICAgICAgIGlmKHhbZm9vXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHhbZm9vXSA9IDE7XG4gICAgICAgICAgICAgICAga1ttXSA9IGttO1xuICAgICAgICAgICAgICAgICsrbTtcbiAgICAgICAgICAgICAgICBqW21dID0gZm9vO1xuICAgICAgICAgICAgICAgIGttID0gQWlbZm9vXTtcbiAgICAgICAgICAgICAgICBrMVttXSA9IGsxMSA9IEFpW2ZvbysxXTtcbiAgICAgICAgICAgIH0gZWxzZSArK2ttO1xuICAgICAgICB9XG4gICAgfVxufVxubnVtZXJpYy5jY3NMUFNvbHZlID0gZnVuY3Rpb24gY2NzTFBTb2x2ZShBLEIseCx4aixJLFBpbnYsZGZzKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl0sbSA9IEFpLmxlbmd0aC0xLCBuPTA7XG4gICAgdmFyIEJpID0gQlswXSwgQmogPSBCWzFdLCBCdiA9IEJbMl07XG4gICAgXG4gICAgdmFyIGksaTAsaTEsaixKLGowLGoxLGssbCxsMCxsMSxhO1xuICAgIGkwID0gQmlbSV07XG4gICAgaTEgPSBCaVtJKzFdO1xuICAgIHhqLmxlbmd0aCA9IDA7XG4gICAgZm9yKGk9aTA7aTxpMTsrK2kpIHsgZGZzLmRmcyhQaW52W0JqW2ldXSxBaSxBaix4LHhqLFBpbnYpOyB9XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkgeyB4W3hqW2ldXSA9IDA7IH1cbiAgICBmb3IoaT1pMDtpIT09aTE7KytpKSB7IGogPSBQaW52W0JqW2ldXTsgeFtqXSA9IEJ2W2ldOyB9XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBqID0geGpbaV07XG4gICAgICAgIGowID0gQWlbal07XG4gICAgICAgIGoxID0gQWlbaisxXTtcbiAgICAgICAgZm9yKGs9ajA7azxqMTsrK2spIHsgaWYoUGludltBaltrXV0gPT09IGopIHsgeFtqXSAvPSBBdltrXTsgYnJlYWs7IH0gfVxuICAgICAgICBhID0geFtqXTtcbiAgICAgICAgZm9yKGs9ajA7azxqMTsrK2spIHtcbiAgICAgICAgICAgIGwgPSBQaW52W0FqW2tdXTtcbiAgICAgICAgICAgIGlmKGwgIT09IGopIHhbbF0gLT0gYSpBdltrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbm51bWVyaWMuY2NzTFVQMSA9IGZ1bmN0aW9uIGNjc0xVUDEoQSx0aHJlc2hvbGQpIHtcbiAgICB2YXIgbSA9IEFbMF0ubGVuZ3RoLTE7XG4gICAgdmFyIEwgPSBbbnVtZXJpYy5yZXAoW20rMV0sMCksW10sW11dLCBVID0gW251bWVyaWMucmVwKFttKzFdLCAwKSxbXSxbXV07XG4gICAgdmFyIExpID0gTFswXSwgTGogPSBMWzFdLCBMdiA9IExbMl0sIFVpID0gVVswXSwgVWogPSBVWzFdLCBVdiA9IFVbMl07XG4gICAgdmFyIHggPSBudW1lcmljLnJlcChbbV0sMCksIHhqID0gbnVtZXJpYy5yZXAoW21dLDApO1xuICAgIHZhciBpLGosayxqMCxqMSxhLGUsYyxkLEs7XG4gICAgdmFyIHNvbCA9IG51bWVyaWMuY2NzTFBTb2x2ZSwgbWF4ID0gTWF0aC5tYXgsIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBQID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSksUGludiA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpO1xuICAgIHZhciBkZnMgPSBuZXcgbnVtZXJpYy5jY3NERlMobSk7XG4gICAgaWYodHlwZW9mIHRocmVzaG9sZCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0aHJlc2hvbGQgPSAxOyB9XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIHNvbChMLEEseCx4aixpLFBpbnYsZGZzKTtcbiAgICAgICAgYSA9IC0xO1xuICAgICAgICBlID0gLTE7XG4gICAgICAgIGZvcihqPXhqLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIGsgPSB4altqXTtcbiAgICAgICAgICAgIGlmKGsgPD0gaSkgY29udGludWU7XG4gICAgICAgICAgICBjID0gYWJzKHhba10pO1xuICAgICAgICAgICAgaWYoYyA+IGEpIHsgZSA9IGs7IGEgPSBjOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoYWJzKHhbaV0pPHRocmVzaG9sZCphKSB7XG4gICAgICAgICAgICBqID0gUFtpXTtcbiAgICAgICAgICAgIGEgPSBQW2VdO1xuICAgICAgICAgICAgUFtpXSA9IGE7IFBpbnZbYV0gPSBpO1xuICAgICAgICAgICAgUFtlXSA9IGo7IFBpbnZbal0gPSBlO1xuICAgICAgICAgICAgYSA9IHhbaV07IHhbaV0gPSB4W2VdOyB4W2VdID0gYTtcbiAgICAgICAgfVxuICAgICAgICBhID0gTGlbaV07XG4gICAgICAgIGUgPSBVaVtpXTtcbiAgICAgICAgZCA9IHhbaV07XG4gICAgICAgIExqW2FdID0gUFtpXTtcbiAgICAgICAgTHZbYV0gPSAxO1xuICAgICAgICArK2E7XG4gICAgICAgIGZvcihqPXhqLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIGsgPSB4altqXTtcbiAgICAgICAgICAgIGMgPSB4W2tdO1xuICAgICAgICAgICAgeGpbal0gPSAwO1xuICAgICAgICAgICAgeFtrXSA9IDA7XG4gICAgICAgICAgICBpZihrPD1pKSB7IFVqW2VdID0gazsgVXZbZV0gPSBjOyAgICsrZTsgfVxuICAgICAgICAgICAgZWxzZSAgICAgeyBMalthXSA9IFBba107IEx2W2FdID0gYy9kOyArK2E7IH1cbiAgICAgICAgfVxuICAgICAgICBMaVtpKzFdID0gYTtcbiAgICAgICAgVWlbaSsxXSA9IGU7XG4gICAgfVxuICAgIGZvcihqPUxqLmxlbmd0aC0xO2ohPT0tMTstLWopIHsgTGpbal0gPSBQaW52W0xqW2pdXTsgfVxuICAgIHJldHVybiB7TDpMLCBVOlUsIFA6UCwgUGludjpQaW52fTtcbn1cbm51bWVyaWMuY2NzREZTMCA9IGZ1bmN0aW9uIGNjc0RGUzAobikge1xuICAgIHRoaXMuayA9IEFycmF5KG4pO1xuICAgIHRoaXMuazEgPSBBcnJheShuKTtcbiAgICB0aGlzLmogPSBBcnJheShuKTtcbn1cbm51bWVyaWMuY2NzREZTMC5wcm90b3R5cGUuZGZzID0gZnVuY3Rpb24gZGZzKEosQWksQWoseCx4aixQaW52LFApIHtcbiAgICB2YXIgbSA9IDAsZm9vLG49eGoubGVuZ3RoO1xuICAgIHZhciBrID0gdGhpcy5rLCBrMSA9IHRoaXMuazEsIGogPSB0aGlzLmosa20sazExO1xuICAgIGlmKHhbSl0hPT0wKSByZXR1cm47XG4gICAgeFtKXSA9IDE7XG4gICAgalswXSA9IEo7XG4gICAga1swXSA9IGttID0gQWlbUGludltKXV07XG4gICAgazFbMF0gPSBrMTEgPSBBaVtQaW52W0pdKzFdO1xuICAgIHdoaWxlKDEpIHtcbiAgICAgICAgaWYoaXNOYU4oa20pKSB0aHJvdyBuZXcgRXJyb3IoXCJPdyFcIik7XG4gICAgICAgIGlmKGttID49IGsxMSkge1xuICAgICAgICAgICAgeGpbbl0gPSBQaW52W2pbbV1dO1xuICAgICAgICAgICAgaWYobT09PTApIHJldHVybjtcbiAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgIC0tbTtcbiAgICAgICAgICAgIGttID0ga1ttXTtcbiAgICAgICAgICAgIGsxMSA9IGsxW21dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9vID0gQWpba21dO1xuICAgICAgICAgICAgaWYoeFtmb29dID09PSAwKSB7XG4gICAgICAgICAgICAgICAgeFtmb29dID0gMTtcbiAgICAgICAgICAgICAgICBrW21dID0ga207XG4gICAgICAgICAgICAgICAgKyttO1xuICAgICAgICAgICAgICAgIGpbbV0gPSBmb287XG4gICAgICAgICAgICAgICAgZm9vID0gUGludltmb29dO1xuICAgICAgICAgICAgICAgIGttID0gQWlbZm9vXTtcbiAgICAgICAgICAgICAgICBrMVttXSA9IGsxMSA9IEFpW2ZvbysxXTtcbiAgICAgICAgICAgIH0gZWxzZSArK2ttO1xuICAgICAgICB9XG4gICAgfVxufVxubnVtZXJpYy5jY3NMUFNvbHZlMCA9IGZ1bmN0aW9uIGNjc0xQU29sdmUwKEEsQix5LHhqLEksUGludixQLGRmcykge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdLG0gPSBBaS5sZW5ndGgtMSwgbj0wO1xuICAgIHZhciBCaSA9IEJbMF0sIEJqID0gQlsxXSwgQnYgPSBCWzJdO1xuICAgIFxuICAgIHZhciBpLGkwLGkxLGosSixqMCxqMSxrLGwsbDAsbDEsYTtcbiAgICBpMCA9IEJpW0ldO1xuICAgIGkxID0gQmlbSSsxXTtcbiAgICB4ai5sZW5ndGggPSAwO1xuICAgIGZvcihpPWkwO2k8aTE7KytpKSB7IGRmcy5kZnMoQmpbaV0sQWksQWoseSx4aixQaW52LFApOyB9XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkgeyBqID0geGpbaV07IHlbUFtqXV0gPSAwOyB9XG4gICAgZm9yKGk9aTA7aSE9PWkxOysraSkgeyBqID0gQmpbaV07IHlbal0gPSBCdltpXTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgaiA9IHhqW2ldO1xuICAgICAgICBsID0gUFtqXTtcbiAgICAgICAgajAgPSBBaVtqXTtcbiAgICAgICAgajEgPSBBaVtqKzFdO1xuICAgICAgICBmb3Ioaz1qMDtrPGoxOysraykgeyBpZihBaltrXSA9PT0gbCkgeyB5W2xdIC89IEF2W2tdOyBicmVhazsgfSB9XG4gICAgICAgIGEgPSB5W2xdO1xuICAgICAgICBmb3Ioaz1qMDtrPGoxOysraykgeVtBaltrXV0gLT0gYSpBdltrXTtcbiAgICAgICAgeVtsXSA9IGE7XG4gICAgfVxufVxubnVtZXJpYy5jY3NMVVAwID0gZnVuY3Rpb24gY2NzTFVQMChBLHRocmVzaG9sZCkge1xuICAgIHZhciBtID0gQVswXS5sZW5ndGgtMTtcbiAgICB2YXIgTCA9IFtudW1lcmljLnJlcChbbSsxXSwwKSxbXSxbXV0sIFUgPSBbbnVtZXJpYy5yZXAoW20rMV0sIDApLFtdLFtdXTtcbiAgICB2YXIgTGkgPSBMWzBdLCBMaiA9IExbMV0sIEx2ID0gTFsyXSwgVWkgPSBVWzBdLCBVaiA9IFVbMV0sIFV2ID0gVVsyXTtcbiAgICB2YXIgeSA9IG51bWVyaWMucmVwKFttXSwwKSwgeGogPSBudW1lcmljLnJlcChbbV0sMCk7XG4gICAgdmFyIGksaixrLGowLGoxLGEsZSxjLGQsSztcbiAgICB2YXIgc29sID0gbnVtZXJpYy5jY3NMUFNvbHZlMCwgbWF4ID0gTWF0aC5tYXgsIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBQID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSksUGludiA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpO1xuICAgIHZhciBkZnMgPSBuZXcgbnVtZXJpYy5jY3NERlMwKG0pO1xuICAgIGlmKHR5cGVvZiB0aHJlc2hvbGQgPT09IFwidW5kZWZpbmVkXCIpIHsgdGhyZXNob2xkID0gMTsgfVxuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBzb2woTCxBLHkseGosaSxQaW52LFAsZGZzKTtcbiAgICAgICAgYSA9IC0xO1xuICAgICAgICBlID0gLTE7XG4gICAgICAgIGZvcihqPXhqLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIGsgPSB4altqXTtcbiAgICAgICAgICAgIGlmKGsgPD0gaSkgY29udGludWU7XG4gICAgICAgICAgICBjID0gYWJzKHlbUFtrXV0pO1xuICAgICAgICAgICAgaWYoYyA+IGEpIHsgZSA9IGs7IGEgPSBjOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoYWJzKHlbUFtpXV0pPHRocmVzaG9sZCphKSB7XG4gICAgICAgICAgICBqID0gUFtpXTtcbiAgICAgICAgICAgIGEgPSBQW2VdO1xuICAgICAgICAgICAgUFtpXSA9IGE7IFBpbnZbYV0gPSBpO1xuICAgICAgICAgICAgUFtlXSA9IGo7IFBpbnZbal0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBMaVtpXTtcbiAgICAgICAgZSA9IFVpW2ldO1xuICAgICAgICBkID0geVtQW2ldXTtcbiAgICAgICAgTGpbYV0gPSBQW2ldO1xuICAgICAgICBMdlthXSA9IDE7XG4gICAgICAgICsrYTtcbiAgICAgICAgZm9yKGo9eGoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgayA9IHhqW2pdO1xuICAgICAgICAgICAgYyA9IHlbUFtrXV07XG4gICAgICAgICAgICB4altqXSA9IDA7XG4gICAgICAgICAgICB5W1Bba11dID0gMDtcbiAgICAgICAgICAgIGlmKGs8PWkpIHsgVWpbZV0gPSBrOyBVdltlXSA9IGM7ICAgKytlOyB9XG4gICAgICAgICAgICBlbHNlICAgICB7IExqW2FdID0gUFtrXTsgTHZbYV0gPSBjL2Q7ICsrYTsgfVxuICAgICAgICB9XG4gICAgICAgIExpW2krMV0gPSBhO1xuICAgICAgICBVaVtpKzFdID0gZTtcbiAgICB9XG4gICAgZm9yKGo9TGoubGVuZ3RoLTE7aiE9PS0xOy0taikgeyBMaltqXSA9IFBpbnZbTGpbal1dOyB9XG4gICAgcmV0dXJuIHtMOkwsIFU6VSwgUDpQLCBQaW52OlBpbnZ9O1xufVxubnVtZXJpYy5jY3NMVVAgPSBudW1lcmljLmNjc0xVUDA7XG5cbm51bWVyaWMuY2NzRGltID0gZnVuY3Rpb24gY2NzRGltKEEpIHsgcmV0dXJuIFtudW1lcmljLnN1cChBWzFdKSsxLEFbMF0ubGVuZ3RoLTFdOyB9XG5udW1lcmljLmNjc0dldEJsb2NrID0gZnVuY3Rpb24gY2NzR2V0QmxvY2soQSxpLGopIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuY2NzRGltKEEpLG09c1swXSxuPXNbMV07XG4gICAgaWYodHlwZW9mIGkgPT09IFwidW5kZWZpbmVkXCIpIHsgaSA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpOyB9XG4gICAgZWxzZSBpZih0eXBlb2YgaSA9PT0gXCJudW1iZXJcIikgeyBpID0gW2ldOyB9XG4gICAgaWYodHlwZW9mIGogPT09IFwidW5kZWZpbmVkXCIpIHsgaiA9IG51bWVyaWMubGluc3BhY2UoMCxuLTEpOyB9XG4gICAgZWxzZSBpZih0eXBlb2YgaiA9PT0gXCJudW1iZXJcIikgeyBqID0gW2pdOyB9XG4gICAgdmFyIHAscDAscDEsUCA9IGkubGVuZ3RoLHEsUSA9IGoubGVuZ3RoLHIsanEsaXA7XG4gICAgdmFyIEJpID0gbnVtZXJpYy5yZXAoW25dLDApLCBCaj1bXSwgQnY9W10sIEIgPSBbQmksQmosQnZdO1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdO1xuICAgIHZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLGNvdW50PTAsZmxhZ3MgPSBudW1lcmljLnJlcChbbV0sMCk7XG4gICAgZm9yKHE9MDtxPFE7KytxKSB7XG4gICAgICAgIGpxID0galtxXTtcbiAgICAgICAgdmFyIHEwID0gQWlbanFdO1xuICAgICAgICB2YXIgcTEgPSBBaVtqcSsxXTtcbiAgICAgICAgZm9yKHA9cTA7cDxxMTsrK3ApIHtcbiAgICAgICAgICAgIHIgPSBBaltwXTtcbiAgICAgICAgICAgIGZsYWdzW3JdID0gMTtcbiAgICAgICAgICAgIHhbcl0gPSBBdltwXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IocD0wO3A8UDsrK3ApIHtcbiAgICAgICAgICAgIGlwID0gaVtwXTtcbiAgICAgICAgICAgIGlmKGZsYWdzW2lwXSkge1xuICAgICAgICAgICAgICAgIEJqW2NvdW50XSA9IHA7XG4gICAgICAgICAgICAgICAgQnZbY291bnRdID0geFtpW3BdXTtcbiAgICAgICAgICAgICAgICArK2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcihwPXEwO3A8cTE7KytwKSB7XG4gICAgICAgICAgICByID0gQWpbcF07XG4gICAgICAgICAgICBmbGFnc1tyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgQmlbcSsxXSA9IGNvdW50O1xuICAgIH1cbiAgICByZXR1cm4gQjtcbn1cblxubnVtZXJpYy5jY3NEb3QgPSBmdW5jdGlvbiBjY3NEb3QoQSxCKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl07XG4gICAgdmFyIEJpID0gQlswXSwgQmogPSBCWzFdLCBCdiA9IEJbMl07XG4gICAgdmFyIHNBID0gbnVtZXJpYy5jY3NEaW0oQSksIHNCID0gbnVtZXJpYy5jY3NEaW0oQik7XG4gICAgdmFyIG0gPSBzQVswXSwgbiA9IHNBWzFdLCBvID0gc0JbMV07XG4gICAgdmFyIHggPSBudW1lcmljLnJlcChbbV0sMCksIGZsYWdzID0gbnVtZXJpYy5yZXAoW21dLDApLCB4aiA9IEFycmF5KG0pO1xuICAgIHZhciBDaSA9IG51bWVyaWMucmVwKFtvXSwwKSwgQ2ogPSBbXSwgQ3YgPSBbXSwgQyA9IFtDaSxDaixDdl07XG4gICAgdmFyIGksaixrLGowLGoxLGkwLGkxLGwscCxhLGI7XG4gICAgZm9yKGs9MDtrIT09bzsrK2spIHtcbiAgICAgICAgajAgPSBCaVtrXTtcbiAgICAgICAgajEgPSBCaVtrKzFdO1xuICAgICAgICBwID0gMDtcbiAgICAgICAgZm9yKGo9ajA7ajxqMTsrK2opIHtcbiAgICAgICAgICAgIGEgPSBCaltqXTtcbiAgICAgICAgICAgIGIgPSBCdltqXTtcbiAgICAgICAgICAgIGkwID0gQWlbYV07XG4gICAgICAgICAgICBpMSA9IEFpW2ErMV07XG4gICAgICAgICAgICBmb3IoaT1pMDtpPGkxOysraSkge1xuICAgICAgICAgICAgICAgIGwgPSBBaltpXTtcbiAgICAgICAgICAgICAgICBpZihmbGFnc1tsXT09PTApIHtcbiAgICAgICAgICAgICAgICAgICAgeGpbcF0gPSBsO1xuICAgICAgICAgICAgICAgICAgICBmbGFnc1tsXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwKzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhbbF0gPSB4W2xdICsgQXZbaV0qYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBqMCA9IENpW2tdO1xuICAgICAgICBqMSA9IGowK3A7XG4gICAgICAgIENpW2srMV0gPSBqMTtcbiAgICAgICAgZm9yKGo9cC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIGIgPSBqMCtqO1xuICAgICAgICAgICAgaSA9IHhqW2pdO1xuICAgICAgICAgICAgQ2pbYl0gPSBpO1xuICAgICAgICAgICAgQ3ZbYl0gPSB4W2ldO1xuICAgICAgICAgICAgZmxhZ3NbaV0gPSAwO1xuICAgICAgICAgICAgeFtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgQ2lbaysxXSA9IENpW2tdK3A7XG4gICAgfVxuICAgIHJldHVybiBDO1xufVxuXG5udW1lcmljLmNjc0xVUFNvbHZlID0gZnVuY3Rpb24gY2NzTFVQU29sdmUoTFVQLEIpIHtcbiAgICB2YXIgTCA9IExVUC5MLCBVID0gTFVQLlUsIFAgPSBMVVAuUDtcbiAgICB2YXIgQmkgPSBCWzBdO1xuICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgaWYodHlwZW9mIEJpICE9PSBcIm9iamVjdFwiKSB7IEIgPSBbWzAsQi5sZW5ndGhdLG51bWVyaWMubGluc3BhY2UoMCxCLmxlbmd0aC0xKSxCXTsgQmkgPSBCWzBdOyBmbGFnID0gdHJ1ZTsgfVxuICAgIHZhciBCaiA9IEJbMV0sIEJ2ID0gQlsyXTtcbiAgICB2YXIgbiA9IExbMF0ubGVuZ3RoLTEsIG0gPSBCaS5sZW5ndGgtMTtcbiAgICB2YXIgeCA9IG51bWVyaWMucmVwKFtuXSwwKSwgeGogPSBBcnJheShuKTtcbiAgICB2YXIgYiA9IG51bWVyaWMucmVwKFtuXSwwKSwgYmogPSBBcnJheShuKTtcbiAgICB2YXIgWGkgPSBudW1lcmljLnJlcChbbSsxXSwwKSwgWGogPSBbXSwgWHYgPSBbXTtcbiAgICB2YXIgc29sID0gbnVtZXJpYy5jY3NUU29sdmU7XG4gICAgdmFyIGksaixqMCxqMSxrLEosTj0wO1xuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBrID0gMDtcbiAgICAgICAgajAgPSBCaVtpXTtcbiAgICAgICAgajEgPSBCaVtpKzFdO1xuICAgICAgICBmb3Ioaj1qMDtqPGoxOysraikgeyBcbiAgICAgICAgICAgIEogPSBMVVAuUGludltCaltqXV07XG4gICAgICAgICAgICBialtrXSA9IEo7XG4gICAgICAgICAgICBiW0pdID0gQnZbal07XG4gICAgICAgICAgICArK2s7XG4gICAgICAgIH1cbiAgICAgICAgYmoubGVuZ3RoID0gaztcbiAgICAgICAgc29sKEwsYix4LGJqLHhqKTtcbiAgICAgICAgZm9yKGo9YmoubGVuZ3RoLTE7aiE9PS0xOy0taikgYltialtqXV0gPSAwO1xuICAgICAgICBzb2woVSx4LGIseGosYmopO1xuICAgICAgICBpZihmbGFnKSByZXR1cm4gYjtcbiAgICAgICAgZm9yKGo9eGoubGVuZ3RoLTE7aiE9PS0xOy0taikgeFt4altqXV0gPSAwO1xuICAgICAgICBmb3Ioaj1iai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBKID0gYmpbal07XG4gICAgICAgICAgICBYaltOXSA9IEo7XG4gICAgICAgICAgICBYdltOXSA9IGJbSl07XG4gICAgICAgICAgICBiW0pdID0gMDtcbiAgICAgICAgICAgICsrTjtcbiAgICAgICAgfVxuICAgICAgICBYaVtpKzFdID0gTjtcbiAgICB9XG4gICAgcmV0dXJuIFtYaSxYaixYdl07XG59XG5cbm51bWVyaWMuY2NzYmlub3AgPSBmdW5jdGlvbiBjY3NiaW5vcChib2R5LHNldHVwKSB7XG4gICAgaWYodHlwZW9mIHNldHVwID09PSBcInVuZGVmaW5lZFwiKSBzZXR1cD0nJztcbiAgICByZXR1cm4gRnVuY3Rpb24oJ1gnLCdZJyxcbiAgICAgICAgICAgICd2YXIgWGkgPSBYWzBdLCBYaiA9IFhbMV0sIFh2ID0gWFsyXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBZaSA9IFlbMF0sIFlqID0gWVsxXSwgWXYgPSBZWzJdO1xcbicrXG4gICAgICAgICAgICAndmFyIG4gPSBYaS5sZW5ndGgtMSxtID0gTWF0aC5tYXgobnVtZXJpYy5zdXAoWGopLG51bWVyaWMuc3VwKFlqKSkrMTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBaaSA9IG51bWVyaWMucmVwKFtuKzFdLDApLCBaaiA9IFtdLCBadiA9IFtdO1xcbicrXG4gICAgICAgICAgICAndmFyIHggPSBudW1lcmljLnJlcChbbV0sMCkseSA9IG51bWVyaWMucmVwKFttXSwwKTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciB4ayx5ayx6aztcXG4nK1xuICAgICAgICAgICAgJ3ZhciBpLGosajAsajEsayxwPTA7XFxuJytcbiAgICAgICAgICAgIHNldHVwK1xuICAgICAgICAgICAgJ2ZvcihpPTA7aTxuOysraSkge1xcbicrXG4gICAgICAgICAgICAnICBqMCA9IFhpW2ldOyBqMSA9IFhpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHtcXG4nK1xuICAgICAgICAgICAgJyAgICBrID0gWGpbal07XFxuJytcbiAgICAgICAgICAgICcgICAgeFtrXSA9IDE7XFxuJytcbiAgICAgICAgICAgICcgICAgWmpbcF0gPSBrO1xcbicrXG4gICAgICAgICAgICAnICAgICsrcDtcXG4nK1xuICAgICAgICAgICAgJyAgfVxcbicrXG4gICAgICAgICAgICAnICBqMCA9IFlpW2ldOyBqMSA9IFlpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHtcXG4nK1xuICAgICAgICAgICAgJyAgICBrID0gWWpbal07XFxuJytcbiAgICAgICAgICAgICcgICAgeVtrXSA9IFl2W2pdO1xcbicrXG4gICAgICAgICAgICAnICAgIGlmKHhba10gPT09IDApIHtcXG4nK1xuICAgICAgICAgICAgJyAgICAgIFpqW3BdID0gaztcXG4nK1xuICAgICAgICAgICAgJyAgICAgICsrcDtcXG4nK1xuICAgICAgICAgICAgJyAgICB9XFxuJytcbiAgICAgICAgICAgICcgIH1cXG4nK1xuICAgICAgICAgICAgJyAgWmlbaSsxXSA9IHA7XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWGlbaV07IGoxID0gWGlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikgeFtYaltqXV0gPSBYdltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBaaVtpXTsgajEgPSBaaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgayA9IFpqW2pdO1xcbicrXG4gICAgICAgICAgICAnICAgIHhrID0geFtrXTtcXG4nK1xuICAgICAgICAgICAgJyAgICB5ayA9IHlba107XFxuJytcbiAgICAgICAgICAgIGJvZHkrJ1xcbicrXG4gICAgICAgICAgICAnICAgIFp2W2pdID0gems7XFxuJytcbiAgICAgICAgICAgICcgIH1cXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBYaVtpXTsgajEgPSBYaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB4W1hqW2pdXSA9IDA7XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWWlbaV07IGoxID0gWWlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikgeVtZaltqXV0gPSAwO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIFtaaSxaaixadl07J1xuICAgICAgICAgICAgKTtcbn07XG5cbihmdW5jdGlvbigpIHtcbiAgICB2YXIgayxBLEIsQztcbiAgICBmb3IoayBpbiBudW1lcmljLm9wczIpIHtcbiAgICAgICAgaWYoaXNGaW5pdGUoZXZhbCgnMScrbnVtZXJpYy5vcHMyW2tdKycwJykpKSBBID0gJ1tZWzBdLFlbMV0sbnVtZXJpYy4nK2srJyhYLFlbMl0pXSc7XG4gICAgICAgIGVsc2UgQSA9ICdOYU4nO1xuICAgICAgICBpZihpc0Zpbml0ZShldmFsKCcwJytudW1lcmljLm9wczJba10rJzEnKSkpIEIgPSAnW1hbMF0sWFsxXSxudW1lcmljLicraysnKFhbMl0sWSldJztcbiAgICAgICAgZWxzZSBCID0gJ05hTic7XG4gICAgICAgIGlmKGlzRmluaXRlKGV2YWwoJzEnK251bWVyaWMub3BzMltrXSsnMCcpKSAmJiBpc0Zpbml0ZShldmFsKCcwJytudW1lcmljLm9wczJba10rJzEnKSkpIEMgPSAnbnVtZXJpYy5jY3MnK2srJ01NKFgsWSknO1xuICAgICAgICBlbHNlIEMgPSAnTmFOJztcbiAgICAgICAgbnVtZXJpY1snY2NzJytrKydNTSddID0gbnVtZXJpYy5jY3NiaW5vcCgnemsgPSB4ayAnK251bWVyaWMub3BzMltrXSsneWs7Jyk7XG4gICAgICAgIG51bWVyaWNbJ2Njcycra10gPSBGdW5jdGlvbignWCcsJ1knLFxuICAgICAgICAgICAgICAgICdpZih0eXBlb2YgWCA9PT0gXCJudW1iZXJcIikgcmV0dXJuICcrQSsnO1xcbicrXG4gICAgICAgICAgICAgICAgJ2lmKHR5cGVvZiBZID09PSBcIm51bWJlclwiKSByZXR1cm4gJytCKyc7XFxuJytcbiAgICAgICAgICAgICAgICAncmV0dXJuICcrQysnO1xcbidcbiAgICAgICAgICAgICAgICApO1xuICAgIH1cbn0oKSk7XG5cbm51bWVyaWMuY2NzU2NhdHRlciA9IGZ1bmN0aW9uIGNjc1NjYXR0ZXIoQSkge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdO1xuICAgIHZhciBuID0gbnVtZXJpYy5zdXAoQWopKzEsbT1BaS5sZW5ndGg7XG4gICAgdmFyIFJpID0gbnVtZXJpYy5yZXAoW25dLDApLFJqPUFycmF5KG0pLCBSdiA9IEFycmF5KG0pO1xuICAgIHZhciBjb3VudHMgPSBudW1lcmljLnJlcChbbl0sMCksaTtcbiAgICBmb3IoaT0wO2k8bTsrK2kpIGNvdW50c1tBaltpXV0rKztcbiAgICBmb3IoaT0wO2k8bjsrK2kpIFJpW2krMV0gPSBSaVtpXSArIGNvdW50c1tpXTtcbiAgICB2YXIgcHRyID0gUmkuc2xpY2UoMCksayxBaWk7XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIEFpaSA9IEFqW2ldO1xuICAgICAgICBrID0gcHRyW0FpaV07XG4gICAgICAgIFJqW2tdID0gQWlbaV07XG4gICAgICAgIFJ2W2tdID0gQXZbaV07XG4gICAgICAgIHB0cltBaWldPXB0cltBaWldKzE7XG4gICAgfVxuICAgIHJldHVybiBbUmksUmosUnZdO1xufVxuXG5udW1lcmljLmNjc0dhdGhlciA9IGZ1bmN0aW9uIGNjc0dhdGhlcihBKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl07XG4gICAgdmFyIG4gPSBBaS5sZW5ndGgtMSxtID0gQWoubGVuZ3RoO1xuICAgIHZhciBSaSA9IEFycmF5KG0pLCBSaiA9IEFycmF5KG0pLCBSdiA9IEFycmF5KG0pO1xuICAgIHZhciBpLGosajAsajEscDtcbiAgICBwPTA7XG4gICAgZm9yKGk9MDtpPG47KytpKSB7XG4gICAgICAgIGowID0gQWlbaV07XG4gICAgICAgIGoxID0gQWlbaSsxXTtcbiAgICAgICAgZm9yKGo9ajA7aiE9PWoxOysraikge1xuICAgICAgICAgICAgUmpbcF0gPSBpO1xuICAgICAgICAgICAgUmlbcF0gPSBBaltqXTtcbiAgICAgICAgICAgIFJ2W3BdID0gQXZbal07XG4gICAgICAgICAgICArK3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtSaSxSaixSdl07XG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgc3BhcnNlIGxpbmVhciBhbGdlYnJhIHJvdXRpbmVzIGFyZSBkZXByZWNhdGVkLlxuXG5udW1lcmljLnNkaW0gPSBmdW5jdGlvbiBkaW0oQSxyZXQsaykge1xuICAgIGlmKHR5cGVvZiByZXQgPT09IFwidW5kZWZpbmVkXCIpIHsgcmV0ID0gW107IH1cbiAgICBpZih0eXBlb2YgQSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJldDtcbiAgICBpZih0eXBlb2YgayA9PT0gXCJ1bmRlZmluZWRcIikgeyBrPTA7IH1cbiAgICBpZighKGsgaW4gcmV0KSkgeyByZXRba10gPSAwOyB9XG4gICAgaWYoQS5sZW5ndGggPiByZXRba10pIHJldFtrXSA9IEEubGVuZ3RoO1xuICAgIHZhciBpO1xuICAgIGZvcihpIGluIEEpIHtcbiAgICAgICAgaWYoQS5oYXNPd25Qcm9wZXJ0eShpKSkgZGltKEFbaV0scmV0LGsrMSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5udW1lcmljLnNjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKEEsayxuKSB7XG4gICAgaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIHsgaz0wOyB9XG4gICAgaWYodHlwZW9mIG4gPT09IFwidW5kZWZpbmVkXCIpIHsgbiA9IG51bWVyaWMuc2RpbShBKS5sZW5ndGg7IH1cbiAgICB2YXIgaSxyZXQgPSBBcnJheShBLmxlbmd0aCk7XG4gICAgaWYoayA9PT0gbi0xKSB7XG4gICAgICAgIGZvcihpIGluIEEpIHsgaWYoQS5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0W2ldID0gQVtpXTsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmb3IoaSBpbiBBKSB7XG4gICAgICAgIGlmKEEuaGFzT3duUHJvcGVydHkoaSkpIHJldFtpXSA9IGNsb25lKEFbaV0saysxLG4pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkaWFnID0gZnVuY3Rpb24gZGlhZyhkKSB7XG4gICAgdmFyIG4gPSBkLmxlbmd0aCxpLHJldCA9IEFycmF5KG4pLGkxLGkyLGkzO1xuICAgIGZvcihpPW4tMTtpPj0xO2ktPTIpIHtcbiAgICAgICAgaTEgPSBpLTE7XG4gICAgICAgIHJldFtpXSA9IFtdOyByZXRbaV1baV0gPSBkW2ldO1xuICAgICAgICByZXRbaTFdID0gW107IHJldFtpMV1baTFdID0gZFtpMV07XG4gICAgfVxuICAgIGlmKGk9PT0wKSB7IHJldFswXSA9IFtdOyByZXRbMF1bMF0gPSBkW2ldOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eShuKSB7IHJldHVybiBudW1lcmljLnNkaWFnKG51bWVyaWMucmVwKFtuXSwxKSk7IH1cblxubnVtZXJpYy5zdHJhbnNwb3NlID0gZnVuY3Rpb24gdHJhbnNwb3NlKEEpIHtcbiAgICB2YXIgcmV0ID0gW10sIG4gPSBBLmxlbmd0aCwgaSxqLEFpO1xuICAgIGZvcihpIGluIEEpIHtcbiAgICAgICAgaWYoIShBLmhhc093blByb3BlcnR5KGkpKSkgY29udGludWU7XG4gICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgZm9yKGogaW4gQWkpIHtcbiAgICAgICAgICAgIGlmKCEoQWkuaGFzT3duUHJvcGVydHkoaikpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmKHR5cGVvZiByZXRbal0gIT09IFwib2JqZWN0XCIpIHsgcmV0W2pdID0gW107IH1cbiAgICAgICAgICAgIHJldFtqXVtpXSA9IEFpW2pdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc0xVUCA9IGZ1bmN0aW9uIExVUChBLHRvbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBudW1lcmljLnNMVVAgaGFkIGEgYnVnIGluIGl0IGFuZCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSBuZXcgbnVtZXJpYy5jY3NMVVAgZnVuY3Rpb24gaW5zdGVhZC5cIik7XG59O1xuXG5udW1lcmljLnNkb3RNTSA9IGZ1bmN0aW9uIGRvdE1NKEEsQikge1xuICAgIHZhciBwID0gQS5sZW5ndGgsIHEgPSBCLmxlbmd0aCwgQlQgPSBudW1lcmljLnN0cmFuc3Bvc2UoQiksIHIgPSBCVC5sZW5ndGgsIEFpLCBCVGs7XG4gICAgdmFyIGksaixrLGFjY3VtO1xuICAgIHZhciByZXQgPSBBcnJheShwKSxyZXRpO1xuICAgIGZvcihpPXAtMTtpPj0wO2ktLSkge1xuICAgICAgICByZXRpID0gW107XG4gICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgZm9yKGs9ci0xO2s+PTA7ay0tKSB7XG4gICAgICAgICAgICBhY2N1bSA9IDA7XG4gICAgICAgICAgICBCVGsgPSBCVFtrXTtcbiAgICAgICAgICAgIGZvcihqIGluIEFpKSB7XG4gICAgICAgICAgICAgICAgaWYoIShBaS5oYXNPd25Qcm9wZXJ0eShqKSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmKGogaW4gQlRrKSB7IGFjY3VtICs9IEFpW2pdKkJUa1tqXTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoYWNjdW0pIHJldGlba10gPSBhY2N1bTtcbiAgICAgICAgfVxuICAgICAgICByZXRbaV0gPSByZXRpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkb3RNViA9IGZ1bmN0aW9uIGRvdE1WKEEseCkge1xuICAgIHZhciBwID0gQS5sZW5ndGgsIEFpLCBpLGo7XG4gICAgdmFyIHJldCA9IEFycmF5KHApLCBhY2N1bTtcbiAgICBmb3IoaT1wLTE7aT49MDtpLS0pIHtcbiAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICBhY2N1bSA9IDA7XG4gICAgICAgIGZvcihqIGluIEFpKSB7XG4gICAgICAgICAgICBpZighKEFpLmhhc093blByb3BlcnR5KGopKSkgY29udGludWU7XG4gICAgICAgICAgICBpZih4W2pdKSBhY2N1bSArPSBBaVtqXSp4W2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGFjY3VtKSByZXRbaV0gPSBhY2N1bTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZG90Vk0gPSBmdW5jdGlvbiBkb3RNVih4LEEpIHtcbiAgICB2YXIgaSxqLEFpLGFscGhhO1xuICAgIHZhciByZXQgPSBbXSwgYWNjdW07XG4gICAgZm9yKGkgaW4geCkge1xuICAgICAgICBpZigheC5oYXNPd25Qcm9wZXJ0eShpKSkgY29udGludWU7XG4gICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgYWxwaGEgPSB4W2ldO1xuICAgICAgICBmb3IoaiBpbiBBaSkge1xuICAgICAgICAgICAgaWYoIUFpLmhhc093blByb3BlcnR5KGopKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmKCFyZXRbal0pIHsgcmV0W2pdID0gMDsgfVxuICAgICAgICAgICAgcmV0W2pdICs9IGFscGhhKkFpW2pdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2RvdFZWID0gZnVuY3Rpb24gZG90VlYoeCx5KSB7XG4gICAgdmFyIGkscmV0PTA7XG4gICAgZm9yKGkgaW4geCkgeyBpZih4W2ldICYmIHlbaV0pIHJldCs9IHhbaV0qeVtpXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2RvdCA9IGZ1bmN0aW9uIGRvdChBLEIpIHtcbiAgICB2YXIgbSA9IG51bWVyaWMuc2RpbShBKS5sZW5ndGgsIG4gPSBudW1lcmljLnNkaW0oQikubGVuZ3RoO1xuICAgIHZhciBrID0gbSoxMDAwK247XG4gICAgc3dpdGNoKGspIHtcbiAgICBjYXNlIDA6IHJldHVybiBBKkI7XG4gICAgY2FzZSAxMDAxOiByZXR1cm4gbnVtZXJpYy5zZG90VlYoQSxCKTtcbiAgICBjYXNlIDIwMDE6IHJldHVybiBudW1lcmljLnNkb3RNVihBLEIpO1xuICAgIGNhc2UgMTAwMjogcmV0dXJuIG51bWVyaWMuc2RvdFZNKEEsQik7XG4gICAgY2FzZSAyMDAyOiByZXR1cm4gbnVtZXJpYy5zZG90TU0oQSxCKTtcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWMuc2RvdCBub3QgaW1wbGVtZW50ZWQgZm9yIHRlbnNvcnMgb2Ygb3JkZXIgJyttKycgYW5kICcrbik7XG4gICAgfVxufVxuXG5udW1lcmljLnNzY2F0dGVyID0gZnVuY3Rpb24gc2NhdHRlcihWKSB7XG4gICAgdmFyIG4gPSBWWzBdLmxlbmd0aCwgVmlqLCBpLCBqLCBtID0gVi5sZW5ndGgsIEEgPSBbXSwgQWo7XG4gICAgZm9yKGk9bi0xO2k+PTA7LS1pKSB7XG4gICAgICAgIGlmKCFWW20tMV1baV0pIGNvbnRpbnVlO1xuICAgICAgICBBaiA9IEE7XG4gICAgICAgIGZvcihqPTA7ajxtLTI7aisrKSB7XG4gICAgICAgICAgICBWaWogPSBWW2pdW2ldO1xuICAgICAgICAgICAgaWYoIUFqW1Zpal0pIEFqW1Zpal0gPSBbXTtcbiAgICAgICAgICAgIEFqID0gQWpbVmlqXTtcbiAgICAgICAgfVxuICAgICAgICBBaltWW2pdW2ldXSA9IFZbaisxXVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIEE7XG59XG5cbm51bWVyaWMuc2dhdGhlciA9IGZ1bmN0aW9uIGdhdGhlcihBLHJldCxrKSB7XG4gICAgaWYodHlwZW9mIHJldCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0ID0gW107XG4gICAgaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIGsgPSBbXTtcbiAgICB2YXIgbixpLEFpO1xuICAgIG4gPSBrLmxlbmd0aDtcbiAgICBmb3IoaSBpbiBBKSB7XG4gICAgICAgIGlmKEEuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIGtbbl0gPSBwYXJzZUludChpKTtcbiAgICAgICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBBaSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmKEFpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpPW4rMTtpPj0wOy0taSkgcmV0W2ldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9bjtpPj0wOy0taSkgcmV0W2ldLnB1c2goa1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldFtuKzFdLnB1c2goQWkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBnYXRoZXIoQWkscmV0LGspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmKGsubGVuZ3RoPm4pIGsucG9wKCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLy8gNi4gQ29vcmRpbmF0ZSBtYXRyaWNlc1xubnVtZXJpYy5jTFUgPSBmdW5jdGlvbiBMVShBKSB7XG4gICAgdmFyIEkgPSBBWzBdLCBKID0gQVsxXSwgViA9IEFbMl07XG4gICAgdmFyIHAgPSBJLmxlbmd0aCwgbT0wLCBpLGosayxhLGIsYztcbiAgICBmb3IoaT0wO2k8cDtpKyspIGlmKElbaV0+bSkgbT1JW2ldO1xuICAgIG0rKztcbiAgICB2YXIgTCA9IEFycmF5KG0pLCBVID0gQXJyYXkobSksIGxlZnQgPSBudW1lcmljLnJlcChbbV0sSW5maW5pdHkpLCByaWdodCA9IG51bWVyaWMucmVwKFttXSwtSW5maW5pdHkpO1xuICAgIHZhciBVaSwgVWosYWxwaGE7XG4gICAgZm9yKGs9MDtrPHA7aysrKSB7XG4gICAgICAgIGkgPSBJW2tdO1xuICAgICAgICBqID0gSltrXTtcbiAgICAgICAgaWYoajxsZWZ0W2ldKSBsZWZ0W2ldID0gajtcbiAgICAgICAgaWYoaj5yaWdodFtpXSkgcmlnaHRbaV0gPSBqO1xuICAgIH1cbiAgICBmb3IoaT0wO2k8bS0xO2krKykgeyBpZihyaWdodFtpXSA+IHJpZ2h0W2krMV0pIHJpZ2h0W2krMV0gPSByaWdodFtpXTsgfVxuICAgIGZvcihpPW0tMTtpPj0xO2ktLSkgeyBpZihsZWZ0W2ldPGxlZnRbaS0xXSkgbGVmdFtpLTFdID0gbGVmdFtpXTsgfVxuICAgIHZhciBjb3VudEwgPSAwLCBjb3VudFUgPSAwO1xuICAgIGZvcihpPTA7aTxtO2krKykge1xuICAgICAgICBVW2ldID0gbnVtZXJpYy5yZXAoW3JpZ2h0W2ldLWxlZnRbaV0rMV0sMCk7XG4gICAgICAgIExbaV0gPSBudW1lcmljLnJlcChbaS1sZWZ0W2ldXSwwKTtcbiAgICAgICAgY291bnRMICs9IGktbGVmdFtpXSsxO1xuICAgICAgICBjb3VudFUgKz0gcmlnaHRbaV0taSsxO1xuICAgIH1cbiAgICBmb3Ioaz0wO2s8cDtrKyspIHsgaSA9IElba107IFVbaV1bSltrXS1sZWZ0W2ldXSA9IFZba107IH1cbiAgICBmb3IoaT0wO2k8bS0xO2krKykge1xuICAgICAgICBhID0gaS1sZWZ0W2ldO1xuICAgICAgICBVaSA9IFVbaV07XG4gICAgICAgIGZvcihqPWkrMTtsZWZ0W2pdPD1pICYmIGo8bTtqKyspIHtcbiAgICAgICAgICAgIGIgPSBpLWxlZnRbal07XG4gICAgICAgICAgICBjID0gcmlnaHRbaV0taTtcbiAgICAgICAgICAgIFVqID0gVVtqXTtcbiAgICAgICAgICAgIGFscGhhID0gVWpbYl0vVWlbYV07XG4gICAgICAgICAgICBpZihhbHBoYSkge1xuICAgICAgICAgICAgICAgIGZvcihrPTE7azw9YztrKyspIHsgVWpbaytiXSAtPSBhbHBoYSpVaVtrK2FdOyB9XG4gICAgICAgICAgICAgICAgTFtqXVtpLWxlZnRbal1dID0gYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIFVpID0gW10sIFVqID0gW10sIFV2ID0gW10sIExpID0gW10sIExqID0gW10sIEx2ID0gW107XG4gICAgdmFyIHAscSxmb287XG4gICAgcD0wOyBxPTA7XG4gICAgZm9yKGk9MDtpPG07aSsrKSB7XG4gICAgICAgIGEgPSBsZWZ0W2ldO1xuICAgICAgICBiID0gcmlnaHRbaV07XG4gICAgICAgIGZvbyA9IFVbaV07XG4gICAgICAgIGZvcihqPWk7ajw9YjtqKyspIHtcbiAgICAgICAgICAgIGlmKGZvb1tqLWFdKSB7XG4gICAgICAgICAgICAgICAgVWlbcF0gPSBpO1xuICAgICAgICAgICAgICAgIFVqW3BdID0gajtcbiAgICAgICAgICAgICAgICBVdltwXSA9IGZvb1tqLWFdO1xuICAgICAgICAgICAgICAgIHArKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb28gPSBMW2ldO1xuICAgICAgICBmb3Ioaj1hO2o8aTtqKyspIHtcbiAgICAgICAgICAgIGlmKGZvb1tqLWFdKSB7XG4gICAgICAgICAgICAgICAgTGlbcV0gPSBpO1xuICAgICAgICAgICAgICAgIExqW3FdID0gajtcbiAgICAgICAgICAgICAgICBMdltxXSA9IGZvb1tqLWFdO1xuICAgICAgICAgICAgICAgIHErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBMaVtxXSA9IGk7XG4gICAgICAgIExqW3FdID0gaTtcbiAgICAgICAgTHZbcV0gPSAxO1xuICAgICAgICBxKys7XG4gICAgfVxuICAgIHJldHVybiB7VTpbVWksVWosVXZdLCBMOltMaSxMaixMdl19O1xufTtcblxubnVtZXJpYy5jTFVzb2x2ZSA9IGZ1bmN0aW9uIExVc29sdmUobHUsYikge1xuICAgIHZhciBMID0gbHUuTCwgVSA9IGx1LlUsIHJldCA9IG51bWVyaWMuY2xvbmUoYik7XG4gICAgdmFyIExpID0gTFswXSwgTGogPSBMWzFdLCBMdiA9IExbMl07XG4gICAgdmFyIFVpID0gVVswXSwgVWogPSBVWzFdLCBVdiA9IFVbMl07XG4gICAgdmFyIHAgPSBVaS5sZW5ndGgsIHEgPSBMaS5sZW5ndGg7XG4gICAgdmFyIG0gPSByZXQubGVuZ3RoLGksaixrO1xuICAgIGsgPSAwO1xuICAgIGZvcihpPTA7aTxtO2krKykge1xuICAgICAgICB3aGlsZShMaltrXSA8IGkpIHtcbiAgICAgICAgICAgIHJldFtpXSAtPSBMdltrXSpyZXRbTGpba11dO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIGsrKztcbiAgICB9XG4gICAgayA9IHAtMTtcbiAgICBmb3IoaT1tLTE7aT49MDtpLS0pIHtcbiAgICAgICAgd2hpbGUoVWpba10gPiBpKSB7XG4gICAgICAgICAgICByZXRbaV0gLT0gVXZba10qcmV0W1VqW2tdXTtcbiAgICAgICAgICAgIGstLTtcbiAgICAgICAgfVxuICAgICAgICByZXRbaV0gLz0gVXZba107XG4gICAgICAgIGstLTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbm51bWVyaWMuY2dyaWQgPSBmdW5jdGlvbiBncmlkKG4sc2hhcGUpIHtcbiAgICBpZih0eXBlb2YgbiA9PT0gXCJudW1iZXJcIikgbiA9IFtuLG5dO1xuICAgIHZhciByZXQgPSBudW1lcmljLnJlcChuLC0xKTtcbiAgICB2YXIgaSxqLGNvdW50O1xuICAgIGlmKHR5cGVvZiBzaGFwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHN3aXRjaChzaGFwZSkge1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgIHNoYXBlID0gZnVuY3Rpb24oaSxqKSB7IHJldHVybiAoaT49blswXS8yIHx8IGo8blsxXS8yKTsgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzaGFwZSA9IGZ1bmN0aW9uKGksaikgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvdW50PTA7XG4gICAgZm9yKGk9MTtpPG5bMF0tMTtpKyspIGZvcihqPTE7ajxuWzFdLTE7aisrKSBcbiAgICAgICAgaWYoc2hhcGUoaSxqKSkge1xuICAgICAgICAgICAgcmV0W2ldW2pdID0gY291bnQ7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5jZGVsc3EgPSBmdW5jdGlvbiBkZWxzcShnKSB7XG4gICAgdmFyIGRpciA9IFtbLTEsMF0sWzAsLTFdLFswLDFdLFsxLDBdXTtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKGcpLCBtID0gc1swXSwgbiA9IHNbMV0sIGksaixrLHAscTtcbiAgICB2YXIgTGkgPSBbXSwgTGogPSBbXSwgTHYgPSBbXTtcbiAgICBmb3IoaT0xO2k8bS0xO2krKykgZm9yKGo9MTtqPG4tMTtqKyspIHtcbiAgICAgICAgaWYoZ1tpXVtqXTwwKSBjb250aW51ZTtcbiAgICAgICAgZm9yKGs9MDtrPDQ7aysrKSB7XG4gICAgICAgICAgICBwID0gaStkaXJba11bMF07XG4gICAgICAgICAgICBxID0gaitkaXJba11bMV07XG4gICAgICAgICAgICBpZihnW3BdW3FdPDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgTGkucHVzaChnW2ldW2pdKTtcbiAgICAgICAgICAgIExqLnB1c2goZ1twXVtxXSk7XG4gICAgICAgICAgICBMdi5wdXNoKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBMaS5wdXNoKGdbaV1bal0pO1xuICAgICAgICBMai5wdXNoKGdbaV1bal0pO1xuICAgICAgICBMdi5wdXNoKDQpO1xuICAgIH1cbiAgICByZXR1cm4gW0xpLExqLEx2XTtcbn1cblxubnVtZXJpYy5jZG90TVYgPSBmdW5jdGlvbiBkb3RNVihBLHgpIHtcbiAgICB2YXIgcmV0LCBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdLGsscD1BaS5sZW5ndGgsTjtcbiAgICBOPTA7XG4gICAgZm9yKGs9MDtrPHA7aysrKSB7IGlmKEFpW2tdPk4pIE4gPSBBaVtrXTsgfVxuICAgIE4rKztcbiAgICByZXQgPSBudW1lcmljLnJlcChbTl0sMCk7XG4gICAgZm9yKGs9MDtrPHA7aysrKSB7IHJldFtBaVtrXV0rPUF2W2tdKnhbQWpba11dOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLy8gNy4gU3BsaW5lc1xuXG5udW1lcmljLlNwbGluZSA9IGZ1bmN0aW9uIFNwbGluZSh4LHlsLHlyLGtsLGtyKSB7IHRoaXMueCA9IHg7IHRoaXMueWwgPSB5bDsgdGhpcy55ciA9IHlyOyB0aGlzLmtsID0ga2w7IHRoaXMua3IgPSBrcjsgfVxubnVtZXJpYy5TcGxpbmUucHJvdG90eXBlLl9hdCA9IGZ1bmN0aW9uIF9hdCh4MSxwKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHlsID0gdGhpcy55bDtcbiAgICB2YXIgeXIgPSB0aGlzLnlyO1xuICAgIHZhciBrbCA9IHRoaXMua2w7XG4gICAgdmFyIGtyID0gdGhpcy5rcjtcbiAgICB2YXIgeDEsYSxiLHQ7XG4gICAgdmFyIGFkZCA9IG51bWVyaWMuYWRkLCBzdWIgPSBudW1lcmljLnN1YiwgbXVsID0gbnVtZXJpYy5tdWw7XG4gICAgYSA9IHN1YihtdWwoa2xbcF0seFtwKzFdLXhbcF0pLHN1Yih5cltwKzFdLHlsW3BdKSk7XG4gICAgYiA9IGFkZChtdWwoa3JbcCsxXSx4W3BdLXhbcCsxXSksc3ViKHlyW3ArMV0seWxbcF0pKTtcbiAgICB0ID0gKHgxLXhbcF0pLyh4W3ArMV0teFtwXSk7XG4gICAgdmFyIHMgPSB0KigxLXQpO1xuICAgIHJldHVybiBhZGQoYWRkKGFkZChtdWwoMS10LHlsW3BdKSxtdWwodCx5cltwKzFdKSksbXVsKGEscyooMS10KSkpLG11bChiLHMqdCkpO1xufVxubnVtZXJpYy5TcGxpbmUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQoeDApIHtcbiAgICBpZih0eXBlb2YgeDAgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICAgIHZhciBuID0geC5sZW5ndGg7XG4gICAgICAgIHZhciBwLHEsbWlkLGZsb29yID0gTWF0aC5mbG9vcixhLGIsdDtcbiAgICAgICAgcCA9IDA7XG4gICAgICAgIHEgPSBuLTE7XG4gICAgICAgIHdoaWxlKHEtcD4xKSB7XG4gICAgICAgICAgICBtaWQgPSBmbG9vcigocCtxKS8yKTtcbiAgICAgICAgICAgIGlmKHhbbWlkXSA8PSB4MCkgcCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgcSA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYXQoeDAscCk7XG4gICAgfVxuICAgIHZhciBuID0geDAubGVuZ3RoLCBpLCByZXQgPSBBcnJheShuKTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgcmV0W2ldID0gdGhpcy5hdCh4MFtpXSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gZGlmZigpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeWwgPSB0aGlzLnlsO1xuICAgIHZhciB5ciA9IHRoaXMueXI7XG4gICAgdmFyIGtsID0gdGhpcy5rbDtcbiAgICB2YXIga3IgPSB0aGlzLmtyO1xuICAgIHZhciBuID0geWwubGVuZ3RoO1xuICAgIHZhciBpLGR4LGR5O1xuICAgIHZhciB6bCA9IGtsLCB6ciA9IGtyLCBwbCA9IEFycmF5KG4pLCBwciA9IEFycmF5KG4pO1xuICAgIHZhciBhZGQgPSBudW1lcmljLmFkZCwgbXVsID0gbnVtZXJpYy5tdWwsIGRpdiA9IG51bWVyaWMuZGl2LCBzdWIgPSBudW1lcmljLnN1YjtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBkeCA9IHhbaSsxXS14W2ldO1xuICAgICAgICBkeSA9IHN1Yih5cltpKzFdLHlsW2ldKTtcbiAgICAgICAgcGxbaV0gPSBkaXYoYWRkKG11bChkeSwgNiksbXVsKGtsW2ldLC00KmR4KSxtdWwoa3JbaSsxXSwtMipkeCkpLGR4KmR4KTtcbiAgICAgICAgcHJbaSsxXSA9IGRpdihhZGQobXVsKGR5LC02KSxtdWwoa2xbaV0sIDIqZHgpLG11bChrcltpKzFdLCA0KmR4KSksZHgqZHgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuU3BsaW5lKHgsemwsenIscGwscHIpO1xufVxubnVtZXJpYy5TcGxpbmUucHJvdG90eXBlLnJvb3RzID0gZnVuY3Rpb24gcm9vdHMoKSB7XG4gICAgZnVuY3Rpb24gc3FyKHgpIHsgcmV0dXJuIHgqeDsgfVxuICAgIGZ1bmN0aW9uIGhldmFsKHkwLHkxLGswLGsxLHgpIHtcbiAgICAgICAgdmFyIEEgPSBrMCoyLSh5MS15MCk7XG4gICAgICAgIHZhciBCID0gLWsxKjIrKHkxLXkwKTtcbiAgICAgICAgdmFyIHQgPSAoeCsxKSowLjU7XG4gICAgICAgIHZhciBzID0gdCooMS10KTtcbiAgICAgICAgcmV0dXJuICgxLXQpKnkwK3QqeTErQSpzKigxLXQpK0Iqcyp0O1xuICAgIH1cbiAgICB2YXIgcmV0ID0gW107XG4gICAgdmFyIHggPSB0aGlzLngsIHlsID0gdGhpcy55bCwgeXIgPSB0aGlzLnlyLCBrbCA9IHRoaXMua2wsIGtyID0gdGhpcy5rcjtcbiAgICBpZih0eXBlb2YgeWxbMF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeWwgPSBbeWxdO1xuICAgICAgICB5ciA9IFt5cl07XG4gICAgICAgIGtsID0gW2tsXTtcbiAgICAgICAga3IgPSBba3JdO1xuICAgIH1cbiAgICB2YXIgbSA9IHlsLmxlbmd0aCxuPXgubGVuZ3RoLTEsaSxqLGsseSxzLHQ7XG4gICAgdmFyIGFpLGJpLGNpLGRpLCByZXQgPSBBcnJheShtKSxyaSxrMCxrMSx5MCx5MSxBLEIsRCxkeCxjeCxzdG9wcyx6MCx6MSx6bSx0MCx0MSx0bTtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICBmb3IoaT0wO2khPT1tOysraSkge1xuICAgICAgICBhaSA9IHlsW2ldO1xuICAgICAgICBiaSA9IHlyW2ldO1xuICAgICAgICBjaSA9IGtsW2ldO1xuICAgICAgICBkaSA9IGtyW2ldO1xuICAgICAgICByaSA9IFtdO1xuICAgICAgICBmb3Ioaj0wO2ohPT1uO2orKykge1xuICAgICAgICAgICAgaWYoaj4wICYmIGJpW2pdKmFpW2pdPDApIHJpLnB1c2goeFtqXSk7XG4gICAgICAgICAgICBkeCA9ICh4W2orMV0teFtqXSk7XG4gICAgICAgICAgICBjeCA9IHhbal07XG4gICAgICAgICAgICB5MCA9IGFpW2pdO1xuICAgICAgICAgICAgeTEgPSBiaVtqKzFdO1xuICAgICAgICAgICAgazAgPSBjaVtqXS9keDtcbiAgICAgICAgICAgIGsxID0gZGlbaisxXS9keDtcbiAgICAgICAgICAgIEQgPSBzcXIoazAtazErMyooeTAteTEpKSArIDEyKmsxKnkwO1xuICAgICAgICAgICAgQSA9IGsxKzMqeTArMiprMC0zKnkxO1xuICAgICAgICAgICAgQiA9IDMqKGsxK2swKzIqKHkwLXkxKSk7XG4gICAgICAgICAgICBpZihEPD0wKSB7XG4gICAgICAgICAgICAgICAgejAgPSBBL0I7XG4gICAgICAgICAgICAgICAgaWYoejA+eFtqXSAmJiB6MDx4W2orMV0pIHN0b3BzID0gW3hbal0sejAseFtqKzFdXTtcbiAgICAgICAgICAgICAgICBlbHNlIHN0b3BzID0gW3hbal0seFtqKzFdXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgejAgPSAoQS1zcXJ0KEQpKS9CO1xuICAgICAgICAgICAgICAgIHoxID0gKEErc3FydChEKSkvQjtcbiAgICAgICAgICAgICAgICBzdG9wcyA9IFt4W2pdXTtcbiAgICAgICAgICAgICAgICBpZih6MD54W2pdICYmIHowPHhbaisxXSkgc3RvcHMucHVzaCh6MCk7XG4gICAgICAgICAgICAgICAgaWYoejE+eFtqXSAmJiB6MTx4W2orMV0pIHN0b3BzLnB1c2goejEpO1xuICAgICAgICAgICAgICAgIHN0b3BzLnB1c2goeFtqKzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQwID0gc3RvcHNbMF07XG4gICAgICAgICAgICB6MCA9IHRoaXMuX2F0KHQwLGopO1xuICAgICAgICAgICAgZm9yKGs9MDtrPHN0b3BzLmxlbmd0aC0xO2srKykge1xuICAgICAgICAgICAgICAgIHQxID0gc3RvcHNbaysxXTtcbiAgICAgICAgICAgICAgICB6MSA9IHRoaXMuX2F0KHQxLGopO1xuICAgICAgICAgICAgICAgIGlmKHowID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpLnB1c2godDApOyBcbiAgICAgICAgICAgICAgICAgICAgdDAgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgejAgPSB6MTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHoxID09PSAwIHx8IHowKnoxPjApIHtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgejAgPSB6MTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaWRlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtID0gKHowKnQxLXoxKnQwKS8oejAtejEpO1xuICAgICAgICAgICAgICAgICAgICBpZih0bSA8PSB0MCB8fCB0bSA+PSB0MSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICB6bSA9IHRoaXMuX2F0KHRtLGopO1xuICAgICAgICAgICAgICAgICAgICBpZih6bSp6MT4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0MSA9IHRtO1xuICAgICAgICAgICAgICAgICAgICAgICAgejEgPSB6bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNpZGUgPT09IC0xKSB6MCo9MC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoem0qejA+MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdDAgPSB0bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHowID0gem07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzaWRlID09PSAxKSB6MSo9MC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmkucHVzaCh0bSk7XG4gICAgICAgICAgICAgICAgdDAgPSBzdG9wc1trKzFdO1xuICAgICAgICAgICAgICAgIHowID0gdGhpcy5fYXQodDAsIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoejEgPT09IDApIHJpLnB1c2godDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldFtpXSA9IHJpO1xuICAgIH1cbiAgICBpZih0eXBlb2YgdGhpcy55bFswXSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHJldFswXTtcbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5zcGxpbmUgPSBmdW5jdGlvbiBzcGxpbmUoeCx5LGsxLGtuKSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aCwgYiA9IFtdLCBkeCA9IFtdLCBkeSA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBzdWIgPSBudW1lcmljLnN1YixtdWwgPSBudW1lcmljLm11bCxhZGQgPSBudW1lcmljLmFkZDtcbiAgICBmb3IoaT1uLTI7aT49MDtpLS0pIHsgZHhbaV0gPSB4W2krMV0teFtpXTsgZHlbaV0gPSBzdWIoeVtpKzFdLHlbaV0pOyB9XG4gICAgaWYodHlwZW9mIGsxID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBrbiA9PT0gXCJzdHJpbmdcIikgeyBcbiAgICAgICAgazEgPSBrbiA9IFwicGVyaW9kaWNcIjtcbiAgICB9XG4gICAgLy8gQnVpbGQgc3BhcnNlIHRyaWRpYWdvbmFsIHN5c3RlbVxuICAgIHZhciBUID0gW1tdLFtdLFtdXTtcbiAgICBzd2l0Y2godHlwZW9mIGsxKSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICBiWzBdID0gbXVsKDMvKGR4WzBdKmR4WzBdKSxkeVswXSk7XG4gICAgICAgIFRbMF0ucHVzaCgwLDApO1xuICAgICAgICBUWzFdLnB1c2goMCwxKTtcbiAgICAgICAgVFsyXS5wdXNoKDIvZHhbMF0sMS9keFswXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgYlswXSA9IGFkZChtdWwoMy8oZHhbbi0yXSpkeFtuLTJdKSxkeVtuLTJdKSxtdWwoMy8oZHhbMF0qZHhbMF0pLGR5WzBdKSk7XG4gICAgICAgIFRbMF0ucHVzaCgwLDAsMCk7XG4gICAgICAgIFRbMV0ucHVzaChuLTIsMCwxKTtcbiAgICAgICAgVFsyXS5wdXNoKDEvZHhbbi0yXSwyL2R4W24tMl0rMi9keFswXSwxL2R4WzBdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgYlswXSA9IGsxO1xuICAgICAgICBUWzBdLnB1c2goMCk7XG4gICAgICAgIFRbMV0ucHVzaCgwKTtcbiAgICAgICAgVFsyXS5wdXNoKDEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yKGk9MTtpPG4tMTtpKyspIHtcbiAgICAgICAgYltpXSA9IGFkZChtdWwoMy8oZHhbaS0xXSpkeFtpLTFdKSxkeVtpLTFdKSxtdWwoMy8oZHhbaV0qZHhbaV0pLGR5W2ldKSk7XG4gICAgICAgIFRbMF0ucHVzaChpLGksaSk7XG4gICAgICAgIFRbMV0ucHVzaChpLTEsaSxpKzEpO1xuICAgICAgICBUWzJdLnB1c2goMS9keFtpLTFdLDIvZHhbaS0xXSsyL2R4W2ldLDEvZHhbaV0pO1xuICAgIH1cbiAgICBzd2l0Y2godHlwZW9mIGtuKSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICBiW24tMV0gPSBtdWwoMy8oZHhbbi0yXSpkeFtuLTJdKSxkeVtuLTJdKTtcbiAgICAgICAgVFswXS5wdXNoKG4tMSxuLTEpO1xuICAgICAgICBUWzFdLnB1c2gobi0yLG4tMSk7XG4gICAgICAgIFRbMl0ucHVzaCgxL2R4W24tMl0sMi9keFtuLTJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBUWzFdW1RbMV0ubGVuZ3RoLTFdID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgYltuLTFdID0ga247XG4gICAgICAgIFRbMF0ucHVzaChuLTEpO1xuICAgICAgICBUWzFdLnB1c2gobi0xKTtcbiAgICAgICAgVFsyXS5wdXNoKDEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYodHlwZW9mIGJbMF0gIT09IFwibnVtYmVyXCIpIGIgPSBudW1lcmljLnRyYW5zcG9zZShiKTtcbiAgICBlbHNlIGIgPSBbYl07XG4gICAgdmFyIGsgPSBBcnJheShiLmxlbmd0aCk7XG4gICAgaWYodHlwZW9mIGsxID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvcihpPWsubGVuZ3RoLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAgICAga1tpXSA9IG51bWVyaWMuY2NzTFVQU29sdmUobnVtZXJpYy5jY3NMVVAobnVtZXJpYy5jY3NTY2F0dGVyKFQpKSxiW2ldKTtcbiAgICAgICAgICAgIGtbaV1bbi0xXSA9IGtbaV1bMF07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoaT1rLmxlbmd0aC0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgICAgIGtbaV0gPSBudW1lcmljLmNMVXNvbHZlKG51bWVyaWMuY0xVKFQpLGJbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmKHR5cGVvZiB5WzBdID09PSBcIm51bWJlclwiKSBrID0ga1swXTtcbiAgICBlbHNlIGsgPSBudW1lcmljLnRyYW5zcG9zZShrKTtcbiAgICByZXR1cm4gbmV3IG51bWVyaWMuU3BsaW5lKHgseSx5LGssayk7XG59XG5cbi8vIDguIEZGVFxubnVtZXJpYy5mZnRwb3cyID0gZnVuY3Rpb24gZmZ0cG93Mih4LHkpIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgIGlmKG4gPT09IDEpIHJldHVybjtcbiAgICB2YXIgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luLCBpLGo7XG4gICAgdmFyIHhlID0gQXJyYXkobi8yKSwgeWUgPSBBcnJheShuLzIpLCB4byA9IEFycmF5KG4vMiksIHlvID0gQXJyYXkobi8yKTtcbiAgICBqID0gbi8yO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIC0tajtcbiAgICAgICAgeG9bal0gPSB4W2ldO1xuICAgICAgICB5b1tqXSA9IHlbaV07XG4gICAgICAgIC0taTtcbiAgICAgICAgeGVbal0gPSB4W2ldO1xuICAgICAgICB5ZVtqXSA9IHlbaV07XG4gICAgfVxuICAgIGZmdHBvdzIoeGUseWUpO1xuICAgIGZmdHBvdzIoeG8seW8pO1xuICAgIGogPSBuLzI7XG4gICAgdmFyIHQsayA9ICgtNi4yODMxODUzMDcxNzk1ODY0NzY5MjUyODY3NjY1NTkwMDU3NjgzOTQzMzg3OTg3NTAyMTE2NDE5L24pLGNpLHNpO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIC0tajtcbiAgICAgICAgaWYoaiA9PT0gLTEpIGogPSBuLzItMTtcbiAgICAgICAgdCA9IGsqaTtcbiAgICAgICAgY2kgPSBjb3ModCk7XG4gICAgICAgIHNpID0gc2luKHQpO1xuICAgICAgICB4W2ldID0geGVbal0gKyBjaSp4b1tqXSAtIHNpKnlvW2pdO1xuICAgICAgICB5W2ldID0geWVbal0gKyBjaSp5b1tqXSArIHNpKnhvW2pdO1xuICAgIH1cbn1cbm51bWVyaWMuX2lmZnRwb3cyID0gZnVuY3Rpb24gX2lmZnRwb3cyKHgseSkge1xuICAgIHZhciBuID0geC5sZW5ndGg7XG4gICAgaWYobiA9PT0gMSkgcmV0dXJuO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW4sIGksajtcbiAgICB2YXIgeGUgPSBBcnJheShuLzIpLCB5ZSA9IEFycmF5KG4vMiksIHhvID0gQXJyYXkobi8yKSwgeW8gPSBBcnJheShuLzIpO1xuICAgIGogPSBuLzI7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgLS1qO1xuICAgICAgICB4b1tqXSA9IHhbaV07XG4gICAgICAgIHlvW2pdID0geVtpXTtcbiAgICAgICAgLS1pO1xuICAgICAgICB4ZVtqXSA9IHhbaV07XG4gICAgICAgIHllW2pdID0geVtpXTtcbiAgICB9XG4gICAgX2lmZnRwb3cyKHhlLHllKTtcbiAgICBfaWZmdHBvdzIoeG8seW8pO1xuICAgIGogPSBuLzI7XG4gICAgdmFyIHQsayA9ICg2LjI4MzE4NTMwNzE3OTU4NjQ3NjkyNTI4Njc2NjU1OTAwNTc2ODM5NDMzODc5ODc1MDIxMTY0MTkvbiksY2ksc2k7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgLS1qO1xuICAgICAgICBpZihqID09PSAtMSkgaiA9IG4vMi0xO1xuICAgICAgICB0ID0gayppO1xuICAgICAgICBjaSA9IGNvcyh0KTtcbiAgICAgICAgc2kgPSBzaW4odCk7XG4gICAgICAgIHhbaV0gPSB4ZVtqXSArIGNpKnhvW2pdIC0gc2kqeW9bal07XG4gICAgICAgIHlbaV0gPSB5ZVtqXSArIGNpKnlvW2pdICsgc2kqeG9bal07XG4gICAgfVxufVxubnVtZXJpYy5pZmZ0cG93MiA9IGZ1bmN0aW9uIGlmZnRwb3cyKHgseSkge1xuICAgIG51bWVyaWMuX2lmZnRwb3cyKHgseSk7XG4gICAgbnVtZXJpYy5kaXZlcSh4LHgubGVuZ3RoKTtcbiAgICBudW1lcmljLmRpdmVxKHkseS5sZW5ndGgpO1xufVxubnVtZXJpYy5jb252cG93MiA9IGZ1bmN0aW9uIGNvbnZwb3cyKGF4LGF5LGJ4LGJ5KSB7XG4gICAgbnVtZXJpYy5mZnRwb3cyKGF4LGF5KTtcbiAgICBudW1lcmljLmZmdHBvdzIoYngsYnkpO1xuICAgIHZhciBpLG4gPSBheC5sZW5ndGgsYXhpLGJ4aSxheWksYnlpO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGF4aSA9IGF4W2ldOyBheWkgPSBheVtpXTsgYnhpID0gYnhbaV07IGJ5aSA9IGJ5W2ldO1xuICAgICAgICBheFtpXSA9IGF4aSpieGktYXlpKmJ5aTtcbiAgICAgICAgYXlbaV0gPSBheGkqYnlpK2F5aSpieGk7XG4gICAgfVxuICAgIG51bWVyaWMuaWZmdHBvdzIoYXgsYXkpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5mZnQgPSBmdW5jdGlvbiBmZnQoKSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aCwgbG9nID0gTWF0aC5sb2csIGxvZzIgPSBsb2coMiksXG4gICAgICAgIHAgPSBNYXRoLmNlaWwobG9nKDIqbi0xKS9sb2cyKSwgbSA9IE1hdGgucG93KDIscCk7XG4gICAgdmFyIGN4ID0gbnVtZXJpYy5yZXAoW21dLDApLCBjeSA9IG51bWVyaWMucmVwKFttXSwwKSwgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciBrLCBjID0gKC0zLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMC9uKSx0O1xuICAgIHZhciBhID0gbnVtZXJpYy5yZXAoW21dLDApLCBiID0gbnVtZXJpYy5yZXAoW21dLDApLG5oYWxmID0gTWF0aC5mbG9vcihuLzIpO1xuICAgIGZvcihrPTA7azxuO2srKykgYVtrXSA9IHhba107XG4gICAgaWYodHlwZW9mIHkgIT09IFwidW5kZWZpbmVkXCIpIGZvcihrPTA7azxuO2srKykgYltrXSA9IHlba107XG4gICAgY3hbMF0gPSAxO1xuICAgIGZvcihrPTE7azw9bS8yO2srKykge1xuICAgICAgICB0ID0gYyprKms7XG4gICAgICAgIGN4W2tdID0gY29zKHQpO1xuICAgICAgICBjeVtrXSA9IHNpbih0KTtcbiAgICAgICAgY3hbbS1rXSA9IGNvcyh0KTtcbiAgICAgICAgY3lbbS1rXSA9IHNpbih0KVxuICAgIH1cbiAgICB2YXIgWCA9IG5ldyBudW1lcmljLlQoYSxiKSwgWSA9IG5ldyBudW1lcmljLlQoY3gsY3kpO1xuICAgIFggPSBYLm11bChZKTtcbiAgICBudW1lcmljLmNvbnZwb3cyKFgueCxYLnksbnVtZXJpYy5jbG9uZShZLngpLG51bWVyaWMubmVnKFkueSkpO1xuICAgIFggPSBYLm11bChZKTtcbiAgICBYLngubGVuZ3RoID0gbjtcbiAgICBYLnkubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gWDtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuaWZmdCA9IGZ1bmN0aW9uIGlmZnQoKSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aCwgbG9nID0gTWF0aC5sb2csIGxvZzIgPSBsb2coMiksXG4gICAgICAgIHAgPSBNYXRoLmNlaWwobG9nKDIqbi0xKS9sb2cyKSwgbSA9IE1hdGgucG93KDIscCk7XG4gICAgdmFyIGN4ID0gbnVtZXJpYy5yZXAoW21dLDApLCBjeSA9IG51bWVyaWMucmVwKFttXSwwKSwgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciBrLCBjID0gKDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTA1ODIwL24pLHQ7XG4gICAgdmFyIGEgPSBudW1lcmljLnJlcChbbV0sMCksIGIgPSBudW1lcmljLnJlcChbbV0sMCksbmhhbGYgPSBNYXRoLmZsb29yKG4vMik7XG4gICAgZm9yKGs9MDtrPG47aysrKSBhW2tdID0geFtrXTtcbiAgICBpZih0eXBlb2YgeSAhPT0gXCJ1bmRlZmluZWRcIikgZm9yKGs9MDtrPG47aysrKSBiW2tdID0geVtrXTtcbiAgICBjeFswXSA9IDE7XG4gICAgZm9yKGs9MTtrPD1tLzI7aysrKSB7XG4gICAgICAgIHQgPSBjKmsqaztcbiAgICAgICAgY3hba10gPSBjb3ModCk7XG4gICAgICAgIGN5W2tdID0gc2luKHQpO1xuICAgICAgICBjeFttLWtdID0gY29zKHQpO1xuICAgICAgICBjeVttLWtdID0gc2luKHQpXG4gICAgfVxuICAgIHZhciBYID0gbmV3IG51bWVyaWMuVChhLGIpLCBZID0gbmV3IG51bWVyaWMuVChjeCxjeSk7XG4gICAgWCA9IFgubXVsKFkpO1xuICAgIG51bWVyaWMuY29udnBvdzIoWC54LFgueSxudW1lcmljLmNsb25lKFkueCksbnVtZXJpYy5uZWcoWS55KSk7XG4gICAgWCA9IFgubXVsKFkpO1xuICAgIFgueC5sZW5ndGggPSBuO1xuICAgIFgueS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBYLmRpdihuKTtcbn1cblxuLy85LiBVbmNvbnN0cmFpbmVkIG9wdGltaXphdGlvblxubnVtZXJpYy5ncmFkaWVudCA9IGZ1bmN0aW9uIGdyYWRpZW50KGYseCkge1xuICAgIHZhciBuID0geC5sZW5ndGg7XG4gICAgdmFyIGYwID0gZih4KTtcbiAgICBpZihpc05hTihmMCkpIHRocm93IG5ldyBFcnJvcignZ3JhZGllbnQ6IGYoeCkgaXMgYSBOYU4hJyk7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4O1xuICAgIHZhciBpLHgwID0gbnVtZXJpYy5jbG9uZSh4KSxmMSxmMiwgSiA9IEFycmF5KG4pO1xuICAgIHZhciBkaXYgPSBudW1lcmljLmRpdiwgc3ViID0gbnVtZXJpYy5zdWIsZXJyZXN0LHJvdW5kb2ZmLG1heCA9IE1hdGgubWF4LGVwcyA9IDFlLTMsYWJzID0gTWF0aC5hYnMsIG1pbiA9IE1hdGgubWluO1xuICAgIHZhciB0MCx0MSx0MixpdD0wLGQxLGQyLE47XG4gICAgZm9yKGk9MDtpPG47aSsrKSB7XG4gICAgICAgIHZhciBoID0gbWF4KDFlLTYqZjAsMWUtOCk7XG4gICAgICAgIHdoaWxlKDEpIHtcbiAgICAgICAgICAgICsraXQ7XG4gICAgICAgICAgICBpZihpdD4yMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJOdW1lcmljYWwgZ3JhZGllbnQgZmFpbHNcIik7IH1cbiAgICAgICAgICAgIHgwW2ldID0geFtpXStoO1xuICAgICAgICAgICAgZjEgPSBmKHgwKTtcbiAgICAgICAgICAgIHgwW2ldID0geFtpXS1oO1xuICAgICAgICAgICAgZjIgPSBmKHgwKTtcbiAgICAgICAgICAgIHgwW2ldID0geFtpXTtcbiAgICAgICAgICAgIGlmKGlzTmFOKGYxKSB8fCBpc05hTihmMikpIHsgaC89MTY7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBKW2ldID0gKGYxLWYyKS8oMipoKTtcbiAgICAgICAgICAgIHQwID0geFtpXS1oO1xuICAgICAgICAgICAgdDEgPSB4W2ldO1xuICAgICAgICAgICAgdDIgPSB4W2ldK2g7XG4gICAgICAgICAgICBkMSA9IChmMS1mMCkvaDtcbiAgICAgICAgICAgIGQyID0gKGYwLWYyKS9oO1xuICAgICAgICAgICAgTiA9IG1heChhYnMoSltpXSksYWJzKGYwKSxhYnMoZjEpLGFicyhmMiksYWJzKHQwKSxhYnModDEpLGFicyh0MiksMWUtOCk7XG4gICAgICAgICAgICBlcnJlc3QgPSBtaW4obWF4KGFicyhkMS1KW2ldKSxhYnMoZDItSltpXSksYWJzKGQxLWQyKSkvTixoL04pO1xuICAgICAgICAgICAgaWYoZXJyZXN0PmVwcykgeyBoLz0xNjsgfVxuICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEo7XG59XG5cbm51bWVyaWMudW5jbWluID0gZnVuY3Rpb24gdW5jbWluKGYseDAsdG9sLGdyYWRpZW50LG1heGl0LGNhbGxiYWNrLG9wdGlvbnMpIHtcbiAgICB2YXIgZ3JhZCA9IG51bWVyaWMuZ3JhZGllbnQ7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgaWYodHlwZW9mIHRvbCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0b2wgPSAxZS04OyB9XG4gICAgaWYodHlwZW9mIGdyYWRpZW50ID09PSBcInVuZGVmaW5lZFwiKSB7IGdyYWRpZW50ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4gZ3JhZChmLHgpOyB9OyB9XG4gICAgaWYodHlwZW9mIG1heGl0ID09PSBcInVuZGVmaW5lZFwiKSBtYXhpdCA9IDEwMDA7XG4gICAgeDAgPSBudW1lcmljLmNsb25lKHgwKTtcbiAgICB2YXIgbiA9IHgwLmxlbmd0aDtcbiAgICB2YXIgZjAgPSBmKHgwKSxmMSxkZjA7XG4gICAgaWYoaXNOYU4oZjApKSB0aHJvdyBuZXcgRXJyb3IoJ3VuY21pbjogZih4MCkgaXMgYSBOYU4hJyk7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4LCBub3JtMiA9IG51bWVyaWMubm9ybTI7XG4gICAgdG9sID0gbWF4KHRvbCxudW1lcmljLmVwc2lsb24pO1xuICAgIHZhciBzdGVwLGcwLGcxLEgxID0gb3B0aW9ucy5IaW52IHx8IG51bWVyaWMuaWRlbnRpdHkobik7XG4gICAgdmFyIGRvdCA9IG51bWVyaWMuZG90LCBpbnYgPSBudW1lcmljLmludiwgc3ViID0gbnVtZXJpYy5zdWIsIGFkZCA9IG51bWVyaWMuYWRkLCB0ZW4gPSBudW1lcmljLnRlbnNvciwgZGl2ID0gbnVtZXJpYy5kaXYsIG11bCA9IG51bWVyaWMubXVsO1xuICAgIHZhciBhbGwgPSBudW1lcmljLmFsbCwgaXNmaW5pdGUgPSBudW1lcmljLmlzRmluaXRlLCBuZWcgPSBudW1lcmljLm5lZztcbiAgICB2YXIgaXQ9MCxpLHMseDEseSxIeSxIcyx5cyxpMCx0LG5zdGVwLHQxLHQyO1xuICAgIHZhciBtc2cgPSBcIlwiO1xuICAgIGcwID0gZ3JhZGllbnQoeDApO1xuICAgIHdoaWxlKGl0PG1heGl0KSB7XG4gICAgICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7IGlmKGNhbGxiYWNrKGl0LHgwLGYwLGcwLEgxKSkgeyBtc2cgPSBcIkNhbGxiYWNrIHJldHVybmVkIHRydWVcIjsgYnJlYWs7IH0gfVxuICAgICAgICBpZighYWxsKGlzZmluaXRlKGcwKSkpIHsgbXNnID0gXCJHcmFkaWVudCBoYXMgSW5maW5pdHkgb3IgTmFOXCI7IGJyZWFrOyB9XG4gICAgICAgIHN0ZXAgPSBuZWcoZG90KEgxLGcwKSk7XG4gICAgICAgIGlmKCFhbGwoaXNmaW5pdGUoc3RlcCkpKSB7IG1zZyA9IFwiU2VhcmNoIGRpcmVjdGlvbiBoYXMgSW5maW5pdHkgb3IgTmFOXCI7IGJyZWFrOyB9XG4gICAgICAgIG5zdGVwID0gbm9ybTIoc3RlcCk7XG4gICAgICAgIGlmKG5zdGVwIDwgdG9sKSB7IG1zZz1cIk5ld3RvbiBzdGVwIHNtYWxsZXIgdGhhbiB0b2xcIjsgYnJlYWs7IH1cbiAgICAgICAgdCA9IDE7XG4gICAgICAgIGRmMCA9IGRvdChnMCxzdGVwKTtcbiAgICAgICAgLy8gbGluZSBzZWFyY2hcbiAgICAgICAgeDEgPSB4MDtcbiAgICAgICAgd2hpbGUoaXQgPCBtYXhpdCkge1xuICAgICAgICAgICAgaWYodCpuc3RlcCA8IHRvbCkgeyBicmVhazsgfVxuICAgICAgICAgICAgcyA9IG11bChzdGVwLHQpO1xuICAgICAgICAgICAgeDEgPSBhZGQoeDAscyk7XG4gICAgICAgICAgICBmMSA9IGYoeDEpO1xuICAgICAgICAgICAgaWYoZjEtZjAgPj0gMC4xKnQqZGYwIHx8IGlzTmFOKGYxKSkge1xuICAgICAgICAgICAgICAgIHQgKj0gMC41O1xuICAgICAgICAgICAgICAgICsraXQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZih0Km5zdGVwIDwgdG9sKSB7IG1zZyA9IFwiTGluZSBzZWFyY2ggc3RlcCBzaXplIHNtYWxsZXIgdGhhbiB0b2xcIjsgYnJlYWs7IH1cbiAgICAgICAgaWYoaXQgPT09IG1heGl0KSB7IG1zZyA9IFwibWF4aXQgcmVhY2hlZCBkdXJpbmcgbGluZSBzZWFyY2hcIjsgYnJlYWs7IH1cbiAgICAgICAgZzEgPSBncmFkaWVudCh4MSk7XG4gICAgICAgIHkgPSBzdWIoZzEsZzApO1xuICAgICAgICB5cyA9IGRvdCh5LHMpO1xuICAgICAgICBIeSA9IGRvdChIMSx5KTtcbiAgICAgICAgSDEgPSBzdWIoYWRkKEgxLFxuICAgICAgICAgICAgICAgIG11bChcbiAgICAgICAgICAgICAgICAgICAgICAgICh5cytkb3QoeSxIeSkpLyh5cyp5cyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW4ocyxzKSAgICApKSxcbiAgICAgICAgICAgICAgICBkaXYoYWRkKHRlbihIeSxzKSx0ZW4ocyxIeSkpLHlzKSk7XG4gICAgICAgIHgwID0geDE7XG4gICAgICAgIGYwID0gZjE7XG4gICAgICAgIGcwID0gZzE7XG4gICAgICAgICsraXQ7XG4gICAgfVxuICAgIHJldHVybiB7c29sdXRpb246IHgwLCBmOiBmMCwgZ3JhZGllbnQ6IGcwLCBpbnZIZXNzaWFuOiBIMSwgaXRlcmF0aW9uczppdCwgbWVzc2FnZTogbXNnfTtcbn1cblxuLy8gMTAuIE9kZSBzb2x2ZXIgKERvcm1hbmQtUHJpbmNlKVxubnVtZXJpYy5Eb3ByaSA9IGZ1bmN0aW9uIERvcHJpKHgseSxmLHltaWQsaXRlcmF0aW9ucyxtc2csZXZlbnRzKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdGhpcy55bWlkID0geW1pZDtcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbn1cbm51bWVyaWMuRG9wcmkucHJvdG90eXBlLl9hdCA9IGZ1bmN0aW9uIF9hdCh4aSxqKSB7XG4gICAgZnVuY3Rpb24gc3FyKHgpIHsgcmV0dXJuIHgqeDsgfVxuICAgIHZhciBzb2wgPSB0aGlzO1xuICAgIHZhciB4cyA9IHNvbC54O1xuICAgIHZhciB5cyA9IHNvbC55O1xuICAgIHZhciBrMSA9IHNvbC5mO1xuICAgIHZhciB5bWlkID0gc29sLnltaWQ7XG4gICAgdmFyIG4gPSB4cy5sZW5ndGg7XG4gICAgdmFyIHgwLHgxLHhoLHkwLHkxLHloLHhpO1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3IsaDtcbiAgICB2YXIgYyA9IDAuNTtcbiAgICB2YXIgYWRkID0gbnVtZXJpYy5hZGQsIG11bCA9IG51bWVyaWMubXVsLHN1YiA9IG51bWVyaWMuc3ViLCBwLHEsdztcbiAgICB4MCA9IHhzW2pdO1xuICAgIHgxID0geHNbaisxXTtcbiAgICB5MCA9IHlzW2pdO1xuICAgIHkxID0geXNbaisxXTtcbiAgICBoICA9IHgxLXgwO1xuICAgIHhoID0geDArYypoO1xuICAgIHloID0geW1pZFtqXTtcbiAgICBwID0gc3ViKGsxW2ogIF0sbXVsKHkwLDEvKHgwLXhoKSsyLyh4MC14MSkpKTtcbiAgICBxID0gc3ViKGsxW2orMV0sbXVsKHkxLDEvKHgxLXhoKSsyLyh4MS14MCkpKTtcbiAgICB3ID0gW3Nxcih4aSAtIHgxKSAqICh4aSAtIHhoKSAvIHNxcih4MCAtIHgxKSAvICh4MCAtIHhoKSxcbiAgICAgICAgIHNxcih4aSAtIHgwKSAqIHNxcih4aSAtIHgxKSAvIHNxcih4MCAtIHhoKSAvIHNxcih4MSAtIHhoKSxcbiAgICAgICAgIHNxcih4aSAtIHgwKSAqICh4aSAtIHhoKSAvIHNxcih4MSAtIHgwKSAvICh4MSAtIHhoKSxcbiAgICAgICAgICh4aSAtIHgwKSAqIHNxcih4aSAtIHgxKSAqICh4aSAtIHhoKSAvIHNxcih4MC14MSkgLyAoeDAgLSB4aCksXG4gICAgICAgICAoeGkgLSB4MSkgKiBzcXIoeGkgLSB4MCkgKiAoeGkgLSB4aCkgLyBzcXIoeDAteDEpIC8gKHgxIC0geGgpXTtcbiAgICByZXR1cm4gYWRkKGFkZChhZGQoYWRkKG11bCh5MCx3WzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bCh5aCx3WzFdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWwoeTEsd1syXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsKCBwLHdbM10pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bCggcSx3WzRdKSk7XG59XG5udW1lcmljLkRvcHJpLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0KHgpIHtcbiAgICB2YXIgaSxqLGssZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIGlmKHR5cGVvZiB4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhciBuID0geC5sZW5ndGgsIHJldCA9IEFycmF5KG4pO1xuICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAgICAgcmV0W2ldID0gdGhpcy5hdCh4W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICB2YXIgeDAgPSB0aGlzLng7XG4gICAgaSA9IDA7IGogPSB4MC5sZW5ndGgtMTtcbiAgICB3aGlsZShqLWk+MSkge1xuICAgICAgICBrID0gZmxvb3IoMC41KihpK2opKTtcbiAgICAgICAgaWYoeDBba10gPD0geCkgaSA9IGs7XG4gICAgICAgIGVsc2UgaiA9IGs7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hdCh4LGkpO1xufVxuXG5udW1lcmljLmRvcHJpID0gZnVuY3Rpb24gZG9wcmkoeDAseDEseTAsZix0b2wsbWF4aXQsZXZlbnQpIHtcbiAgICBpZih0eXBlb2YgdG9sID09PSBcInVuZGVmaW5lZFwiKSB7IHRvbCA9IDFlLTY7IH1cbiAgICBpZih0eXBlb2YgbWF4aXQgPT09IFwidW5kZWZpbmVkXCIpIHsgbWF4aXQgPSAxMDAwOyB9XG4gICAgdmFyIHhzID0gW3gwXSwgeXMgPSBbeTBdLCBrMSA9IFtmKHgwLHkwKV0sIGsyLGszLGs0LGs1LGs2LGs3LCB5bWlkID0gW107XG4gICAgdmFyIEEyID0gMS81O1xuICAgIHZhciBBMyA9IFszLzQwLDkvNDBdO1xuICAgIHZhciBBNCA9IFs0NC80NSwtNTYvMTUsMzIvOV07XG4gICAgdmFyIEE1ID0gWzE5MzcyLzY1NjEsLTI1MzYwLzIxODcsNjQ0NDgvNjU2MSwtMjEyLzcyOV07XG4gICAgdmFyIEE2ID0gWzkwMTcvMzE2OCwtMzU1LzMzLDQ2NzMyLzUyNDcsNDkvMTc2LC01MTAzLzE4NjU2XTtcbiAgICB2YXIgYiA9IFszNS8zODQsMCw1MDAvMTExMywxMjUvMTkyLC0yMTg3LzY3ODQsMTEvODRdO1xuICAgIHZhciBibSA9IFswLjUqNjAyNTE5Mjc0My8zMDA4NTU1MzE1MixcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMC41KjUxMjUyMjkyOTI1LzY1NDAwODIxNTk4LFxuICAgICAgICAgICAgICAwLjUqLTI2OTE4Njg5MjUvNDUxMjgzMjk3MjgsXG4gICAgICAgICAgICAgIDAuNSoxODc5NDAzNzIwNjcvMTU5NDUzNDMxNzA1NixcbiAgICAgICAgICAgICAgMC41Ki0xNzc2MDk0MzMxLzE5NzQzNjQ0MjU2LFxuICAgICAgICAgICAgICAwLjUqMTEyMzcwOTkvMjM1MDQzMzg0XTtcbiAgICB2YXIgYyA9IFsxLzUsMy8xMCw0LzUsOC85LDEsMV07XG4gICAgdmFyIGUgPSBbLTcxLzU3NjAwLDAsNzEvMTY2OTUsLTcxLzE5MjAsMTcyNTMvMzM5MjAwLC0yMi81MjUsMS80MF07XG4gICAgdmFyIGkgPSAwLGVyLGo7XG4gICAgdmFyIGggPSAoeDEteDApLzEwO1xuICAgIHZhciBpdCA9IDA7XG4gICAgdmFyIGFkZCA9IG51bWVyaWMuYWRkLCBtdWwgPSBudW1lcmljLm11bCwgeTEsZXJpbmY7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4LCBtaW4gPSBNYXRoLm1pbiwgYWJzID0gTWF0aC5hYnMsIG5vcm1pbmYgPSBudW1lcmljLm5vcm1pbmYscG93ID0gTWF0aC5wb3c7XG4gICAgdmFyIGFueSA9IG51bWVyaWMuYW55LCBsdCA9IG51bWVyaWMubHQsIGFuZCA9IG51bWVyaWMuYW5kLCBzdWIgPSBudW1lcmljLnN1YjtcbiAgICB2YXIgZTAsIGUxLCBldjtcbiAgICB2YXIgcmV0ID0gbmV3IG51bWVyaWMuRG9wcmkoeHMseXMsazEseW1pZCwtMSxcIlwiKTtcbiAgICBpZih0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikgZTAgPSBldmVudCh4MCx5MCk7XG4gICAgd2hpbGUoeDA8eDEgJiYgaXQ8bWF4aXQpIHtcbiAgICAgICAgKytpdDtcbiAgICAgICAgaWYoeDAraD54MSkgaCA9IHgxLXgwO1xuICAgICAgICBrMiA9IGYoeDArY1swXSpoLCAgICAgICAgICAgICAgICBhZGQoeTAsbXVsKCAgIEEyKmgsazFbaV0pKSk7XG4gICAgICAgIGszID0gZih4MCtjWzFdKmgsICAgICAgICAgICAgYWRkKGFkZCh5MCxtdWwoQTNbMF0qaCxrMVtpXSkpLG11bChBM1sxXSpoLGsyKSkpO1xuICAgICAgICBrNCA9IGYoeDArY1syXSpoLCAgICAgICAgYWRkKGFkZChhZGQoeTAsbXVsKEE0WzBdKmgsazFbaV0pKSxtdWwoQTRbMV0qaCxrMikpLG11bChBNFsyXSpoLGszKSkpO1xuICAgICAgICBrNSA9IGYoeDArY1szXSpoLCAgICBhZGQoYWRkKGFkZChhZGQoeTAsbXVsKEE1WzBdKmgsazFbaV0pKSxtdWwoQTVbMV0qaCxrMikpLG11bChBNVsyXSpoLGszKSksbXVsKEE1WzNdKmgsazQpKSk7XG4gICAgICAgIGs2ID0gZih4MCtjWzRdKmgsYWRkKGFkZChhZGQoYWRkKGFkZCh5MCxtdWwoQTZbMF0qaCxrMVtpXSkpLG11bChBNlsxXSpoLGsyKSksbXVsKEE2WzJdKmgsazMpKSxtdWwoQTZbM10qaCxrNCkpLG11bChBNls0XSpoLGs1KSkpO1xuICAgICAgICB5MSA9IGFkZChhZGQoYWRkKGFkZChhZGQoeTAsbXVsKGsxW2ldLGgqYlswXSkpLG11bChrMyxoKmJbMl0pKSxtdWwoazQsaCpiWzNdKSksbXVsKGs1LGgqYls0XSkpLG11bChrNixoKmJbNV0pKTtcbiAgICAgICAgazcgPSBmKHgwK2gseTEpO1xuICAgICAgICBlciA9IGFkZChhZGQoYWRkKGFkZChhZGQobXVsKGsxW2ldLGgqZVswXSksbXVsKGszLGgqZVsyXSkpLG11bChrNCxoKmVbM10pKSxtdWwoazUsaCplWzRdKSksbXVsKGs2LGgqZVs1XSkpLG11bChrNyxoKmVbNl0pKTtcbiAgICAgICAgaWYodHlwZW9mIGVyID09PSBcIm51bWJlclwiKSBlcmluZiA9IGFicyhlcik7XG4gICAgICAgIGVsc2UgZXJpbmYgPSBub3JtaW5mKGVyKTtcbiAgICAgICAgaWYoZXJpbmYgPiB0b2wpIHsgLy8gcmVqZWN0XG4gICAgICAgICAgICBoID0gMC4yKmgqcG93KHRvbC9lcmluZiwwLjI1KTtcbiAgICAgICAgICAgIGlmKHgwK2ggPT09IHgwKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1zZyA9IFwiU3RlcCBzaXplIGJlY2FtZSB0b28gc21hbGxcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHltaWRbaV0gPSBhZGQoYWRkKGFkZChhZGQoYWRkKGFkZCh5MCxcbiAgICAgICAgICAgICAgICBtdWwoazFbaV0saCpibVswXSkpLFxuICAgICAgICAgICAgICAgIG11bChrMyAgICxoKmJtWzJdKSksXG4gICAgICAgICAgICAgICAgbXVsKGs0ICAgLGgqYm1bM10pKSxcbiAgICAgICAgICAgICAgICBtdWwoazUgICAsaCpibVs0XSkpLFxuICAgICAgICAgICAgICAgIG11bChrNiAgICxoKmJtWzVdKSksXG4gICAgICAgICAgICAgICAgbXVsKGs3ICAgLGgqYm1bNl0pKTtcbiAgICAgICAgKytpO1xuICAgICAgICB4c1tpXSA9IHgwK2g7XG4gICAgICAgIHlzW2ldID0geTE7XG4gICAgICAgIGsxW2ldID0gazc7XG4gICAgICAgIGlmKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgeWkseGwgPSB4MCx4ciA9IHgwKzAuNSpoLHhpO1xuICAgICAgICAgICAgZTEgPSBldmVudCh4cix5bWlkW2ktMV0pO1xuICAgICAgICAgICAgZXYgPSBhbmQobHQoZTAsMCksbHQoMCxlMSkpO1xuICAgICAgICAgICAgaWYoIWFueShldikpIHsgeGwgPSB4cjsgeHIgPSB4MCtoOyBlMCA9IGUxOyBlMSA9IGV2ZW50KHhyLHkxKTsgZXYgPSBhbmQobHQoZTAsMCksbHQoMCxlMSkpOyB9XG4gICAgICAgICAgICBpZihhbnkoZXYpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhjLCB5YywgZW4sZWk7XG4gICAgICAgICAgICAgICAgdmFyIHNpZGU9MCwgc2wgPSAxLjAsIHNyID0gMS4wO1xuICAgICAgICAgICAgICAgIHdoaWxlKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGUwID09PSBcIm51bWJlclwiKSB4aSA9IChzciplMSp4bC1zbCplMCp4cikvKHNyKmUxLXNsKmUwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHhyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGo9ZTAubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGUwW2pdPDAgJiYgZTFbal0+MCkgeGkgPSBtaW4oeGksKHNyKmUxW2pdKnhsLXNsKmUwW2pdKnhyKS8oc3IqZTFbal0tc2wqZTBbal0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZih4aSA8PSB4bCB8fCB4aSA+PSB4cikgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHlpID0gcmV0Ll9hdCh4aSwgaS0xKTtcbiAgICAgICAgICAgICAgICAgICAgZWkgPSBldmVudCh4aSx5aSk7XG4gICAgICAgICAgICAgICAgICAgIGVuID0gYW5kKGx0KGUwLDApLGx0KDAsZWkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoYW55KGVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeHIgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUxID0gZWk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldiA9IGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3IgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzaWRlID09PSAtMSkgc2wgKj0gMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBzbCA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhsID0geGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlMCA9IGVpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2wgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzaWRlID09PSAxKSBzciAqPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHNyID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeTEgPSByZXQuX2F0KDAuNSooeDAreGkpLGktMSk7XG4gICAgICAgICAgICAgICAgcmV0LmZbaV0gPSBmKHhpLHlpKTtcbiAgICAgICAgICAgICAgICByZXQueFtpXSA9IHhpO1xuICAgICAgICAgICAgICAgIHJldC55W2ldID0geWk7XG4gICAgICAgICAgICAgICAgcmV0LnltaWRbaS0xXSA9IHkxO1xuICAgICAgICAgICAgICAgIHJldC5ldmVudHMgPSBldjtcbiAgICAgICAgICAgICAgICByZXQuaXRlcmF0aW9ucyA9IGl0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeDAgKz0gaDtcbiAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgZTAgPSBlMTtcbiAgICAgICAgaCA9IG1pbigwLjgqaCpwb3codG9sL2VyaW5mLDAuMjUpLDQqaCk7XG4gICAgfVxuICAgIHJldC5pdGVyYXRpb25zID0gaXQ7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLy8gMTEuIEF4ID0gYlxubnVtZXJpYy5MVSA9IGZ1bmN0aW9uKEEsIGZhc3QpIHtcbiAgZmFzdCA9IGZhc3QgfHwgZmFsc2U7XG5cbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuICB2YXIgaSwgaiwgaywgYWJzQWprLCBBa2ssIEFrLCBQaywgQWk7XG4gIHZhciBtYXg7XG4gIHZhciBuID0gQS5sZW5ndGgsIG4xID0gbi0xO1xuICB2YXIgUCA9IG5ldyBBcnJheShuKTtcbiAgaWYoIWZhc3QpIEEgPSBudW1lcmljLmNsb25lKEEpO1xuXG4gIGZvciAoayA9IDA7IGsgPCBuOyArK2spIHtcbiAgICBQayA9IGs7XG4gICAgQWsgPSBBW2tdO1xuICAgIG1heCA9IGFicyhBa1trXSk7XG4gICAgZm9yIChqID0gayArIDE7IGogPCBuOyArK2opIHtcbiAgICAgIGFic0FqayA9IGFicyhBW2pdW2tdKTtcbiAgICAgIGlmIChtYXggPCBhYnNBamspIHtcbiAgICAgICAgbWF4ID0gYWJzQWprO1xuICAgICAgICBQayA9IGo7XG4gICAgICB9XG4gICAgfVxuICAgIFBba10gPSBQaztcblxuICAgIGlmIChQayAhPSBrKSB7XG4gICAgICBBW2tdID0gQVtQa107XG4gICAgICBBW1BrXSA9IEFrO1xuICAgICAgQWsgPSBBW2tdO1xuICAgIH1cblxuICAgIEFrayA9IEFrW2tdO1xuXG4gICAgZm9yIChpID0gayArIDE7IGkgPCBuOyArK2kpIHtcbiAgICAgIEFbaV1ba10gLz0gQWtrO1xuICAgIH1cblxuICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBBaSA9IEFbaV07XG4gICAgICBmb3IgKGogPSBrICsgMTsgaiA8IG4xOyArK2opIHtcbiAgICAgICAgQWlbal0gLT0gQWlba10gKiBBa1tqXTtcbiAgICAgICAgKytqO1xuICAgICAgICBBaVtqXSAtPSBBaVtrXSAqIEFrW2pdO1xuICAgICAgfVxuICAgICAgaWYoaj09PW4xKSBBaVtqXSAtPSBBaVtrXSAqIEFrW2pdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgTFU6IEEsXG4gICAgUDogIFBcbiAgfTtcbn1cblxubnVtZXJpYy5MVXNvbHZlID0gZnVuY3Rpb24gTFVzb2x2ZShMVVAsIGIpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBMVSA9IExVUC5MVTtcbiAgdmFyIG4gICA9IExVLmxlbmd0aDtcbiAgdmFyIHggPSBudW1lcmljLmNsb25lKGIpO1xuICB2YXIgUCAgID0gTFVQLlA7XG4gIHZhciBQaSwgTFVpLCBMVWlpLCB0bXA7XG5cbiAgZm9yIChpPW4tMTtpIT09LTE7LS1pKSB4W2ldID0gYltpXTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIFBpID0gUFtpXTtcbiAgICBpZiAoUFtpXSAhPT0gaSkge1xuICAgICAgdG1wID0geFtpXTtcbiAgICAgIHhbaV0gPSB4W1BpXTtcbiAgICAgIHhbUGldID0gdG1wO1xuICAgIH1cblxuICAgIExVaSA9IExVW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCBpOyArK2opIHtcbiAgICAgIHhbaV0gLT0geFtqXSAqIExVaVtqXTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBMVWkgPSBMVVtpXTtcbiAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47ICsraikge1xuICAgICAgeFtpXSAtPSB4W2pdICogTFVpW2pdO1xuICAgIH1cblxuICAgIHhbaV0gLz0gTFVpW2ldO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59XG5cbm51bWVyaWMuc29sdmUgPSBmdW5jdGlvbiBzb2x2ZShBLGIsZmFzdCkgeyByZXR1cm4gbnVtZXJpYy5MVXNvbHZlKG51bWVyaWMuTFUoQSxmYXN0KSwgYik7IH1cblxuLy8gMTIuIExpbmVhciBwcm9ncmFtbWluZ1xubnVtZXJpYy5lY2hlbG9uaXplID0gZnVuY3Rpb24gZWNoZWxvbml6ZShBKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbShBKSwgbSA9IHNbMF0sIG4gPSBzWzFdO1xuICAgIHZhciBJID0gbnVtZXJpYy5pZGVudGl0eShtKTtcbiAgICB2YXIgUCA9IEFycmF5KG0pO1xuICAgIHZhciBpLGosayxsLEFpLElpLFosYTtcbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIGRpdmVxID0gbnVtZXJpYy5kaXZlcTtcbiAgICBBID0gbnVtZXJpYy5jbG9uZShBKTtcbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgSWkgPSBJW2ldO1xuICAgICAgICBmb3Ioaj0xO2o8bjsrK2opIGlmKGFicyhBaVtrXSk8YWJzKEFpW2pdKSkgaz1qO1xuICAgICAgICBQW2ldID0gaztcbiAgICAgICAgZGl2ZXEoSWksQWlba10pO1xuICAgICAgICBkaXZlcShBaSxBaVtrXSk7XG4gICAgICAgIGZvcihqPTA7ajxtOysraikgaWYoaiE9PWkpIHtcbiAgICAgICAgICAgIFogPSBBW2pdOyBhID0gWltrXTtcbiAgICAgICAgICAgIGZvcihsPW4tMTtsIT09LTE7LS1sKSBaW2xdIC09IEFpW2xdKmE7XG4gICAgICAgICAgICBaID0gSVtqXTtcbiAgICAgICAgICAgIGZvcihsPW0tMTtsIT09LTE7LS1sKSBaW2xdIC09IElpW2xdKmE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtJOkksIEE6QSwgUDpQfTtcbn1cblxubnVtZXJpYy5fX3NvbHZlTFAgPSBmdW5jdGlvbiBfX3NvbHZlTFAoYyxBLGIsdG9sLG1heGl0LHgsZmxhZykge1xuICAgIHZhciBzdW0gPSBudW1lcmljLnN1bSwgbG9nID0gbnVtZXJpYy5sb2csIG11bCA9IG51bWVyaWMubXVsLCBzdWIgPSBudW1lcmljLnN1YiwgZG90ID0gbnVtZXJpYy5kb3QsIGRpdiA9IG51bWVyaWMuZGl2LCBhZGQgPSBudW1lcmljLmFkZDtcbiAgICB2YXIgbSA9IGMubGVuZ3RoLCBuID0gYi5sZW5ndGgseTtcbiAgICB2YXIgdW5ib3VuZGVkID0gZmFsc2UsIGNiLGkwPTA7XG4gICAgdmFyIGFscGhhID0gMS4wO1xuICAgIHZhciBmMCxkZjAsQVQgPSBudW1lcmljLnRyYW5zcG9zZShBKSwgc3ZkID0gbnVtZXJpYy5zdmQsdHJhbnNwb3NlID0gbnVtZXJpYy50cmFuc3Bvc2UsbGVxID0gbnVtZXJpYy5sZXEsIHNxcnQgPSBNYXRoLnNxcnQsIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBtdWxlcSA9IG51bWVyaWMubXVsZXE7XG4gICAgdmFyIG5vcm0gPSBudW1lcmljLm5vcm1pbmYsIGFueSA9IG51bWVyaWMuYW55LG1pbiA9IE1hdGgubWluO1xuICAgIHZhciBhbGwgPSBudW1lcmljLmFsbCwgZ3QgPSBudW1lcmljLmd0O1xuICAgIHZhciBwID0gQXJyYXkobSksIEEwID0gQXJyYXkobiksZT1udW1lcmljLnJlcChbbl0sMSksIEg7XG4gICAgdmFyIHNvbHZlID0gbnVtZXJpYy5zb2x2ZSwgeiA9IHN1YihiLGRvdChBLHgpKSxjb3VudDtcbiAgICB2YXIgZG90Y2MgPSBkb3QoYyxjKTtcbiAgICB2YXIgZztcbiAgICBmb3IoY291bnQ9aTA7Y291bnQ8bWF4aXQ7Kytjb3VudCkge1xuICAgICAgICB2YXIgaSxqLGQ7XG4gICAgICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSBBMFtpXSA9IGRpdihBW2ldLHpbaV0pO1xuICAgICAgICB2YXIgQTEgPSB0cmFuc3Bvc2UoQTApO1xuICAgICAgICBmb3IoaT1tLTE7aSE9PS0xOy0taSkgcFtpXSA9ICgvKnhbaV0rKi9zdW0oQTFbaV0pKTtcbiAgICAgICAgYWxwaGEgPSAwLjI1KmFicyhkb3RjYy9kb3QoYyxwKSk7XG4gICAgICAgIHZhciBhMSA9IDEwMCpzcXJ0KGRvdGNjL2RvdChwLHApKTtcbiAgICAgICAgaWYoIWlzRmluaXRlKGFscGhhKSB8fCBhbHBoYT5hMSkgYWxwaGEgPSBhMTtcbiAgICAgICAgZyA9IGFkZChjLG11bChhbHBoYSxwKSk7XG4gICAgICAgIEggPSBkb3QoQTEsQTApO1xuICAgICAgICBmb3IoaT1tLTE7aSE9PS0xOy0taSkgSFtpXVtpXSArPSAxO1xuICAgICAgICBkID0gc29sdmUoSCxkaXYoZyxhbHBoYSksdHJ1ZSk7XG4gICAgICAgIHZhciB0MCA9IGRpdih6LGRvdChBLGQpKTtcbiAgICAgICAgdmFyIHQgPSAxLjA7XG4gICAgICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSBpZih0MFtpXTwwKSB0ID0gbWluKHQsLTAuOTk5KnQwW2ldKTtcbiAgICAgICAgeSA9IHN1Yih4LG11bChkLHQpKTtcbiAgICAgICAgeiA9IHN1YihiLGRvdChBLHkpKTtcbiAgICAgICAgaWYoIWFsbChndCh6LDApKSkgcmV0dXJuIHsgc29sdXRpb246IHgsIG1lc3NhZ2U6IFwiXCIsIGl0ZXJhdGlvbnM6IGNvdW50IH07XG4gICAgICAgIHggPSB5O1xuICAgICAgICBpZihhbHBoYTx0b2wpIHJldHVybiB7IHNvbHV0aW9uOiB5LCBtZXNzYWdlOiBcIlwiLCBpdGVyYXRpb25zOiBjb3VudCB9O1xuICAgICAgICBpZihmbGFnKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGRvdChjLGcpLCBBZyA9IGRvdChBLGcpO1xuICAgICAgICAgICAgdW5ib3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSBpZihzKkFnW2ldPDApIHsgdW5ib3VuZGVkID0gZmFsc2U7IGJyZWFrOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZih4W20tMV0+PTApIHVuYm91bmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSB1bmJvdW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHVuYm91bmRlZCkgcmV0dXJuIHsgc29sdXRpb246IHksIG1lc3NhZ2U6IFwiVW5ib3VuZGVkXCIsIGl0ZXJhdGlvbnM6IGNvdW50IH07XG4gICAgfVxuICAgIHJldHVybiB7IHNvbHV0aW9uOiB4LCBtZXNzYWdlOiBcIm1heGltdW0gaXRlcmF0aW9uIGNvdW50IGV4Y2VlZGVkXCIsIGl0ZXJhdGlvbnM6Y291bnQgfTtcbn1cblxubnVtZXJpYy5fc29sdmVMUCA9IGZ1bmN0aW9uIF9zb2x2ZUxQKGMsQSxiLHRvbCxtYXhpdCkge1xuICAgIHZhciBtID0gYy5sZW5ndGgsIG4gPSBiLmxlbmd0aCx5O1xuICAgIHZhciBzdW0gPSBudW1lcmljLnN1bSwgbG9nID0gbnVtZXJpYy5sb2csIG11bCA9IG51bWVyaWMubXVsLCBzdWIgPSBudW1lcmljLnN1YiwgZG90ID0gbnVtZXJpYy5kb3QsIGRpdiA9IG51bWVyaWMuZGl2LCBhZGQgPSBudW1lcmljLmFkZDtcbiAgICB2YXIgYzAgPSBudW1lcmljLnJlcChbbV0sMCkuY29uY2F0KFsxXSk7XG4gICAgdmFyIEogPSBudW1lcmljLnJlcChbbiwxXSwtMSk7XG4gICAgdmFyIEEwID0gbnVtZXJpYy5ibG9ja01hdHJpeChbW0EgICAgICAgICAgICAgICAgICAgLCAgIEogIF1dKTtcbiAgICB2YXIgYjAgPSBiO1xuICAgIHZhciB5ID0gbnVtZXJpYy5yZXAoW21dLDApLmNvbmNhdChNYXRoLm1heCgwLG51bWVyaWMuc3VwKG51bWVyaWMubmVnKGIpKSkrMSk7XG4gICAgdmFyIHgwID0gbnVtZXJpYy5fX3NvbHZlTFAoYzAsQTAsYjAsdG9sLG1heGl0LHksZmFsc2UpO1xuICAgIHZhciB4ID0gbnVtZXJpYy5jbG9uZSh4MC5zb2x1dGlvbik7XG4gICAgeC5sZW5ndGggPSBtO1xuICAgIHZhciBmb28gPSBudW1lcmljLmluZihzdWIoYixkb3QoQSx4KSkpO1xuICAgIGlmKGZvbzwwKSB7IHJldHVybiB7IHNvbHV0aW9uOiBOYU4sIG1lc3NhZ2U6IFwiSW5mZWFzaWJsZVwiLCBpdGVyYXRpb25zOiB4MC5pdGVyYXRpb25zIH07IH1cbiAgICB2YXIgcmV0ID0gbnVtZXJpYy5fX3NvbHZlTFAoYywgQSwgYiwgdG9sLCBtYXhpdC14MC5pdGVyYXRpb25zLCB4LCB0cnVlKTtcbiAgICByZXQuaXRlcmF0aW9ucyArPSB4MC5pdGVyYXRpb25zO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5udW1lcmljLnNvbHZlTFAgPSBmdW5jdGlvbiBzb2x2ZUxQKGMsQSxiLEFlcSxiZXEsdG9sLG1heGl0KSB7XG4gICAgaWYodHlwZW9mIG1heGl0ID09PSBcInVuZGVmaW5lZFwiKSBtYXhpdCA9IDEwMDA7XG4gICAgaWYodHlwZW9mIHRvbCA9PT0gXCJ1bmRlZmluZWRcIikgdG9sID0gbnVtZXJpYy5lcHNpbG9uO1xuICAgIGlmKHR5cGVvZiBBZXEgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudW1lcmljLl9zb2x2ZUxQKGMsQSxiLHRvbCxtYXhpdCk7XG4gICAgdmFyIG0gPSBBZXEubGVuZ3RoLCBuID0gQWVxWzBdLmxlbmd0aCwgbyA9IEEubGVuZ3RoO1xuICAgIHZhciBCID0gbnVtZXJpYy5lY2hlbG9uaXplKEFlcSk7XG4gICAgdmFyIGZsYWdzID0gbnVtZXJpYy5yZXAoW25dLDApO1xuICAgIHZhciBQID0gQi5QO1xuICAgIHZhciBRID0gW107XG4gICAgdmFyIGk7XG4gICAgZm9yKGk9UC5sZW5ndGgtMTtpIT09LTE7LS1pKSBmbGFnc1tQW2ldXSA9IDE7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIGlmKGZsYWdzW2ldPT09MCkgUS5wdXNoKGkpO1xuICAgIHZhciBnID0gbnVtZXJpYy5nZXRSYW5nZTtcbiAgICB2YXIgSSA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpLCBKID0gbnVtZXJpYy5saW5zcGFjZSgwLG8tMSk7XG4gICAgdmFyIEFlcTIgPSBnKEFlcSxJLFEpLCBBMSA9IGcoQSxKLFApLCBBMiA9IGcoQSxKLFEpLCBkb3QgPSBudW1lcmljLmRvdCwgc3ViID0gbnVtZXJpYy5zdWI7XG4gICAgdmFyIEEzID0gZG90KEExLEIuSSk7XG4gICAgdmFyIEE0ID0gc3ViKEEyLGRvdChBMyxBZXEyKSksIGI0ID0gc3ViKGIsZG90KEEzLGJlcSkpO1xuICAgIHZhciBjMSA9IEFycmF5KFAubGVuZ3RoKSwgYzIgPSBBcnJheShRLmxlbmd0aCk7XG4gICAgZm9yKGk9UC5sZW5ndGgtMTtpIT09LTE7LS1pKSBjMVtpXSA9IGNbUFtpXV07XG4gICAgZm9yKGk9US5sZW5ndGgtMTtpIT09LTE7LS1pKSBjMltpXSA9IGNbUVtpXV07XG4gICAgdmFyIGM0ID0gc3ViKGMyLGRvdChjMSxkb3QoQi5JLEFlcTIpKSk7XG4gICAgdmFyIFMgPSBudW1lcmljLl9zb2x2ZUxQKGM0LEE0LGI0LHRvbCxtYXhpdCk7XG4gICAgdmFyIHgyID0gUy5zb2x1dGlvbjtcbiAgICBpZih4MiE9PXgyKSByZXR1cm4gUztcbiAgICB2YXIgeDEgPSBkb3QoQi5JLHN1YihiZXEsZG90KEFlcTIseDIpKSk7XG4gICAgdmFyIHggPSBBcnJheShjLmxlbmd0aCk7XG4gICAgZm9yKGk9UC5sZW5ndGgtMTtpIT09LTE7LS1pKSB4W1BbaV1dID0geDFbaV07XG4gICAgZm9yKGk9US5sZW5ndGgtMTtpIT09LTE7LS1pKSB4W1FbaV1dID0geDJbaV07XG4gICAgcmV0dXJuIHsgc29sdXRpb246IHgsIG1lc3NhZ2U6Uy5tZXNzYWdlLCBpdGVyYXRpb25zOiBTLml0ZXJhdGlvbnMgfTtcbn1cblxubnVtZXJpYy5NUFN0b0xQID0gZnVuY3Rpb24gTVBTdG9MUChNUFMpIHtcbiAgICBpZihNUFMgaW5zdGFuY2VvZiBTdHJpbmcpIHsgTVBTLnNwbGl0KCdcXG4nKTsgfVxuICAgIHZhciBzdGF0ZSA9IDA7XG4gICAgdmFyIHN0YXRlcyA9IFsnSW5pdGlhbCBzdGF0ZScsJ05BTUUnLCdST1dTJywnQ09MVU1OUycsJ1JIUycsJ0JPVU5EUycsJ0VOREFUQSddO1xuICAgIHZhciBuID0gTVBTLmxlbmd0aDtcbiAgICB2YXIgaSxqLHosTj0wLHJvd3MgPSB7fSwgc2lnbiA9IFtdLCBybCA9IDAsIHZhcnMgPSB7fSwgbnYgPSAwO1xuICAgIHZhciBuYW1lO1xuICAgIHZhciBjID0gW10sIEEgPSBbXSwgYiA9IFtdO1xuICAgIGZ1bmN0aW9uIGVycihlKSB7IHRocm93IG5ldyBFcnJvcignTVBTdG9MUDogJytlKydcXG5MaW5lICcraSsnOiAnK01QU1tpXSsnXFxuQ3VycmVudCBzdGF0ZTogJytzdGF0ZXNbc3RhdGVdKydcXG4nKTsgfVxuICAgIGZvcihpPTA7aTxuOysraSkge1xuICAgICAgICB6ID0gTVBTW2ldO1xuICAgICAgICB2YXIgdzAgPSB6Lm1hdGNoKC9cXFMqL2cpO1xuICAgICAgICB2YXIgdyA9IFtdO1xuICAgICAgICBmb3Ioaj0wO2o8dzAubGVuZ3RoOysraikgaWYodzBbal0hPT1cIlwiKSB3LnB1c2godzBbal0pO1xuICAgICAgICBpZih3Lmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICAgIGZvcihqPTA7ajxzdGF0ZXMubGVuZ3RoOysraikgaWYoei5zdWJzdHIoMCxzdGF0ZXNbal0ubGVuZ3RoKSA9PT0gc3RhdGVzW2pdKSBicmVhaztcbiAgICAgICAgaWYoajxzdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGo7XG4gICAgICAgICAgICBpZihqPT09MSkgeyBuYW1lID0gd1sxXTsgfVxuICAgICAgICAgICAgaWYoaj09PTYpIHJldHVybiB7IG5hbWU6bmFtZSwgYzpjLCBBOm51bWVyaWMudHJhbnNwb3NlKEEpLCBiOmIsIHJvd3M6cm93cywgdmFyczp2YXJzIH07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goc3RhdGUpIHtcbiAgICAgICAgY2FzZSAwOiBjYXNlIDE6IGVycignVW5leHBlY3RlZCBsaW5lJyk7XG4gICAgICAgIGNhc2UgMjogXG4gICAgICAgICAgICBzd2l0Y2god1swXSkge1xuICAgICAgICAgICAgY2FzZSAnTic6IGlmKE49PT0wKSBOID0gd1sxXTsgZWxzZSBlcnIoJ1R3byBvciBtb3JlIE4gcm93cycpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0wnOiByb3dzW3dbMV1dID0gcmw7IHNpZ25bcmxdID0gMTsgYltybF0gPSAwOyArK3JsOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0cnOiByb3dzW3dbMV1dID0gcmw7IHNpZ25bcmxdID0gLTE7YltybF0gPSAwOyArK3JsOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0UnOiByb3dzW3dbMV1dID0gcmw7IHNpZ25bcmxdID0gMDtiW3JsXSA9IDA7ICsrcmw7IGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogZXJyKCdQYXJzZSBlcnJvciAnK251bWVyaWMucHJldHR5UHJpbnQodykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmKCF2YXJzLmhhc093blByb3BlcnR5KHdbMF0pKSB7IHZhcnNbd1swXV0gPSBudjsgY1tudl0gPSAwOyBBW252XSA9IG51bWVyaWMucmVwKFtybF0sMCk7ICsrbnY7IH1cbiAgICAgICAgICAgIHZhciBwID0gdmFyc1t3WzBdXTtcbiAgICAgICAgICAgIGZvcihqPTE7ajx3Lmxlbmd0aDtqKz0yKSB7XG4gICAgICAgICAgICAgICAgaWYod1tqXSA9PT0gTikgeyBjW3BdID0gcGFyc2VGbG9hdCh3W2orMV0pOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgIHZhciBxID0gcm93c1t3W2pdXTtcbiAgICAgICAgICAgICAgICBBW3BdW3FdID0gKHNpZ25bcV08MD8tMToxKSpwYXJzZUZsb2F0KHdbaisxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZm9yKGo9MTtqPHcubGVuZ3RoO2orPTIpIGJbcm93c1t3W2pdXV0gPSAoc2lnbltyb3dzW3dbal1dXTwwPy0xOjEpKnBhcnNlRmxvYXQod1tqKzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6IC8qRklYTUUqLyBicmVhaztcbiAgICAgICAgY2FzZSA2OiBlcnIoJ0ludGVybmFsIGVycm9yJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXJyKCdSZWFjaGVkIGVuZCBvZiBmaWxlIHdpdGhvdXQgRU5EQVRBJyk7XG59XG4vLyBzZWVkcmFuZG9tLmpzIHZlcnNpb24gMi4wLlxuLy8gQXV0aG9yOiBEYXZpZCBCYXUgNC8yLzIwMTFcbi8vXG4vLyBEZWZpbmVzIGEgbWV0aG9kIE1hdGguc2VlZHJhbmRvbSgpIHRoYXQsIHdoZW4gY2FsbGVkLCBzdWJzdGl0dXRlc1xuLy8gYW4gZXhwbGljaXRseSBzZWVkZWQgUkM0LWJhc2VkIGFsZ29yaXRobSBmb3IgTWF0aC5yYW5kb20oKS4gIEFsc29cbi8vIHN1cHBvcnRzIGF1dG9tYXRpYyBzZWVkaW5nIGZyb20gbG9jYWwgb3IgbmV0d29yayBzb3VyY2VzIG9mIGVudHJvcHkuXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gICA8c2NyaXB0IHNyYz1odHRwOi8vZGF2aWRiYXUuY29tL2VuY29kZS9zZWVkcmFuZG9tLW1pbi5qcz48L3NjcmlwdD5cbi8vXG4vLyAgIE1hdGguc2VlZHJhbmRvbSgneWlwZWUnKTsgU2V0cyBNYXRoLnJhbmRvbSB0byBhIGZ1bmN0aW9uIHRoYXQgaXNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplZCB1c2luZyB0aGUgZ2l2ZW4gZXhwbGljaXQgc2VlZC5cbi8vXG4vLyAgIE1hdGguc2VlZHJhbmRvbSgpOyAgICAgICAgU2V0cyBNYXRoLnJhbmRvbSB0byBhIGZ1bmN0aW9uIHRoYXQgaXNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkZWQgdXNpbmcgdGhlIGN1cnJlbnQgdGltZSwgZG9tIHN0YXRlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBvdGhlciBhY2N1bXVsYXRlZCBsb2NhbCBlbnRyb3B5LlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc2VlZCBzdHJpbmcgaXMgcmV0dXJuZWQuXG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oJ3lvd3phJywgdHJ1ZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlZHMgdXNpbmcgdGhlIGdpdmVuIGV4cGxpY2l0IHNlZWQgbWl4ZWRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2dldGhlciB3aXRoIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4vL1xuLy8gICA8c2NyaXB0IHNyYz1cImh0dHA6Ly9iaXQubHkvc3JhbmRvbS01MTJcIj48L3NjcmlwdD5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWVkcyB1c2luZyBwaHlzaWNhbCByYW5kb20gYml0cyBkb3dubG9hZGVkXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSByYW5kb20ub3JnLlxuLy9cbi8vICAgPHNjcmlwdCBzcmM9XCJodHRwczovL2pzb25saWIuYXBwc3BvdC5jb20vdXJhbmRvbT9jYWxsYmFjaz1NYXRoLnNlZWRyYW5kb21cIj5cbi8vICAgPC9zY3JpcHQ+ICAgICAgICAgICAgICAgICBTZWVkcyB1c2luZyB1cmFuZG9tIGJpdHMgZnJvbSBjYWxsLmpzb25saWIuY29tLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGlzIGZhc3RlciB0aGFuIHJhbmRvbS5vcmcuXG4vL1xuLy8gRXhhbXBsZXM6XG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oXCJoZWxsb1wiKTsgICAgICAgICAgICAvLyBVc2UgXCJoZWxsb1wiIGFzIHRoZSBzZWVkLlxuLy8gICBkb2N1bWVudC53cml0ZShNYXRoLnJhbmRvbSgpKTsgICAgICAgLy8gQWx3YXlzIDAuNTQ2MzY2Mzc2ODE0MDczNFxuLy8gICBkb2N1bWVudC53cml0ZShNYXRoLnJhbmRvbSgpKTsgICAgICAgLy8gQWx3YXlzIDAuNDM5NzM3OTM3NzA1OTIyMzRcbi8vICAgdmFyIHJuZzEgPSBNYXRoLnJhbmRvbTsgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjdXJyZW50IHBybmcuXG4vL1xuLy8gICB2YXIgYXV0b3NlZWQgPSBNYXRoLnNlZWRyYW5kb20oKTsgICAgLy8gTmV3IHBybmcgd2l0aCBhbiBhdXRvbWF0aWMgc2VlZC5cbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIFByZXR0eSBtdWNoIHVucHJlZGljdGFibGUuXG4vL1xuLy8gICBNYXRoLnJhbmRvbSA9IHJuZzE7ICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgXCJoZWxsb1wiIHBybmcgc2VxdWVuY2UuXG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBBbHdheXMgMC41NTQ3Njk0MzI0NzM0NTVcbi8vXG4vLyAgIE1hdGguc2VlZHJhbmRvbShhdXRvc2VlZCk7ICAgICAgICAgICAvLyBSZXN0YXJ0IGF0IHRoZSBwcmV2aW91cyBzZWVkLlxuLy8gICBkb2N1bWVudC53cml0ZShNYXRoLnJhbmRvbSgpKTsgICAgICAgLy8gUmVwZWF0IHRoZSAndW5wcmVkaWN0YWJsZScgdmFsdWUuXG4vL1xuLy8gTm90ZXM6XG4vL1xuLy8gRWFjaCB0aW1lIHNlZWRyYW5kb20oJ2FyZycpIGlzIGNhbGxlZCwgZW50cm9weSBmcm9tIHRoZSBwYXNzZWQgc2VlZFxuLy8gaXMgYWNjdW11bGF0ZWQgaW4gYSBwb29sIHRvIGhlbHAgZ2VuZXJhdGUgZnV0dXJlIHNlZWRzIGZvciB0aGVcbi8vIHplcm8tYXJndW1lbnQgZm9ybSBvZiBNYXRoLnNlZWRyYW5kb20sIHNvIGVudHJvcHkgY2FuIGJlIGluamVjdGVkIG92ZXJcbi8vIHRpbWUgYnkgY2FsbGluZyBzZWVkcmFuZG9tIHdpdGggZXhwbGljaXQgZGF0YSByZXBlYXRlZGx5LlxuLy9cbi8vIE9uIHNwZWVkIC0gVGhpcyBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIE1hdGgucmFuZG9tKCkgaXMgYWJvdXRcbi8vIDMtMTB4IHNsb3dlciB0aGFuIHRoZSBidWlsdC1pbiBNYXRoLnJhbmRvbSgpIGJlY2F1c2UgaXQgaXMgbm90IG5hdGl2ZVxuLy8gY29kZSwgYnV0IHRoaXMgaXMgdHlwaWNhbGx5IGZhc3QgZW5vdWdoIGFueXdheS4gIFNlZWRpbmcgaXMgbW9yZSBleHBlbnNpdmUsXG4vLyBlc3BlY2lhbGx5IGlmIHlvdSB1c2UgYXV0by1zZWVkaW5nLiAgU29tZSBkZXRhaWxzICh0aW1pbmdzIG9uIENocm9tZSA0KTpcbi8vXG4vLyBPdXIgTWF0aC5yYW5kb20oKSAgICAgICAgICAgIC0gYXZnIGxlc3MgdGhhbiAwLjAwMiBtaWxsaXNlY29uZHMgcGVyIGNhbGxcbi8vIHNlZWRyYW5kb20oJ2V4cGxpY2l0JykgICAgICAgLSBhdmcgbGVzcyB0aGFuIDAuNSBtaWxsaXNlY29uZHMgcGVyIGNhbGxcbi8vIHNlZWRyYW5kb20oJ2V4cGxpY2l0JywgdHJ1ZSkgLSBhdmcgbGVzcyB0aGFuIDIgbWlsbGlzZWNvbmRzIHBlciBjYWxsXG4vLyBzZWVkcmFuZG9tKCkgICAgICAgICAgICAgICAgIC0gYXZnIGFib3V0IDM4IG1pbGxpc2Vjb25kcyBwZXIgY2FsbFxuLy9cbi8vIExJQ0VOU0UgKEJTRCk6XG4vL1xuLy8gQ29weXJpZ2h0IDIwMTAgRGF2aWQgQmF1LCBhbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vLyBcbi8vICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy9cbi8vICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuLy8gXG4vLyAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhpcyBtb2R1bGUgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuLy8gICAgICBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuLy8gICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vIFxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy9cbi8qKlxuICogQWxsIGNvZGUgaXMgaW4gYW4gYW5vbnltb3VzIGNsb3N1cmUgdG8ga2VlcCB0aGUgZ2xvYmFsIG5hbWVzcGFjZSBjbGVhbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcj19IG92ZXJmbG93IFxuICogQHBhcmFtIHtudW1iZXI9fSBzdGFydGRlbm9tXG4gKi9cblxuLy8gUGF0Y2hlZCBieSBTZWIgc28gdGhhdCBzZWVkcmFuZG9tLmpzIGRvZXMgbm90IHBvbGx1dGUgdGhlIE1hdGggb2JqZWN0LlxuLy8gTXkgdGVzdHMgc3VnZ2VzdCB0aGF0IGRvaW5nIE1hdGgudHJvdWJsZSA9IDEgbWFrZXMgTWF0aCBsb29rdXBzIGFib3V0IDUlXG4vLyBzbG93ZXIuXG5udW1lcmljLnNlZWRyYW5kb20gPSB7IHBvdzpNYXRoLnBvdywgcmFuZG9tOk1hdGgucmFuZG9tIH07XG5cbihmdW5jdGlvbiAocG9vbCwgbWF0aCwgd2lkdGgsIGNodW5rcywgc2lnbmlmaWNhbmNlLCBvdmVyZmxvdywgc3RhcnRkZW5vbSkge1xuXG5cbi8vXG4vLyBzZWVkcmFuZG9tKClcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxuLy9cbm1hdGhbJ3NlZWRyYW5kb20nXSA9IGZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgdXNlX2VudHJvcHkpIHtcbiAgdmFyIGtleSA9IFtdO1xuICB2YXIgYXJjNDtcblxuICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cbiAgc2VlZCA9IG1peGtleShmbGF0dGVuKFxuICAgIHVzZV9lbnRyb3B5ID8gW3NlZWQsIHBvb2xdIDpcbiAgICBhcmd1bWVudHMubGVuZ3RoID8gc2VlZCA6XG4gICAgW25ldyBEYXRlKCkuZ2V0VGltZSgpLCBwb29sLCB3aW5kb3ddLCAzKSwga2V5KTtcblxuICAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cbiAgYXJjNCA9IG5ldyBBUkM0KGtleSk7XG5cbiAgLy8gTWl4IHRoZSByYW5kb21uZXNzIGludG8gYWNjdW11bGF0ZWQgZW50cm9weS5cbiAgbWl4a2V5KGFyYzQuUywgcG9vbCk7XG5cbiAgLy8gT3ZlcnJpZGUgTWF0aC5yYW5kb21cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXG5cbiAgbWF0aFsncmFuZG9tJ10gPSBmdW5jdGlvbiByYW5kb20oKSB7ICAvLyBDbG9zdXJlIHRvIHJldHVybiBhIHJhbmRvbSBkb3VibGU6XG4gICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKTsgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XG4gICAgdmFyIGQgPSBzdGFydGRlbm9tOyAgICAgICAgICAgICAgICAgLy8gICBhbmQgZGVub21pbmF0b3IgZCA9IDIgXiA0OC5cbiAgICB2YXIgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cbiAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcbiAgICAgIGQgKj0gd2lkdGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGRlbm9taW5hdG9yIGFuZCBnZW5lcmF0aW5nIGFcbiAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxuICAgIH1cbiAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG4gICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcbiAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxuICAgIH1cbiAgICByZXR1cm4gKG4gKyB4KSAvIGQ7ICAgICAgICAgICAgICAgICAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHNlZWQgdGhhdCB3YXMgdXNlZFxuICByZXR1cm4gc2VlZDtcbn07XG5cbi8vXG4vLyBBUkM0XG4vL1xuLy8gQW4gQVJDNCBpbXBsZW1lbnRhdGlvbi4gIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIGtleSBpbiB0aGUgZm9ybSBvZlxuLy8gYW4gYXJyYXkgb2YgYXQgbW9zdCAod2lkdGgpIGludGVnZXJzIHRoYXQgc2hvdWxkIGJlIDAgPD0geCA8ICh3aWR0aCkuXG4vL1xuLy8gVGhlIGcoY291bnQpIG1ldGhvZCByZXR1cm5zIGEgcHNldWRvcmFuZG9tIGludGVnZXIgdGhhdCBjb25jYXRlbmF0ZXNcbi8vIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBmcm9tIEFSQzQuICBJdHMgcmV0dXJuIHZhbHVlIGlzIGEgbnVtYmVyIHhcbi8vIHRoYXQgaXMgaW4gdGhlIHJhbmdlIDAgPD0geCA8ICh3aWR0aCBeIGNvdW50KS5cbi8vXG4vKiogQGNvbnN0cnVjdG9yICovXG5mdW5jdGlvbiBBUkM0KGtleSkge1xuICB2YXIgdCwgdSwgbWUgPSB0aGlzLCBrZXlsZW4gPSBrZXkubGVuZ3RoO1xuICB2YXIgaSA9IDAsIGogPSBtZS5pID0gbWUuaiA9IG1lLm0gPSAwO1xuICBtZS5TID0gW107XG4gIG1lLmMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkgeyBtZS5TW2ldID0gaSsrOyB9XG4gIGZvciAoaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgdCA9IG1lLlNbaV07XG4gICAgaiA9IGxvd2JpdHMoaiArIHQgKyBrZXlbaSAlIGtleWxlbl0pO1xuICAgIHUgPSBtZS5TW2pdO1xuICAgIG1lLlNbaV0gPSB1O1xuICAgIG1lLlNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICBtZS5nID0gZnVuY3Rpb24gZ2V0bmV4dChjb3VudCkge1xuICAgIHZhciBzID0gbWUuUztcbiAgICB2YXIgaSA9IGxvd2JpdHMobWUuaSArIDEpOyB2YXIgdCA9IHNbaV07XG4gICAgdmFyIGogPSBsb3diaXRzKG1lLmogKyB0KTsgdmFyIHUgPSBzW2pdO1xuICAgIHNbaV0gPSB1O1xuICAgIHNbal0gPSB0O1xuICAgIHZhciByID0gc1tsb3diaXRzKHQgKyB1KV07XG4gICAgd2hpbGUgKC0tY291bnQpIHtcbiAgICAgIGkgPSBsb3diaXRzKGkgKyAxKTsgdCA9IHNbaV07XG4gICAgICBqID0gbG93Yml0cyhqICsgdCk7IHUgPSBzW2pdO1xuICAgICAgc1tpXSA9IHU7XG4gICAgICBzW2pdID0gdDtcbiAgICAgIHIgPSByICogd2lkdGggKyBzW2xvd2JpdHModCArIHUpXTtcbiAgICB9XG4gICAgbWUuaSA9IGk7XG4gICAgbWUuaiA9IGo7XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLlxuICAvLyBTZWUgaHR0cDovL3d3dy5yc2EuY29tL3JzYWxhYnMvbm9kZS5hc3A/aWQ9MjAwOVxuICBtZS5nKHdpZHRoKTtcbn1cblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbi8qKiBAcGFyYW0ge09iamVjdD19IHJlc3VsdCBcbiAgKiBAcGFyYW0ge3N0cmluZz19IHByb3BcbiAgKiBAcGFyYW0ge3N0cmluZz19IHR5cCAqL1xuZnVuY3Rpb24gZmxhdHRlbihvYmosIGRlcHRoLCByZXN1bHQsIHByb3AsIHR5cCkge1xuICByZXN1bHQgPSBbXTtcbiAgdHlwID0gdHlwZW9mKG9iaik7XG4gIGlmIChkZXB0aCAmJiB0eXAgPT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAocHJvcC5pbmRleE9mKCdTJykgPCA1KSB7ICAgIC8vIEF2b2lkIEZGMyBidWcgKGxvY2FsL3Nlc3Npb25TdG9yYWdlKVxuICAgICAgICB0cnkgeyByZXN1bHQucHVzaChmbGF0dGVuKG9ialtwcm9wXSwgZGVwdGggLSAxKSk7IH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAocmVzdWx0Lmxlbmd0aCA/IHJlc3VsdCA6IG9iaiArICh0eXAgIT0gJ3N0cmluZycgPyAnXFwwJyA6ICcnKSk7XG59XG5cbi8vXG4vLyBtaXhrZXkoKVxuLy8gTWl4ZXMgYSBzdHJpbmcgc2VlZCBpbnRvIGEga2V5IHRoYXQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFuZFxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4vL1xuLyoqIEBwYXJhbSB7bnVtYmVyPX0gc21lYXIgXG4gICogQHBhcmFtIHtudW1iZXI9fSBqICovXG5mdW5jdGlvbiBtaXhrZXkoc2VlZCwga2V5LCBzbWVhciwgaikge1xuICBzZWVkICs9ICcnOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHNlZWQgaXMgYSBzdHJpbmdcbiAgc21lYXIgPSAwO1xuICBmb3IgKGogPSAwOyBqIDwgc2VlZC5sZW5ndGg7IGorKykge1xuICAgIGtleVtsb3diaXRzKGopXSA9XG4gICAgICBsb3diaXRzKChzbWVhciBePSBrZXlbbG93Yml0cyhqKV0gKiAxOSkgKyBzZWVkLmNoYXJDb2RlQXQoaikpO1xuICB9XG4gIHNlZWQgPSAnJztcbiAgZm9yIChqIGluIGtleSkgeyBzZWVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5W2pdKTsgfVxuICByZXR1cm4gc2VlZDtcbn1cblxuLy9cbi8vIGxvd2JpdHMoKVxuLy8gQSBxdWljayBcIm4gbW9kIHdpZHRoXCIgZm9yIHdpZHRoIGEgcG93ZXIgb2YgMi5cbi8vXG5mdW5jdGlvbiBsb3diaXRzKG4pIHsgcmV0dXJuIG4gJiAod2lkdGggLSAxKTsgfVxuXG4vL1xuLy8gVGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIHJlbGF0ZWQgdG8gSUVFRSA3NTQgbGltaXRzLlxuLy9cbnN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKTtcbnNpZ25pZmljYW5jZSA9IG1hdGgucG93KDIsIHNpZ25pZmljYW5jZSk7XG5vdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDI7XG5cbi8vXG4vLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cbi8vIG5vdCB3YW50IHRvIGludGVmZXJlIHdpdGggZGV0ZXJtaW5zdGljIFBSTkcgc3RhdGUgbGF0ZXIsXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24uXG4vL1xubWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4vLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbn0oXG4gIFtdLCAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgbnVtZXJpYy5zZWVkcmFuZG9tLCAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4gIDI1NiwgIC8vIHdpZHRoOiBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XG4gIDYsICAgIC8vIGNodW5rczogYXQgbGVhc3Qgc2l4IFJDNCBvdXRwdXRzIGZvciBlYWNoIGRvdWJsZVxuICA1MiAgICAvLyBzaWduaWZpY2FuY2U6IHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcbiAgKSk7XG4vKiBUaGlzIGZpbGUgaXMgYSBzbGlnaHRseSBtb2RpZmllZCB2ZXJzaW9uIG9mIHF1YWRwcm9nLmpzIGZyb20gQWxiZXJ0byBTYW50aW5pLlxuICogSXQgaGFzIGJlZW4gc2xpZ2h0bHkgbW9kaWZpZWQgYnkgU8OpYmFzdGllbiBMb2lzZWwgdG8gbWFrZSBzdXJlIHRoYXQgaXQgaGFuZGxlc1xuICogMC1iYXNlZCBBcnJheXMgaW5zdGVhZCBvZiAxLWJhc2VkIEFycmF5cy5cbiAqIExpY2Vuc2UgaXMgaW4gcmVzb3VyY2VzL0xJQ0VOU0UucXVhZHByb2cgKi9cbihmdW5jdGlvbihleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIGJhc2UwdG8xKEEpIHtcbiAgICBpZih0eXBlb2YgQSAhPT0gXCJvYmplY3RcIikgeyByZXR1cm4gQTsgfVxuICAgIHZhciByZXQgPSBbXSwgaSxuPUEubGVuZ3RoO1xuICAgIGZvcihpPTA7aTxuO2krKykgcmV0W2krMV0gPSBiYXNlMHRvMShBW2ldKTtcbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gYmFzZTF0bzAoQSkge1xuICAgIGlmKHR5cGVvZiBBICE9PSBcIm9iamVjdFwiKSB7IHJldHVybiBBOyB9XG4gICAgdmFyIHJldCA9IFtdLCBpLG49QS5sZW5ndGg7XG4gICAgZm9yKGk9MTtpPG47aSsrKSByZXRbaS0xXSA9IGJhc2UxdG8wKEFbaV0pO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRwb3JpKGEsIGxkYSwgbikge1xuICAgIHZhciBpLCBqLCBrLCBrcDEsIHQ7XG5cbiAgICBmb3IgKGsgPSAxOyBrIDw9IG47IGsgPSBrICsgMSkge1xuICAgICAgICBhW2tdW2tdID0gMSAvIGFba11ba107XG4gICAgICAgIHQgPSAtYVtrXVtrXTtcbiAgICAgICAgLy9+IGRzY2FsKGsgLSAxLCB0LCBhWzFdW2tdLCAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgYVtpXVtrXSA9IHQgKiBhW2ldW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAga3AxID0gayArIDE7XG4gICAgICAgIGlmIChuIDwga3AxKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSBrcDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICB0ID0gYVtrXVtqXTtcbiAgICAgICAgICAgIGFba11bal0gPSAwO1xuICAgICAgICAgICAgLy9+IGRheHB5KGssIHQsIGFbMV1ba10sIDEsIGFbMV1bal0sIDEpO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBrOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBhW2ldW2pdID0gYVtpXVtqXSArICh0ICogYVtpXVtrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gZHBvc2woYSwgbGRhLCBuLCBiKSB7XG4gICAgdmFyIGksIGssIGtiLCB0O1xuXG4gICAgZm9yIChrID0gMTsgayA8PSBuOyBrID0gayArIDEpIHtcbiAgICAgICAgLy9+IHQgPSBkZG90KGsgLSAxLCBhWzFdW2tdLCAxLCBiWzFdLCAxKTtcbiAgICAgICAgdCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBrOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHQgPSB0ICsgKGFbaV1ba10gKiBiW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJba10gPSAoYltrXSAtIHQpIC8gYVtrXVtrXTtcbiAgICB9XG5cbiAgICBmb3IgKGtiID0gMTsga2IgPD0gbjsga2IgPSBrYiArIDEpIHtcbiAgICAgICAgayA9IG4gKyAxIC0ga2I7XG4gICAgICAgIGJba10gPSBiW2tdIC8gYVtrXVtrXTtcbiAgICAgICAgdCA9IC1iW2tdO1xuICAgICAgICAvL34gZGF4cHkoayAtIDEsIHQsIGFbMV1ba10sIDEsIGJbMV0sIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBiW2ldID0gYltpXSArICh0ICogYVtpXVtrXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRwb2ZhKGEsIGxkYSwgbiwgaW5mbykge1xuICAgIHZhciBpLCBqLCBqbTEsIGssIHQsIHM7XG5cbiAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICBpbmZvWzFdID0gajtcbiAgICAgICAgcyA9IDA7XG4gICAgICAgIGptMSA9IGogLSAxO1xuICAgICAgICBpZiAoam0xIDwgMSkge1xuICAgICAgICAgICAgcyA9IGFbal1bal0gLSBzO1xuICAgICAgICAgICAgaWYgKHMgPD0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqXVtqXSA9IE1hdGguc3FydChzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoayA9IDE7IGsgPD0gam0xOyBrID0gayArIDEpIHtcbiAgICAgICAgICAgICAgICAvL34gdCA9IGFba11bal0gLSBkZG90KGsgLSAxLCBhWzFdW2tdLCAxLCBhWzFdW2pdLCAxKTtcbiAgICAgICAgICAgICAgICB0ID0gYVtrXVtqXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSB0IC0gKGFbaV1bal0gKiBhW2ldW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdCA9IHQgLyBhW2tdW2tdO1xuICAgICAgICAgICAgICAgIGFba11bal0gPSB0O1xuICAgICAgICAgICAgICAgIHMgPSBzICsgdCAqIHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gYVtqXVtqXSAtIHM7XG4gICAgICAgICAgICBpZiAocyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2pdW2pdID0gTWF0aC5zcXJ0KHMpO1xuICAgICAgICB9XG4gICAgICAgIGluZm9bMV0gPSAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcXBnZW4yKGRtYXQsIGR2ZWMsIGZkZG1hdCwgbiwgc29sLCBjcnZhbCwgYW1hdCxcbiAgICBidmVjLCBmZGFtYXQsIHEsIG1lcSwgaWFjdCwgbmFjdCwgaXRlciwgd29yaywgaWVycikge1xuXG4gICAgdmFyIGksIGosIGwsIGwxLCBpbmZvLCBpdDEsIGl3enYsIGl3cnYsIGl3cm0sIGl3c3YsIGl3dXYsIG52bCwgciwgaXduYnYsXG4gICAgICAgIHRlbXAsIHN1bSwgdDEsIHR0LCBnYywgZ3MsIG51LFxuICAgICAgICB0MWluZiwgdDJtaW4sXG4gICAgICAgIHZzbWFsbCwgdG1wYSwgdG1wYixcbiAgICAgICAgZ287XG5cbiAgICByID0gTWF0aC5taW4obiwgcSk7XG4gICAgbCA9IDIgKiBuICsgKHIgKiAociArIDUpKSAvIDIgKyAyICogcSArIDE7XG5cbiAgICB2c21hbGwgPSAxLjBlLTYwO1xuICAgIGRvIHtcbiAgICAgICAgdnNtYWxsID0gdnNtYWxsICsgdnNtYWxsO1xuICAgICAgICB0bXBhID0gMSArIDAuMSAqIHZzbWFsbDtcbiAgICAgICAgdG1wYiA9IDEgKyAwLjIgKiB2c21hbGw7XG4gICAgfSB3aGlsZSAodG1wYSA8PSAxIHx8IHRtcGIgPD0gMSk7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICB3b3JrW2ldID0gZHZlY1tpXTtcbiAgICB9XG4gICAgZm9yIChpID0gbiArIDE7IGkgPD0gbDsgaSA9IGkgKyAxKSB7XG4gICAgICAgIHdvcmtbaV0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICBpYWN0W2ldID0gMDtcbiAgICB9XG5cbiAgICBpbmZvID0gW107XG5cbiAgICBpZiAoaWVyclsxXSA9PT0gMCkge1xuICAgICAgICBkcG9mYShkbWF0LCBmZGRtYXQsIG4sIGluZm8pO1xuICAgICAgICBpZiAoaW5mb1sxXSAhPT0gMCkge1xuICAgICAgICAgICAgaWVyclsxXSA9IDI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZHBvc2woZG1hdCwgZmRkbWF0LCBuLCBkdmVjKTtcbiAgICAgICAgZHBvcmkoZG1hdCwgZmRkbWF0LCBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgc29sW2pdID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gajsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgc29sW2pdID0gc29sW2pdICsgZG1hdFtpXVtqXSAqIGR2ZWNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIGR2ZWNbal0gPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gajsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBkdmVjW2pdID0gZHZlY1tqXSArIGRtYXRbal1baV0gKiBzb2xbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcnZhbFsxXSA9IDA7XG4gICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgc29sW2pdID0gZHZlY1tqXTtcbiAgICAgICAgY3J2YWxbMV0gPSBjcnZhbFsxXSArIHdvcmtbal0gKiBzb2xbal07XG4gICAgICAgIHdvcmtbal0gPSAwO1xuICAgICAgICBmb3IgKGkgPSBqICsgMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGRtYXRbaV1bal0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNydmFsWzFdID0gLWNydmFsWzFdIC8gMjtcbiAgICBpZXJyWzFdID0gMDtcblxuICAgIGl3enYgPSBuO1xuICAgIGl3cnYgPSBpd3p2ICsgbjtcbiAgICBpd3V2ID0gaXdydiArIHI7XG4gICAgaXdybSA9IGl3dXYgKyByICsgMTtcbiAgICBpd3N2ID0gaXdybSArIChyICogKHIgKyAxKSkgLyAyO1xuICAgIGl3bmJ2ID0gaXdzdiArIHE7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgc3VtID0gc3VtICsgYW1hdFtqXVtpXSAqIGFtYXRbal1baV07XG4gICAgICAgIH1cbiAgICAgICAgd29ya1tpd25idiArIGldID0gTWF0aC5zcXJ0KHN1bSk7XG4gICAgfVxuICAgIG5hY3QgPSAwO1xuICAgIGl0ZXJbMV0gPSAwO1xuICAgIGl0ZXJbMl0gPSAwO1xuXG4gICAgZnVuY3Rpb24gZm5fZ290b181MCgpIHtcbiAgICAgICAgaXRlclsxXSA9IGl0ZXJbMV0gKyAxO1xuXG4gICAgICAgIGwgPSBpd3N2O1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgbCA9IGwgKyAxO1xuICAgICAgICAgICAgc3VtID0gLWJ2ZWNbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIGFtYXRbal1baV0gKiBzb2xbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA8IHZzbWFsbCkge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IG1lcSkge1xuICAgICAgICAgICAgICAgIHdvcmtbbF0gPSBzdW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdvcmtbbF0gPSAtTWF0aC5hYnMoc3VtKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VtID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1hdFtqXVtpXSA9IC1hbWF0W2pdW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ2ZWNbaV0gPSAtYnZlY1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgd29ya1tpd3N2ICsgaWFjdFtpXV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbnZsID0gMDtcbiAgICAgICAgdGVtcCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBpZiAod29ya1tpd3N2ICsgaV0gPCB0ZW1wICogd29ya1tpd25idiArIGldKSB7XG4gICAgICAgICAgICAgICAgbnZsID0gaTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gd29ya1tpd3N2ICsgaV0gLyB3b3JrW2l3bmJ2ICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG52bCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDk5OTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNTUoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyBkbWF0W2pdW2ldICogYW1hdFtqXVtudmxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya1tpXSA9IHN1bTtcbiAgICAgICAgfVxuXG4gICAgICAgIGwxID0gaXd6djtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHdvcmtbbDEgKyBpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0gbmFjdCArIDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHdvcmtbbDEgKyBpXSA9IHdvcmtbbDEgKyBpXSArIGRtYXRbaV1bal0gKiB3b3JrW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdDFpbmYgPSB0cnVlO1xuICAgICAgICBmb3IgKGkgPSBuYWN0OyBpID49IDE7IGkgPSBpIC0gMSkge1xuICAgICAgICAgICAgc3VtID0gd29ya1tpXTtcbiAgICAgICAgICAgIGwgPSBpd3JtICsgKGkgKiAoaSArIDMpKSAvIDI7XG4gICAgICAgICAgICBsMSA9IGwgLSBpO1xuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPD0gbmFjdDsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtIC0gd29ya1tsXSAqIHdvcmtbaXdydiArIGpdO1xuICAgICAgICAgICAgICAgIGwgPSBsICsgajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1bSA9IHN1bSAvIHdvcmtbbDFdO1xuICAgICAgICAgICAgd29ya1tpd3J2ICsgaV0gPSBzdW07XG4gICAgICAgICAgICBpZiAoaWFjdFtpXSA8IG1lcSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1bSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQxaW5mID0gZmFsc2U7XG4gICAgICAgICAgICBpdDEgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0MWluZikge1xuICAgICAgICAgICAgdDEgPSB3b3JrW2l3dXYgKyBpdDFdIC8gd29ya1tpd3J2ICsgaXQxXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmFjdDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlhY3RbaV0gPCBtZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod29ya1tpd3J2ICsgaV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVtcCA9IHdvcmtbaXd1diArIGldIC8gd29ya1tpd3J2ICsgaV07XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAgPCB0MSkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgIGl0MSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChpID0gaXd6diArIDE7IGkgPD0gaXd6diArIG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgc3VtID0gc3VtICsgd29ya1tpXSAqIHdvcmtbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKHN1bSkgPD0gdnNtYWxsKSB7XG4gICAgICAgICAgICBpZiAodDFpbmYpIHtcbiAgICAgICAgICAgICAgICBpZXJyWzFdID0gMTtcbiAgICAgICAgICAgICAgICAvLyBHT1RPIDk5OVxuICAgICAgICAgICAgICAgIHJldHVybiA5OTk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmFjdDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbaXd1diArIGldID0gd29ya1tpd3V2ICsgaV0gLSB0MSAqIHdvcmtbaXdydiArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3b3JrW2l3dXYgKyBuYWN0ICsgMV0gPSB3b3JrW2l3dXYgKyBuYWN0ICsgMV0gKyB0MTtcbiAgICAgICAgICAgICAgICAvLyBHT1RPIDcwMFxuICAgICAgICAgICAgICAgIHJldHVybiA3MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyB3b3JrW2l3enYgKyBpXSAqIGFtYXRbaV1bbnZsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR0ID0gLXdvcmtbaXdzdiArIG52bF0gLyBzdW07XG4gICAgICAgICAgICB0Mm1pbiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXQxaW5mKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQxIDwgdHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHQgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgdDJtaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgc29sW2ldID0gc29sW2ldICsgdHQgKiB3b3JrW2l3enYgKyBpXTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc29sW2ldKSA8IHZzbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBzb2xbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3J2YWxbMV0gPSBjcnZhbFsxXSArIHR0ICogc3VtICogKHR0IC8gMiArIHdvcmtbaXd1diArIG5hY3QgKyAxXSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHdvcmtbaXd1diArIGldID0gd29ya1tpd3V2ICsgaV0gLSB0dCAqIHdvcmtbaXdydiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya1tpd3V2ICsgbmFjdCArIDFdID0gd29ya1tpd3V2ICsgbmFjdCArIDFdICsgdHQ7XG5cbiAgICAgICAgICAgIGlmICh0Mm1pbikge1xuICAgICAgICAgICAgICAgIG5hY3QgPSBuYWN0ICsgMTtcbiAgICAgICAgICAgICAgICBpYWN0W25hY3RdID0gbnZsO1xuXG4gICAgICAgICAgICAgICAgbCA9IGl3cm0gKyAoKG5hY3QgLSAxKSAqIG5hY3QpIC8gMiArIDE7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0IC0gMTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbbF0gPSB3b3JrW2ldO1xuICAgICAgICAgICAgICAgICAgICBsID0gbCArIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5hY3QgPT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tsXSA9IHdvcmtbbl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbjsgaSA+PSBuYWN0ICsgMTsgaSA9IGkgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya1tpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2MgPSBNYXRoLm1heChNYXRoLmFicyh3b3JrW2kgLSAxXSksIE1hdGguYWJzKHdvcmtbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdzID0gTWF0aC5taW4oTWF0aC5hYnMod29ya1tpIC0gMV0pLCBNYXRoLmFicyh3b3JrW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya1tpIC0gMV0gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBNYXRoLmFicyhnYyAqIE1hdGguc3FydCgxICsgZ3MgKiBncyAvIChnYyAqIGdjKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gLU1hdGguYWJzKGdjICogTWF0aC5zcXJ0KDEgKyBncyAqIGdzIC8gKGdjICogZ2MpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnYyA9IHdvcmtbaSAtIDFdIC8gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdzID0gd29ya1tpXSAvIHRlbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdjID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya1tpIC0gMV0gPSBncyAqIHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGRtYXRbal1baSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWF0W2pdW2kgLSAxXSA9IGRtYXRbal1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtYXRbal1baV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya1tpIC0gMV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51ID0gZ3MgLyAoMSArIGdjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gZ2MgKiBkbWF0W2pdW2kgLSAxXSArIGdzICogZG1hdFtqXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1hdFtqXVtpXSA9IG51ICogKGRtYXRbal1baSAtIDFdICsgdGVtcCkgLSBkbWF0W2pdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWF0W2pdW2kgLSAxXSA9IHRlbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd29ya1tsXSA9IHdvcmtbbmFjdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAtYnZlY1tudmxdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIHNvbFtqXSAqIGFtYXRbal1bbnZsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG52bCA+IG1lcSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2l3c3YgKyBudmxdID0gc3VtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbaXdzdiArIG52bF0gPSAtTWF0aC5hYnMoc3VtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1hdFtqXVtudmxdID0gLWFtYXRbal1bbnZsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJ2ZWNbbnZsXSA9IC1idmVjW252bF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR09UTyA3MDBcbiAgICAgICAgICAgICAgICByZXR1cm4gNzAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm5fZ290b183OTcoKSB7XG4gICAgICAgIGwgPSBpd3JtICsgKGl0MSAqIChpdDEgKyAxKSkgLyAyICsgMTtcbiAgICAgICAgbDEgPSBsICsgaXQxO1xuICAgICAgICBpZiAod29ya1tsMV0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIEdPVE8gNzk4XG4gICAgICAgICAgICByZXR1cm4gNzk4O1xuICAgICAgICB9XG4gICAgICAgIGdjID0gTWF0aC5tYXgoTWF0aC5hYnMod29ya1tsMSAtIDFdKSwgTWF0aC5hYnMod29ya1tsMV0pKTtcbiAgICAgICAgZ3MgPSBNYXRoLm1pbihNYXRoLmFicyh3b3JrW2wxIC0gMV0pLCBNYXRoLmFicyh3b3JrW2wxXSkpO1xuICAgICAgICBpZiAod29ya1tsMSAtIDFdID49IDApIHtcbiAgICAgICAgICAgIHRlbXAgPSBNYXRoLmFicyhnYyAqIE1hdGguc3FydCgxICsgZ3MgKiBncyAvIChnYyAqIGdjKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IC1NYXRoLmFicyhnYyAqIE1hdGguc3FydCgxICsgZ3MgKiBncyAvIChnYyAqIGdjKSkpO1xuICAgICAgICB9XG4gICAgICAgIGdjID0gd29ya1tsMSAtIDFdIC8gdGVtcDtcbiAgICAgICAgZ3MgPSB3b3JrW2wxXSAvIHRlbXA7XG5cbiAgICAgICAgaWYgKGdjID09PSAxKSB7XG4gICAgICAgICAgICAvLyBHT1RPIDc5OFxuICAgICAgICAgICAgcmV0dXJuIDc5ODtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2MgPT09IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGl0MSArIDE7IGkgPD0gbmFjdDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHdvcmtbbDEgLSAxXTtcbiAgICAgICAgICAgICAgICB3b3JrW2wxIC0gMV0gPSB3b3JrW2wxXTtcbiAgICAgICAgICAgICAgICB3b3JrW2wxXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgbDEgPSBsMSArIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBkbWF0W2ldW2l0MV07XG4gICAgICAgICAgICAgICAgZG1hdFtpXVtpdDFdID0gZG1hdFtpXVtpdDEgKyAxXTtcbiAgICAgICAgICAgICAgICBkbWF0W2ldW2l0MSArIDFdID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG51ID0gZ3MgLyAoMSArIGdjKTtcbiAgICAgICAgICAgIGZvciAoaSA9IGl0MSArIDE7IGkgPD0gbmFjdDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IGdjICogd29ya1tsMSAtIDFdICsgZ3MgKiB3b3JrW2wxXTtcbiAgICAgICAgICAgICAgICB3b3JrW2wxXSA9IG51ICogKHdvcmtbbDEgLSAxXSArIHRlbXApIC0gd29ya1tsMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMSAtIDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICBsMSA9IGwxICsgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IGdjICogZG1hdFtpXVtpdDFdICsgZ3MgKiBkbWF0W2ldW2l0MSArIDFdO1xuICAgICAgICAgICAgICAgIGRtYXRbaV1baXQxICsgMV0gPSBudSAqIChkbWF0W2ldW2l0MV0gKyB0ZW1wKSAtIGRtYXRbaV1baXQxICsgMV07XG4gICAgICAgICAgICAgICAgZG1hdFtpXVtpdDFdID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNzk4KCkge1xuICAgICAgICBsMSA9IGwgLSBpdDE7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gaXQxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHdvcmtbbDFdID0gd29ya1tsXTtcbiAgICAgICAgICAgIGwgPSBsICsgMTtcbiAgICAgICAgICAgIGwxID0gbDEgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgd29ya1tpd3V2ICsgaXQxXSA9IHdvcmtbaXd1diArIGl0MSArIDFdO1xuICAgICAgICBpYWN0W2l0MV0gPSBpYWN0W2l0MSArIDFdO1xuICAgICAgICBpdDEgPSBpdDEgKyAxO1xuICAgICAgICBpZiAoaXQxIDwgbmFjdCkge1xuICAgICAgICAgICAgLy8gR09UTyA3OTdcbiAgICAgICAgICAgIHJldHVybiA3OTc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzc5OSgpIHtcbiAgICAgICAgd29ya1tpd3V2ICsgbmFjdF0gPSB3b3JrW2l3dXYgKyBuYWN0ICsgMV07XG4gICAgICAgIHdvcmtbaXd1diArIG5hY3QgKyAxXSA9IDA7XG4gICAgICAgIGlhY3RbbmFjdF0gPSAwO1xuICAgICAgICBuYWN0ID0gbmFjdCAtIDE7XG4gICAgICAgIGl0ZXJbMl0gPSBpdGVyWzJdICsgMTtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBnbyA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgZ28gPSBmbl9nb3RvXzUwKCk7XG4gICAgICAgIGlmIChnbyA9PT0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGdvID0gZm5fZ290b181NSgpO1xuICAgICAgICAgICAgaWYgKGdvID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ28gPT09IDk5OSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnbyA9PT0gNzAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0MSA9PT0gbmFjdCkge1xuICAgICAgICAgICAgICAgICAgICBmbl9nb3RvXzc5OSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbl9nb3RvXzc5NygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ28gPSBmbl9nb3RvXzc5OCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdvICE9PSA3OTcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmbl9nb3RvXzc5OSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBzb2x2ZVFQKERtYXQsIGR2ZWMsIEFtYXQsIGJ2ZWMsIG1lcSwgZmFjdG9yaXplZCkge1xuICAgIERtYXQgPSBiYXNlMHRvMShEbWF0KTtcbiAgICBkdmVjID0gYmFzZTB0bzEoZHZlYyk7XG4gICAgQW1hdCA9IGJhc2UwdG8xKEFtYXQpO1xuICAgIHZhciBpLCBuLCBxLFxuICAgICAgICBuYWN0LCByLFxuICAgICAgICBjcnZhbCA9IFtdLCBpYWN0ID0gW10sIHNvbCA9IFtdLCB3b3JrID0gW10sIGl0ZXIgPSBbXSxcbiAgICAgICAgbWVzc2FnZTtcblxuICAgIG1lcSA9IG1lcSB8fCAwO1xuICAgIGZhY3Rvcml6ZWQgPSBmYWN0b3JpemVkID8gYmFzZTB0bzEoZmFjdG9yaXplZCkgOiBbdW5kZWZpbmVkLCAwXTtcbiAgICBidmVjID0gYnZlYyA/IGJhc2UwdG8xKGJ2ZWMpIDogW107XG5cbiAgICAvLyBJbiBGb3J0cmFuIHRoZSBhcnJheSBpbmRleCBzdGFydHMgZnJvbSAxXG4gICAgbiA9IERtYXQubGVuZ3RoIC0gMTtcbiAgICBxID0gQW1hdFsxXS5sZW5ndGggLSAxO1xuXG4gICAgaWYgKCFidmVjKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBidmVjW2ldID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICBpYWN0W2ldID0gMDtcbiAgICB9XG4gICAgbmFjdCA9IDA7XG4gICAgciA9IE1hdGgubWluKG4sIHEpO1xuICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgIHNvbFtpXSA9IDA7XG4gICAgfVxuICAgIGNydmFsWzFdID0gMDtcbiAgICBmb3IgKGkgPSAxOyBpIDw9ICgyICogbiArIChyICogKHIgKyA1KSkgLyAyICsgMiAqIHEgKyAxKTsgaSA9IGkgKyAxKSB7XG4gICAgICAgIHdvcmtbaV0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGkgPSAxOyBpIDw9IDI7IGkgPSBpICsgMSkge1xuICAgICAgICBpdGVyW2ldID0gMDtcbiAgICB9XG5cbiAgICBxcGdlbjIoRG1hdCwgZHZlYywgbiwgbiwgc29sLCBjcnZhbCwgQW1hdCxcbiAgICAgICAgYnZlYywgbiwgcSwgbWVxLCBpYWN0LCBuYWN0LCBpdGVyLCB3b3JrLCBmYWN0b3JpemVkKTtcblxuICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgIGlmIChmYWN0b3JpemVkWzFdID09PSAxKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImNvbnN0cmFpbnRzIGFyZSBpbmNvbnNpc3RlbnQsIG5vIHNvbHV0aW9uIVwiO1xuICAgIH1cbiAgICBpZiAoZmFjdG9yaXplZFsxXSA9PT0gMikge1xuICAgICAgICBtZXNzYWdlID0gXCJtYXRyaXggRCBpbiBxdWFkcmF0aWMgZnVuY3Rpb24gaXMgbm90IHBvc2l0aXZlIGRlZmluaXRlIVwiO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHNvbHV0aW9uOiBiYXNlMXRvMChzb2wpLFxuICAgICAgICB2YWx1ZTogYmFzZTF0bzAoY3J2YWwpLFxuICAgICAgICB1bmNvbnN0cmFpbmVkX3NvbHV0aW9uOiBiYXNlMXRvMChkdmVjKSxcbiAgICAgICAgaXRlcmF0aW9uczogYmFzZTF0bzAoaXRlciksXG4gICAgICAgIGlhY3Q6IGJhc2UxdG8wKGlhY3QpLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgfTtcbn1cbmV4cG9ydHMuc29sdmVRUCA9IHNvbHZlUVA7XG59KG51bWVyaWMpKTtcbi8qXHJcblNoYW50aSBSYW8gc2VudCBtZSB0aGlzIHJvdXRpbmUgYnkgcHJpdmF0ZSBlbWFpbC4gSSBoYWQgdG8gbW9kaWZ5IGl0XHJcbnNsaWdodGx5IHRvIHdvcmsgb24gQXJyYXlzIGluc3RlYWQgb2YgdXNpbmcgYSBNYXRyaXggb2JqZWN0LlxyXG5JdCBpcyBhcHBhcmVudGx5IHRyYW5zbGF0ZWQgZnJvbSBodHRwOi8vc3RpdGNocGFub3JhbWEuc291cmNlZm9yZ2UubmV0L1B5dGhvbi9zdmQucHlcclxuKi9cclxuXHJcbm51bWVyaWMuc3ZkPSBmdW5jdGlvbiBzdmQoQSkge1xyXG4gICAgdmFyIHRlbXA7XHJcbi8vQ29tcHV0ZSB0aGUgdGhpbiBTVkQgZnJvbSBHLiBILiBHb2x1YiBhbmQgQy4gUmVpbnNjaCwgTnVtZXIuIE1hdGguIDE0LCA0MDMtNDIwICgxOTcwKVxyXG5cdHZhciBwcmVjPSBudW1lcmljLmVwc2lsb247IC8vTWF0aC5wb3coMiwtNTIpIC8vIGFzc3VtZXMgZG91YmxlIHByZWNcclxuXHR2YXIgdG9sZXJhbmNlPSAxLmUtNjQvcHJlYztcclxuXHR2YXIgaXRtYXg9IDUwO1xyXG5cdHZhciBjPTA7XHJcblx0dmFyIGk9MDtcclxuXHR2YXIgaj0wO1xyXG5cdHZhciBrPTA7XHJcblx0dmFyIGw9MDtcclxuXHRcclxuXHR2YXIgdT0gbnVtZXJpYy5jbG9uZShBKTtcclxuXHR2YXIgbT0gdS5sZW5ndGg7XHJcblx0XHJcblx0dmFyIG49IHVbMF0ubGVuZ3RoO1xyXG5cdFxyXG5cdGlmIChtIDwgbikgdGhyb3cgXCJOZWVkIG1vcmUgcm93cyB0aGFuIGNvbHVtbnNcIlxyXG5cdFxyXG5cdHZhciBlID0gbmV3IEFycmF5KG4pO1xyXG5cdHZhciBxID0gbmV3IEFycmF5KG4pO1xyXG5cdGZvciAoaT0wOyBpPG47IGkrKykgZVtpXSA9IHFbaV0gPSAwLjA7XHJcblx0dmFyIHYgPSBudW1lcmljLnJlcChbbixuXSwwKTtcclxuLy9cdHYuemVybygpO1xyXG5cdFxyXG4gXHRmdW5jdGlvbiBweXRoYWcoYSxiKVxyXG4gXHR7XHJcblx0XHRhID0gTWF0aC5hYnMoYSlcclxuXHRcdGIgPSBNYXRoLmFicyhiKVxyXG5cdFx0aWYgKGEgPiBiKVxyXG5cdFx0XHRyZXR1cm4gYSpNYXRoLnNxcnQoMS4wKyhiKmIvYS9hKSlcclxuXHRcdGVsc2UgaWYgKGIgPT0gMC4wKSBcclxuXHRcdFx0cmV0dXJuIGFcclxuXHRcdHJldHVybiBiKk1hdGguc3FydCgxLjArKGEqYS9iL2IpKVxyXG5cdH1cclxuXHJcblx0Ly9Ib3VzZWhvbGRlcidzIHJlZHVjdGlvbiB0byBiaWRpYWdvbmFsIGZvcm1cclxuXHJcblx0dmFyIGY9IDAuMDtcclxuXHR2YXIgZz0gMC4wO1xyXG5cdHZhciBoPSAwLjA7XHJcblx0dmFyIHg9IDAuMDtcclxuXHR2YXIgeT0gMC4wO1xyXG5cdHZhciB6PSAwLjA7XHJcblx0dmFyIHM9IDAuMDtcclxuXHRcclxuXHRmb3IgKGk9MDsgaSA8IG47IGkrKylcclxuXHR7XHRcclxuXHRcdGVbaV09IGc7XHJcblx0XHRzPSAwLjA7XHJcblx0XHRsPSBpKzE7XHJcblx0XHRmb3IgKGo9aTsgaiA8IG07IGorKykgXHJcblx0XHRcdHMgKz0gKHVbal1baV0qdVtqXVtpXSk7XHJcblx0XHRpZiAocyA8PSB0b2xlcmFuY2UpXHJcblx0XHRcdGc9IDAuMDtcclxuXHRcdGVsc2VcclxuXHRcdHtcdFxyXG5cdFx0XHRmPSB1W2ldW2ldO1xyXG5cdFx0XHRnPSBNYXRoLnNxcnQocyk7XHJcblx0XHRcdGlmIChmID49IDAuMCkgZz0gLWc7XHJcblx0XHRcdGg9IGYqZy1zXHJcblx0XHRcdHVbaV1baV09Zi1nO1xyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHM9IDAuMFxyXG5cdFx0XHRcdGZvciAoaz1pOyBrIDwgbTsgaysrKSBcclxuXHRcdFx0XHRcdHMgKz0gdVtrXVtpXSp1W2tdW2pdXHJcblx0XHRcdFx0Zj0gcy9oXHJcblx0XHRcdFx0Zm9yIChrPWk7IGsgPCBtOyBrKyspIFxyXG5cdFx0XHRcdFx0dVtrXVtqXSs9Zip1W2tdW2ldXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHFbaV09IGdcclxuXHRcdHM9IDAuMFxyXG5cdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspIFxyXG5cdFx0XHRzPSBzICsgdVtpXVtqXSp1W2ldW2pdXHJcblx0XHRpZiAocyA8PSB0b2xlcmFuY2UpXHJcblx0XHRcdGc9IDAuMFxyXG5cdFx0ZWxzZVxyXG5cdFx0e1x0XHJcblx0XHRcdGY9IHVbaV1baSsxXVxyXG5cdFx0XHRnPSBNYXRoLnNxcnQocylcclxuXHRcdFx0aWYgKGYgPj0gMC4wKSBnPSAtZ1xyXG5cdFx0XHRoPSBmKmcgLSBzXHJcblx0XHRcdHVbaV1baSsxXSA9IGYtZztcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspIGVbal09IHVbaV1bal0vaFxyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG07IGorKylcclxuXHRcdFx0e1x0XHJcblx0XHRcdFx0cz0wLjBcclxuXHRcdFx0XHRmb3IgKGs9bDsgayA8IG47IGsrKykgXHJcblx0XHRcdFx0XHRzICs9ICh1W2pdW2tdKnVbaV1ba10pXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBuOyBrKyspIFxyXG5cdFx0XHRcdFx0dVtqXVtrXSs9cyplW2tdXHJcblx0XHRcdH1cdFxyXG5cdFx0fVxyXG5cdFx0eT0gTWF0aC5hYnMocVtpXSkrTWF0aC5hYnMoZVtpXSlcclxuXHRcdGlmICh5PngpIFxyXG5cdFx0XHR4PXlcclxuXHR9XHJcblx0XHJcblx0Ly8gYWNjdW11bGF0aW9uIG9mIHJpZ2h0IGhhbmQgZ3RyYW5zZm9ybWF0aW9uc1xyXG5cdGZvciAoaT1uLTE7IGkgIT0gLTE7IGkrPSAtMSlcclxuXHR7XHRcclxuXHRcdGlmIChnICE9IDAuMClcclxuXHRcdHtcclxuXHRcdCBcdGg9IGcqdVtpXVtpKzFdXHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBcclxuXHRcdFx0XHR2W2pdW2ldPXVbaV1bal0vaFxyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKylcclxuXHRcdFx0e1x0XHJcblx0XHRcdFx0cz0wLjBcclxuXHRcdFx0XHRmb3IgKGs9bDsgayA8IG47IGsrKykgXHJcblx0XHRcdFx0XHRzICs9IHVbaV1ba10qdltrXVtqXVxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbjsgaysrKSBcclxuXHRcdFx0XHRcdHZba11bal0rPShzKnZba11baV0pXHJcblx0XHRcdH1cdFxyXG5cdFx0fVxyXG5cdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspXHJcblx0XHR7XHJcblx0XHRcdHZbaV1bal0gPSAwO1xyXG5cdFx0XHR2W2pdW2ldID0gMDtcclxuXHRcdH1cclxuXHRcdHZbaV1baV0gPSAxO1xyXG5cdFx0Zz0gZVtpXVxyXG5cdFx0bD0gaVxyXG5cdH1cclxuXHRcclxuXHQvLyBhY2N1bXVsYXRpb24gb2YgbGVmdCBoYW5kIHRyYW5zZm9ybWF0aW9uc1xyXG5cdGZvciAoaT1uLTE7IGkgIT0gLTE7IGkrPSAtMSlcclxuXHR7XHRcclxuXHRcdGw9IGkrMVxyXG5cdFx0Zz0gcVtpXVxyXG5cdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspIFxyXG5cdFx0XHR1W2ldW2pdID0gMDtcclxuXHRcdGlmIChnICE9IDAuMClcclxuXHRcdHtcclxuXHRcdFx0aD0gdVtpXVtpXSpnXHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cz0wLjBcclxuXHRcdFx0XHRmb3IgKGs9bDsgayA8IG07IGsrKykgcyArPSB1W2tdW2ldKnVba11bal07XHJcblx0XHRcdFx0Zj0gcy9oXHJcblx0XHRcdFx0Zm9yIChrPWk7IGsgPCBtOyBrKyspIHVba11bal0rPWYqdVtrXVtpXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IgKGo9aTsgaiA8IG07IGorKykgdVtqXVtpXSA9IHVbal1baV0vZztcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdFx0Zm9yIChqPWk7IGogPCBtOyBqKyspIHVbal1baV0gPSAwO1xyXG5cdFx0dVtpXVtpXSArPSAxO1xyXG5cdH1cclxuXHRcclxuXHQvLyBkaWFnb25hbGl6YXRpb24gb2YgdGhlIGJpZGlhZ29uYWwgZm9ybVxyXG5cdHByZWM9IHByZWMqeFxyXG5cdGZvciAoaz1uLTE7IGsgIT0gLTE7IGsrPSAtMSlcclxuXHR7XHJcblx0XHRmb3IgKHZhciBpdGVyYXRpb249MDsgaXRlcmF0aW9uIDwgaXRtYXg7IGl0ZXJhdGlvbisrKVxyXG5cdFx0e1x0Ly8gdGVzdCBmIHNwbGl0dGluZ1xyXG5cdFx0XHR2YXIgdGVzdF9jb252ZXJnZW5jZSA9IGZhbHNlXHJcblx0XHRcdGZvciAobD1rOyBsICE9IC0xOyBsKz0gLTEpXHJcblx0XHRcdHtcdFxyXG5cdFx0XHRcdGlmIChNYXRoLmFicyhlW2xdKSA8PSBwcmVjKVxyXG5cdFx0XHRcdHtcdHRlc3RfY29udmVyZ2VuY2U9IHRydWVcclxuXHRcdFx0XHRcdGJyZWFrIFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoTWF0aC5hYnMocVtsLTFdKSA8PSBwcmVjKVxyXG5cdFx0XHRcdFx0YnJlYWsgXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCF0ZXN0X2NvbnZlcmdlbmNlKVxyXG5cdFx0XHR7XHQvLyBjYW5jZWxsYXRpb24gb2YgZVtsXSBpZiBsPjBcclxuXHRcdFx0XHRjPSAwLjBcclxuXHRcdFx0XHRzPSAxLjBcclxuXHRcdFx0XHR2YXIgbDE9IGwtMVxyXG5cdFx0XHRcdGZvciAoaSA9bDsgaTxrKzE7IGkrKylcclxuXHRcdFx0XHR7XHRcclxuXHRcdFx0XHRcdGY9IHMqZVtpXVxyXG5cdFx0XHRcdFx0ZVtpXT0gYyplW2ldXHJcblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoZikgPD0gcHJlYylcclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdGc9IHFbaV1cclxuXHRcdFx0XHRcdGg9IHB5dGhhZyhmLGcpXHJcblx0XHRcdFx0XHRxW2ldPSBoXHJcblx0XHRcdFx0XHRjPSBnL2hcclxuXHRcdFx0XHRcdHM9IC1mL2hcclxuXHRcdFx0XHRcdGZvciAoaj0wOyBqIDwgbTsgaisrKVxyXG5cdFx0XHRcdFx0e1x0XHJcblx0XHRcdFx0XHRcdHk9IHVbal1bbDFdXHJcblx0XHRcdFx0XHRcdHo9IHVbal1baV1cclxuXHRcdFx0XHRcdFx0dVtqXVtsMV0gPSAgeSpjKyh6KnMpXHJcblx0XHRcdFx0XHRcdHVbal1baV0gPSAteSpzKyh6KmMpXHJcblx0XHRcdFx0XHR9IFxyXG5cdFx0XHRcdH1cdFxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIHRlc3QgZiBjb252ZXJnZW5jZVxyXG5cdFx0XHR6PSBxW2tdXHJcblx0XHRcdGlmIChsPT0gaylcclxuXHRcdFx0e1x0Ly9jb252ZXJnZW5jZVxyXG5cdFx0XHRcdGlmICh6PDAuMClcclxuXHRcdFx0XHR7XHQvL3Fba10gaXMgbWFkZSBub24tbmVnYXRpdmVcclxuXHRcdFx0XHRcdHFba109IC16XHJcblx0XHRcdFx0XHRmb3IgKGo9MDsgaiA8IG47IGorKylcclxuXHRcdFx0XHRcdFx0dltqXVtrXSA9IC12W2pdW2tdXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrICAvL2JyZWFrIG91dCBvZiBpdGVyYXRpb24gbG9vcCBhbmQgbW92ZSBvbiB0byBuZXh0IGsgdmFsdWVcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoaXRlcmF0aW9uID49IGl0bWF4LTEpXHJcblx0XHRcdFx0dGhyb3cgJ0Vycm9yOiBubyBjb252ZXJnZW5jZS4nXHJcblx0XHRcdC8vIHNoaWZ0IGZyb20gYm90dG9tIDJ4MiBtaW5vclxyXG5cdFx0XHR4PSBxW2xdXHJcblx0XHRcdHk9IHFbay0xXVxyXG5cdFx0XHRnPSBlW2stMV1cclxuXHRcdFx0aD0gZVtrXVxyXG5cdFx0XHRmPSAoKHkteikqKHkreikrKGctaCkqKGcraCkpLygyLjAqaCp5KVxyXG5cdFx0XHRnPSBweXRoYWcoZiwxLjApXHJcblx0XHRcdGlmIChmIDwgMC4wKVxyXG5cdFx0XHRcdGY9ICgoeC16KSooeCt6KStoKih5LyhmLWcpLWgpKS94XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRmPSAoKHgteikqKHgreikraCooeS8oZitnKS1oKSkveFxyXG5cdFx0XHQvLyBuZXh0IFFSIHRyYW5zZm9ybWF0aW9uXHJcblx0XHRcdGM9IDEuMFxyXG5cdFx0XHRzPSAxLjBcclxuXHRcdFx0Zm9yIChpPWwrMTsgaTwgaysxOyBpKyspXHJcblx0XHRcdHtcdFxyXG5cdFx0XHRcdGc9IGVbaV1cclxuXHRcdFx0XHR5PSBxW2ldXHJcblx0XHRcdFx0aD0gcypnXHJcblx0XHRcdFx0Zz0gYypnXHJcblx0XHRcdFx0ej0gcHl0aGFnKGYsaClcclxuXHRcdFx0XHRlW2ktMV09IHpcclxuXHRcdFx0XHRjPSBmL3pcclxuXHRcdFx0XHRzPSBoL3pcclxuXHRcdFx0XHRmPSB4KmMrZypzXHJcblx0XHRcdFx0Zz0gLXgqcytnKmNcclxuXHRcdFx0XHRoPSB5KnNcclxuXHRcdFx0XHR5PSB5KmNcclxuXHRcdFx0XHRmb3IgKGo9MDsgaiA8IG47IGorKylcclxuXHRcdFx0XHR7XHRcclxuXHRcdFx0XHRcdHg9IHZbal1baS0xXVxyXG5cdFx0XHRcdFx0ej0gdltqXVtpXVxyXG5cdFx0XHRcdFx0dltqXVtpLTFdID0geCpjK3oqc1xyXG5cdFx0XHRcdFx0dltqXVtpXSA9IC14KnMreipjXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHo9IHB5dGhhZyhmLGgpXHJcblx0XHRcdFx0cVtpLTFdPSB6XHJcblx0XHRcdFx0Yz0gZi96XHJcblx0XHRcdFx0cz0gaC96XHJcblx0XHRcdFx0Zj0gYypnK3MqeVxyXG5cdFx0XHRcdHg9IC1zKmcrYyp5XHJcblx0XHRcdFx0Zm9yIChqPTA7IGogPCBtOyBqKyspXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0eT0gdVtqXVtpLTFdXHJcblx0XHRcdFx0XHR6PSB1W2pdW2ldXHJcblx0XHRcdFx0XHR1W2pdW2ktMV0gPSB5KmMreipzXHJcblx0XHRcdFx0XHR1W2pdW2ldID0gLXkqcyt6KmNcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZVtsXT0gMC4wXHJcblx0XHRcdGVba109IGZcclxuXHRcdFx0cVtrXT0geFxyXG5cdFx0fSBcclxuXHR9XHJcblx0XHRcclxuXHQvL3Z0PSB0cmFuc3Bvc2UodilcclxuXHQvL3JldHVybiAodSxxLHZ0KVxyXG5cdGZvciAoaT0wO2k8cS5sZW5ndGg7IGkrKykgXHJcblx0ICBpZiAocVtpXSA8IHByZWMpIHFbaV0gPSAwXHJcblx0ICBcclxuXHQvL3NvcnQgZWlnZW52YWx1ZXNcdFxyXG5cdGZvciAoaT0wOyBpPCBuOyBpKyspXHJcblx0e1x0IFxyXG5cdC8vd3JpdGVsbihxKVxyXG5cdCBmb3IgKGo9aS0xOyBqID49IDA7IGotLSlcclxuXHQge1xyXG5cdCAgaWYgKHFbal0gPCBxW2ldKVxyXG5cdCAge1xyXG5cdC8vICB3cml0ZWxuKGksJy0nLGopXHJcblx0ICAgYyA9IHFbal1cclxuXHQgICBxW2pdID0gcVtpXVxyXG5cdCAgIHFbaV0gPSBjXHJcblx0ICAgZm9yKGs9MDtrPHUubGVuZ3RoO2srKykgeyB0ZW1wID0gdVtrXVtpXTsgdVtrXVtpXSA9IHVba11bal07IHVba11bal0gPSB0ZW1wOyB9XHJcblx0ICAgZm9yKGs9MDtrPHYubGVuZ3RoO2srKykgeyB0ZW1wID0gdltrXVtpXTsgdltrXVtpXSA9IHZba11bal07IHZba11bal0gPSB0ZW1wOyB9XHJcbi8vXHQgICB1LnN3YXBDb2xzKGksailcclxuLy9cdCAgIHYuc3dhcENvbHMoaSxqKVxyXG5cdCAgIGkgPSBqXHQgICBcclxuXHQgIH1cclxuXHQgfVx0XHJcblx0fVxyXG5cdFxyXG5cdHJldHVybiB7VTp1LFM6cSxWOnZ9XHJcbn07XHJcblxyXG4iLCJmdW5jdGlvbiBTcHJlYWRTaGVldEVycm9yKCkge1xuICAgIHRoaXMubmFtZSA9ICdTcHJlYWRTaGVldEVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSAn5Y+R55Sf5LqG6ZSZ6K+vJztcbn1cblxuU3ByZWFkU2hlZXRFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblNwcmVhZFNoZWV0RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByZWFkU2hlZXRFcnJvcjtcblNwcmVhZFNoZWV0RXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUgKyAnID0+ICcgKyB0aGlzLm1lc3NhZ2U7XG59O1xuXG5leHBvcnQge1NwcmVhZFNoZWV0RXJyb3J9XG5cbiIsImltcG9ydCB7Z2xvYmFsU2V0dGluZ3MsIGRlZmF1bHRTZXR0aW5nc30gZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgU3ByZWFkU2hlZXQgZnJvbSAnLi9jb3JlJztcblxuaW1wb3J0IHBvbHlmaWxsIGZyb20gJy4vcG9seWZpbGwnO1xuXG5pbXBvcnQge1hGb3JtdWxhc30gZnJvbSAnLi9wbHVnaW5zL3hmb3JtdWxhcy9YRm9ybXVsYXMnO1xuXG5pbXBvcnQge1BsdWdpbiwgcmVnaXN0ZXJQbHVnaW59IGZyb20gJy4vcGx1Z2lucy9QbHVnaW4nO1xuaW1wb3J0IFBlcnNpc3RlbnQgZnJvbSAnLi9wbHVnaW5zL3BlcnNpc3RlbnQvUGVyc2lzdGVudCc7XG5cblxuU3ByZWFkU2hlZXQuZ2xvYmFsU2V0dGluZ3MgPSBnbG9iYWxTZXR0aW5ncztcblNwcmVhZFNoZWV0LmRlZmF1bHRTZXR0aW5ncyA9IGRlZmF1bHRTZXR0aW5ncztcblNwcmVhZFNoZWV0LnZlcnNpb24gPSAnQEBfdmVyc2lvbl9AQCc7XG5cblxuU3ByZWFkU2hlZXQucGx1Z2lucyA9IHtcbiAgICBQbHVnaW46IFBsdWdpbixcbiAgICByZWdpc3RlclBsdWdpbjogcmVnaXN0ZXJQbHVnaW5cbn07XG5cbi8vIOWGhee9ruaPkuS7tlxucmVnaXN0ZXJQbHVnaW4oJ3BlcnNpc3RlbnQnLCBQZXJzaXN0ZW50KTtcblxuXG4vLyDmtY/op4jlmajnjq/looPkuIvnmoTlhajlsYDlj5jph4/lkI3jgIJcbndpbmRvdy5Ccmlja1NwcmVhZFNoZWV0ID0gU3ByZWFkU2hlZXQ7XG5wb2x5ZmlsbCh3aW5kb3cpO1xuXG4vLyBUT0RPIOaPkOS+m+abtOaUueWFqOWxgOWPmOmHj+WQjeeahOaWueazle+8jOS7pemYsuatouWFqOWxgOWPmOmHj+WGsueqgeOAglxuXG4iLCJpbXBvcnQgRnJhbWUgZnJvbSAnLi9kZXNpZ25lci9GcmFtZSc7XG5pbXBvcnQgV29ya2Jvb2sgZnJvbSAnLi9kZXNpZ25lci9Xb3JrYm9vayc7XG5pbXBvcnQge2V4dGVuZCwgZW1wdHlGdW5jdGlvbiwgcmFuZG9tU3RyaW5nfSBmcm9tICcuL3V0aWxzL2NvbW1vbic7XG5pbXBvcnQge2dldEFsbFBsdWdpbnMsIHZhbGlkYXRlUGx1Z2lufSBmcm9tICcuL3BsdWdpbnMvUGx1Z2luJztcbmltcG9ydCBFbWl0dGVyIGZyb20gJy4vdXRpbHMvRW1pdHRlcic7XG5cbnZhciBBVVRPX0lEID0gMTtcblxuY2xhc3MgU3ByZWFkU2hlZXQgZXh0ZW5kcyBFbWl0dGVyIHtcblxuICAgIC8qKlxuICAgICAqIOexu+S8vCBFeGNlbCDnmoTnlLXlrZDooajmoLzjgIJcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSByb290RWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1c2VyU2V0dGluZ3MgLSDnlLXlrZDooajmoLznmoTnlKjmiLfphY3nva7kv6Hmga9cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdXNlclNldHRpbmdzLndvcmtib29rIC0gV29ya2Jvb2sg55qE6YWN572uXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gdXNlclNldHRpbmdzLnNoZWV0cyAtIOmFjee9ruaJgOacieWIneWniyBTaGVldCDpobXnmoTmlbDnu4RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbZGlzcGxheU1vZGU9ZmFsc2VdIC0g5bGV56S65qih5byP77yM5LiN5Y+v57yW6L6R44CCXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdEVsZW1lbnQsIHVzZXJTZXR0aW5ncywgZGlzcGxheU1vZGUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcbiAgICAgICAgdGhpcy5nZXRVc2VyU2V0dGluZ3ModXNlclNldHRpbmdzKTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzID0ge307XG4gICAgICAgIGV4dGVuZCh0aGlzLnNldHRpbmdzLCBTcHJlYWRTaGVldC5kZWZhdWx0U2V0dGluZ3MpO1xuICAgICAgICBleHRlbmQodGhpcy5zZXR0aW5ncywgdGhpcy51c2VyU2V0dGluZ3MpO1xuXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLnNldHRpbmdzLmlkIHx8IHRoaXMuZ2V0SWQoKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5TW9kZSA9IGRpc3BsYXlNb2RlO1xuXG4gICAgICAgIHRoaXMuX2luaXRQbHVnaW4oKTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IG5ldyBGcmFtZSh0aGlzLCB0aGlzLnNldHRpbmdzLmZyYW1lKTtcbiAgICAgICAgdGhpcy53b3JrYm9vayA9IG5ldyBXb3JrYm9vayh0aGlzLCB0aGlzLnNldHRpbmdzLndvcmtib29rKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlUGx1Z2luKCk7XG4gICAgfVxuXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIC8vIOS4jeaMh+WumiBpZCDml7bvvIzlsL3ph4/nlJ/miJDkuI3lj6/ph43lpI3nmoQgaWTvvIjkvb/nlKjlvZPliY0gaWZyYW1lIOiHquWinuWPmOmHj+mFjeWQiOmaj+acuuWtl+espuS4sueahOaWueW8j++8iVxuICAgICAgICByZXR1cm4gdGhpcy5pZCB8fCBTcHJlYWRTaGVldC5nbG9iYWxTZXR0aW5ncy5pZFByZWZpeCArIChBVVRPX0lEKyspICsgJy0nICsgcmFuZG9tU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgZ2V0Um9vdEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RFbGVtZW50O1xuICAgIH1cblxuICAgIGdldERpc3BsYXlNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5TW9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5bnlKjmiLfkvKDlhaXnmoTliJ3lp4vphY3nva7jgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHMgLSDooajnpLrnlKjmiLfphY3nva7nmoQgSlNPTiDlrZfnrKbkuLJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFVzZXJTZXR0aW5ncyhzKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZXJTZXR0aW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlclNldHRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzICYmIHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy51c2VyU2V0dGluZ3MgPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51c2VyU2V0dGluZ3MgPSBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJTZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5YgU3ByZWFkU2hlZXQg5a6e6ZmF55Sf5pWI55qE6YWN572u5L+h5oGv44CCXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5Y+v5Lqk5o2i55qE5Lit6Ze05pWw5o2u77yM55So5LqO5pWw5o2u5o+Q5Lqk44CB6Kej5p6Q6L2s5o2i562J44CCXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3JhZ2luPWZhbHNlXSAtIOS4uiBgdHJ1ZWAg5pe26I635Y+W5Y6f5aeLIEphdmFTY3JpcHQg5a+56LGhXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRFeGNoYW5nZURhdGEob3JhZ2luID0gZmFsc2UpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmtib29rLl9nZXRFeGNoYW5nZSgpO1xuICAgICAgICB2YXIgZiA9IHRoaXMuZnJhbWUuX2dldEV4Y2hhbmdlKCk7IC8vIFRPRE8gZnJhbWVcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICB3b3JrYm9vazogdyxcbiAgICAgICAgICAgIGZyYW1lOiBmLFxuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SWQoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3JhZ2luID8gbyA6IEpTT04uc3RyaW5naWZ5KG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjSBTcHJlYWRTaGVldCDlr7nlupTnmoQgV29ya2Jvb2sg5a6e5L6L44CCXG4gICAgICogQHJldHVybnMge1dvcmtib29rfVxuICAgICAqL1xuICAgIGdldFdvcmtib29rSW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtib29rO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjSBTcHJlYWRTaGVldCDlr7nlupTnmoQgRnJhbWUg5a6e5L6L44CCXG4gICAgICogQHJldHVybnMge0ZyYW1lfVxuICAgICAqL1xuICAgIGdldEZyYW1lSW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1lO1xuICAgIH1cblxuXG4gICAgX2luaXRQbHVnaW4oKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZ2V0QWxsUGx1Z2lucygpLmZvckVhY2goUCA9PiB7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQKHRoaXMpO1xuICAgICAgICAgICAgdmFsaWRhdGVQbHVnaW4ocCk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMuc2V0KHAuX19uYW1lX18sIHApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfZW5hYmxlUGx1Z2luKCkge1xuICAgICAgICB0aGlzLnBsdWdpbnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgIGlmIChwLmlzRW5hYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBwLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwcmVhZFNoZWV0OyIsImltcG9ydCB7aXNFbXB0eVZhbHVlfSBmcm9tICcuLi91dGlscy9jb21tb24nXG5cbi8qKlxuICog6YWN572u57+76K+R57G744CCXG4gKiDmoYbmnrblhoXpg6jkvb/nlKjvvIznlKjmiLfku6PnoIHkuI3lupTor6XosIPnlKjlroPjgIJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb25maWdUcmFuc2xhdG9yIHtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U2hlZXR9IHNoZWV0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzaGVldCkge1xuICAgICAgICB0aGlzLmluaXRpYWxDb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDkuK3pl7TmlbDmja7moLzlvI/nmoTorr7orqHkvJrlsL3ph4/lkIzml7bkv53or4HlnKggRXhjZWwg5Y+KIFdlYiDpobXpnaLkuK3lnYfkvr/kuo7lpITnkIbvvIxcbiAgICAgKiDkvYbkuI3lhY3lrZjlnKjkuIDkupsgV2ViIOS4remavuS7peebtOaOpeS9v+eUqOeahOaVsOaNruagvOW8j++8jOivpeaWueazleWNs+aYr+WujOaIkOatpOexu+aVsOaNruagvOW8j1xuICAgICAqIOeahOmAgumFjei9rOaNouW3peS9nOOAglxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgdHJhbnNsYXRlKCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0eS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5W2ldLnN0YXJ0c1dpdGgoJ190cmFucycpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eVtpXV0uY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5pbmZvKHRoaXMuc2hlZXQuZ2V0TmFtZSgpICsgJ1tDb25maWdUcmFuc2xhdG9yLnRyYW5zbGF0ZV0gc2V0dGluZ3MgLT4nLCBzZXR0aW5ncyk7XG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kc29udGFibGUg5Lit55qE5LiA5Lqb54q25oCB5peg5rOV6YCa6L+H5Yid5aeL6YWN572u5Y+C5pWw5o6n5Yi277yMXG4gICAgICog5Y+q6IO95Zyo5a6e5L6L5YyW5LmL5ZCO6LCD55So55u45bqU55qE5pa55rOV5p2l5oGi5aSN55u45bqU55qE54q25oCB77yM5q2k5pa55rOVXG4gICAgICog5Y2z5piv5a6M5oiQ6K+l5Yqf6IO944CCXG4gICAgICovXG4gICAgaW5pdFNoZWV0U3RhdGUoKSB7XG4gICAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydHkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVtpXS5zdGFydHNXaXRoKCdfaW5pdCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eVtpXV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB0cmFuc2xhdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBfdHJhbnNDZWxsKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5pbml0aWFsQ29uZmlnLmNlbGxNZXRhcztcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmNlbGwgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCByb3cgPSBtW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsTWV0YSA9IHJvd1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5yb3cgPSBjZWxsTWV0YS5yb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbCA9IGNlbGxNZXRhLmNvbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5kYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGR0IGluIGNlbGxNZXRhLmRhdGFUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5kYXRhVHlwZS5oYXNPd25Qcm9wZXJ0eShkdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxbZHRdID0gY2VsbE1ldGEuZGF0YVR5cGVbZHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwudHlwZSA9IGNlbGxNZXRhLmRhdGFUeXBlLnR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjZWxsLnR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuc3R5bGVzLmFsaWdubWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGMgPSBjZWxsTWV0YS5zdHlsZXMuYWxpZ25tZW50cy5qb2luKCcgaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jbGFzc05hbWUgPSBjZWxsLmNsYXNzTmFtZSA/IChjZWxsLmNsYXNzTmFtZSArPSAnIGh0JyArIGMpIDogJ2h0JyArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuZm9udEZhbWlseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLl9zdHlsZV9mb250RmFtaWx5ID0gY2VsbE1ldGEuc3R5bGVzLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuZm9udFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5fc3R5bGVfZm9udFNpemUgPSBjZWxsTWV0YS5zdHlsZXMuZm9udFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5fc3R5bGVfY29sb3IgPSBjZWxsTWV0YS5zdHlsZXMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuX3N0eWxlX2JhY2tncm91bmRDb2xvciA9IGNlbGxNZXRhLnN0eWxlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuZm9udFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NOYW1lID0gY2VsbC5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGNlbGwuY2xhc3NOYW1lICs9ICcgc3NkLWZvbnQtJyArIGNlbGxNZXRhLnN0eWxlcy5mb250U3R5bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzc2QtZm9udC0nICsgY2VsbE1ldGEuc3R5bGVzLmZvbnRTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxNZXRhLnN0eWxlcy5mb250V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NOYW1lID0gY2VsbC5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGNlbGwuY2xhc3NOYW1lICs9ICcgc3NkLWZvbnQtYm9sZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzc2QtZm9udC1ib2xkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxNZXRhLnN0eWxlcy50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNsYXNzTmFtZSA9IGNlbGwuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChjZWxsLmNsYXNzTmFtZSArPSAnIHNzZC1mb250LXVuZGVybGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzc2QtZm9udC11bmRlcmxpbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmNlbGwucHVzaChjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF90cmFuc0RhdGEoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmluaXRpYWxDb25maWcuZGF0YTtcbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIC8vIGhvdFRhYmxlIOWcqOaciSBkYXRhIOeahOaDheWGteS4i+WPquiDveaYvuekuuacieaVsOaNrueahOihjOWIl++8jOi/meWvueS6juiuvuiuoeWZqOadpeivtOW5tuS4jeaWueS+v+S9v+eUqO+8jFxuICAgICAgICAgICAgLy8g5pWF5aGr5YWF56m65pWw5o2u5Lul5pKR6LW36KGo5qC86IezIGluaXRSb3dzICogaW5pdENvbHMg55qE5aSn5bCP44CCXG4gICAgICAgICAgICAvLyAgICBpZiAocy5sZW5ndGggPCB0aGlzLnNoZWV0LmluaXRSb3dzKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgbGV0IGZvcm1lckNvbCA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gICAgICAgIHMubGVuZ3RoID0gdGhpcy5zaGVldC5pbml0Um93cztcbiAgICAgICAgICAgIC8vICAgICAgICBzLmZpbGwoW10sIGZvcm1lckNvbCk7XG4gICAgICAgICAgICAvLyAgICB9XG4gICAgICAgICAgICAvLyAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vICAgICAgICBsZXQgcm93ID0gc1tpXTtcbiAgICAgICAgICAgIC8vICAgICAgICBpZiAocm93Lmxlbmd0aCA8IHRoaXMuc2hlZXQuaW5pdENvbHMpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgbGV0IGZvcm1lclJvdyA9IHJvdy5sZW5ndGg7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgIHJvdy5sZW5ndGggPSB0aGlzLnNoZWV0LmluaXRDb2xzO1xuICAgICAgICAgICAgLy8gICAgICAgICAgICByb3cuZmlsbCgnJywgZm9ybWVyUm93KTtcbiAgICAgICAgICAgIC8vICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICB9XG4gICAgICAgICAgICBzZXR0aW5ncy5taW5Sb3dzID0gdGhpcy5zaGVldC5pbml0Um93cztcbiAgICAgICAgICAgIHNldHRpbmdzLm1pbkNvbHMgPSB0aGlzLnNoZWV0LmluaXRDb2xzO1xuXG4gICAgICAgICAgICBzZXR0aW5ncy5kYXRhID0gcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOWIl+WuvVxuICAgIF90cmFuc0NvbFdpZHRocyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgdyA9IHRoaXMuaW5pdGlhbENvbmZpZy5jb2xXaWR0aHM7XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5jb2xXaWR0aHMgPSB3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g6KGM6auYXG4gICAgX3RyYW5zUm93SGVpZ2h0cyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgaCA9IHRoaXMuaW5pdGlhbENvbmZpZy5yb3dIZWlnaHRzO1xuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgICAgc2V0dGluZ3Mucm93SGVpZ2h0cyA9IGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDovrnmoYZcbiAgICBfdHJhbnNCb3JkZXJzKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbml0aWFsQ29uZmlnLmJvcmRlcnM7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5jdXN0b21Cb3JkZXJzID0gcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOWQiOW5tuWNleWFg+agvFxuICAgIF90cmFuc01lcmdlQ2VsbHMoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmluaXRpYWxDb25maWcubWVyZ2VDZWxscztcbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm1lcmdlQ2VsbHMgPSBzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGluaXRTdGF0ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIOmAieWMulxuICAgIF9pbml0U2VsZWN0aW9uKCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuaW5pdGlhbENvbmZpZy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICB0aGlzLnNoZWV0LnNlbGVjdChzLnJvdywgcy5jb2wsIHMuZW5kUm93LCBzLmVuZENvbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNoZWV0LnNlbGVjdCgwLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdUcmFuc2xhdG9yOyIsImltcG9ydCBDb250ZXh0TWVudSBmcm9tICcuL2ZyYW1lL0NvbnRleHRNZW51J1xuXG4vKipcbiAqIOeUteWtkOihqOagvOiuvuiuoeWZqOS4re+8jOmZpOS6hiBXb3JrYm9vayDlpJbnmoTnu4Tku7bnrqHnkIblmajvvIxcbiAqIOWMheWQq+iPnOWNleagj+OAgeW3peWFt+agj+OAgeS+p+i+ueagj+OAgeWPs+mUruiPnOWNleetieetieOAglxuICovXG5jbGFzcyBGcmFtZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihpbnN0YW5jZSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuc3ByZWFkU2hlZXQgPSBpbnN0YW5jZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtDb250ZXh0TWVudX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGV4dE1lbnUgPSBuZXcgQ29udGV4dE1lbnUoaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIF9nZXRFeGNoYW5nZSgpIHtcblxuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmFtZTsiLCJpbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vdXRpbHMvY29tbW9uLmpzJ1xuaW1wb3J0IENvbmZpZ1RyYW5zbGF0b3IgZnJvbSAnLi9Db25maWdUcmFuc2xhdG9yLmpzJ1xuXG5cbi8qKlxuICogSGFuZHNvbnRhYmxlIOe7hOS7tueahOmAgumFjeexu1xuICovXG5jbGFzcyBIb3RUYWJsZUFkYXB0b3IgZXh0ZW5kcyBIYW5kc29udGFibGUge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290RWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSDljp/lp4vphY3nva7kv6Hmga9cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXh0Q29uZmlnIC0g6ZmE5Yqg55qE6YWN572u5L+h5oGvXG4gICAgICogQHBhcmFtIHtTaGVldH0gc2hlZXQgLSDlr7nlupTnmoQgc2hlZXQg5a6e5L6LXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdEVsZW1lbnQsIGNvbmZpZywgZXh0Q29uZmlnLCBzaGVldCkge1xuICAgICAgICB2YXIgaG90U2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdmFyIHRyYW5zbGF0b3IgPSBuZXcgQ29uZmlnVHJhbnNsYXRvcihjb25maWcsIHNoZWV0KTtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdHJhbnNsYXRvci50cmFuc2xhdGUoKTtcblxuICAgICAgICB2YXIgZnJhbWUgPSBzaGVldC53b3JrYm9vay5zcHJlYWRTaGVldC5nZXRGcmFtZUluc3RhbmNlKCk7XG4gICAgICAgIHZhciBtZW51SXRlbXMgPSBmcmFtZS5jb250ZXh0TWVudS5tZW51SXRlbXM7XG4gICAgICAgIHZhciBjb250ZXh0TWVudSA9IHt9O1xuICAgICAgICBjb250ZXh0TWVudS5pdGVtcyA9IGZyYW1lLmNvbnRleHRNZW51LmdldE1lbnVJdGVtczRIb3RUYWJsZSgpO1xuICAgICAgICBjb250ZXh0TWVudS5jYWxsYmFjayA9IChmdW5jdGlvbiAoc2hlZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IG1lbnVJdGVtcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5oYW5kbGVyLmNhbGwodGhpcywgc2hlZXQsIG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oc2hlZXQpKTtcbiAgICAgICAgSG90VGFibGVBZGFwdG9yLl9wcmVmZXJlbmNlLmNvbnRleHRNZW51ID0gY29udGV4dE1lbnU7XG5cbiAgICAgICAgZXh0ZW5kKGhvdFNldHRpbmdzLCBIb3RUYWJsZUFkYXB0b3IuX3ByZWZlcmVuY2UpO1xuICAgICAgICBleHRlbmQoaG90U2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgZXh0ZW5kKGhvdFNldHRpbmdzLCBleHRDb25maWcpO1xuXG4gICAgICAgIHN1cGVyKHJvb3RFbGVtZW50LCBob3RTZXR0aW5ncyk7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNsYXRvciA9IHRyYW5zbGF0b3I7XG5cbiAgICAgICAgLy8gaGFuZG9udGFibGUg5q+P5qyhIHJlbmRlciDnmoTml7blgJnvvIzkuI3kv53nlZkgdGQg55qE54q25oCB77yM5Zug5q2k6YCa6L+H6K+l5LqL5Lu26YeN5bu65LiA5Lqb5qC35byP44CCXG4gICAgICAgIEhhbmRzb250YWJsZS5ob29rcy5hZGQoJ2JlZm9yZVJlbmRlcmVyJywgZnVuY3Rpb24gKFRELCByb3csIGNvbCwgcHJvcCwgdmFsdWUsIGNlbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBURC5zdHlsZS5jb2xvciA9IGNlbGxQcm9wZXJ0aWVzLl9zdHlsZV9jb2xvciB8fCAnJztcbiAgICAgICAgICAgIFRELnN0eWxlLmZvbnRGYW1pbHkgPSBjZWxsUHJvcGVydGllcy5fc3R5bGVfZm9udEZhbWlseSB8fCAnJztcbiAgICAgICAgICAgIFRELnN0eWxlLmZvbnRTaXplID0gY2VsbFByb3BlcnRpZXMuX3N0eWxlX2ZvbnRTaXplIHx8ICcnO1xuICAgICAgICAgICAgVEQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY2VsbFByb3BlcnRpZXMuX3N0eWxlX2JhY2tncm91bmRDb2xvciB8fCAnJztcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICog5bCGIEhhbmRzb250YWJsZSDnmoTmiYDmnInkuovku7bpg73lp5TmiZjnu5kgU3ByZWFkU2hlZXQg5ZCO5Lya5pyJ5Lqb5Y2h44CCXG4gICAgICAgICAqIOWPquWlveWwhiBIYW5kc29udGFibGUuaG9va3MuZ2V0UmVnaXN0ZXJlZCgpIOaNouaIkCBFQ1Ag6aG555uu6ZyA6KaB55qE44CCXG4gICAgICAgICAqL1xuICAgICAgICBbJ2FmdGVyU2VsZWN0aW9uRW5kJ10uZm9yRWFjaChob29rID0+IHtcbiAgICAgICAgICAgIEhhbmRzb250YWJsZS5ob29rcy5hZGQoaG9vaywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGhvb2spO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChzaGVldCk7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgdmFyIGN4dCA9IHNoZWV0Lndvcmtib29rLnNwcmVhZFNoZWV0O1xuICAgICAgICAgICAgICAgIGN4dC5lbWl0LmFwcGx5KGN4dCwgYXJncyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fdHJhbnNsYXRvcjtcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIOmihOiuvumFjee9ruOAglxuICogQHByaXZhdGVcbiAqL1xuSG90VGFibGVBZGFwdG9yLl9wcmVmZXJlbmNlID0ge1xuICAgIG91dHNpZGVDbGlja0Rlc2VsZWN0czogZmFsc2UsXG4gICAgY29udGV4dE1lbnU6IHRydWUsXG5cbiAgICByb3dIZWFkZXJzOiB0cnVlLFxuICAgIGNvbEhlYWRlcnM6IHRydWUsXG5cbiAgICBtYW51YWxDb2x1bW5SZXNpemU6IHRydWUsXG4gICAgbWFudWFsUm93UmVzaXplOiB0cnVlLFxuXG4gICAgdGFibGVDbGFzc05hbWU6ICdzc2QtaGFuZHNvbnRhYmxlJyxcblxuICAgIHhGb3JtdWxhczogdHJ1ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgSG90VGFibGVBZGFwdG9yOyIsImltcG9ydCBUYWJzIGZyb20gICcuL3ZpZXdzL1RhYnMnO1xuaW1wb3J0IEhhbmRzb250YWJsZSBmcm9tICcuL0hvdFRhYmxlQWRhcHRvcic7XG5pbXBvcnQge1NoZWV0RXJyb3J9IGZyb20gJy4vU2hlZXRFcnJvcic7XG5pbXBvcnQge0V4Y2hhbmdlfSBmcm9tICcuL2V4dC9TaGVldF9leGNoYW5nZSc7XG5pbXBvcnQge1NoZWV0SGVscGVyfSBmcm9tICcuL2V4dC9TaGVldF9oZWxwZXInO1xuaW1wb3J0IHtDb29yZGluYXRlfSBmcm9tICcuLi91dGlscy9jb21tb24nO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnLi4vdXRpbHMvRW1pdHRlcic7XG5cblxuY29uc3QgSU5JVF9ST1dTID0gMTUwOyAvLyBTaGVldCDliJ3lp4vlj6/mmL7npLrnmoTooYzmlbBcbmNvbnN0IElOSVRfQ09MUyA9IDUwOyAgLy8gU2hlZXQg5Yid5aeL5Y+v5pi+56S655qE5YiX5pWwXG5cbi8vIFdlYnN0b3JtIElERSDnmoTor63ms5Xmo4Dmn6XmiJYgc291cmVtYXAg6Kej5p6Q5pe25LiN5pSv5oyB55u05o6l5YaZ5Yiw57G755qEIGV4dGVuZHMg5ZCO44CCXG52YXIgTWl4aW4gPSBTaGVldEhlbHBlcihFeGNoYW5nZShFbWl0dGVyKSk7XG5cbi8qKlxuICog5bel5L2c6KGoXG4gKlxuICogQGZpcmVzIFNoZWV0I2FmdGVyUmVuYW1lXG4gKiBAZmlyZXMgU2hlZXQjYWZ0ZXJSZW5hbWVDYW5jZWxcbiAqL1xuY2xhc3MgU2hlZXQgZXh0ZW5kcyBNaXhpbiB7XG5cbiAgICAvKipcbiAgICAgKiDmnoTpgKAgU2hlZXQg5a6e5L6L77yM55So5oi35Luj56CB5LiN5bqU6K+l55u05o6l6LCD55So5a6D77yMXG4gICAgICog6ICM5piv5L2/55SoIFdvcmtib29rLmNyZWF0ZVNoZWV0KCkg5pa55rOV5p6E6YCg44CCXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmtib29rfSB3b3JrYm9va1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdvcmtib29rLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNoZWV0IOaJgOWcqOeahOW3peS9nOihqFxuICAgICAgICAgKiBAdHlwZSB7V29ya2Jvb2t9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndvcmtib29rID0gd29ya2Jvb2s7XG4gICAgICAgIHRoaXMuJCR2aWV3ID0gd29ya2Jvb2suJCR2aWV3O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gY29uZmlnO1xuICAgICAgICB0aGlzLnNoZWV0TmFtZSA9IGNvbmZpZy5uYW1lO1xuXG4gICAgICAgIHRoaXMuaW5pdFJvd3MgPSBJTklUX1JPV1M7XG4gICAgICAgIHRoaXMuaW5pdENvbHMgPSBJTklUX0NPTFM7XG5cbiAgICAgICAgdGhpcy5meCA9IHt9OyAvLyBUT0RPXG5cbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyKCkge1xuICAgICAgICB0aGlzLiQkdmlldy5hcHBlbmRUYWIodGhpcy5zaGVldE5hbWUpO1xuICAgICAgICB2YXIge2NvbnRhaW5lciwgd2lkdGgsIGhlaWdodH0gPSB0aGlzLiQkdmlldy5faG90VGFibGVzLmdldCh0aGlzLnNoZWV0TmFtZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIYW5kc29udGFibGV9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlID0gbmV3IEhhbmRzb250YWJsZShjb250YWluZXIsIHRoaXMuc2V0dGluZ3MsIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRoaXMud29ya2Jvb2suc3ByZWFkU2hlZXQuZ2V0RGlzcGxheU1vZGUoKSxcbiAgICAgICAgICAgIHN0YXJ0Um93czogdGhpcy5pbml0Um93cyxcbiAgICAgICAgICAgIHN0YXJ0Q29sczogdGhpcy5pbml0Q29scyxcbiAgICAgICAgICAgIF9pc0hvdFRhYmxlQWRhcHRvcjogdHJ1ZSxcbiAgICAgICAgICAgIF9zaGVldDogdGhpc1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUuX3RyYW5zbGF0b3IuaW5pdFNoZWV0U3RhdGUoKTtcbiAgICAgICAgdGhpcy4kJHZpZXcuaGlkZUNvbnRlbnQodGhpcy5nZXROYW1lKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjSBzaGVldCDnmoTlkI3lrZdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoZWV0TmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmv4DmtLvlvZPliY0gc2hlZXQg6aG1XG4gICAgICovXG4gICAgYWN0aXZlKCkge1xuICAgICAgICB0aGlzLndvcmtib29rLmFjdGl2ZVNoZWV0ID0gdGhpcy5nZXROYW1lKCk7XG4gICAgICAgIHRoaXMuJCR2aWV3LmFjdGl2ZVRhYih0aGlzLmdldE5hbWUoKSk7XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOajgOa1i+W9k+WJjSBzaGVldCDmmK/lkKbooqvmv4DmtLtcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2Jvb2suYWN0aXZlU2hlZXQgPT09IHRoaXMuZ2V0TmFtZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWFs+mXrSBzaGVldCDpobVcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy53b3JrYm9vay5jbG9zZVNoZWV0KHRoaXMuZ2V0TmFtZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDplIDmr4HlvZPliY0gc2hlZXRcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMud29ya2Jvb2suc2hlZXRzLmRlbGV0ZSh0aGlzLmdldE5hbWUoKSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLndvcmtib29rO1xuICAgICAgICBkZWxldGUgdGhpcy4kJHZpZXc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uZIHNoZWV0IOmhtemHjeWRveWQjVxuICAgICAqIEBwYXJhbSBuYW1lIC0g5paw5ZCN5a2XXG4gICAgICovXG4gICAgcmVuYW1lKG5hbWUpIHtcbiAgICAgICAgdGhpcy53b3JrYm9vay5yZW5hbWVTaGVldCh0aGlzLmdldE5hbWUoKSwgbmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6YCJ5LitIHNoZWV0IOS4reeahOafkOWMuuWfn+OAglxuICAgICAqIOS4jeaMh+WumiB0b1JvdyDjgIF0b0NvbCDml7bliJnpgInkuK3lr7nlupTnmoTljZXlhYPmoLzjgIJcbiAgICAgKiBAcGFyYW0ge2ludH0gZnJvbVJvdyAtIOi1t+Wni+ihjFxuICAgICAqIEBwYXJhbSB7aW50fSBmcm9tQ29sIC0g6LW35aeL5YiXXG4gICAgICogQHBhcmFtIHtpbnR9IFt0b1Jvd10gLSDnu4jmraLooYxcbiAgICAgKiBAcGFyYW0ge2ludH0gW3RvQ29sXSAtIOe7iOatouWIl1xuICAgICAqL1xuICAgIHNlbGVjdChmcm9tUm93LCBmcm9tQ29sLCB0b1JvdywgdG9Db2wpIHtcbiAgICAgICAgdG9Sb3cgPSB0b1JvdyB8fCBmcm9tUm93O1xuICAgICAgICB0b0NvbCA9IHRvQ29sIHx8IGZyb21Db2w7XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnNlbGVjdENlbGwoZnJvbVJvdywgZnJvbUNvbCwgdG9Sb3csIHRvQ29sLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635b6X5b2T5YmNIHNoZWV0IOeahOmAieWMulxuICAgICAqIEByZXR1cm5zIHt7cm93LCBjb2wsIGVuZFJvdywgZW5kQ29sfX1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmhhbmRzb250YWJsZS5nZXRTZWxlY3RlZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93OiBzZWxlY3Rpb25bMF0sXG4gICAgICAgICAgICBjb2w6IHNlbGVjdGlvblsxXSxcbiAgICAgICAgICAgIGVuZFJvdzogc2VsZWN0aW9uWzJdLFxuICAgICAgICAgICAgZW5kQ29sOiBzZWxlY3Rpb25bM11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWQiOW5tuWNleWFg+agvFxuICAgICAqIFRJUDogaGFuZHNvbnRhYmxlIOWumOaWueWQiOW5tuWKn+iDveS4jeiDveato+ehruWkhOeQhuW3suacieeahOWQiOW5tuWMuuWfn++8jOaVheWBmumHjeaWsOiuoeeul+OAglxuICAgICAqIEBwYXJhbSB7aW50fSByb3cgLSDotbflp4vooYxcbiAgICAgKiBAcGFyYW0ge2ludH0gY29sIC0g6LW35aeL5YiXXG4gICAgICogQHBhcmFtIHtpbnR9IHJvd3NwYW4gLSDlvoXlkIjlubbnmoTooYzmlbBcbiAgICAgKiBAcGFyYW0ge2ludH0gY29sc3BhbiAtIOW+heWQiOW5tueahOWIl+aVsFxuICAgICAqL1xuICAgIC8vIFRPRE8g5pyA5aSn6KGM5YiX5pWw6ZmQ5Yi2XG4gICAgbWVyZ2VDZWxscyhyb3csIGNvbCwgcm93c3BhbiwgY29sc3Bhbikge1xuICAgICAgICB2YXIgciA9IDA7XG4gICAgICAgIHZhciBjb3ZlciA9IFtdO1xuICAgICAgICB2YXIgbWVyZ2VDZWxscyA9IHRoaXMuaGFuZHNvbnRhYmxlLmdldFNldHRpbmdzKCkubWVyZ2VDZWxscztcblxuICAgICAgICB2YXIgcjEgPSBbcm93LCBjb2wsIHJvdyArIHJvd3NwYW4gLSAxLCBjb2wgKyBjb2xzcGFuIC0gMV07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG1lcmdlQ2VsbHMubGVuZ3RoOyBpOyAtLWkpIHtcbiAgICAgICAgICAgIGxldCBmID0gbWVyZ2VDZWxsc1tpIC0gMV07XG4gICAgICAgICAgICBsZXQgcjIgPSBbZi5yb3csIGYuY29sLCBmLnJvdyArIGYucm93c3BhbiAtIDEsIGYuY29sICsgZi5jb2xzcGFuIC0gMV07XG5cbiAgICAgICAgICAgIC8vIOS4juWOn+WMuuWfn+WtmOWcqOWujOWFqOmHjeWPoFxuICAgICAgICAgICAgaWYgKENvb3JkaW5hdGUuaXNFcXVhbChyMSwgcjIpKSB7XG4gICAgICAgICAgICAgICAgciA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDmmK/ljp/ljLrln5/nmoTlrZDpm4ZcbiAgICAgICAgICAgIGlmIChDb29yZGluYXRlLmlzU3Vic2V0KHIxLCByMikpIHtcbiAgICAgICAgICAgICAgICByID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOimhuebluWOn+WMuuWfn++8iOatpOaXtuWPr+iDveS4juWPpuS4gOS4quWOn+WMuuWfn+S6pOmbhuaIluWujOWFqOimhueblu+8iVxuICAgICAgICAgICAgaWYgKENvb3JkaW5hdGUuaXNTdXBlcnNldChyMSwgcjIpKSB7XG4gICAgICAgICAgICAgICAgY292ZXIucHVzaChpIC0gMSk7XG4gICAgICAgICAgICAgICAgciA9IDM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDkuI7ljp/ljLrln5/lrZjlnKjkuqTpm4Yo5LiN5ZCr5a2Q6ZuG44CB6LaF6ZuG5oOF5Ya1KVxuICAgICAgICAgICAgaWYgKENvb3JkaW5hdGUuaW50ZXJzZWN0aW9uKHIxLCByMikpIHtcbiAgICAgICAgICAgICAgICByID0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyID09PSAwIHx8IHIgPT09IDMpIHtcbiAgICAgICAgICAgIGlmIChyID09PSAzKSB7IC8vIOi/meenjeaDheWGteS4i+S4gOWumuWtmOWcqOW3sue7j+WQiOW5tui/h+eahOWNleWFg+agvFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY292ZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VDZWxscy5zcGxpY2UoY292ZXJbaV0sIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcmdlQ2VsbHMgPSBtZXJnZUNlbGxzIHx8IFtdO1xuICAgICAgICAgICAgbWVyZ2VDZWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICByb3dzcGFuOiByb3dzcGFuLFxuICAgICAgICAgICAgICAgIGNvbHNwYW46IGNvbHNwYW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe1xuICAgICAgICAgICAgICAgIG1lcmdlQ2VsbHM6IG1lcmdlQ2VsbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHIgPT09IDIgfHwgciA9PT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNoZWV0RXJyb3IoYOe7meWumueahOWQiOW5tuWMuuWfn+S4jeWQiOazlTogWyR7cm93fSwgJHtjb2x9LCAke3Jvd3NwYW59LCAke2NvbHNwYW59XWApXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIOWPlua2iOWNleWFg+agvOWQiOW5tlxuICAgICAqIEBwYXJhbSB7aW50fSByb3cgLSDotbflp4vooYxcbiAgICAgKiBAcGFyYW0ge2ludH0gY29sIC0g6LW35aeL5YiXXG4gICAgICogQHBhcmFtIHtpbnR9IHJvd3NwYW4gLSDlvoXlkIjlubbnmoTooYzmlbBcbiAgICAgKiBAcGFyYW0ge2ludH0gY29sc3BhbiAtIOW+heWQiOW5tueahOWIl+aVsFxuICAgICAqL1xuICAgIHVuTWVyZ2VDZWxscyhyb3csIGNvbCwgcm93c3BhbiwgY29sc3Bhbikge1xuICAgICAgICB2YXIgbWVyZ2VkID0gdGhpcy5oYW5kc29udGFibGUuZ2V0U2V0dGluZ3MoKS5tZXJnZUNlbGxzO1xuICAgICAgICB2YXIgbWVyZ2VDZWxscyA9IFtdO1xuICAgICAgICBpZiAobWVyZ2VkICYmIG1lcmdlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVyZ2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKENvb3JkaW5hdGUuaXNTdWJzZXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW2ldLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZFtpXS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRbaV0ucm93ICsgbWVyZ2VkW2ldLnJvd3NwYW4gLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW2ldLmNvbCArIG1lcmdlZFtpXS5jb2xzcGFuIC0gMVxuICAgICAgICAgICAgICAgICAgICBdLCBbcm93LCBjb2wsIHJvdyArIHJvd3NwYW4gLSAxLCBjb2wgKyBjb2xzcGFuIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXJnZUNlbGxzLnB1c2gobWVyZ2VkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS51cGRhdGVTZXR0aW5ncyh7XG4gICAgICAgICAgICBtZXJnZUNlbGxzOiBtZXJnZUNlbGxzLmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogbWVyZ2VDZWxsc1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzcGxpY2VDbGFzcyhzZWxlY3Rpb24sIG5ld0NsYXNzTmFtZSwgLi4uY2xhc3NOYW1lcykge1xuICAgICAgICB0aGlzLl93YWxrb25DZWxsTWV0YXMoc2VsZWN0aW9uLCAocm93LCBjb2wsIGNlbGxNZXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKHRoaXMuX3JlbW92ZUZvcm1lckNsYXNzKFxuICAgICAgICAgICAgICAgICAgICBjZWxsTWV0YS5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXNcbiAgICAgICAgICAgICAgICApICsgJyAnICsgbmV3Q2xhc3NOYW1lKS50cmltKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHtjbGFzc05hbWU6IG5ld0NsYXNzTmFtZX0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuvue9ruWtl+S9k+WKoOeyl1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbHVlPXRydWVdIGB0cnVlYCDkuLrliqDnspfvvIxgZmFsc2VgIOWPlua2iOWKoOeyl1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZWxlY3Rpb24gLSDlvoXorr7nva7nmoTpgInljLpcbiAgICAgKiBAcGFyYW0ge2ludH0gc2VsZWN0aW9uLnJvd1xuICAgICAqIEBwYXJhbSB7aW50fSBzZWxlY3Rpb24uY29sXG4gICAgICogQHBhcmFtIHtpbnR9IFtzZWxlY3Rpb24uZW5kUm93XVxuICAgICAqIEBwYXJhbSB7aW50fSBbc2VsZWN0aW9uLmVuZENvbF1cbiAgICAgKi9cbiAgICBzZXRGb250Qm9sZCh2YWx1ZSA9IHRydWUsIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZUNsYXNzKHNlbGVjdGlvbiwgJ3NzZC1mb250LWJvbGQnLCAnc3NkLWZvbnQtYm9sZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2VDbGFzcyhzZWxlY3Rpb24sICcnLCAnc3NkLWZvbnQtYm9sZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuvue9ruaWnOS9k+Wtl1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbHVlPXRydWVdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlbGVjdGlvbiAtIOW+heiuvue9rueahOmAieWMulxuICAgICAqIEBwYXJhbSB7aW50fSBzZWxlY3Rpb24ucm93XG4gICAgICogQHBhcmFtIHtpbnR9IHNlbGVjdGlvbi5jb2xcbiAgICAgKiBAcGFyYW0ge2ludH0gW3NlbGVjdGlvbi5lbmRSb3ddXG4gICAgICogQHBhcmFtIHtpbnR9IFtzZWxlY3Rpb24uZW5kQ29sXVxuICAgICAqL1xuICAgIHNldEZvbnRJdGFsaWModmFsdWUgPSB0cnVlLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2VDbGFzcyhzZWxlY3Rpb24sICdzc2QtZm9udC1pdGFsaWMnLCAnc3NkLWZvbnQtaXRhbGljJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZUNsYXNzKHNlbGVjdGlvbiwgJycsICdzc2QtZm9udC1pdGFsaWMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIOiuvue9ruWtl+S9k+S4i+WIkue6v1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbHVlPXRydWVdXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbiAtIOW+heiuvue9rueahOmAieWMulxuICAgICAqIEBwYXJhbSB7aW50fSBzZWxlY3Rpb24ucm93XG4gICAgICogQHBhcmFtIHtpbnR9IHNlbGVjdGlvbi5jb2xcbiAgICAgKiBAcGFyYW0ge2ludH0gW3NlbGVjdGlvbi5lbmRSb3ddXG4gICAgICogQHBhcmFtIHtpbnR9IFtzZWxlY3Rpb24uZW5kQ29sXVxuICAgICAqL1xuICAgIHNldEZvbnRVbmRlcmxpbmUodmFsdWUgPSB0cnVlLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2VDbGFzcyhzZWxlY3Rpb24sICdzc2QtZm9udC11bmRlcmxpbmUnLCAnc3NkLWZvbnQtdW5kZXJsaW5lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZUNsYXNzKHNlbGVjdGlvbiwgJycsICdzc2QtZm9udC11bmRlcmxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva7lrZfkvZPpopzoibJcbiAgICAgKiBUSVAg5aaC5p6cIOKAnGhhbmRvbnRhYmxlIOebtOaOpemAmui/hyBnZXRDZWxsIOiOt+W+lyBURCDlkI7orr7nva7moLflvI/igJ3vvIzlvZPlho3mrKEgcmVuZGVyIOaXtuS8muWkseaViOOAglxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBzZXRGb250Q29sb3IodmFsdWUgPSAnJywgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKSkge1xuICAgICAgICB0aGlzLl93YWxrb25DZWxsTWV0YXMoc2VsZWN0aW9uLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9zdHlsZV9jb2xvcjogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHtfc3R5bGVfY29sb3I6IHZhbHVlfSk7XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWtl+S9k+exu+Wei1xuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBzZXRGb250RmFtaWx5KHZhbHVlID0gJycsIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5fd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfc3R5bGVfZm9udEZhbWlseTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHtfc3R5bGVfZm9udEZhbWlseTogdmFsdWV9KTtcbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5a2X5L2T5aSn5bCPXG4gICAgICogQHBhcmFtIHZhbHVlIC0g6ZyA6KaB5oyH5a6a5Y2V5L2N77yM5aaCIDEycHhcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2V0Rm9udFNpemUodmFsdWUsIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5fd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfc3R5bGVfZm9udFNpemU6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7X3N0eWxlX2ZvbnRTaXplOiB2YWx1ZX0pO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva7og4zmma/oibJcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2V0QmFja2dyb3VuZENvbG9yKHZhbHVlID0gJycsIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5fd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfc3R5bGVfYmFja2dyb3VuZENvbG9yOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwge19zdHlsZV9iYWNrZ3JvdW5kQ29sb3I6IHZhbHVlfSk7XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnJlbmRlcigpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRklYTUUgaGFuZHNvbnRhYmxlIOeahCBCVUcg5bCa5pyq5aSE55CG77yM5rqQ56CB5aSN5p2C77yM5LiA5pe25Lmf5LiN5aW95omp5bGV44CCXG4gICAgICog6K6+572u6L655qGGXG4gICAgICogQHBhcmFtIHJhbmdlIC0g6L655qGG6IyD5Zu077yM5b2i5aaCIGB7Zm9ybToge3JvdzogMSwgY29sOiAxfSwgdG86IHtyb3c6IDMsIGNvbDogNH19YCDnmoTlr7nosaFcbiAgICAgKiBAcGFyYW0gdG9wIC0g5LiK6L655qGG77yM5b2i5aaCIGB7d2lkdGg6IDIsIGNvbG9yOiAnIzUyOTJGNyd9YCDnmoTlr7nosaFcbiAgICAgKiBAcGFyYW0gW3JpZ2h0XVxuICAgICAqIEBwYXJhbSBbYm90dG9tXVxuICAgICAqIEBwYXJhbSBbbGVmdF1cbiAgICAgKi9cbiAgICBzZXRCb3JkZXIocmFuZ2UsIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlnLnJpZ2h0ID0gcmlnaHQgfHwgdG9wO1xuICAgICAgICBjb25maWcuYm90dG9tID0gYm90dG9tIHx8IHRvcDtcbiAgICAgICAgY29uZmlnLmxlZnQgPSBsZWZ0IHx8IGNvbmZpZy5yaWdodDtcblxuICAgICAgICB2YXIgZm9ybWVyQm9yZGVycyA9IHRoaXMuaGFuZHNvbnRhYmxlLmdldFNldHRpbmdzKCkuY3VzdG9tQm9yZGVycyB8fCBbXTtcbiAgICAgICAgZm9ybWVyQm9yZGVycy5wdXNoKGNvbmZpZyk7XG5cbiAgICAgICAgLy8gVE9ETyBjdXN0b21Cb3JkZXJzIGNhbm5vdCBiZSB1cGRhdGVkIHZpYSB1cGRhdGVTZXR0aW5nc1xuICAgICAgICAvLyBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvMjAwMn1cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe1xuICAgICAgICAgICAgY3VzdG9tQm9yZGVyczogZm9ybWVyQm9yZGVyc1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2hlZXQ7XG5cblxuLyoqXG4gKiBhZnRlclJlbmFtZSDkuovku7bjgIJcbiAqXG4gKiBAZXZlbnQgU2hlZXQjYWZ0ZXJSZW5hbWVcbiAqIEB0eXBlIHtTaGVldH1cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5cbi8qKlxuICogYWZ0ZXJSZW5hbWVDYW5jZWwg5LqL5Lu244CCXG4gKlxuICogQGV2ZW50IFNoZWV0I2FmdGVyUmVuYW1lQ2FuY2VsXG4gKiBAdHlwZSB7U2hlZXR9XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG4iLCJpbXBvcnQge1NwcmVhZFNoZWV0RXJyb3J9IGZyb20gJy4uL1NwcmVhZFNoZWV0RXJyb3InXG5cbmV4cG9ydCBmdW5jdGlvbiBTaGVldEVycm9yKHZhbHVlKSB7XG4gICAgdGhpcy5uYW1lID0gJ1NoZWV0RXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IHZhbHVlO1xufVxuU2hlZXRFcnJvci5wcm90b3R5cGUgPSBuZXcgU3ByZWFkU2hlZXRFcnJvcigpO1xuU2hlZXRFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGVldEVycm9yOyIsImltcG9ydCBUYWJzIGZyb20gICcuL3ZpZXdzL1RhYnMnXG5pbXBvcnQgU2hlZXQgZnJvbSAnLi9TaGVldCdcbmltcG9ydCB7U2hlZXRFcnJvcn0gZnJvbSAnLi9TaGVldEVycm9yJ1xuaW1wb3J0IHtDYXNlSW5zZW5zaXRpdmVNYXB9IGZyb20gJy4uL3V0aWxzL2RhdGFTdHJ1Y3R1cmUnXG5pbXBvcnQge3VwcGVyQ2FzZX0gZnJvbSAnLi4vdXRpbHMvY29tbW9uJ1xuaW1wb3J0IHtnbG9iYWxTZXR0aW5nc30gZnJvbSAnLi4vc2V0dGluZ3MnXG5cblxuY29uc3QgcmVnRXhwID0gZ2xvYmFsU2V0dGluZ3Muc2hlZXQuc2hlZXROYW1lO1xuXG4vKipcbiAqIOW3peS9nOewv+OAguS4gOS4qiBXb3JrYm9vayDljIXlkKvkuIDkuKrmiJblpJrkuKogU2hlZXQgLlxuICovXG5jbGFzcyBXb3JrYm9vayB7XG5cbiAgICAvKipcbiAgICAgKiBXb3JrYm9vayDmnoTpgKDlmahcbiAgICAgKiBAcGFyYW0ge1NwcmVhZFNoZWV0fSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnN0YW5jZSwgY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U3ByZWFkU2hlZXR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwcmVhZFNoZWV0ID0gaW5zdGFuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Q2FzZUluc2Vuc2l0aXZlTWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaGVldHMgPSBuZXcgQ2FzZUluc2Vuc2l0aXZlTWFwKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBjb25maWc7XG5cbiAgICAgICAgdGhpcy5faW5pdFNldHRpbmdzKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuJCR2aWV3ID0gbmV3IFRhYnModGhpcyk7XG5cbiAgICAgICAgY29uZmlnLnNoZWV0cy5mb3JFYWNoKHYgPT4gdGhpcy5jcmVhdGVTaGVldCh2KSk7XG5cbiAgICAgICAgLy8g5qC55o2u5Yid5aeL5YyW5pWw5o2u5r+A5rS7IHNoZWV0IOmhtVxuICAgICAgICB2YXIgdG9BY3RpdmUgPSB0aGlzLmdldFNoZWV0KHRoaXMuYWN0aXZlU2hlZXQpO1xuICAgICAgICBpZiAoIXRvQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5oyH5a6a55qEIGFjdGl2ZVNoZWV0IOS4jeWtmOWcqDogJHt0aGlzLmFjdGl2ZVNoZWV0fWApO1xuICAgICAgICB9XG4gICAgICAgIHRvQWN0aXZlLmFjdGl2ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHNldHRpbmdzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2V0dGluZ3MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKGtleXNbaV0gPT09ICdzaGVldHMnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gc2V0dGluZ3Nba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5YgV29ya2Jvb2sg5omA5bGe55qE55S15a2Q6KGo5qC855qE55So5oi35Yid5aeL6YWN572u44CCXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ByZWFkU2hlZXQuZ2V0U2V0dGluZ3MoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5blvZPliY0gV29ya2Jvb2sg55qEIGlkXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgfHwgKHRoaXMuaWQgPSB0aGlzLnNwcmVhZFNoZWV0LmdldElkKCkgKyBnbG9iYWxTZXR0aW5ncy5pZFN1ZmZpeDRXb3JrYm9vayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5qC55o2u5oyH5a6aIHNoZWV0IOWQjeiOt+WPliBzaGVldCDlrp7kvotcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEByZXR1cm5zIHtTaGVldH1cbiAgICAgKi9cbiAgICBnZXRTaGVldChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoZWV0cy5nZXQobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmNIFdvcmtib29rIOS4i+eahOaJgOaciSBzaGVldCDlrp7kvotcbiAgICAgKiBAcmV0dXJucyB7Q2FzZUluc2Vuc2l0aXZlTWFwfVxuICAgICAqL1xuICAgIGdldFNoZWV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hlZXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluaJgOaciSBzaGVldCDnmoTlkI3lrZdcbiAgICAgKiBAcmV0dXJucyB7SXRlcmF0b3IuPHN0cmluZz59XG4gICAgICovXG4gICAgZ2V0U2hlZXROYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hlZXRzLmtleXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmo4Dpqowgc2hlZXQg5piv5ZCm5bey5a2Y5ZyoXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleGFjdGx5PWZhbHNlXSAtIOaYr+WQpuS9v+eUqOeyvuehruWkp+Wwj+WGmeeahCBuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTaGVldEV4aXN0KG5hbWUsIGV4YWN0bHkpIHtcbiAgICAgICAgaWYgKGV4YWN0bHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoZWV0cy5oYXNFeGFjdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gISF0aGlzLmdldFNoZWV0KG5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5zaGVldHMuaGFzKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOeUn+aIkCBzaGVldCDntKLlvJVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgX2dldEF1dG9TaGVldEluZGV4KCkge1xuICAgICAgICBpZiAoIXRoaXMuJCRhdXRvU2hlZXRJbmRleCkge1xuICAgICAgICAgICAgdGhpcy4kJGF1dG9TaGVldEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKyt0aGlzLiQkYXV0b1NoZWV0SW5kZXg7IC8vIOS7jiAxIOW8gOWni1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiHquWKqOeUn+aIkCBzaGVldCDlkI1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEF1dG9TaGVldE5hbWUoKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGdsb2JhbFNldHRpbmdzLnNoZWV0LmF1dG9QcmVmaXggKyAnJzsgLy8g6Ziy5q2i5Ye6546w5pWw5a2X55u45YqgXG4gICAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgdGhpcy5fZ2V0QXV0b1NoZWV0SW5kZXgoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTaGVldEV4aXN0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXV0b1NoZWV0TmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjea/gOa0u+eahCBzaGVldCDpobVcbiAgICAgKiBAcmV0dXJucyB7U2hlZXR9XG4gICAgICovXG4gICAgZ2V0QWN0aXZlU2hlZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoZWV0cy5nZXQodGhpcy5hY3RpdmVTaGVldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yib5bu65paw55qEIHNoZWV0IOmhtVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29uZmlnXSAtIHNoZWV0IOmhteeahOmFjee9ruS/oeaBr1xuICAgICAqIEByZXR1cm5zIHtTaGVldH0g5paw5Yib5bu655qE5bel5L2c6KGoXG4gICAgICovXG4gICAgY3JlYXRlU2hlZXQoY29uZmlnKSB7XG5cbiAgICAgICAgaWYgKGNvbmZpZykgeyAgLy8g5qC55o2u5Yid5aeL6YWN572u5Yib5bu677yMbmFtZSDkuI3og73kuLrnqbpcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlU2hlZXROYW1lKGNvbmZpZy5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHsgLy8g55So5oi35pON5L2c5Yib5bu677yM5Yqo5oCB55Sf5oiQIG5hbWVcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgY29uZmlnLm5hbWUgPSB0aGlzLl9nZXRBdXRvU2hlZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld09uZSA9IG5ldyBTaGVldCh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLnNoZWV0cy5zZXQoY29uZmlnLm5hbWUsIG5ld09uZSk7XG4gICAgICAgIHJldHVybiBuZXdPbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6ZSA5q+B5oyH5a6aIHNoZWV0IOmhtVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgU2hlZXR9IHNoZWV0IC0gc2hlZXQg5ZCN56ew5oiW5a6e5L6LXG4gICAgICovXG4gICAgZGVzdHJveVNoZWV0KHNoZWV0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2hlZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoc2hlZXQpO1xuICAgICAgICB9XG4gICAgICAgIHNoZWV0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu5nmjIflrprnmoQgc2hlZXQg6aG16YeN5ZG95ZCNXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUxIC0g5b6F6YeN5ZG95ZCN55qEIHNoZWV0IOmhteWQjeWtl1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lMiAtIOaWsOWQjeWtl1xuICAgICAqL1xuICAgIC8vIEZJWE1FIOe8lui+kemUmeS9je+8mlxuICAgIC8vIGhhbmRzb250YWJsZSDlnKjpgInkuK3mn5DljZXlhYPmoLzkvYbmsqHov5vlhaXnvJbovpHml7bvvIzkvJrnm5HlkKwgZG9jdW1lbnQg5LiK55qEIGtleWRvd24g5LqL5Lu277yMXG4gICAgLy8g6YCg5oiQ5L+u5pS5IHNoZWV0IOWQjeaXtueahOaWh+acrOahhuaXoOazleato+ehruWkhOeQhu+8iOS8mui+k+WFpeWIsOihqOagvOS4re+8iVxuICAgIC8vIOaaguaXtuS9v+eUqCBpbnB1dCDnmoQgc2VsZWN0IOS7o+abvyBmb2N1c++8jOi/q+S9v+eUqOaIt+WGjeasoeeCueWHu3NoZWV05ZCN5pe25omN6IO95L+u5pS544CCXG4gICAgcmVuYW1lU2hlZXQobmFtZTEsIG5hbWUyKSB7XG4gICAgICAgIHZhciBzaGVldCA9IHRoaXMuZ2V0U2hlZXQobmFtZTEpO1xuICAgICAgICBpZiAoIXNoZWV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5bel5L2c6KGoIFwiJHtuYW1lMX1cIiDkuI3lrZjlnKhgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZTEgIT09IG5hbWUyKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVNoZWV0TmFtZShuYW1lMiwgdXBwZXJDYXNlKG5hbWUxKSA9PT0gdXBwZXJDYXNlKG5hbWUyKSk7XG4gICAgICAgICAgICBzaGVldC5zaGVldE5hbWUgPSBuYW1lMjtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVNoZWV0ID09PSBuYW1lMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlU2hlZXQgPSBuYW1lMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2V0U2hlZXRzKCkuZGVsZXRlKG5hbWUxKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2hlZXRzKCkuc2V0KG5hbWUyLCBzaGVldCk7XG4gICAgICAgICAgICB0aGlzLiQkdmlldy50YWJSZW5hbWUobmFtZTEsIG5hbWUyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCR2aWV3LnRhYlJlbmFtZUNhbmNlbChuYW1lMSwgbmFtZTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5YWz6Zet5oyH5a6aIHNoZWV0IOmhtVxuICAgICAqL1xuICAgIGNsb3NlU2hlZXQobmFtZSkge1xuICAgICAgICB2YXIgc2hlZXQgPSB0aGlzLmdldFNoZWV0KG5hbWUpO1xuICAgICAgICBpZiAoIXNoZWV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5peg5rOV5YWz6Zet5LiN5a2Y5Zyo55qE5bel5L2c6KGoIFwiJHtuYW1lfVwiIOOAgmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNoZWV0cy5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDml6Dms5XlhbPpl63ku4XmnInnmoTkuIDkuKrlt6XkvZzooaggXCIke25hbWV9XCIg44CCYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoZWV0LmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgb2YgdGhpcy5zaGVldHMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsgJiYgayAhPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVNoZWV0ID0gaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTaGVldChrKS5hY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hlZXRzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgdGhpcy4kJHZpZXcucmVtb3ZlVGFiKG5hbWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lTaGVldChzaGVldCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDmv4DmtLvlvZPliY0gd29ya2Jvb2tcbiAgICAgKi9cbiAgICBhY3RpdmUoKSB7XG4gICAgICAgIHRoaXMuZ2V0QWN0aXZlU2hlZXQoKS5hY3RpdmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmv4DmtLvmjIflrpogc2hlZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lXG4gICAgICovXG4gICAgYWN0aXZlU2hlZXQoc2hlZXROYW1lKSB7XG4gICAgICAgIHZhciBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoc2hlZXROYW1lKTtcbiAgICAgICAgaWYgKHNoZWV0KSB7XG4gICAgICAgICAgICBzaGVldC5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOmqjOivgSBzaGVldCDlkI3mmK/lkKblkIjms5VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhhY3RseVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbGlkYXRlU2hlZXROYW1lKG5hbWUsIGV4YWN0bHkpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcign5bel5L2c6KGo55qE5ZCN56ew5LiN6IO95Li656m6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIOemgeatouS4gOS6m+eJueauiuWtl+esplxuICAgICAgICBpZiAocmVnRXhwLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDlt6XkvZzooaggXCIke25hbWV9XCIg5YyF5ZCr6Z2e5rOV5a2X56ymYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTaGVldEV4aXN0KG5hbWUsIGV4YWN0bHkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5bel5L2c6KGoIFwiJHtuYW1lfVwiIOW3suWtmOWcqGApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldEV4Y2hhbmdlKCkge1xuICAgICAgICB2YXIgc2hlZXRzID0gW107XG4gICAgICAgIGZvciAobGV0IFssc2hlZXRdIG9mIHRoaXMuZ2V0U2hlZXRzKCkudG9NYXAoKSkge1xuICAgICAgICAgICAgc2hlZXQgJiYgc2hlZXRzLnB1c2goc2hlZXQuX2dldEV4Y2hhbmdlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmVTaGVldDogdGhpcy5hY3RpdmVTaGVldCxcbiAgICAgICAgICAgIHNoZWV0czogc2hlZXRzXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV29ya2Jvb2s7IiwiZXhwb3J0IGNvbnN0IEV4Y2hhbmdlID0gU3VwID0+IGNsYXNzIGV4dGVuZHMgU3VwIHtcblxuICAgIF9nZXRFeGNoYW5nZSgpIHtcbiAgICAgICAgdmFyIHtkYXRhLCBjZWxsc30gPSB0aGlzLl9nZXREYXRhTWV0YSgpO1xuICAgICAgICB2YXIge2hlaWdodHMsIHdpZHRoc30gPSB0aGlzLl9nZXRTaXplRXgoKTtcbiAgICAgICAgdmFyIG1lcmdlQ2VsbHMgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRTZXR0aW5ncygpLm1lcmdlQ2VsbHM7XG5cbiAgICAgICAgaWYgKG1lcmdlQ2VsbHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtZXJnZUNlbGxzID0gbnVsbDsgLy8g6YG/5YWN5by657G75Z6L6K+t6KiA6Kej5p6Q5pe25peg5rOV5aSE55CG5Yqo5oCB57G75Z6LXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5nZXROYW1lKCksXG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBkYXRhOiBkYXRhLmxlbmd0aCA/IGRhdGEgOiBbXS5fLFxuICAgICAgICAgICAgcm93SGVpZ2h0czogaGVpZ2h0cyxcbiAgICAgICAgICAgIGNvbFdpZHRoczogd2lkdGhzLFxuICAgICAgICAgICAgbWVyZ2VDZWxsczogbWVyZ2VDZWxscyxcbiAgICAgICAgICAgIGNlbGxNZXRhczogY2VsbHNcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgX2dldFN0eWxlc0V4KG1ldGEpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICB2YXIgYWxpZ25tZW50cyA9IHRoaXMuX2dldEFsaWdubWVudEV4KG1ldGEuY2xhc3NOYW1lKTtcbiAgICAgICAgaWYgKGFsaWdubWVudHMpIHtcbiAgICAgICAgICAgIHJldC5hbGlnbm1lbnRzID0gYWxpZ25tZW50c1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dldEZvbnRFeChtZXRhLCByZXQpO1xuICAgICAgICB0aGlzLl9nZXRCZ0NvbG9yRXgobWV0YSwgcmV0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cblxuICAgIF9nZXRCZ0NvbG9yRXgobWV0YSwgcmV0KSB7XG4gICAgICAgIGlmIChtZXRhLl9zdHlsZV9iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIHJldC5iYWNrZ3JvdW5kQ29sb3IgPSBtZXRhLl9zdHlsZV9iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9nZXRGb250RXgobWV0YSwgcmV0KSB7XG4gICAgICAgIGlmIChtZXRhLl9zdHlsZV9mb250RmFtaWx5KSB7XG4gICAgICAgICAgICByZXQuZm9udEZhbWlseSA9IG1ldGEuX3N0eWxlX2ZvbnRGYW1pbHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuX3N0eWxlX2ZvbnRTaXplKSB7XG4gICAgICAgICAgICByZXQuZm9udFNpemUgPSBtZXRhLl9zdHlsZV9mb250U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5jbGFzc05hbWUgJiYgbWV0YS5jbGFzc05hbWUuY29udGFpbnMoJ3NzZC1mb250LWl0YWxpYycpKSB7XG4gICAgICAgICAgICByZXQuZm9udFN0eWxlID0gJ2l0YWxpYyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuY2xhc3NOYW1lICYmIG1ldGEuY2xhc3NOYW1lLmNvbnRhaW5zKCdzc2QtZm9udC1ib2xkJykpIHtcbiAgICAgICAgICAgIHJldC5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmNsYXNzTmFtZSAmJiBtZXRhLmNsYXNzTmFtZS5jb250YWlucygnc3NkLWZvbnQtdW5kZXJsaW5lJykpIHtcbiAgICAgICAgICAgIHJldC50ZXh0RGVjb3JhdGlvbiA9ICd1bmRlcmxpbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLl9zdHlsZV9jb2xvcikge1xuICAgICAgICAgICAgcmV0LmNvbG9yID0gbWV0YS5fc3R5bGVfY29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9nZXRBbGlnbm1lbnRFeChjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGFsaWdubWVudCA9IFtdO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0TGVmdCcpICYmIGFsaWdubWVudC5wdXNoKCdMZWZ0Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0Q2VudGVyJykgJiYgYWxpZ25tZW50LnB1c2goJ0NlbnRlcicpO1xuICAgICAgICAgICAgY2xhc3NOYW1lLmNvbnRhaW5zKCdodFJpZ2h0JykgJiYgYWxpZ25tZW50LnB1c2goJ1JpZ2h0Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0SnVzdGlmeScpICYmIGFsaWdubWVudC5wdXNoKCdKdXN0aWZ5Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0VG9wJykgJiYgYWxpZ25tZW50LnB1c2goJ1RvcCcpO1xuICAgICAgICAgICAgY2xhc3NOYW1lLmNvbnRhaW5zKCdodE1pZGRsZScpICYmIGFsaWdubWVudC5wdXNoKCdNaWRkbGUnKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZS5jb250YWlucygnaHRCb3R0b20nKSAmJiBhbGlnbm1lbnQucHVzaCgnQm90dG9tJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsaWdubWVudC5sZW5ndGggPyBhbGlnbm1lbnQgOiBmYWxzZTtcbiAgICB9XG5cblxuICAgIF9nZXRTaXplRXgoKSB7XG4gICAgICAgIHZhciBob3QgPSB0aGlzLmhhbmRzb250YWJsZTtcbiAgICAgICAgdmFyIGNvbHMgPSBNYXRoLm1heChob3QuY291bnRDb2xzKCkgLSBob3QuY291bnRFbXB0eUNvbHModHJ1ZSksIDIwKTtcbiAgICAgICAgdmFyIHJvd3MgPSBNYXRoLm1heChob3QuY291bnRSb3dzKCkgLSBob3QuY291bnRFbXB0eVJvd3ModHJ1ZSksIDUwKTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBbXTtcbiAgICAgICAgdmFyIHdpZHRocyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGhvdC5nZXRSb3dIZWlnaHQoaSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiAhaCkgeyAvLyBoYW5kc29udGFibGUgYnVnXG4gICAgICAgICAgICAgICAgaCA9IDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVpZ2h0cy5wdXNoKGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgKytpKSB7XG4gICAgICAgICAgICB3aWR0aHMucHVzaChob3QuZ2V0Q29sV2lkdGgoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7aGVpZ2h0cywgd2lkdGhzfTtcbiAgICB9XG5cblxuICAgIF9nZXREYXRhTWV0YSgpIHtcbiAgICAgICAgdmFyIGhvdCA9IHRoaXMuaGFuZHNvbnRhYmxlO1xuICAgICAgICB2YXIgY29scyA9IGhvdC5jb3VudENvbHMoKSAtIGhvdC5jb3VudEVtcHR5Q29scyh0cnVlKTtcbiAgICAgICAgdmFyIHJvd3MgPSBob3QuY291bnRSb3dzKCkgLSBob3QuY291bnRFbXB0eVJvd3ModHJ1ZSk7XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIHZhciBjZWxscyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBsZXQgcm93UmVzdWx0ID0gW107XG4gICAgICAgICAgICBsZXQgcm93Q2VsbE1ldGEgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgX3NvdXJjZURhdGEgPSBob3QuZ2V0U291cmNlRGF0YUF0Q2VsbChpLCBqKTtcbiAgICAgICAgICAgICAgICBsZXQgX21ldGEgPSBob3QuZ2V0Q2VsbE1ldGEoaSwgaik7XG4gICAgICAgICAgICAgICAgbGV0IF9kYXRhID0gaG90LmdldERhdGFBdENlbGwoaSwgaik7XG4gICAgICAgICAgICAgICAgbGV0IF9jZWxsTWF0YSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLnJvdyA9IGk7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLmNvbCA9IGo7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLmlzRm9ybXVsYSA9ICEhKF9zb3VyY2VEYXRhICYmIChfc291cmNlRGF0YSArICcnKS5jaGFyQXQoMCkgPT09ICc9Jyk7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLnNvdXJjZVZhbHVlID0gX3NvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLnZhbHVlID0gX2RhdGE7XG5cbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKG8sIG0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRMb2NhbFN5bWJvbHMsTG9vcFN0YXRlbWVudFRoYXREb2VzbnRMb29wSlNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCBpbiBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnN0eWxlcyA9IG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KHRoaXMuX2dldFN0eWxlc0V4KF9tZXRhKSwgX2NlbGxNYXRhKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIGRhdGFUeXBlXG4gICAgICAgICAgICAgICAgcm93UmVzdWx0LnB1c2goX3NvdXJjZURhdGEpO1xuICAgICAgICAgICAgICAgIHJvd0NlbGxNZXRhLnB1c2goX2NlbGxNYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEucHVzaChyb3dSZXN1bHQpO1xuICAgICAgICAgICAgY2VsbHMucHVzaChyb3dDZWxsTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtkYXRhLCBjZWxsc307XG4gICAgfVxuXG4gICAgLy8gVE9ET1xuICAgIF9nZXRCb3JkZXJzRXgoKSB7XG5cbiAgICB9XG59OyIsImV4cG9ydCBjb25zdCBTaGVldEhlbHBlciA9IFN1cCA9PiBjbGFzcyBleHRlbmRzIFN1cCB7XG5cbiAgICBfZGVmYXVsdFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0Um93OiBzZWxlY3Rpb24ucm93LFxuICAgICAgICAgICAgZW5kUm93OiBzZWxlY3Rpb24uZW5kUm93IHx8IHNlbGVjdGlvbi5yb3csXG4gICAgICAgICAgICBzdGFydENvbDogc2VsZWN0aW9uLmNvbCxcbiAgICAgICAgICAgIGVuZENvbDogc2VsZWN0aW9uLmVuZENvbCB8fCBzZWxlY3Rpb24uY29sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgX3JlbW92ZUZvcm1lckNsYXNzKGN1cnJlbnQsIC4uLnN1cHBvcnRlZCkge1xuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjbGF6eiBvZiBzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNwbGl0KGNsYXp6KS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC50cmltKCk7XG4gICAgfVxuXG4gICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgX3dhbGtvbkNlbGxNZXRhcyhzZWxlY3Rpb24sIGNhbGxiYWNrLCB1bmhvbGQpIHtcbiAgICAgICAgdmFyIHtzdGFydFJvdywgZW5kUm93LCBzdGFydENvbCwgZW5kQ29sfSA9IHRoaXMuX2RlZmF1bHRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Um93OyBpIDw9IGVuZFJvdzsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gc3RhcnRDb2w7IGogPD0gZW5kQ29sOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgY2VsbE1ldGEgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRDZWxsTWV0YShpLCBqKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld01ldGEgPSBjYWxsYmFjay5jYWxsKHRoaXMsIGksIGosIGNlbGxNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWV0YSAmJiB0aGlzLmhhbmRzb250YWJsZS5zZXRDZWxsTWV0YU9iamVjdChpLCBqLCBuZXdNZXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bmhvbGQgJiYgdGhpcy5oYW5kc29udGFibGUuc2V0Q2VsbE1ldGFPYmplY3QoaSwgaiwgdW5ob2xkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBfd2Fsa29uQ2VsbHMoc2VsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIge3N0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sLCBlbmRDb2x9ID0gdGhpcy5fZGVmYXVsdFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRSb3c7IGkgPD0gZW5kUm93OyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydENvbDsgaiA8PSBlbmRDb2w7ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBjZWxsVEQgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRDZWxsKGksIGosIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsVEQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBpLCBqLCBjZWxsVEQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTsiLCJpbXBvcnQge0Nvb3JkaW5hdGV9IGZyb20gJy4uLy4uL3V0aWxzL2NvbW1vbidcbmltcG9ydCB7YWxpZ25tZW50SXRlbX0gZnJvbSAnLi9Db250ZXh0TWVudV9hbGlnbm1lbnQnXG5cbi8qKlxuICog55S15a2Q6KGo5qC85Y+z6ZSu6I+c5Y2V44CCXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRNZW51KHNwcmVhZFNoZWV0KSB7XG4gICAgdGhpcy5zcHJlYWRTaGVldCA9IHNwcmVhZFNoZWV0O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge01hcH1cbiAgICAgKi9cbiAgICB0aGlzLm1lbnVJdGVtcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9pbml0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRleHRNZW51O1xuXG5Db250ZXh0TWVudS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoa2V5LCBjb25maWcsIGhhbmRsZXIpIHtcbiAgICB0aGlzLm1lbnVJdGVtcy5zZXQoa2V5LCB7XG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIOiOt+WPliBoYW5kc29udGFibGUg6ZyA6KaB55qE6I+c5Y2V6YWN572u6aG5XG4gKi9cbkNvbnRleHRNZW51LnByb3RvdHlwZS5nZXRNZW51SXRlbXM0SG90VGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9ob3RUYWJsZUl0ZW1zKSB7XG4gICAgICAgIHRoaXMuX2hvdFRhYmxlSXRlbXMgPSB7fTtcbiAgICAgICAgdGhpcy5tZW51SXRlbXMuZm9yRWFjaCgoe2NvbmZpZ30sIGtleSkgPT4gdGhpcy5faG90VGFibGVJdGVtc1trZXldID0gY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2hvdFRhYmxlSXRlbXM7XG59O1xuXG5cbi8qXG4gIyMjIGhhbmRzb250YWJsZSDoh6rluKblj7PplK7lip/og73vvJojIyNcbiByb3dfYWJvdmVcbiByb3dfYmVsb3dcbiBoc2VwMVxuIGNvbF9sZWZ0XG4gY29sX3JpZ2h0XG4gaHNlcDJcbiByZW1vdmVfcm93XG4gcmVtb3ZlX2NvbFxuIGhzZXAzXG4gdW5kb1xuIHJlZG9cbiBtYWtlX3JlYWRfb25seVxuIGFsaWdubWVudFxuIGJvcmRlcnNcbiAqL1xuQ29udGV4dE1lbnUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IFNFUCA9ICctLS0tLS0tLS0nO1xuXG5cbiAgICB0aGlzLnJlZ2lzdGVyKCdyb3dfYWJvdmUnLCB7XG4gICAgICAgIG5hbWU6ICfkuIrmlrnmj5LlhaXkuIDooYwnLFxuICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8g6LCD55So6ICF6KaB56Gu5L+d5q2k5aSEIHRoaXMgIOS4uuW9k+WJjSBob3RUYWJsZSDlrp7kvotcbiAgICAgICAgICAgIC8vIFRPRE8g6ZmQ5Yi25pyA5aSn6KGM5pWwXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXIoJ3Jvd19iZWxvdycsIHtcbiAgICAgICAgbmFtZTogJ+S4i+aWueaPkuWFpeS4gOihjCdcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXIoJ2hzZXAxJywgU0VQKTtcblxuICAgIHRoaXMucmVnaXN0ZXIoJ2NvbF9sZWZ0Jywge1xuICAgICAgICBuYW1lOiAn5bem5L6n5o+S5YWl5LiA5YiXJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlcignY29sX3JpZ2h0Jywge1xuICAgICAgICBuYW1lOiAn5Y+z5L6n5o+S5YWl5LiA5YiXJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlcignaHNlcDInLCBTRVApO1xuXG4gICAgLy8gRklYTUUgaGFuZHNvbnRhYmxlIOiHquW4pueahOWIoOmZpOWKn+iDve+8jOWcqOWtmOWcqOWNleWFg+agvOWQiOW5tuaXtuaciUJVR++8jOaUueaIkOiHquWumuS5iemAu+i+keOAglxuICAgIHRoaXMucmVnaXN0ZXIoJ3JlbW92ZV9yb3cnLCB7XG4gICAgICAgIG5hbWU6ICfliKDpmaTpgInkuK3ooYwnLFxuICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETyDpmZDliLbmnIDlsI/ooYzmlbBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoJ3JlbW92ZV9jb2wnLCB7XG4gICAgICAgIG5hbWU6ICfliKDpmaTpgInkuK3liJcnXG4gICAgfSk7XG5cblxuICAgIHRoaXMucmVnaXN0ZXIoJ2hzZXAzJywgU0VQKTtcbiAgICB0aGlzLnJlZ2lzdGVyKCdhbGlnbm1lbnQnLCBhbGlnbm1lbnRJdGVtKCkpO1xuICAgIHRoaXMucmVnaXN0ZXIoJ2hzZXA0JywgU0VQKTtcblxuXG4gICAgdGhpcy5yZWdpc3RlcigncV9tZXJnZV9jZWxscycsIHtcbiAgICAgICAgbmFtZTogJ+WNleWFg+agvOWQiOW5ticsXG4gICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgW3IxLCBjMSwgcjIsIGMyXSA9IHRoaXMuZ2V0U2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIGlmIChyMSA9PT0gcjIgJiYgYzEgPT09IGMyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIW1lcmdlQ29tcGFyZS5jYWxsKHRoaXMsICdpc0VxdWFsJyk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoc2hlZXQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgc2hlZXQubWVyZ2VDZWxscyhcbiAgICAgICAgICAgIHN0YXJ0LnJvdyxcbiAgICAgICAgICAgIHN0YXJ0LmNvbCxcbiAgICAgICAgICAgIGVuZC5yb3cgLSBzdGFydC5yb3cgKyAxLFxuICAgICAgICAgICAgZW5kLmNvbCAtIHN0YXJ0LmNvbCArIDFcbiAgICAgICAgKTtcbiAgICB9KTtcblxuXG4gICAgdGhpcy5yZWdpc3RlcigncV9jYW5jZWxfbWVyZ2VfY2VsbHMnLCB7XG4gICAgICAgIG5hbWU6ICflj5bmtojljZXlhYPmoLzlkIjlubYnLFxuICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlQ29tcGFyZS5jYWxsKHRoaXMsICdpc1N1YnNldCcpO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHNoZWV0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHNoZWV0LnVuTWVyZ2VDZWxscyhcbiAgICAgICAgICAgIHN0YXJ0LnJvdyxcbiAgICAgICAgICAgIHN0YXJ0LmNvbCxcbiAgICAgICAgICAgIGVuZC5yb3cgLSBzdGFydC5yb3cgKyAxLFxuICAgICAgICAgICAgZW5kLmNvbCAtIHN0YXJ0LmNvbCArIDFcbiAgICAgICAgKTtcbiAgICB9KTtcblxufTtcblxuXG4vLyBwcml2YXRlXG5mdW5jdGlvbiBtZXJnZUNvbXBhcmUodHlwZSkge1xuICAgIHZhciBtZXJnZWQgPSB0aGlzLmdldFNldHRpbmdzKCkubWVyZ2VDZWxscztcbiAgICBpZiAobWVyZ2VkICYmIG1lcmdlZC5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXJnZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCB7cm93LCBjb2wsIHJvd3NwYW4sIGNvbHNwYW59ID0gbWVyZ2VkW2ldO1xuICAgICAgICAgICAgaWYgKENvb3JkaW5hdGVbdHlwZV0oXG4gICAgICAgICAgICAgICAgICAgIFtyb3csIGNvbCwgcm93ICsgcm93c3BhbiAtIDEsIGNvbCArIGNvbHNwYW4gLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTZWxlY3RlZCgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0iLCIvLyBUT0RPIOWvuem9kOaTjeS9nOWBmuaIkCBBUEkg5pa55rOV44CCXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25tZW50SXRlbSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAn5a+56b2QJyxcbiAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGVkUmFuZ2UoKSAmJiAhdGhpcy5zZWxlY3Rpb24uc2VsZWN0ZWRIZWFkZXIuY29ybmVyID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBzdWJtZW51OiB7XG4gICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnYWxpZ25tZW50OmxlZnQnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0TGVmdCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNDbGFzcyA/IG1hcmtMYWJlbEFzU2VsZWN0ZWQoJ+W3puWvuem9kCcpIDogJ+W3puWvuem9kCc7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGVkUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gJ2hvcml6b250YWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFsaWdubWVudCA9ICdodExlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ2VsbEFsaWdubWVudCcsIHN0YXRlQmVmb3JlLCByYW5nZSwgdHlwZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduKHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2FsaWdubWVudDpjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0Q2VudGVyJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc0NsYXNzID8gbWFya0xhYmVsQXNTZWxlY3RlZCgn5rC05bmz5bGF5LitJykgOiAn5rC05bmz5bGF5LitJztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXRlQmVmb3JlID0gZ2V0QWxpZ25tZW50Q2xhc3NlcyhyYW5nZSwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0Q2VudGVyJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ2VsbEFsaWdubWVudCcsIHN0YXRlQmVmb3JlLCByYW5nZSwgdHlwZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduKHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogYGFsaWdubWVudDpyaWdodGAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9ICflj7Plr7npvZAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0NsYXNzID0gY2hlY2tTZWxlY3Rpb25Db25zaXN0ZW5jeSh0aGlzLmdldFNlbGVjdGVkUmFuZ2UoKSwgKHJvdywgY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0UmlnaHQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbWFya0xhYmVsQXNTZWxlY3RlZChsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXRlQmVmb3JlID0gZ2V0QWxpZ25tZW50Q2xhc3NlcyhyYW5nZSwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0UmlnaHQnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDZWxsQWxpZ25tZW50Jywgc3RhdGVCZWZvcmUsIHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24ocmFuZ2UsIHR5cGUsIGFsaWdubWVudCwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBgYWxpZ25tZW50Omp1c3RpZnlgLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSAn5Lik56uv5a+56b2QJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoYXNDbGFzcyA9IGNoZWNrU2VsZWN0aW9uQ29uc2lzdGVuY3kodGhpcy5nZXRTZWxlY3RlZFJhbmdlKCksIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZS5pbmRleE9mKCdodEp1c3RpZnknKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbWFya0xhYmVsQXNTZWxlY3RlZChsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXRlQmVmb3JlID0gZ2V0QWxpZ25tZW50Q2xhc3NlcyhyYW5nZSwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0SnVzdGlmeSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVuSG9va3MoJ2JlZm9yZUNlbGxBbGlnbm1lbnQnLCBzdGF0ZUJlZm9yZSwgcmFuZ2UsIHR5cGUsIGFsaWdubWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnLS0tLS0tLS0tJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGBhbGlnbm1lbnQ6dG9wYCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gJ+mhtumDqOWvuem9kCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0VG9wJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IG1hcmtMYWJlbEFzU2VsZWN0ZWQobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdGVCZWZvcmUgPSBnZXRBbGlnbm1lbnRDbGFzc2VzKHJhbmdlLCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0VG9wJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ2VsbEFsaWdubWVudCcsIHN0YXRlQmVmb3JlLCByYW5nZSwgdHlwZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduKHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogYGFsaWdubWVudDptaWRkbGVgLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSAn5Z6C55u05bGF5LitJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoYXNDbGFzcyA9IGNoZWNrU2VsZWN0aW9uQ29uc2lzdGVuY3kodGhpcy5nZXRTZWxlY3RlZFJhbmdlKCksIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZS5pbmRleE9mKCdodE1pZGRsZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBtYXJrTGFiZWxBc1NlbGVjdGVkKGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdGVCZWZvcmUgPSBnZXRBbGlnbm1lbnRDbGFzc2VzKHJhbmdlLCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0TWlkZGxlJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ2VsbEFsaWdubWVudCcsIHN0YXRlQmVmb3JlLCByYW5nZSwgdHlwZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduKHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogYGFsaWdubWVudDpib3R0b21gLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSAn5bqV6YOo5a+56b2QJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoYXNDbGFzcyA9IGNoZWNrU2VsZWN0aW9uQ29uc2lzdGVuY3kodGhpcy5nZXRTZWxlY3RlZFJhbmdlKCksIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZS5pbmRleE9mKCdodEJvdHRvbScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBtYXJrTGFiZWxBc1NlbGVjdGVkKGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdGVCZWZvcmUgPSBnZXRBbGlnbm1lbnRDbGFzc2VzKHJhbmdlLCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0Qm90dG9tJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ2VsbEFsaWdubWVudCcsIHN0YXRlQmVmb3JlLCByYW5nZSwgdHlwZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduKHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHJhbmdlLCBjb21wYXJhdG9yKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgICByYW5nZS5mb3JBbGwoZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihyb3csIGNvbCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtMYWJlbEFzU2VsZWN0ZWQobGFiZWwpIHtcbiAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwic2VsZWN0ZWRcIj4nICsgU3RyaW5nLmZyb21DaGFyQ29kZSgxMDAwMykgKyAnPC9zcGFuPicgKyBsYWJlbDtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50Q2xhc3NlcyhyYW5nZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjbGFzc2VzID0ge307XG4gICAgZm9yIChsZXQgcm93ID0gcmFuZ2UuZnJvbS5yb3c7IHJvdyA8PSByYW5nZS50by5yb3c7IHJvdysrKSB7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IHJhbmdlLmZyb20uY29sOyBjb2wgPD0gcmFuZ2UudG8uY29sOyBjb2wrKykge1xuICAgICAgICAgICAgaWYgKCFjbGFzc2VzW3Jvd10pIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzW3Jvd10gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzZXNbcm93XVtjb2xdID0gY2FsbGJhY2socm93LCBjb2wpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGFzc2VzO1xufVxuXG5mdW5jdGlvbiBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCBjZWxsRGVzY3JpcHRvcikge1xuICAgIGlmIChyYW5nZS5mcm9tLnJvdyA9PSByYW5nZS50by5yb3cgJiYgcmFuZ2UuZnJvbS5jb2wgPT0gcmFuZ2UudG8uY29sKSB7XG4gICAgICAgIGFwcGx5QWxpZ25DbGFzc05hbWUocmFuZ2UuZnJvbS5yb3csIHJhbmdlLmZyb20uY29sLCB0eXBlLCBhbGlnbm1lbnQsIGNlbGxEZXNjcmlwdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCByb3cgPSByYW5nZS5mcm9tLnJvdzsgcm93IDw9IHJhbmdlLnRvLnJvdzsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHJhbmdlLmZyb20uY29sOyBjb2wgPD0gcmFuZ2UudG8uY29sOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGFwcGx5QWxpZ25DbGFzc05hbWUocm93LCBjb2wsIHR5cGUsIGFsaWdubWVudCwgY2VsbERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUFsaWduQ2xhc3NOYW1lKHJvdywgY29sLCB0eXBlLCBhbGlnbm1lbnQsIGNlbGxEZXNjcmlwdG9yKSB7XG4gICAgbGV0IGNlbGxNZXRhID0gY2VsbERlc2NyaXB0b3Iocm93LCBjb2wpO1xuICAgIGxldCBjbGFzc05hbWUgPSBhbGlnbm1lbnQ7XG5cbiAgICBpZiAoY2VsbE1ldGEuY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcmVwYXJlVmVydGljYWxBbGlnbkNsYXNzKGNlbGxNZXRhLmNsYXNzTmFtZSwgYWxpZ25tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZXBhcmVIb3Jpem9udGFsQWxpZ25DbGFzcyhjZWxsTWV0YS5jbGFzc05hbWUsIGFsaWdubWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2VsbE1ldGEuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xufVxuXG5cbmZ1bmN0aW9uIHByZXBhcmVWZXJ0aWNhbEFsaWduQ2xhc3MoY2xhc3NOYW1lLCBhbGlnbm1lbnQpIHtcbiAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoYWxpZ25tZW50KSAhPSAtMSkge1xuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH1cbiAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVcbiAgICAgICAgLnJlcGxhY2UoJ2h0VG9wJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCdodE1pZGRsZScsICcnKVxuICAgICAgICAucmVwbGFjZSgnaHRCb3R0b20nLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJyAgJywgJycpO1xuXG4gICAgY2xhc3NOYW1lICs9ICcgJyArIGFsaWdubWVudDtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlSG9yaXpvbnRhbEFsaWduQ2xhc3MoY2xhc3NOYW1lLCBhbGlnbm1lbnQpIHtcbiAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoYWxpZ25tZW50KSAhPSAtMSkge1xuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH1cbiAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVcbiAgICAgICAgLnJlcGxhY2UoJ2h0TGVmdCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnaHRDZW50ZXInLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ2h0UmlnaHQnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ2h0SnVzdGlmeScsICcnKVxuICAgICAgICAucmVwbGFjZSgnICAnLCAnJyk7XG5cbiAgICBjbGFzc05hbWUgKz0gJyAnICsgYWxpZ25tZW50O1xuXG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn0iLCJpbXBvcnQge1xuICAgIGlubmVySFRNTCwgaW5zZXJ0QWZ0ZXIsXG4gICAgY2xvc2VzdCwgZW1wdHksXG4gICAgb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcbn0gZnJvbSAnLi4vLi4vdXRpbHMvZG9tSGVscGVyLmpzJztcbmltcG9ydCB7aXNFbXB0eVZhbHVlLCB1cHBlckNhc2V9IGZyb20gJy4uLy4uL3V0aWxzL2NvbW1vbi5qcyc7XG5pbXBvcnQge0Nhc2VJbnNlbnNpdGl2ZU1hcH0gZnJvbSAnLi4vLi4vdXRpbHMvZGF0YVN0cnVjdHVyZS5qcyc7XG5pbXBvcnQge3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbn0gZnJvbSAnLi4vLi4vdXRpbHMvZXZlbnRIZWxwZXIuanMnO1xuaW1wb3J0IHtnbG9iYWxTZXR0aW5nc30gZnJvbSAnLi4vLi4vc2V0dGluZ3MuanMnO1xuaW1wb3J0IHtXQVJOU30gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQge1NoZWV0RXJyb3J9IGZyb20gJy4uLy4vU2hlZXRFcnJvcidcblxuY29uc3QgQ0xBU1NfQ1VSUkVOVCA9ICdjdXJyZW50JztcbmNvbnN0IENMQVNTX1RBQlMgPSAnc3NkLXRhYnMnO1xuY29uc3QgQ0xBU1NfQ09OVEVOVCA9ICdzc2QtdGFicy1jb250ZW50JztcbmNvbnN0IENMQVNTX1NFQ1RJT04gPSAnc3NkLXRhYnMtc2VjdGlvbic7XG5jb25zdCBDTEFTU19OQVYgPSAnc3NkLXRhYnMtbmF2JztcbmNvbnN0IENMQVNTX1VMID0gJ3NzZC10YWJzLXVsJztcbmNvbnN0IENMQVNTX0xJID0gJ3NzZC10YWJzLWxpJztcbmNvbnN0IENMQVNTX0ZYID0gJ3NzZC10YWJzLWZ4JztcblxuY29uc3QgYW5pbWF0ZWQgPSBnbG9iYWxTZXR0aW5ncy5zaGVldC5hbmltYXRlZDtcbmNvbnN0IHJlZ0V4cCA9IGdsb2JhbFNldHRpbmdzLnNoZWV0LnNoZWV0TmFtZTtcblxuLyoqXG4gKiB3b3JrYm9vayDlr7nlupTnmoTop4blm77vvIzlrp7pmYXnmoQgRE9NIOaehOaIkOOAglxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7V29ya2Jvb2t9IHdvcmtib29rXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVGFicyh3b3JrYm9vaykge1xuICAgIHRoaXMud29ya2Jvb2sgPSB3b3JrYm9vaztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q2FzZUluc2Vuc2l0aXZlTWFwfVxuICAgICAqL1xuICAgIHRoaXMubGlJdGVtcyA9IG5ldyBDYXNlSW5zZW5zaXRpdmVNYXAoKTtcbiAgICB0aGlzLnNlY3Rpb25JdGVtcyA9IG5ldyBDYXNlSW5zZW5zaXRpdmVNYXAoKTtcbiAgICB0aGlzLl9ob3RUYWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yb290RWxlbWVudCA9IHdvcmtib29rLnNwcmVhZFNoZWV0LmdldFJvb3RFbGVtZW50KCk7XG4gICAgdGhpcy5kaXNwbGF5TW9kZSA9IHdvcmtib29rLnNwcmVhZFNoZWV0LmdldERpc3BsYXlNb2RlKCk7XG5cbiAgICB0aGlzLmluaXRET00oKTtcbiAgICB0aGlzLmluaXRCb3goKTtcbiAgICB0aGlzLnJlbmRlcigpO1xufVxuXG5UYWJzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLlRBQlMpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5UYWJzLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuVEFCUyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuQ09OVEVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuTkFWID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmF2Jyk7XG4gICAgdGhpcy5VTCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG5cbiAgICB0aGlzLlRBQlMuY2xhc3NMaXN0LmFkZChDTEFTU19UQUJTKTtcbiAgICB0aGlzLlRBQlMuaWQgPSB0aGlzLndvcmtib29rLmdldElkKCk7XG4gICAgdGhpcy5DT05URU5ULmNsYXNzTGlzdC5hZGQoQ0xBU1NfQ09OVEVOVCk7XG4gICAgdGhpcy5OQVYuY2xhc3NMaXN0LmFkZChDTEFTU19OQVYpO1xuICAgIHRoaXMuVUwuY2xhc3NMaXN0LmFkZChDTEFTU19VTCk7XG5cbiAgICB0aGlzLlRBQlMuYXBwZW5kQ2hpbGQodGhpcy5DT05URU5UKTtcbiAgICB0aGlzLlRBQlMuYXBwZW5kQ2hpbGQodGhpcy5OQVYpO1xuICAgIHRoaXMuTkFWLmFwcGVuZENoaWxkKHRoaXMuVUwpO1xuXG4gICAgLy8g5aKe5YqgIHNoZWV0IOmhteeahCBidXR0b25cbiAgICB0aGlzLmFwcGVuZEFkZEJ1dHRvbigpO1xuXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblRhYnMucHJvdG90eXBlLmluaXRCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvb3RFbCA9IHRoaXMud29ya2Jvb2suc3ByZWFkU2hlZXQuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICB0aGlzLndpZHRoID0gdGhpcy53b3JrYm9vay53aWR0aCB8fCBvdXRlcldpZHRoKHJvb3RFbCwgZmFsc2UpO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy53b3JrYm9vay5oZWlnaHQgfHwgb3V0ZXJIZWlnaHQocm9vdEVsLCBmYWxzZSk7XG5cbiAgICB0aGlzLlRBQlMuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICB0aGlzLlRBQlMuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xufTtcblxuXG4vKipcbiAqIOWinuWKoOS4gOS4qiB0YWIg6aG1XG4gKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lIC0gc2hlZXQg5ZCN77yMIOWNsyB0YWIg6aG155qE5qCH6aKYXG4gKi9cblRhYnMucHJvdG90eXBlLmFwcGVuZFRhYiA9IGZ1bmN0aW9uIChzaGVldE5hbWUpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICB2YXIgY2xhenogPSB0aGlzLmRpc3BsYXlNb2RlID8gJycgOiAnY2xvc2UgaGFpcmxpbmUnO1xuXG4gICAgbGkuaW5uZXJIVE1MID0gYFxuICAgICAgICA8YSBocmVmPVwiamF2YXNjcmlwdDo7XCI+XG4gICAgICAgICAgICA8c3Bhbj4ke3NoZWV0TmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Y2xhenp9XCI+PC9zcGFuPlxuICAgICAgICA8L2E+XG4gICAgYDtcbiAgICBsaS5jbGFzc0xpc3QuYWRkKENMQVNTX0xJKTtcbiAgICBsaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2hlZXQnLCBzaGVldE5hbWUpO1xuXG5cbiAgICB2YXIgYWN0aXZlVGFiID0gdGhpcy5UQUJTLnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX0NVUlJFTlR9LiR7Q0xBU1NfTEl9YCk7XG4gICAgaWYgKGFjdGl2ZVRhYikge1xuICAgICAgICBpbnNlcnRBZnRlcihhY3RpdmVUYWIsIGxpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLlVMLmFwcGVuZENoaWxkKGxpKTtcbiAgICB9XG4gICAgdGhpcy5saUl0ZW1zLnNldChzaGVldE5hbWUsIGxpKTtcblxuICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHNoZWV0TmFtZSA9IHRoaXMuZGF0YXNldC5zaGVldDtcbiAgICAgICAgdmFyIHNoZWV0ID0gdGhhdC53b3JrYm9vay5nZXRTaGVldChzaGVldE5hbWUpO1xuICAgICAgICBzaGVldC5hY3RpdmUoKTtcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmRpc3BsYXlNb2RlKSB7XG4gICAgICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoYXQuX29uVGFiRGJsY2xpY2suY2FsbCh0aGF0LCB0aGlzKTtcbiAgICAgICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGkucXVlcnlTZWxlY3RvcignLmNsb3NlJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHNoZWV0TmFtZSA9IGxpLmRhdGFzZXQuc2hlZXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoYXQud29ya2Jvb2suY2xvc2VTaGVldChzaGVldE5hbWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU2hlZXRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGVuZENvbnRlbnQoc2hlZXROYW1lKTtcbn07XG5cblxuLyoqXG4gKiDlop7liqDkuIDkuKogdGFiIOmhtVxuICogQHBhcmFtIHtzdHJpbmd9IHNoZWV0TmFtZSAtIHNoZWV0IOWQje+8jCDljbMgdGFiIOmhteeahOagh+mimFxuICovXG5UYWJzLnByb3RvdHlwZS5yZW1vdmVUYWIgPSBmdW5jdGlvbiAoc2hlZXROYW1lKSB7XG4gICAgdmFyIGxpID0gdGhpcy5saUl0ZW1zLmdldChzaGVldE5hbWUpO1xuICAgIHRoaXMuVUwucmVtb3ZlQ2hpbGQobGkpO1xuICAgIHRoaXMubGlJdGVtcy5kZWxldGUoc2hlZXROYW1lKTtcblxuICAgIHRoaXMucmVtb3ZlQ29udGVudChzaGVldE5hbWUpO1xufTtcblxuVGFicy5wcm90b3R5cGUuYXBwZW5kQWRkQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIHZhciBpbm5lckh0bWwgPSB0aGlzLmRpc3BsYXlNb2RlID8gJyZuYnNwOycgOiAnKyc7XG5cbiAgICBsaS5pbm5lckhUTUwgPSBgPGEgaHJlZj1cImphdmFzY3JpcHQ6O1wiPjxzcGFuPiR7aW5uZXJIdG1sfTwvc3Bhbj48L2E+YDtcbiAgICBsaS5jbGFzc0xpc3QuYWRkKENMQVNTX0xJKTtcbiAgICBpZiAoIXRoaXMuZGlzcGxheU1vZGUpIHtcbiAgICAgICAgbGkuY2xhc3NMaXN0LmFkZCgnYWRkLXRhYicpO1xuICAgIH1cbiAgICB0aGlzLlVMLmFwcGVuZENoaWxkKGxpKTtcblxuICAgIGlmICghdGhpcy5kaXNwbGF5TW9kZSkge1xuICAgICAgICBsaS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NoZWV0ID0gdGhhdC53b3JrYm9vay5jcmVhdGVTaGVldCgpO1xuICAgICAgICAgICAgICAgIG5ld1NoZWV0LmFjdGl2ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU2hlZXRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxpXG4gKiBAcHJpdmF0ZVxuICovXG5UYWJzLnByb3RvdHlwZS5fb25UYWJEYmxjbGljayA9IGZ1bmN0aW9uIChsaSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgc2hlZXROYW1lID0gbGkuZGF0YXNldC5zaGVldDtcbiAgICB2YXIgc3BhbiA9IGxpLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzcGFuJylbMF07XG4gICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcblxuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgaW5wdXQudmFsdWUgPSBzaGVldE5hbWU7XG4gICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnZWRpdG9yaWFsJyk7XG4gICAgaW5wdXQuc3R5bGUud2lkdGggPSBvdXRlcldpZHRoKHNwYW4pICsgMjAgKyAncHgnOyAvLyDlkI3lrZflpKrnn63ml7bkuI3lpb3ovpPlhaXvvIzlop7ooaUyMHB4XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hlY2sgPSB0aGF0Ll9jaGVja1RhYk5hbWUoc2hlZXROYW1lLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgaWYgKGNoZWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGF0Lndvcmtib29rLnJlbmFtZVNoZWV0KHNoZWV0TmFtZSwgdGhpcy52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydChjaGVjayk7IC8vIFRPRE8gYWxlcnQg5aSq5LiRXG4gICAgICAgICAgICB0aGF0LnRhYlJlbmFtZUNhbmNlbChzaGVldE5hbWUsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZW1wdHkoc3Bhbik7XG4gICAgc3Bhbi5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgaW5wdXQuc2VsZWN0KCk7XG59O1xuXG5UYWJzLnByb3RvdHlwZS5fY2hlY2tUYWJOYW1lID0gZnVuY3Rpb24gKG5hbWUxLCBuYW1lMikge1xuICAgIGlmIChpc0VtcHR5VmFsdWUobmFtZTIpKSB7XG4gICAgICAgIHJldHVybiBXQVJOUy5TMTtcbiAgICB9XG4gICAgaWYgKHJlZ0V4cC50ZXN0KG5hbWUyKSkge1xuICAgICAgICByZXR1cm4gV0FSTlMuUzI7XG4gICAgfVxuICAgIC8vIOaUueaIkOWFtuWug+W3suacieeahHNoZWV05ZCNXG4gICAgaWYgKHVwcGVyQ2FzZShuYW1lMSkgIT09IHVwcGVyQ2FzZShuYW1lMikgJiYgdGhpcy53b3JrYm9vay5pc1NoZWV0RXhpc3QobmFtZTIpKSB7XG4gICAgICAgIHJldHVybiBXQVJOUy5TMztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyDmlLnlkI3ml7bvvIxET03kuIrnmoTkuIDkupvmk43kvZzvvIzov5vlhaXmraTmlrnms5Xml7bku6Pooajlt7Lnu4/lgZrkuoblkIjms5Xpqozor4HjgIJcblRhYnMucHJvdG90eXBlLnRhYlJlbmFtZSA9IGZ1bmN0aW9uIChuYW1lMSwgbmFtZTIpIHtcbiAgICB2YXIgbGkgPSB0aGlzLmxpSXRlbXMuZ2V0KG5hbWUxKTtcbiAgICB2YXIgc3BhbiA9IGxpLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzcGFuJylbMF07XG4gICAgaW5uZXJIVE1MKHNwYW4sIG5hbWUyKTtcbiAgICBsaS5kYXRhc2V0LnNoZWV0ID0gbmFtZTI7XG4gICAgdGhpcy5saUl0ZW1zLnNldChuYW1lMiwgbGkpO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5zZWN0aW9uSXRlbXMuZ2V0KG5hbWUxKTtcbiAgICBzZWN0aW9uLmRhdGFzZXQuc2hlZXQgPSBuYW1lMjtcbiAgICB0aGlzLnNlY3Rpb25JdGVtcy5kZWxldGUobmFtZTEpO1xuICAgIHRoaXMuc2VjdGlvbkl0ZW1zLnNldChuYW1lMiwgc2VjdGlvbik7XG5cbiAgICB2YXIgc2hlZXROb3cgPSB0aGlzLndvcmtib29rLmdldFNoZWV0KG5hbWUyKTtcbiAgICBzaGVldE5vdy5lbWl0KCdhZnRlclJlbmFtZScsIHNoZWV0Tm93LCBuYW1lMSwgbmFtZTIpO1xufTtcblxuLy8g5pu05ZCN5aSx6LSl77yM5bCG5ZCN5a2X6K6+5Li6IG5hbWUxLCBuYW1lMuS4uuWksei0peeahOWQjeWtl1xuVGFicy5wcm90b3R5cGUudGFiUmVuYW1lQ2FuY2VsID0gZnVuY3Rpb24gKG5hbWUxLCBuYW1lMikge1xuICAgIHZhciBsaSA9IHRoaXMubGlJdGVtcy5nZXQobmFtZTEpO1xuICAgIHZhciBzcGFuID0gbGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NwYW4nKVswXTtcbiAgICBpbm5lckhUTUwoc3BhbiwgbmFtZTEpO1xuXG4gICAgdmFyIHNoZWV0Tm93ID0gdGhpcy53b3JrYm9vay5nZXRTaGVldChuYW1lMSk7XG4gICAgc2hlZXROb3cuZW1pdCgnYWZ0ZXJSZW5hbWVDYW5jZWwnLCBzaGVldE5vdywgbmFtZTEsIG5hbWUyKTtcbn07XG5cblxuLyoqXG4gKiDlop7liqDmoIfnrb7pobXlr7nlupTnmoTlhoXlrrlcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGVldE5hbWVcbiAqL1xuVGFicy5wcm90b3R5cGUuYXBwZW5kQ29udGVudCA9IGZ1bmN0aW9uIChzaGVldE5hbWUpIHtcbiAgICB2YXIgc2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICB2YXIgZnggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgaG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBzZWN0aW9uLnNldEF0dHJpYnV0ZSgnZGF0YS1zaGVldCcsIHNoZWV0TmFtZSk7XG4gICAgc2VjdGlvbi5hcHBlbmRDaGlsZChmeCk7XG4gICAgc2VjdGlvbi5hcHBlbmRDaGlsZChob3QpO1xuICAgIHNlY3Rpb24uY2xhc3NMaXN0LmFkZChDTEFTU19TRUNUSU9OKTtcbiAgICBhbmltYXRlZCAmJiBzZWN0aW9uLmNsYXNzTGlzdC5hZGQoJ3NzZC1hbmltYXRlZC1mYXN0Jyk7XG5cbiAgICB0aGlzLkNPTlRFTlQuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XG4gICAgdGhpcy5zZWN0aW9uSXRlbXMuc2V0KHNoZWV0TmFtZSwgc2VjdGlvbik7XG5cbiAgICB0aGlzLmFwcGVuZEZ4KGZ4LCBzaGVldE5hbWUpO1xuICAgIHRoaXMuYXBwZW5kVGFibGUoaG90LCBzaGVldE5hbWUpO1xufTtcblxuXG5UYWJzLnByb3RvdHlwZS5yZW1vdmVDb250ZW50ID0gZnVuY3Rpb24gKHNoZWV0TmFtZSkge1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5zZWN0aW9uSXRlbXMuZ2V0KHNoZWV0TmFtZSk7XG4gICAgdGhpcy5DT05URU5ULnJlbW92ZUNoaWxkKHNlY3Rpb24pO1xuICAgIHRoaXMuc2VjdGlvbkl0ZW1zLmRlbGV0ZShzaGVldE5hbWUpO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNoZWV0TmFtZVxuICovXG5UYWJzLnByb3RvdHlwZS5oaWRlQ29udGVudCA9IGZ1bmN0aW9uIChzaGVldE5hbWUpIHtcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbkl0ZW1zLmdldChzaGVldE5hbWUpO1xuICAgIHNlY3Rpb24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbn07XG5cblxuLyoqXG4gKiBUT0RPIOWFrOW8j+i+k+WFpeahhlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZ4XG4gKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lXG4gKi9cblRhYnMucHJvdG90eXBlLmFwcGVuZEZ4ID0gZnVuY3Rpb24gKGZ4LCBzaGVldE5hbWUpIHtcbiAgICBmeC5jbGFzc0xpc3QuYWRkKENMQVNTX0ZYKTtcbiAgICBmeC5jbGFzc0xpc3QuYWRkKGAke0NMQVNTX0ZYfS0ke3NoZWV0TmFtZX1gKTtcbn07XG5cbi8qKlxuICog5YGH5riy5p+TIEhhbnNvbnRhYmxlIOe7hOS7tuOAglxuICogaGFuZHNvbnRhYmxlIOeahOiuvuiuoeaXoOazleWcqERPTeS4reiuoeeul+inhuWbvu+8jOW/hemhu+a4suafk3Jvb3RFbGVtZW505LmL5ZCO5omN6IO955Sf5pWI44CCXG4gKiDlr7zoh7Tlu7bov5/muLLmn5Ppmr7ku6Xlrp7njrDvvIzmnInmuLLmn5PmgKfog73pl67popjml7blho3op6PlhrPjgIJcbiAqIOWPpuWklu+8jOa4suafk+WIsOWFiOmakOiXj+WQjuaYvuekuueahOWFg+e0oOS4reaXtu+8jOS5n+aXoOazleato+W4uOaYvuekuuOAglxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBob3RcbiAqIEBwYXJhbSBzaGVldE5hbWVcbiAqL1xuVGFicy5wcm90b3R5cGUuYXBwZW5kVGFibGUgPSBmdW5jdGlvbiAoaG90LCBzaGVldE5hbWUpIHtcbiAgICB0aGlzLl9ob3RUYWJsZXMuc2V0KHNoZWV0TmFtZSwge1xuICAgICAgICBjb250YWluZXI6IGhvdCxcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogKCkgPT4gdGhpcy5oZWlnaHQgLSBvdXRlckhlaWdodCh0aGlzLk5BVilcbiAgICB9KTtcbn07XG5cbi8qKlxuICog5r+A5rS75oyH5a6a55qE5qCH562+6aG1XG4gKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lIC0gc2hlZXQg5ZCNXG4gKi9cblRhYnMucHJvdG90eXBlLmFjdGl2ZVRhYiA9IGZ1bmN0aW9uIChzaGVldE5hbWUpIHtcbiAgICB2YXIgZm9ybWVyID0gdGhpcy5UQUJTLnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX0NVUlJFTlR9LiR7Q0xBU1NfTEl9YCk7XG4gICAgZm9ybWVyICYmIGZvcm1lci5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX0NVUlJFTlQpO1xuICAgIHZhciBsaSA9IHRoaXMubGlJdGVtcy5nZXQoc2hlZXROYW1lKTtcbiAgICBsaS5jbGFzc0xpc3QuYWRkKENMQVNTX0NVUlJFTlQpO1xuICAgIHRoaXMuYWN0aXZlQ29udGVudChzaGVldE5hbWUpO1xufTtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lIC0gc2hlZXQg5ZCNXG4gKi9cblRhYnMucHJvdG90eXBlLmFjdGl2ZUNvbnRlbnQgPSBmdW5jdGlvbiAoc2hlZXROYW1lKSB7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25JdGVtcy5nZXQoc2hlZXROYW1lKTtcbiAgICB2YXIgZm9ybWVyID0gdGhpcy5fZm9ybWVyQWN0aXZlQ29udGVudDtcbiAgICBpZiAoZm9ybWVyKSB7XG4gICAgICAgIGFuaW1hdGVkICYmIGZvcm1lci5jbGFzc0xpc3QucmVtb3ZlKCdmYWRlSW4nKTtcbiAgICAgICAgZm9ybWVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIHNlY3Rpb24uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgYW5pbWF0ZWQgJiYgc2VjdGlvbi5jbGFzc0xpc3QuYWRkKCdmYWRlSW4nKTtcblxuICAgIHRoaXMuX2Zvcm1lckFjdGl2ZUNvbnRlbnQgPSBzZWN0aW9uO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBUYWJzOyIsIlxuXG5leHBvcnQgY29uc3QgV0FSTlMgPSB7XG5cbiAgICBTMTogYOW3peS9nOihqOWQjeS4jeiDveS4uuepuueZveOAgmAsXG4gICAgUzI6IGDlt6XkvZzooajlkI3np7DljIXlkKvml6DmlYjlrZfnrKY6IDogXFwgLyA/ICogWyBd44CCYCxcbiAgICBTMzogYOivpeWQjeensOW3suiiq+S9v+eUqO+8jOivt+WwneivleWFtuS7luWQjeensOOAgmBcblxufTsiLCJpbXBvcnQge1BsdWdpbkVycm9yfSBmcm9tICcuL1BsdWdpbkVycm9yJ1xuXG52YXIgX3BsdWdpbnMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICog5o+S5Lu25Z+657G7XG4gKi9cbmNsYXNzIFBsdWdpbiB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3ByZWFkU2hlZXR9IHNwcmVhZFNoZWV0XG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3ByZWFkU2hlZXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTcHJlYWRTaGVldH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ByZWFkc2hlZXQgPSBzcHJlYWRTaGVldDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8g5pqC5pe25LiN6ICD6JmR5byA5pS+6L+Z5Liq5pa55rOV77yM55So5oi35a6a5LmJ55qE5o+S5Lu25LiN6IO95omp5bGVIFNwcmVhZFNoZWV0IOeahCBBUElcbiAgICBfcmVnaXN0ZXJNZXRob2QobmFtZSkge1xuICAgICAgICB2YXIgcHJvdG8gPSB0aGlzLnNwcmVhZHNoZWV0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSAoKSA9PiB0aGlzW25hbWVdKCk7XG4gICAgfVxuXG4gICAgaXNFbmFibGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlbmFibGUoKSB7XG5cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuXG4gICAgfVxuXG59XG5cbmV4cG9ydCB7UGx1Z2lufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQbHVnaW4ocCkge1xuICAgIGlmICghcC5lbmFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBsdWdpbkVycm9yKCfmj5Lku7blv4XpobvljIXlkKvlkK/nlKjmlrnms5XvvJplbmFibGUnKTtcbiAgICB9XG4gICAgaWYgKCFwLmRlc3Ryb3kpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBsdWdpbkVycm9yKCfmj5Lku7blv4XpobvljIXlkKvplIDmr4Hmlrnms5XvvJpkZXN0cm95Jyk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4obmFtZSwgcGx1Z2luKSB7XG4gICAgX3BsdWdpbnMuc2V0KG5hbWUsIHBsdWdpbik7XG4gICAgcGx1Z2luLnByb3RvdHlwZS5fX25hbWVfXyA9IG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbHVnaW4obmFtZSkge1xuICAgIHZhciBwID0gX3BsdWdpbnMuZ2V0KG5hbWUpO1xuICAgIGlmICghcCkge1xuICAgICAgICB0aHJvdyBuZXcgUGx1Z2luRXJyb3IoJ+aPkuS7tuS4jeWtmOWcqO+8micgKyBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICog6I635Y+W5omA5pyJ5o+S5Lu2XG4gKiBAcmV0dXJucyB7TWFwfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsUGx1Z2lucygpIHtcbiAgICByZXR1cm4gX3BsdWdpbnM7XG59XG5cblxuIiwiaW1wb3J0IHtTcHJlYWRTaGVldEVycm9yfSBmcm9tICcuLi9TcHJlYWRTaGVldEVycm9yJ1xuXG5leHBvcnQgZnVuY3Rpb24gUGx1Z2luRXJyb3IodmFsdWUpIHtcbiAgICB0aGlzLm5hbWUgPSAnUGx1Z2luRXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IHZhbHVlO1xufVxuUGx1Z2luRXJyb3IucHJvdG90eXBlID0gbmV3IFNwcmVhZFNoZWV0RXJyb3IoKTtcblBsdWdpbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsdWdpbkVycm9yOyIsImltcG9ydCB7UGx1Z2lufSBmcm9tICcuLi9QbHVnaW4nO1xuaW1wb3J0IHtTdG9yYWdlfSBmcm9tICcuL1N0b3JhZ2UnO1xuXG5jbGFzcyBQZXJzaXN0ZW50IGV4dGVuZHMgUGx1Z2luIHtcblxuICAgIGNvbnN0cnVjdG9yKHNzZCkge1xuICAgICAgICBzdXBlcihzc2QpO1xuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc3ByZWFkc2hlZXQuc2V0dGluZ3M7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnBlcnNpc3RlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHBlcnNpc3RlbnQg5Li6IGB0cnVlYCDml7bvvIzkvb/nlKjpu5jorqTmlrnmoYhcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog55S15a2Q6KGo5qC85pys5Zyw5oyB5LmF5YyW5pe25L2/55So55qEIGtleVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbnRLZXkgPSBzc2QuZ2V0SWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE8gcGVyc2lzdGVudCDkuLrlr7nosaHml7bvvIzmj5DkvpsgbG9jYWxTdG9yYWdl44CBc2Vzc2lvbiDnrYnmlrnmoYjlj4rotoXml7bml7bpl7TnrYnnm7jlhbPphY3nva5cbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVudEtleSA9IHNldHRpbmdzLnBlcnNpc3RlbnQua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zcHJlYWRzaGVldC5zZXR0aW5ncyA9IFN0b3JhZ2UubG9hZCh0aGlzLnBlcnNpc3RlbnRLZXkpIHx8IHNldHRpbmdzO1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyTWV0aG9kKCdzYXZlU3RhdGUnKTtcbiAgICB9XG5cbiAgICBpc0VuYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zcHJlYWRzaGVldC5nZXRTZXR0aW5ncygpLnBlcnNpc3RlbnQ7XG4gICAgfVxuXG4gICAgZW5hYmxlKCkge1xuICAgICAgICBzdXBlci5lbmFibGUoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgc2F2ZVN0YXRlKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc3ByZWFkc2hlZXQuZ2V0RXhjaGFuZ2VEYXRhKCk7XG4gICAgICAgIFN0b3JhZ2Uuc2F2ZSh0aGlzLnBlcnNpc3RlbnRLZXksIGRhdGEpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQZXJzaXN0ZW50OyIsIi8qKlxuICog5a2Y5YKo5pa55qGIXG4gKi9cbmNsYXNzIFN0b3JhZ2Uge1xuXG4gICAgc3RhdGljIHNhdmUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFN0b3JhZ2UuUFJFRklYICsga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGxvYWQoa2V5KSB7XG4gICAgICAgIHZhciB2YWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZS5QUkVGSVggKyBrZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlbW92ZShrZXkpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhbFN0b3JhZ2VbU3RvcmFnZS5QUkVGSVggKyBrZXldKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU3RvcmFnZS5QUkVGSVggKyBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNsZWFyKCkge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLmNsZWFyKCk7XG4gICAgfVxuXG59XG5cblN0b3JhZ2UuUFJFRklYID0gJyQkYnJpY2shc3RvcmFnZS0nO1xuXG5leHBvcnQge1N0b3JhZ2V9OyIsImltcG9ydCB7Q2VsbFZhbHVlfSBmcm9tICcuL0NlbGxWYWx1ZSc7XG5pbXBvcnQge2lzRm9ybXVsYUV4cHJlc3Npb259IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtFeHByZXNzaW9uTW9kaWZpZXJ9IGZyb20gJy4vZXhwcmVzc2lvbk1vZGlmaWVyJztcblxudmFyIGFycmF5RWFjaCA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlFYWNoO1xudmFyIG1peGluID0gSGFuZHNvbnRhYmxlLmhlbHBlci5taXhpbjtcbnZhciBsb2NhbEhvb2tzID0gSGFuZHNvbnRhYmxlLnV0aWxzLmxvY2FsSG9va3M7IC8vIHByaXZhdGVcblxuXG5jbGFzcyBBbHRlck1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHNoZWV0KSB7XG5cbiAgICAgICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuXG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gc2hlZXQuZGF0YVByb3ZpZGVyO1xuXG4gICAgICAgIHRoaXMubWF0cml4ID0gc2hlZXQubWF0cml4O1xuICAgIH1cblxuICAgIGluc2VydFJvdyhyb3csIGFtb3VudCwgbW9kaWZ5Rm9ybXVsYSkge1xuICAgICAgICB0aGlzLl9hbHRlcignaW5zZXJ0JywgJ3JvdycsIHJvdywgYW1vdW50LCBtb2RpZnlGb3JtdWxhKTtcbiAgICB9XG5cbiAgICByZW1vdmVSb3cocm93LCBhbW91bnQsIG1vZGlmeUZvcm11bGEpIHtcbiAgICAgICAgdGhpcy5fYWx0ZXIoJ3JlbW92ZScsICdyb3cnLCByb3csIC1hbW91bnQsIG1vZGlmeUZvcm11bGEpO1xuICAgIH1cblxuICAgIGluc2VydENvbHVtbihjb2x1bW4sIGFtb3VudCwgbW9kaWZ5Rm9ybXVsYSkge1xuICAgICAgICB0aGlzLl9hbHRlcignaW5zZXJ0JywgJ2NvbHVtbicsIGNvbHVtbiwgYW1vdW50LCBtb2RpZnlGb3JtdWxhKTtcbiAgICB9XG5cbiAgICByZW1vdmVDb2x1bW4oY29sdW1uLCBhbW91bnQsIG1vZGlmeUZvcm11bGEpIHtcbiAgICAgICAgdGhpcy5fYWx0ZXIoJ3JlbW92ZScsICdjb2x1bW4nLCBjb2x1bW4sIC1hbW91bnQsIG1vZGlmeUZvcm11bGEpO1xuICAgIH1cblxuICAgIF9hbHRlcihhY3Rpb24sIGF4aXMsIHN0YXJ0LCBhbW91bnQsIG1vZGlmeUZvcm11bGEgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29vcmQgPSAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3c6IGF4aXMgPT09ICdyb3cnID8gc3RhcnQgOiBjZWxsLnJvdyxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGF4aXMgPT09ICdjb2x1bW4nID8gc3RhcnQgOiBjZWxsLmNvbHVtbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZUNlbGxSZWZzID0gKHJvdywgY29sdW1uKSA9PiB7XG4gICAgICAgICAgICBhcnJheUVhY2godGhpcy5tYXRyaXguY2VsbFJlZmVyZW5jZXMsIChjZWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxbYXhpc10gPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC50cmFuc2xhdGVUbyhyb3csIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gW107XG4gICAgICAgIGNvbnN0IGluZGV4T2Zmc2V0ID0gTWF0aC5hYnMoYW1vdW50KSAtIDE7XG5cbiAgICAgICAgaWYgKGF4aXMgPT09ICdyb3cnKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGUucHVzaChhbW91bnQsIDApO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZS5wdXNoKDAsIGFtb3VudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgbGV0IHJlbW92ZWRDZWxsUmVmID0gdGhpcy5tYXRyaXgucmVtb3ZlQ2VsbFJlZnNBdFJhbmdlKHtbYXhpc106IHN0YXJ0fSwge1theGlzXTogc3RhcnQgKyBpbmRleE9mZnNldH0pO1xuICAgICAgICAgICAgbGV0IHRvUmVtb3ZlID0gW107XG5cbiAgICAgICAgICAgIGFycmF5RWFjaCh0aGlzLm1hdHJpeC5kYXRhLCAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFycmF5RWFjaChyZW1vdmVkQ2VsbFJlZiwgKGNlbGxSZWYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjZWxsLmhhc1ByZWNlZGVudChjZWxsUmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2VsbC5yZW1vdmVQcmVjZWRlbnQoY2VsbFJlZik7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0U3RhdGUoQ2VsbFZhbHVlLlNUQVRFX09VVF9PRkZfREFURSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlFYWNoKHRoaXMuc2hlZXQuZ2V0Q2VsbERlcGVuZGVuY2llcyhjZWxsLnJvdywgY2VsbC5jb2x1bW4pLCAoY2VsbFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuc2V0U3RhdGUoQ2VsbFZhbHVlLlNUQVRFX09VVF9PRkZfREFURSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNlbGxbYXhpc10gPj0gc3RhcnQgJiYgY2VsbFtheGlzXSA8PSAoc3RhcnQgKyBpbmRleE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9SZW1vdmUucHVzaChjZWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tYXRyaXgucmVtb3ZlKHRvUmVtb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zbGF0ZUNlbGxSZWZzKC4uLnRyYW5zbGF0ZSk7XG5cbiAgICAgICAgYXJyYXlFYWNoKHRoaXMubWF0cml4LmRhdGEsIChjZWxsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcmlnUm93ID0gY2VsbC5yb3c7XG4gICAgICAgICAgICBjb25zdCBvcmlnQ29sdW1uID0gY2VsbC5jb2x1bW47XG5cbiAgICAgICAgICAgIGlmIChjZWxsW2F4aXNdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgY2VsbC50cmFuc2xhdGVUbyguLi50cmFuc2xhdGUpO1xuICAgICAgICAgICAgICAgIGNlbGwuc2V0U3RhdGUoQ2VsbFZhbHVlLlNUQVRFX09VVF9PRkZfREFURSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb2RpZnlGb3JtdWxhKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gY2VsbC5yb3c7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gY2VsbC5jb2x1bW47XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRhdGFQcm92aWRlci5nZXRTb3VyY2VEYXRhQXRDZWxsKHJvdywgY29sdW1uKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBNb2RpZmllciA9IG5ldyBFeHByZXNzaW9uTW9kaWZpZXIodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGV4cE1vZGlmaWVyLnRyYW5zbGF0ZShzdGFydENvb3JkKHtyb3c6IG9yaWdSb3csIGNvbHVtbjogb3JpZ0NvbHVtbn0pLCB7W2F4aXNdOiBhbW91bnR9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci51cGRhdGVTb3VyY2VEYXRhKHJvdywgY29sdW1uLCBleHBNb2RpZmllci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJ1bkxvY2FsSG9va3MoJ2FmdGVyQWx0ZXInLCBhY3Rpb24sIGF4aXMsIHN0YXJ0LCBhbW91bnQpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2hlZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgICB9XG59XG5cbm1peGluKEFsdGVyTWFuYWdlciwgbG9jYWxIb29rcyk7XG5cbmV4cG9ydCB7QWx0ZXJNYW5hZ2VyfTtcbiIsImltcG9ydCB7dG9MYWJlbH0gZnJvbSAnLi9wYXJzZXIvdXRpbHMnO1xuXG52YXIgaXNPYmplY3QgPSBIYW5kc29udGFibGUuaGVscGVyLmlzT2JqZWN0O1xuXG5jbGFzcyBCYXNlQ2VsbCB7XG4gICAgY29uc3RydWN0b3Iocm93LCBjb2x1bW4pIHtcbiAgICAgICAgY29uc3Qgcm93T2JqZWN0ID0gaXNPYmplY3Qocm93KTtcbiAgICAgICAgY29uc3QgY29sdW1uT2JqZWN0ID0gaXNPYmplY3QoY29sdW1uKTtcblxuICAgICAgICB0aGlzLl9yb3cgPSByb3dPYmplY3QgPyByb3cuaW5kZXggOiByb3c7XG4gICAgICAgIHRoaXMucm93QWJzb2x1dGUgPSByb3dPYmplY3QgPyByb3cuaXNBYnNvbHV0ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb2x1bW4gPSBjb2x1bW5PYmplY3QgPyBjb2x1bW4uaW5kZXggOiBjb2x1bW47XG4gICAgICAgIHRoaXMuY29sdW1uQWJzb2x1dGUgPSBjb2x1bW5PYmplY3QgPyBjb2x1bW4uaXNBYnNvbHV0ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnJvd09mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uT2Zmc2V0ID0gMDtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JvdycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd09mZnNldCArIHRoaXMuX3JvdztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2x1bW4nLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5PZmZzZXQgKyB0aGlzLl9jb2x1bW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhbnNsYXRlVG8ocm93T2Zmc2V0LCBjb2x1bW5PZmZzZXQpIHtcbiAgICAgICAgdGhpcy5yb3cgPSB0aGlzLnJvdyArIHJvd09mZnNldDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSB0aGlzLmNvbHVtbiArIGNvbHVtbk9mZnNldDtcbiAgICB9XG5cbiAgICBpc0VxdWFsKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIGNlbGwucm93ID09PSB0aGlzLnJvdyAmJiBjZWxsLmNvbHVtbiA9PT0gdGhpcy5jb2x1bW47XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0b0xhYmVsKFxuICAgICAgICAgICAge2luZGV4OiB0aGlzLnJvdywgaXNBYnNvbHV0ZTogdGhpcy5yb3dBYnNvbHV0ZX0sXG4gICAgICAgICAgICB7aW5kZXg6IHRoaXMuY29sdW1uLCBpc0Fic29sdXRlOiB0aGlzLmNvbHVtbkFic29sdXRlfVxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZUNlbGw7XG4iLCJpbXBvcnQgQmFzZUNlbGwgZnJvbSAnLi9CYXNlQ2VsbCc7XG5pbXBvcnQge3RvTGFiZWx9IGZyb20gJy4vcGFyc2VyL3V0aWxzJztcblxuY2xhc3MgQ2VsbFJlZmVyZW5jZSBleHRlbmRzIEJhc2VDZWxsIHtcbiAgICBjb25zdHJ1Y3Rvcihyb3csIGNvbHVtbikge1xuICAgICAgICBzdXBlcihyb3csIGNvbHVtbik7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0b0xhYmVsKFxuICAgICAgICAgICAge2luZGV4OiB0aGlzLnJvdywgaXNBYnNvbHV0ZTogZmFsc2V9LFxuICAgICAgICAgICAge2luZGV4OiB0aGlzLmNvbHVtbiwgaXNBYnNvbHV0ZTogZmFsc2V9XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQge0NlbGxSZWZlcmVuY2V9O1xuIiwiaW1wb3J0IEJhc2VDZWxsIGZyb20gJy4vQmFzZUNlbGwnO1xuaW1wb3J0IHtFUlJPUl9SRUZ9IGZyb20gJy4vcGFyc2VyL2Vycm9yJztcblxuY29uc3QgU1RBVEVfT1VUX09GRl9EQVRFID0gMTtcbmNvbnN0IFNUQVRFX0NPTVBVVElORyA9IDI7XG5jb25zdCBTVEFURV9VUF9UT19EQVRFID0gMztcbmNvbnN0IHN0YXRlcyA9IFtTVEFURV9PVVRfT0ZGX0RBVEUsIFNUQVRFX0NPTVBVVElORywgU1RBVEVfVVBfVE9fREFURV07XG5cbnZhciBhcnJheUZpbHRlciA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlGaWx0ZXI7XG5cblxuY2xhc3MgQ2VsbFZhbHVlIGV4dGVuZHMgQmFzZUNlbGwge1xuXG4gICAgc3RhdGljIGdldCBTVEFURV9PVVRfT0ZGX0RBVEUoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgU1RBVEVfQ09NUFVUSU5HKCkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IFNUQVRFX1VQX1RPX0RBVEUoKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHN1cGVyKHJvdywgY29sdW1uKTtcbiAgICAgICAgdGhpcy5wcmVjZWRlbnRzID0gW107XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENlbGxWYWx1ZS5TVEFURV9VUF9UT19EQVRFO1xuICAgIH1cblxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgc2V0RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cblxuICAgIGdldEVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcjtcbiAgICB9XG5cbiAgICBoYXNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IgIT09IG51bGw7XG4gICAgfVxuXG4gICAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlcy5pbmRleE9mKHN0YXRlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93KGDmnKrnn6XnirbmgIE6ICR7c3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cblxuICAgIGlzU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IHN0YXRlO1xuICAgIH1cblxuICAgIGFkZFByZWNlZGVudChjZWxsUmVmZXJlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXF1YWwoY2VsbFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKEVSUk9SX1JFRik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhc1ByZWNlZGVudChjZWxsUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVjZWRlbnRzLnB1c2goY2VsbFJlZmVyZW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVQcmVjZWRlbnQoY2VsbFJlZmVyZW5jZSkge1xuICAgICAgICBpZiAodGhpcy5pc0VxdWFsKGNlbGxSZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJPUl9SRUYpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlY2VkZW50cyA9IGFycmF5RmlsdGVyKHRoaXMucHJlY2VkZW50cywgKGNlbGwpID0+ICFjZWxsLmlzRXF1YWwoY2VsbFJlZmVyZW5jZSkpO1xuICAgIH1cblxuICAgIGdldFByZWNlZGVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNlZGVudHM7XG4gICAgfVxuXG4gICAgaGFzUHJlY2VkZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY2VkZW50cy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIGhhc1ByZWNlZGVudChjZWxsUmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiBhcnJheUZpbHRlcih0aGlzLnByZWNlZGVudHMsIChjZWxsKSA9PiBjZWxsLmlzRXF1YWwoY2VsbFJlZmVyZW5jZSkpLmxlbmd0aCA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7Q2VsbFZhbHVlfTtcbiIsImltcG9ydCB7aXNGb3JtdWxhRXhwcmVzc2lvbn0gZnJvbSAnLi91dGlscyc7XG5cbnZhciBhcnJheUVhY2ggPSBIYW5kc29udGFibGUuaGVscGVyLmFycmF5RWFjaDtcbnZhciByYW5nZUVhY2ggPSBIYW5kc29udGFibGUuaGVscGVyLnJhbmdlRWFjaDtcblxuXG5jbGFzcyBEYXRhUHJvdmlkZXIge1xuXG4gICAgY29uc3RydWN0b3IoaG90KSB7XG4gICAgICAgIHRoaXMuaG90ID0gaG90O1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSB7fTtcbiAgICB9XG5cbiAgICBjb2xsZWN0Q2hhbmdlcyhyb3csIGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc0Zvcm11bGFFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzW0RhdGFQcm92aWRlci5fY29vcmRJZChyb3csIGNvbHVtbildID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhckNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IHt9O1xuICAgIH1cblxuICAgIGlzSW5EYXRhUmFuZ2Uocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHJvdyA+PSAwICYmIHJvdyA8IHRoaXMuaG90LmNvdW50Um93cygpICYmIGNvbHVtbiA+PSAwICYmIGNvbHVtbiA8IHRoaXMuaG90LmNvdW50Q29scygpO1xuICAgIH1cblxuICAgIGdldERhdGFBdENlbGwocm93LCBjb2x1bW4pIHtcbiAgICAgICAgY29uc3QgaWQgPSBEYXRhUHJvdmlkZXIuX2Nvb3JkSWQocm93LCBjb2x1bW4pO1xuICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgIGlmICh0aGlzLmNoYW5nZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNoYW5nZXNbaWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5ob3QuZ2V0RGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXREYXRhQXRDZWxsSW5TaGVldChzaGVldE5hbWUsIHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBzaGVldCA9IHRoaXMud29ya2Jvb2suZ2V0U2hlZXQoc2hlZXROYW1lKTtcbiAgICAgICAgdmFyIGZvcm11bGFzID0gc2hlZXQuaGFuZHNvbnRhYmxlLmdldFBsdWdpbignWEZvcm11bGFzJyk7XG4gICAgICAgIHJldHVybiBmb3JtdWxhcy5zaGVldC5kYXRhUHJvdmlkZXIuZ2V0RGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG4gICAgfVxuXG4gICAgZ2V0RGF0YUJ5UmFuZ2Uocm93MSwgY29sdW1uMSwgcm93MiwgY29sdW1uMikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhvdC5nZXREYXRhKHJvdzEsIGNvbHVtbjEsIHJvdzIsIGNvbHVtbjIpO1xuXG4gICAgICAgIGFycmF5RWFjaChyZXN1bHQsIChyb3dEYXRhLCByb3dJbmRleCkgPT4ge1xuICAgICAgICAgICAgYXJyYXlFYWNoKHJvd0RhdGEsICh2YWx1ZSwgY29sdW1uSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IERhdGFQcm92aWRlci5fY29vcmRJZChyb3dJbmRleCArIHJvdzEsIGNvbHVtbkluZGV4ICsgY29sdW1uMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFuZ2VzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcm93SW5kZXhdW2NvbHVtbkluZGV4XSA9IHRoaXMuY2hhbmdlc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3QuZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG4gICAgfVxuXG4gICAgZ2V0U291cmNlRGF0YUJ5UmFuZ2Uocm93MSwgY29sdW1uMSwgcm93MiwgY29sdW1uMikge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3QuZ2V0U291cmNlRGF0YUFycmF5KHJvdzEsIGNvbHVtbjEsIHJvdzIsIGNvbHVtbjIpO1xuICAgIH1cblxuICAgIHVwZGF0ZVNvdXJjZURhdGEocm93LCBjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaG90LmdldFNvdXJjZURhdGEoKVtyb3ddW3RoaXMuaG90LmNvbFRvUHJvcChjb2x1bW4pXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBfY29vcmRJZChyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gYCR7cm93fToke2NvbHVtbn1gO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaG90ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCB7RGF0YVByb3ZpZGVyfTtcbiIsImltcG9ydCB7Q2VsbFZhbHVlfSBmcm9tICcuL0NlbGxWYWx1ZSc7XG5cbnZhciBhcnJheUVhY2ggPSBIYW5kc29udGFibGUuaGVscGVyLmFycmF5RWFjaDtcbnZhciBhcnJheUZpbHRlciA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlGaWx0ZXI7XG52YXIgYXJyYXlSZWR1Y2UgPSBIYW5kc29udGFibGUuaGVscGVyLmFycmF5UmVkdWNlO1xuXG5jbGFzcyBNYXRyaXgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5jZWxsUmVmZXJlbmNlcyA9IFtdO1xuICAgIH1cblxuICAgIGdldENlbGxBdChyb3csIGNvbHVtbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgICBhcnJheUVhY2godGhpcy5kYXRhLCAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNlbGwucm93ID09PSByb3cgJiYgY2VsbC5jb2x1bW4gPT09IGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNlbGw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZ2V0T3V0T2ZEYXRlQ2VsbHMoKSB7XG4gICAgICAgIHJldHVybiBhcnJheUZpbHRlcih0aGlzLmRhdGEsIChjZWxsKSA9PiBjZWxsLmlzU3RhdGUoQ2VsbFZhbHVlLlNUQVRFX09VVF9PRkZfREFURSkpO1xuICAgIH1cblxuICAgIGFkZChjZWxsVmFsdWUpIHtcbiAgICAgICAgaWYgKCFhcnJheUZpbHRlcih0aGlzLmRhdGEsIChjZWxsKSA9PiBjZWxsLmlzRXF1YWwoY2VsbFZhbHVlKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaChjZWxsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlKGNlbGxWYWx1ZSkge1xuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShjZWxsVmFsdWUpO1xuICAgICAgICBjb25zdCBpc0VxdWFsID0gKGNlbGwsIGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5RWFjaChjZWxsVmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC5pc0VxdWFsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNlbGwuaXNFcXVhbChjZWxsVmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRhdGEgPSBhcnJheUZpbHRlcih0aGlzLmRhdGEsIChjZWxsKSA9PiAhaXNFcXVhbChjZWxsLCBjZWxsVmFsdWUpKTtcbiAgICB9XG5cbiAgICBnZXREZXBlbmRlbmNpZXMoY2VsbFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGdldERlcGVuZGVuY2llcyA9IChjZWxsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2UodGhpcy5kYXRhLCAoYWNjLCBjZWxsVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbFZhbHVlLmhhc1ByZWNlZGVudChjZWxsKSAmJiBhY2MuaW5kZXhPZihjZWxsVmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaChjZWxsVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZ2V0VG90YWxEZXBlbmRlbmNpZXMgPSAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRlcHMgPSBnZXREZXBlbmRlbmNpZXMoY2VsbCk7XG5cbiAgICAgICAgICAgIGlmIChkZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFycmF5RWFjaChkZXBzLCAoY2VsbFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsVmFsdWUuaGFzUHJlY2VkZW50cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzID0gZGVwcy5jb25jYXQoZ2V0VG90YWxEZXBlbmRlbmNpZXMoY2VsbFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlcHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGdldFRvdGFsRGVwZW5kZW5jaWVzKGNlbGxWYWx1ZSk7XG4gICAgfVxuXG5cbiAgICByZWdpc3RlckNlbGxSZWYoY2VsbFJlZmVyZW5jZSkge1xuICAgICAgICBpZiAoIWFycmF5RmlsdGVyKHRoaXMuY2VsbFJlZmVyZW5jZXMsIChjZWxsKSA9PiBjZWxsLmlzRXF1YWwoY2VsbFJlZmVyZW5jZSkpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jZWxsUmVmZXJlbmNlcy5wdXNoKGNlbGxSZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlQ2VsbFJlZnNBdFJhbmdlKHtyb3c6IHN0YXJ0Um93LCBjb2x1bW46IHN0YXJ0Q29sdW1ufSwge3JvdzogZW5kUm93LCBjb2x1bW46IGVuZENvbHVtbn0pIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHJvd01hdGNoID0gKGNlbGwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFJvdyA9PT0gdm9pZCAwID8gdHJ1ZSA6IGNlbGwucm93ID49IHN0YXJ0Um93ICYmIGNlbGwucm93IDw9IGVuZFJvdztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29sTWF0Y2ggPSAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0Q29sdW1uID09PSB2b2lkIDAgPyB0cnVlIDogY2VsbC5jb2x1bW4gPj0gc3RhcnRDb2x1bW4gJiYgY2VsbC5jb2x1bW4gPD0gZW5kQ29sdW1uO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2VsbFJlZmVyZW5jZXMgPSBhcnJheUZpbHRlcih0aGlzLmNlbGxSZWZlcmVuY2VzLCAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJvd01hdGNoKGNlbGwpICYmIGNvbE1hdGNoKGNlbGwpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGNlbGwpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZGF0YS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNlbGxSZWZlcmVuY2VzLmxlbmd0aCA9IDA7XG4gICAgfVxufVxuXG5leHBvcnQge01hdHJpeH07XG4iLCJpbXBvcnQge0NlbGxWYWx1ZX0gZnJvbSAnLi9DZWxsVmFsdWUnO1xuaW1wb3J0IHtDZWxsUmVmZXJlbmNlfSBmcm9tICcuL0NlbGxSZWZlcmVuY2UnO1xuaW1wb3J0IHtpc0Zvcm11bGFFeHByZXNzaW9uLCB0b1VwcGVyQ2FzZUZvcm11bGF9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtNYXRyaXh9IGZyb20gJy4vTWF0cml4JztcbmltcG9ydCB7QWx0ZXJNYW5hZ2VyfSBmcm9tICcuL0FsdGVyTWFuYWdlcic7XG5pbXBvcnQge1BhcnNlcn0gZnJvbSAnLi9wYXJzZXIvcGFyc2VyJztcbmltcG9ydCB7RVJST1JfUkVGfSBmcm9tICcuL3BhcnNlci9lcnJvcic7XG5cbmNvbnN0IFNUQVRFX1VQX1RPX0RBVEUgPSAxO1xuY29uc3QgU1RBVEVfTkVFRF9SRUJVSUxEID0gMjtcbmNvbnN0IFNUQVRFX05FRURfRlVMTF9SRUJVSUxEID0gMztcblxudmFyIGFycmF5RWFjaCA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlFYWNoO1xudmFyIGFycmF5TWFwID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheU1hcDtcbnZhciByYW5nZUVhY2ggPSBIYW5kc29udGFibGUuaGVscGVyLnJhbmdlRWFjaDtcbnZhciBvYmplY3RFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5vYmplY3RFYWNoO1xudmFyIG1peGluID0gSGFuZHNvbnRhYmxlLmhlbHBlci5taXhpbjtcbnZhciBsb2NhbEhvb2tzID0gSGFuZHNvbnRhYmxlLnV0aWxzLmxvY2FsSG9va3M7IC8vIHByaXZhdGVcblxuXG5jbGFzcyBTaGVldCB7XG5cbiAgICBjb25zdHJ1Y3RvcihkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBkYXRhUHJvdmlkZXI7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgICAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5hbHRlck1hbmFnZXIgPSBuZXcgQWx0ZXJNYW5hZ2VyKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NpbmdDZWxsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURV9ORUVEX0ZVTExfUkVCVUlMRDtcblxuICAgICAgICB0aGlzLnBhcnNlci5vbignY2FsbENlbGxWYWx1ZScsICguLi5hcmdzKSA9PiB0aGlzLl9vbkNhbGxDZWxsVmFsdWUoLi4uYXJncykpO1xuICAgICAgICB0aGlzLnBhcnNlci5vbignY2FsbFJhbmdlVmFsdWUnLCAoLi4uYXJncykgPT4gdGhpcy5fb25DYWxsUmFuZ2VWYWx1ZSguLi5hcmdzKSk7XG4gICAgICAgIHRoaXMucGFyc2VyLm9uKCdjYWxsQ2VsbFZhbHVlSW5TaGVldCcsICguLi5hcmdzKSA9PiB0aGlzLl9vbkNhbGxDZWxsVmFsdWVJblNoZWV0KC4uLmFyZ3MpKTtcbiAgICAgICAgdGhpcy5wYXJzZXIub24oJ2NhbGxSYW5nZVZhbHVlSW5TaGVldCcsICguLi5hcmdzKSA9PiB0aGlzLl9vbkNhbGxSYW5nZVZhbHVlSW5TaGVldCguLi5hcmdzKSk7XG4gICAgICAgIHRoaXMuYWx0ZXJNYW5hZ2VyLmFkZExvY2FsSG9vaygnYWZ0ZXJBbHRlcicsICguLi5hcmdzKSA9PiB0aGlzLl9vbkFmdGVyQWx0ZXIoLi4uYXJncykpO1xuICAgIH1cblxuICAgIHJlY2FsY3VsYXRlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFNUQVRFX05FRURfRlVMTF9SRUJVSUxEOlxuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGVGdWxsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNUQVRFX05FRURfUkVCVUlMRDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlT3B0aW1pemVkKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWNhbGN1bGF0ZU9wdGltaXplZCgpIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSB0aGlzLm1hdHJpeC5nZXRPdXRPZkRhdGVDZWxscygpO1xuXG4gICAgICAgIGFycmF5RWFjaChjZWxscywgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRhdGFQcm92aWRlci5nZXRTb3VyY2VEYXRhQXRDZWxsKGNlbGxWYWx1ZS5yb3csIGNlbGxWYWx1ZS5jb2x1bW4pO1xuXG4gICAgICAgICAgICBpZiAoaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXhwcmVzc2lvbihjZWxsVmFsdWUsIHZhbHVlLnN1YnN0cigxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gU1RBVEVfVVBfVE9fREFURTtcbiAgICAgICAgdGhpcy5ydW5Mb2NhbEhvb2tzKCdhZnRlclJlY2FsY3VsYXRlJywgY2VsbHMsICdvcHRpbWl6ZWQnKTtcbiAgICB9XG5cbiAgICByZWNhbGN1bGF0ZUZ1bGwoKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5kYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUJ5UmFuZ2UoKTtcbiAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcblxuICAgICAgICBhcnJheUVhY2goY2VsbHMsIChyb3dEYXRhLCByb3cpID0+IHtcbiAgICAgICAgICAgIGFycmF5RWFjaChyb3dEYXRhLCAodmFsdWUsIGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXhwcmVzc2lvbihuZXcgQ2VsbFZhbHVlKHJvdywgY29sdW1uKSwgdmFsdWUuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURV9VUF9UT19EQVRFO1xuICAgICAgICB0aGlzLnJ1bkxvY2FsSG9va3MoJ2FmdGVyUmVjYWxjdWxhdGUnLCBjZWxscywgJ2Z1bGwnKTtcbiAgICB9XG5cbiAgICBzZXRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcnNlci5zZXRWYXJpYWJsZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG5cbiAgICBnZXRWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5nZXRWYXJpYWJsZShuYW1lKTtcbiAgICB9XG5cblxuICAgIGFwcGx5Q2hhbmdlcyhyb3csIGNvbHVtbiwgbmV3VmFsdWUpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIHJlY2FsY3VsYXRlKClcbiAgICAgICAgdGhpcy5tYXRyaXgucmVtb3ZlKHtyb3csIGNvbHVtbn0pO1xuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byByZWNhbGN1bGF0ZSgpXG4gICAgICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUV4cHJlc3Npb24obmV3IENlbGxWYWx1ZShyb3csIGNvbHVtbiksIG5ld1ZhbHVlLnN1YnN0cigxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXBzID0gdGhpcy5nZXRDZWxsRGVwZW5kZW5jaWVzKHJvdywgY29sdW1uKTtcblxuICAgICAgICBhcnJheUVhY2goZGVwcywgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY2VsbFZhbHVlLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IFNUQVRFX05FRURfUkVCVUlMRDtcbiAgICB9XG5cbiAgICBwYXJzZUV4cHJlc3Npb24oY2VsbFZhbHVlLCBmb3JtdWxhKSB7XG4gICAgICAgIGNlbGxWYWx1ZS5zZXRTdGF0ZShDZWxsVmFsdWUuU1RBVEVfQ09NUFVUSU5HKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ0NlbGwgPSBjZWxsVmFsdWU7XG5cbiAgICAgICAgLy8gVE9ETyAgd3JhcHBlciBmb3JtdWxhXG4gICAgICAgIC8vIHZhciBzaGVldE5hbWVzID0gdGhpcy5kYXRhUHJvdmlkZXIud29ya2Jvb2suZ2V0U2hlZXROYW1lcygpO1xuXG4gICAgICAgIGNvbnN0IHtlcnJvciwgcmVzdWx0fSA9IHRoaXMucGFyc2VyLnBhcnNlKHRvVXBwZXJDYXNlRm9ybXVsYShmb3JtdWxhKSk7XG5cbiAgICAgICAgY2VsbFZhbHVlLnNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIGNlbGxWYWx1ZS5zZXRFcnJvcihlcnJvcik7XG4gICAgICAgIGNlbGxWYWx1ZS5zZXRTdGF0ZShDZWxsVmFsdWUuU1RBVEVfVVBfVE9fREFURSk7XG5cbiAgICAgICAgdGhpcy5tYXRyaXguYWRkKGNlbGxWYWx1ZSk7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NpbmdDZWxsID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRDZWxsQXQocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldENlbGxBdChyb3csIGNvbHVtbik7XG4gICAgfVxuXG4gICAgZ2V0Q2VsbERlcGVuZGVuY2llcyhyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0RGVwZW5kZW5jaWVzKHtyb3csIGNvbHVtbn0pO1xuICAgIH1cblxuICAgIF9vbkNhbGxDZWxsVmFsdWUoe3JvdywgY29sdW1ufSwgZG9uZSkge1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IENlbGxSZWZlcmVuY2Uocm93LCBjb2x1bW4pO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhUHJvdmlkZXIuaXNJbkRhdGFSYW5nZShjZWxsLnJvdywgY2VsbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJPUl9SRUYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXRyaXgucmVnaXN0ZXJDZWxsUmVmKGNlbGwpO1xuICAgICAgICB0aGlzLl9wcm9jZXNzaW5nQ2VsbC5hZGRQcmVjZWRlbnQoY2VsbCk7XG5cbiAgICAgICAgZG9uZSh0aGlzLmRhdGFQcm92aWRlci5nZXREYXRhQXRDZWxsKGNlbGwucm93LCBjZWxsLmNvbHVtbikpO1xuICAgIH1cblxuICAgIF9vbkNhbGxDZWxsVmFsdWVJblNoZWV0KHtzaGVldE5hbWUsIHJvdywgY29sdW1ufSwgZG9uZSkge1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IENlbGxSZWZlcmVuY2Uocm93LCBjb2x1bW4pO1xuXG4gICAgICAgIC8vIFRPRE8g5pu05pS55pWw5o2u5pe277yM5YWs5byP5byV55So55qE5pWw5o2u57qn6IGU5pu05pawXG5cbiAgICAgICAgZG9uZSh0aGlzLmRhdGFQcm92aWRlci5nZXREYXRhQXRDZWxsSW5TaGVldChzaGVldE5hbWUsIGNlbGwucm93LCBjZWxsLmNvbHVtbikpO1xuICAgIH1cblxuICAgIF9vbkNhbGxSYW5nZVZhbHVlKHtyb3c6IHN0YXJ0Um93LCBjb2x1bW46IHN0YXJ0Q29sdW1ufSwge3JvdzogZW5kUm93LCBjb2x1bW46IGVuZENvbHVtbn0sIGRvbmUpIHtcbiAgICAgICAgcmFuZ2VFYWNoKHN0YXJ0Um93LmluZGV4LCBlbmRSb3cuaW5kZXgsIChyb3cpID0+IHtcbiAgICAgICAgICAgIHJhbmdlRWFjaChzdGFydENvbHVtbi5pbmRleCwgZW5kQ29sdW1uLmluZGV4LCAoY29sdW1uKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGwgPSBuZXcgQ2VsbFJlZmVyZW5jZShyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC5yZWdpc3RlckNlbGxSZWYoY2VsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ0NlbGwuYWRkUHJlY2VkZW50KGNlbGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb25lKHRoaXMuZGF0YVByb3ZpZGVyLmdldERhdGFCeVJhbmdlKHN0YXJ0Um93LmluZGV4LCBzdGFydENvbHVtbi5pbmRleCwgZW5kUm93LmluZGV4LCBlbmRDb2x1bW4uaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIOiwg+eUqOiMg+WbtOWFrOW8j1xuICAgIF9vbkNhbGxSYW5nZVZhbHVlSW5TaGVldChzaGVldE5hbWUsIHtyb3c6IHN0YXJ0Um93LCBjb2x1bW46IHN0YXJ0Q29sdW1ufSwge3JvdzogZW5kUm93LCBjb2x1bW46IGVuZENvbHVtbn0sIGRvbmUpIHtcblxuXG4gICAgICAgIGRvbmUoJ19vbkNhbGxSYW5nZVZhbHVlSW5TaGVldCcpO1xuICAgIH1cblxuICAgIF9vbkFmdGVyQWx0ZXIoKSB7XG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVPcHRpbWl6ZWQoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbHRlck1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmFsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICAgIH1cbn1cblxubWl4aW4oU2hlZXQsIGxvY2FsSG9va3MpO1xuXG5leHBvcnQge1NoZWV0fTtcbiIsImltcG9ydCB7Q2VsbFZhbHVlfSBmcm9tICcuL0NlbGxWYWx1ZSc7XG5pbXBvcnQge1N0YWNrfSBmcm9tICcuLi8uLi91dGlscy9kYXRhU3RydWN0dXJlJ1xuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgcmFuZ2VFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5yYW5nZUVhY2g7XG5cbmNsYXNzIFVuZG9SZWRvU25hcHNob3Qge1xuICAgIGNvbnN0cnVjdG9yKHNoZWV0KSB7XG4gICAgICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIH1cblxuICAgIHNhdmUoYXhpcywgaW5kZXgsIGFtb3VudCkge1xuICAgICAgICBjb25zdCB7bWF0cml4LCBkYXRhUHJvdmlkZXJ9ID0gdGhpcy5zaGVldDtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuXG4gICAgICAgIGFycmF5RWFjaChtYXRyaXguZGF0YSwgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge3JvdywgY29sdW1ufSA9IGNlbGxWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKGNlbGxWYWx1ZVtheGlzXSA8IGluZGV4IHx8IGNlbGxWYWx1ZVtheGlzXSA+IGluZGV4ICsgKGFtb3VudCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe3JvdywgY29sdW1uLCB2YWx1ZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN0YWNrLnB1c2goe2F4aXMsIGluZGV4LCBhbW91bnQsIGNoYW5nZXN9KTtcbiAgICB9XG5cbiAgICByZXN0b3JlKCkge1xuICAgICAgICBjb25zdCB7bWF0cml4LCBkYXRhUHJvdmlkZXJ9ID0gdGhpcy5zaGVldDtcbiAgICAgICAgY29uc3Qge2F4aXMsIGluZGV4LCBhbW91bnQsIGNoYW5nZXN9ID0gdGhpcy5zdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgYXJyYXlFYWNoKGNoYW5nZXMsIChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlW2F4aXNdID4gaW5kZXggKyAoYW1vdW50IC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlW2F4aXNdIC09IGFtb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qge3JvdywgY29sdW1uLCB2YWx1ZX0gPSBjaGFuZ2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBkYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBpZiAocmF3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm92aWRlci51cGRhdGVTb3VyY2VEYXRhKHJvdywgY29sdW1uLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXRDZWxsQXQocm93LCBjb2x1bW4pLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zaGVldCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IHtVbmRvUmVkb1NuYXBzaG90fTtcbiIsIi8qKlxuICog5omp5bGV5YWs5byP77ya5pSv5oyB6Leo5bel5L2c6KGo55qE5YWs5byP44CCXG4gKiDnpLrkvovvvJpcbiAqICsgd29ya3NoZWV0MuS4reafkOWNleWFg+agvOWAvOS4uiBgPXdvcmtzaGVldDEhQTIrQjJgXG4gKiArIOW3peS9nOihqDPkuK3mn5DljZXlhYPmoLzlgLzkuLogYD3lt6XkvZzooagxIUExK+W3peS9nOihqDJCMWBcbiAqICsgc2hlZXQ15Lit5p+Q5Y2V5YWD5qC85YC85Li6YD1TVU0oc2hlZXQzIUIxOkI1LCBzaGVldDQhQjYpYFxuICpcbiAqIFRPRE8g55uu5YmN5LuF5pSv5oyB4oCc55u45a+55byV55So4oCd55qE5Z2Q5qCH5b2i5byP77yM5L2G5rKh5pyJ5YWs5byP5aGr5YWF55qE5pWI5p6c77ybXG4gKiDnm67liY3kuI3mlK/mjIHigJznu53lr7nlvJXnlKjigJ3lkozigJzmt7flkIjlvJXnlKjigJ3mlrnlvI/jgIJcbiAqXG4gKiDmraTmj5Lku7bpnIDopoHnu5XlvIAgaGFuc29udGFibGUg5LiA5Liq5o+S5Lu25a+55bqU5LiA5Liq5a6e5L6L55qE6K6+6K6h5oCd6Lev77yM6ICM5ZCM5pe2566h55CG5aSa5Liq5a6e5L6L44CCXG4gKiDlrp7kvovnmoTnrqHnkIblt6XkvZzkuqTnu5kgV29ya2Jvb2sg5p2l5YGa77yM5Zug5q2k77yM5q2k5o+S5Lu25LiN5Y+v5L2c5Li654us56uL55qEIGhhbnNvbnRhYmxlIOaPkuS7tlxuICog5L2/55So77yM5Y+q6IO95L6d5omY5LqO6K+l55S15a2Q6KGo5qC86K6+6K6h5Zmo44CCXG4gKlxuICogQHBsdWdpbiBFeHRlcm5hbCBwbHVnaW4gWEZvcm11bGFzLlxuICogQHBhcmFtIGhvdEluc3RhbmNlXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKi9cblxuLy8gVE9ETyDnpoHmraLlhazlvI/lvqrnjq/lvJXnlKggQTE9QjEsIEIxPUExXG5cbmltcG9ydCB7XG4gICAgaXNGb3JtdWxhRXhwcmVzc2lvbixcbiAgICB0b1VwcGVyQ2FzZUZvcm11bGEsXG4gICAgaXNGb3JtdWxhRXhwcmVzc2lvbkVzY2FwZWQsXG4gICAgdW5lc2NhcGVGb3JtdWxhRXhwcmVzc2lvbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge1NoZWV0fSBmcm9tICcuL1NoZWV0JztcbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuL0RhdGFQcm92aWRlcic7XG5pbXBvcnQge1VuZG9SZWRvU25hcHNob3R9IGZyb20gJy4vVW5kb1JlZG9TbmFwc2hvdCc7XG5cblxudmFyIGFycmF5RWFjaCA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlFYWNoO1xudmFyIGlzT2JqZWN0ID0gSGFuZHNvbnRhYmxlLmhlbHBlci5pc09iamVjdDtcbnZhciBvYmplY3RFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5vYmplY3RFYWNoO1xuXG5mdW5jdGlvbiBYRm9ybXVsYXMoaG90SW5zdGFuY2UpIHtcblxuICAgIEhhbmRzb250YWJsZS5wbHVnaW5zLkJhc2VQbHVnaW4uY2FsbCh0aGlzLCBob3RJbnN0YW5jZSk7XG4gICAgdGhpcy5fc3VwZXJDbGFzcyA9IEhhbmRzb250YWJsZS5wbHVnaW5zLkJhc2VQbHVnaW47XG5cbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IEhhbmRzb250YWJsZS5ldmVudE1hbmFnZXIoKTtcbiAgICB0aGlzLmRhdGFQcm92aWRlciA9IG5ldyBEYXRhUHJvdmlkZXIodGhpcy5ob3QpO1xuICAgIHRoaXMuc2hlZXQgPSBuZXcgU2hlZXQodGhpcy5kYXRhUHJvdmlkZXIpO1xuICAgIHRoaXMudW5kb1JlZG9TbmFwc2hvdCA9IG5ldyBVbmRvUmVkb1NuYXBzaG90KHRoaXMuc2hlZXQpO1xuXG4gICAgdGhpcy5fc2tpcFJlbmRlcmluZyA9IGZhbHNlO1xufVxuXG5YRm9ybXVsYXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShIYW5kc29udGFibGUucGx1Z2lucy5CYXNlUGx1Z2luLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBYRm9ybXVsYXNcbiAgICB9XG59KTtcblxuXG5YRm9ybXVsYXMucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLmhvdC5nZXRTZXR0aW5ncygpLnhGb3JtdWxhcztcbn07XG5cbi8qKlxuICog5o+S5Lu25Yid5aeL5YyW6L+H56iL44CCXG4gKiBQUzogZW5hYmxlUGx1Z2luIOaWueazleS8muWcqCBiZWZvcmVJbml0IGhvb2sg5Lit6Kem5Y+R77yMXG4gKiAgICAg5LuF5b2TIGlzRW5hYmxlZCDmlrnms5Xov5Tlm54gdHJ1ZSDml7bmiafooYzjgIJcbiAqL1xuWEZvcm11bGFzLnByb3RvdHlwZS5lbmFibGVQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLmhvdC5nZXRTZXR0aW5ncygpO1xuICAgIGlmICghc2V0dGluZ3MuX2lzSG90VGFibGVBZGFwdG9yKSB7XG4gICAgICAgIHRocm93KCdYRm9ybXVsYXMg5o+S5Lu25ZCv55So5aSx6LSlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybXVsYXNTZXR0aW5ncyA9IHNldHRpbmdzLmZvcm11bGFzO1xuICAgIGlmIChpc09iamVjdChmb3JtdWxhc1NldHRpbmdzKSkge1xuICAgICAgICBpZiAoaXNPYmplY3QoZm9ybXVsYXNTZXR0aW5ncy52YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICBvYmplY3RFYWNoKGZvcm11bGFzU2V0dGluZ3MudmFyaWFibGVzLCAodmFsdWUsIG5hbWUpID0+IHRoaXMuc2V0VmFyaWFibGUobmFtZSwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gbW92ZSB0byBEYXRhUHJvdmlkZXJcbiAgICB2YXIgd29ya3NoZWV0ID0gdGhpcy5kYXRhUHJvdmlkZXIud29ya3NoZWV0ID0gdGhpcy5ob3QuZ2V0U2V0dGluZ3MoKS5fc2hlZXQ7XG4gICAgdGhpcy5kYXRhUHJvdmlkZXIud29ya2Jvb2sgPSB3b3Jrc2hlZXQud29ya2Jvb2s7XG5cbiAgICB0aGlzLmFkZEhvb2soJ2FmdGVyQ3JlYXRlQ29sJywgKC4uLmFyZ3MpID0+IHRoaXMub25BZnRlckNyZWF0ZUNvbCguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdhZnRlckNyZWF0ZVJvdycsICguLi5hcmdzKSA9PiB0aGlzLm9uQWZ0ZXJDcmVhdGVSb3coLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnYWZ0ZXJMb2FkRGF0YScsICgpID0+IHRoaXMub25BZnRlckxvYWREYXRhKCkpO1xuICAgIHRoaXMuYWRkSG9vaygnYWZ0ZXJSZW1vdmVDb2wnLCAoLi4uYXJncykgPT4gdGhpcy5vbkFmdGVyUmVtb3ZlQ29sKC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2FmdGVyUmVtb3ZlUm93JywgKC4uLmFyZ3MpID0+IHRoaXMub25BZnRlclJlbW92ZVJvdyguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdhZnRlclNldERhdGFBdENlbGwnLCAoLi4uYXJncykgPT4gdGhpcy5vbkFmdGVyU2V0RGF0YUF0Q2VsbCguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdhZnRlclNldERhdGFBdFJvd1Byb3AnLCAoLi4uYXJncykgPT4gdGhpcy5vbkFmdGVyU2V0RGF0YUF0Q2VsbCguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdiZWZvcmVDcmVhdGVDb2wnLCAoLi4uYXJncykgPT4gdGhpcy5vbkJlZm9yZUNyZWF0ZUNvbCguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdiZWZvcmVDcmVhdGVSb3cnLCAoLi4uYXJncykgPT4gdGhpcy5vbkJlZm9yZUNyZWF0ZVJvdyguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdiZWZvcmVSZW1vdmVDb2wnLCAoLi4uYXJncykgPT4gdGhpcy5vbkJlZm9yZVJlbW92ZUNvbCguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdiZWZvcmVSZW1vdmVSb3cnLCAoLi4uYXJncykgPT4gdGhpcy5vbkJlZm9yZVJlbW92ZVJvdyguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdiZWZvcmVWYWxpZGF0ZScsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlVmFsaWRhdGUoLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnYmVmb3JlVmFsdWVSZW5kZXInLCAoLi4uYXJncykgPT4gdGhpcy5vbkJlZm9yZVZhbHVlUmVuZGVyKC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ21vZGlmeURhdGEnLCAoLi4uYXJncykgPT4gdGhpcy5vbk1vZGlmeURhdGEoLi4uYXJncykpO1xuXG4gICAgdGhpcy5zaGVldC5hZGRMb2NhbEhvb2soJ2FmdGVyUmVjYWxjdWxhdGUnLCAoLi4uYXJncykgPT4gdGhpcy5vblNoZWV0QWZ0ZXJSZWNhbGN1bGF0ZSguLi5hcmdzKSk7XG5cbiAgICB0aGlzLl9zdXBlckNsYXNzLnByb3RvdHlwZS5lbmFibGVQbHVnaW4uY2FsbCh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiDnpoHnlKjmj5Lku7bjgIJcbiAqIFBTOiDms6jmhI/lsIbmiYDmnInlsZ7mgKfph43nva7kuLrpu5jorqTlgLxcbiAqL1xuWEZvcm11bGFzLnByb3RvdHlwZS5kaXNhYmxlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3N1cGVyQ2xhc3MucHJvdG90eXBlLmRpc2FibGVQbHVnaW4uY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICog6YeN572uIEhhbmRzb250YWJsZSDnmoQgc2V0dGluZ3Mg5pe277yM55So5p2l6YeN572uIFhGb3JtdWxhcyDmj5Lku7bnmoTlsZ7mgKfjgIJcbiAqIFBTOiDlnKggYWZ0ZXJVcGRhdGVTZXR0aW5ncyBob29rIOS4reiwg+eUqOOAglxuICovXG5YRm9ybXVsYXMucHJvdG90eXBlLnVwZGF0ZVBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc2FibGVQbHVnaW4oKTtcbiAgICB0aGlzLmVuYWJsZVBsdWdpbigpO1xuICAgIHRoaXMuX3N1cGVyQ2xhc3MucHJvdG90eXBlLnVwZGF0ZVBsdWdpbi5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiDplIDmr4Hmj5Lku7ZcbiAqL1xuWEZvcm11bGFzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRhdGFQcm92aWRlciA9IG51bGw7XG4gICAgdGhpcy5zaGVldC5kZXN0cm95KCk7XG4gICAgdGhpcy5zaGVldCA9IG51bGw7XG4gICAgdGhpcy5fc3VwZXJDbGFzcy5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1bc3RhcnRdIEhvb2tzXG5cbi8vIFRPRE8g5bel5L2c6KGo5pS55ZCN5pe277yM5YW25a6D5bel5L2c6KGo5YWz6IGU5Yiw5a6D55qE5YWs5byP5YC86KaB5pS5XG5YRm9ybXVsYXMucHJvdG90eXBlLm9uU2hlZXRSZW5hbWUgPSBmdW5jdGlvbiAoc2hlZXQsIG5hbWUxLCBuYW1lMikge1xuXG5cbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25TaGVldEFmdGVyUmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoY2VsbHMpIHtcbiAgICBpZiAodGhpcy5fc2tpcFJlbmRlcmluZykge1xuICAgICAgICB0aGlzLl9za2lwUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaG90ID0gdGhpcy5ob3Q7XG5cbiAgICBhcnJheUVhY2goY2VsbHMsICh7cm93LCBjb2x1bW59KSA9PiB7XG4gICAgICAgIGhvdC52YWxpZGF0ZUNlbGwoXG4gICAgICAgICAgICBob3QuZ2V0RGF0YUF0Q2VsbChyb3csIGNvbHVtbiksXG4gICAgICAgICAgICBob3QuZ2V0Q2VsbE1ldGEocm93LCBjb2x1bW4pLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0pO1xuICAgIGhvdC5yZW5kZXIoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25Nb2RpZnlEYXRhID0gZnVuY3Rpb24gKHJvdywgY29sdW1uLCB2YWx1ZUhvbGRlciwgaW9Nb2RlKSB7XG4gICAgaWYgKGlvTW9kZSA9PT0gJ2dldCcgJiYgdGhpcy5oYXNDb21wdXRlZENlbGxWYWx1ZShyb3csIGNvbHVtbikpIHtcbiAgICAgICAgdmFsdWVIb2xkZXIudmFsdWUgPSB0aGlzLmdldENlbGxWYWx1ZShyb3csIGNvbHVtbik7XG5cbiAgICB9IGVsc2UgaWYgKGlvTW9kZSA9PT0gJ3NldCcgJiYgaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZUhvbGRlci52YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVIb2xkZXIudmFsdWUgPSB0b1VwcGVyQ2FzZUZvcm11bGEodmFsdWVIb2xkZXIudmFsdWUpO1xuICAgIH1cbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25CZWZvcmVWYWx1ZVJlbmRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uRXNjYXBlZCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB1bmVzY2FwZUZvcm11bGFFeHByZXNzaW9uKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkJlZm9yZVZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCByb3csIHByb3ApIHtcbiAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmhvdC5wcm9wVG9Db2wocHJvcCk7XG5cbiAgICBpZiAodGhpcy5oYXNDb21wdXRlZENlbGxWYWx1ZShyb3csIGNvbHVtbikpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldENlbGxWYWx1ZShyb3csIGNvbHVtbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkFmdGVyU2V0RGF0YUF0Q2VsbCA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAnbG9hZERhdGEnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFQcm92aWRlci5jbGVhckNoYW5nZXMoKTtcbiAgICBhcnJheUVhY2goY2hhbmdlcywgKFtyb3csIGNvbHVtbiwgb2xkVmFsdWUsIG5ld1ZhbHVlXSkgPT4ge1xuICAgICAgICBjb2x1bW4gPSB0aGlzLmhvdC5wcm9wVG9Db2woY29sdW1uKTtcbiAgICAgICAgaWYgKGlzRm9ybXVsYUV4cHJlc3Npb24obmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvVXBwZXJDYXNlRm9ybXVsYShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuY29sbGVjdENoYW5nZXMocm93LCBjb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zaGVldC5hcHBseUNoYW5nZXMocm93LCBjb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25CZWZvcmVDcmVhdGVSb3cgPSBmdW5jdGlvbiAocm93LCBhbW91bnQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09ICd1bmRvJykge1xuICAgICAgICB0aGlzLnVuZG9SZWRvU25hcHNob3QucmVzdG9yZSgpO1xuICAgIH1cbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25BZnRlckNyZWF0ZVJvdyA9IGZ1bmN0aW9uIChyb3csIGFtb3VudCwgc291cmNlKSB7XG4gICAgdGhpcy5zaGVldC5hbHRlck1hbmFnZXIuaW5zZXJ0Um93KHJvdywgYW1vdW50LCBzb3VyY2UgIT09ICd1bmRvJyk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQmVmb3JlUmVtb3ZlUm93ID0gZnVuY3Rpb24gKHJvdywgYW1vdW50KSB7XG4gICAgU3RvcmFnZS5zYXZlKCdyb3cnLCByb3csIGFtb3VudCk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQWZ0ZXJSZW1vdmVSb3cgPSBmdW5jdGlvbiAocm93LCBhbW91bnQpIHtcbiAgICB0aGlzLnNoZWV0LmFsdGVyTWFuYWdlci5yZW1vdmVSb3cocm93LCBhbW91bnQpO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkJlZm9yZUNyZWF0ZUNvbCA9IGZ1bmN0aW9uIChjb2x1bW4sIGFtb3VudCwgc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gJ3VuZG8nKSB7XG4gICAgICAgIHRoaXMudW5kb1JlZG9TbmFwc2hvdC5yZXN0b3JlKCk7XG4gICAgfVxufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkFmdGVyQ3JlYXRlQ29sID0gZnVuY3Rpb24gKGNvbHVtbiwgYW1vdW50LCBzb3VyY2UpIHtcbiAgICB0aGlzLnNoZWV0LmFsdGVyTWFuYWdlci5pbnNlcnRDb2x1bW4oY29sdW1uLCBhbW91bnQsIHNvdXJjZSAhPT0gJ3VuZG8nKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25CZWZvcmVSZW1vdmVDb2wgPSBmdW5jdGlvbiAoY29sdW1uLCBhbW91bnQpIHtcbiAgICBTdG9yYWdlLnNhdmUoJ2NvbHVtbicsIGNvbHVtbiwgYW1vdW50KTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25BZnRlclJlbW92ZUNvbCA9IGZ1bmN0aW9uIChjb2x1bW4sIGFtb3VudCkge1xuICAgIHRoaXMuc2hlZXQuYWx0ZXJNYW5hZ2VyLnJlbW92ZUNvbHVtbihjb2x1bW4sIGFtb3VudCk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQWZ0ZXJMb2FkRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9za2lwUmVuZGVyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlRnVsbCgpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tW2VuZF0gSG9va3NcblxuWEZvcm11bGFzLnByb3RvdHlwZS5nZXRDZWxsVmFsdWUgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICBjb25zdCBjZWxsID0gdGhpcy5zaGVldC5nZXRDZWxsQXQocm93LCBjb2x1bW4pO1xuICAgIHJldHVybiBjZWxsID8gKGNlbGwuZ2V0RXJyb3IoKSB8fCBjZWxsLmdldFZhbHVlKCkpIDogdm9pZCAwO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5oYXNDb21wdXRlZENlbGxWYWx1ZSA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgIHJldHVybiB0aGlzLnNoZWV0LmdldENlbGxBdChyb3csIGNvbHVtbikgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hlZXQucmVjYWxjdWxhdGUoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUucmVjYWxjdWxhdGVGdWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hlZXQucmVjYWxjdWxhdGVGdWxsKCk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLnJlY2FsY3VsYXRlT3B0aW1pemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hlZXQucmVjYWxjdWxhdGVPcHRpbWl6ZWQoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUuc2V0VmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLnNoZWV0LnNldFZhcmlhYmxlKG5hbWUsIHZhbHVlKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUuZ2V0VmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNoZWV0LmdldFZhcmlhYmxlKG5hbWUpO1xufTtcblxuSGFuZHNvbnRhYmxlLnBsdWdpbnMucmVnaXN0ZXJQbHVnaW4oJ3hGb3JtdWxhcycsIFhGb3JtdWxhcyk7XG5cbmV4cG9ydCB7WEZvcm11bGFzfTsiLCJpbXBvcnQge3RvVXBwZXJDYXNlRm9ybXVsYX0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge3RvTGFiZWwsIGV4dHJhY3RMYWJlbH0gZnJvbSAnLi9wYXJzZXIvdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGVycm9yLCBFUlJPUl9SRUZ9IGZyb20gJy4vcGFyc2VyL2Vycm9yJztcblxudmFyIGFycmF5RWFjaCA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlFYWNoO1xudmFyIGFycmF5RmlsdGVyID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUZpbHRlcjtcbnZhciBzdGFydHNXaXRoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5zdGFydHNXaXRoO1xudmFyIG1peGluID0gSGFuZHNvbnRhYmxlLmhlbHBlci5taXhpbjtcbnZhciBsb2NhbEhvb2tzID0gSGFuZHNvbnRhYmxlLnV0aWxzLmxvY2FsSG9va3M7IC8vIHByaXZhdGVcblxuY29uc3QgQkFSRV9DRUxMX1NUUklDVF9SRUdFWCA9IC9eXFwkP1tBLVpdK1xcJD9cXGQrJC87XG5jb25zdCBCQVJFX0NFTExfUkVHRVggPSAvXFwkP1tBLVpdK1xcJD9cXGQrLztcbmNvbnN0IENFTExfUkVHRVggPSAvKD86W14wLTlBLVokOiBdfF4pXFxzKihcXCQ/W0EtWl0rXFwkP1xcZCspXFxzKig/IVswLTlBLVpfOiBdKS9nO1xuY29uc3QgUkFOR0VfUkVHRVggPSAvXFwkP1tBLVpdK1xcJD9cXGQrXFxzKjpcXHMqXFwkP1tBLVpdK1xcJD9cXGQrL2c7XG5jb25zdCBDRUxMX0FORF9SQU5HRV9SRUdFWCA9IC8oKD86W14wLTlBLVokOiBdfF4pXFxzKihcXCQ/W0EtWl0rXFwkP1xcZCspXFxzKig/IVswLTlBLVpfOiBdKSl8KFxcJD9bQS1aXStcXCQ/XFxkK1xccyo6XFxzKlxcJD9bQS1aXStcXCQ/XFxkKykvZztcblxuXG5jbGFzcyBFeHByZXNzaW9uTW9kaWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb24pIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5b6F5L+u5pS555qE6KGo6L6+5byPXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSAnJztcblxuICAgICAgICB0aGlzLmNlbGxzID0gW107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5zZXRFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0RXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuY2VsbHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gdG9VcHBlckNhc2VGb3JtdWxhKGV4cHJlc3Npb24pO1xuXG4gICAgICAgIHRoaXMuX2V4dHJhY3RDZWxscygpO1xuICAgICAgICB0aGlzLl9leHRyYWN0Q2VsbHNSYW5nZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRyYW5zbGF0ZSh7cm93OiBiYXNlUm93LCBjb2x1bW46IGJhc2VDb2x1bW59LCB7cm93OiBkZWx0YVJvdywgY29sdW1uOiBkZWx0YUNvbHVtbn0pIHtcbiAgICAgICAgYXJyYXlFYWNoKHRoaXMuY2VsbHMsIChjZWxsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGVsdGFSb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIEV4cHJlc3Npb25Nb2RpZmllci5fdHJhbnNsYXRlQ2VsbChjZWxsLCAncm93JywgYmFzZVJvdywgZGVsdGFSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhQ29sdW1uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uTW9kaWZpZXIuX3RyYW5zbGF0ZUNlbGwoY2VsbCwgJ2NvbHVtbicsIGJhc2VDb2x1bW4sIGRlbHRhQ29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uLnJlcGxhY2UoQ0VMTF9BTkRfUkFOR0VfUkVHRVgsIChtYXRjaCwgcDEsIHAyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1NpbmdsZUNlbGwgPSBtYXRjaC5pbmRleE9mKCc6JykgPT09IC0xO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoO1xuICAgICAgICAgICAgbGV0IGNlbGxMYWJlbCA9IG1hdGNoO1xuICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZWRDZWxsTGFiZWwgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoaXNTaW5nbGVDZWxsKSB7XG4gICAgICAgICAgICAgICAgY2VsbExhYmVsID0gQkFSRV9DRUxMX1NUUklDVF9SRUdFWC50ZXN0KHAxKSA/IHAxIDogcDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5fc2VhcmNoQ2VsbChjZWxsTGFiZWwpO1xuXG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRDZWxsTGFiZWwgPSBjZWxsLnJlZkVycm9yID8gZXJyb3IoRVJST1JfUkVGKSA6IGNlbGwudG9MYWJlbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2luZ2xlQ2VsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRjaC5yZXBsYWNlKGNlbGxMYWJlbCwgdHJhbnNsYXRlZENlbGxMYWJlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJhbnNsYXRlZENlbGxMYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghc3RhcnRzV2l0aChleHByZXNzaW9uLCAnPScpKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gJz0nICsgZXhwcmVzc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cblxuICAgIHN0YXRpYyBfdHJhbnNsYXRlQ2VsbChjZWxsLCBwcm9wZXJ0eSwgYmFzZUluZGV4ID0gMCwgZGVsdGEgPSAwKSB7XG4gICAgICAgIGNvbnN0IHt0eXBlLCBzdGFydCwgZW5kfSA9IGNlbGw7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnRbcHJvcGVydHldLmluZGV4O1xuICAgICAgICBsZXQgZW5kSW5kZXggPSBlbmRbcHJvcGVydHldLmluZGV4O1xuICAgICAgICBsZXQgZGVsdGFTdGFydCA9IGRlbHRhO1xuICAgICAgICBsZXQgZGVsdGFFbmQgPSBkZWx0YTtcbiAgICAgICAgbGV0IHJlZkVycm9yID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGluZGV4T2Zmc2V0ID0gTWF0aC5hYnMoZGVsdGEpIC0gMTtcblxuICAgICAgICAvLyDlop7liqBcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgaWYgKGJhc2VJbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBkZWx0YVN0YXJ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYXNlSW5kZXggPiBlbmRJbmRleCkge1xuICAgICAgICAgICAgICAgIGRlbHRhRW5kID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8g5Yig6ZmkXG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA+PSBiYXNlSW5kZXggJiYgZW5kSW5kZXggPD0gYmFzZUluZGV4ICsgaW5kZXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZWZFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlZkVycm9yICYmIHR5cGUgPT09ICdjZWxsJykge1xuICAgICAgICAgICAgICAgIGlmIChiYXNlSW5kZXggPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFFbmQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVmRXJyb3IgJiYgdHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICAgICAgICAgIGlmIChiYXNlSW5kZXggPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VJbmRleCA+IGVuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhRW5kID0gMDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kSW5kZXggPD0gYmFzZUluZGV4ICsgaW5kZXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFFbmQgLT0gTWF0aC5taW4oZW5kSW5kZXggLSAoYmFzZUluZGV4ICsgaW5kZXhPZmZzZXQpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVsdGFTdGFydCAmJiAhcmVmRXJyb3IpIHtcbiAgICAgICAgICAgIHN0YXJ0W3Byb3BlcnR5XS5pbmRleCA9IE1hdGgubWF4KHN0YXJ0SW5kZXggKyBkZWx0YVN0YXJ0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGFFbmQgJiYgIXJlZkVycm9yKSB7XG4gICAgICAgICAgICBlbmRbcHJvcGVydHldLmluZGV4ID0gTWF0aC5tYXgoZW5kSW5kZXggKyBkZWx0YUVuZCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkVycm9yKSB7XG4gICAgICAgICAgICBjZWxsLnJlZkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9leHRyYWN0Q2VsbHMoKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmV4cHJlc3Npb24ubWF0Y2goQ0VMTF9SRUdFWCk7XG5cbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlFYWNoKG1hdGNoZXMsIChjb29yZCkgPT4ge1xuICAgICAgICAgICAgY29vcmQgPSBjb29yZC5tYXRjaChCQVJFX0NFTExfUkVHRVgpO1xuXG4gICAgICAgICAgICBpZiAoIWNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3JvdywgY29sdW1uXSA9IGV4dHJhY3RMYWJlbChjb29yZFswXSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2VsbHMucHVzaCh0aGlzLl9jcmVhdGVDZWxsKHtyb3csIGNvbHVtbn0sIHtyb3csIGNvbHVtbn0sIGNvb3JkWzBdKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9leHRyYWN0Q2VsbHNSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuZXhwcmVzc2lvbi5tYXRjaChSQU5HRV9SRUdFWCk7XG5cbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlFYWNoKG1hdGNoZXMsIChtYXRjaCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gbWF0Y2guc3BsaXQoJzonKTtcbiAgICAgICAgICAgIGNvbnN0IFtzdGFydFJvdywgc3RhcnRDb2x1bW5dID0gZXh0cmFjdExhYmVsKHN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IFtlbmRSb3csIGVuZENvbHVtbl0gPSBleHRyYWN0TGFiZWwoZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q2VsbCA9IHtcbiAgICAgICAgICAgICAgICByb3c6IHN0YXJ0Um93LFxuICAgICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRDb2x1bW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZW5kQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICByb3c6IGVuZFJvdyxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGVuZENvbHVtbixcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuY2VsbHMucHVzaCh0aGlzLl9jcmVhdGVDZWxsKHN0YXJ0Q2VsbCwgZW5kQ2VsbCwgbWF0Y2gpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBfc2VhcmNoQ2VsbChsYWJlbCkge1xuICAgICAgICBjb25zdCBbY2VsbF0gPSBhcnJheUZpbHRlcih0aGlzLmNlbGxzLCAoY2VsbCkgPT4gY2VsbC5vcmlnTGFiZWwgPT09IGxhYmVsKTtcblxuICAgICAgICByZXR1cm4gY2VsbCB8fCBudWxsO1xuICAgIH1cblxuICAgIF9jcmVhdGVDZWxsKHN0YXJ0LCBlbmQsIGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIG9yaWdMYWJlbDogbGFiZWwsXG4gICAgICAgICAgICB0eXBlOiBsYWJlbC5pbmRleE9mKCc6JykgPT09IC0xID8gJ2NlbGwnIDogJ3JhbmdlJyxcbiAgICAgICAgICAgIHJlZkVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIHRvTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IHRvTGFiZWwodGhpcy5zdGFydC5yb3csIHRoaXMuc3RhcnQuY29sdW1uKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYW5nZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgKz0gJzonICsgdG9MYWJlbCh0aGlzLmVuZC5yb3csIHRoaXMuZW5kLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxubWl4aW4oRXhwcmVzc2lvbk1vZGlmaWVyLCBsb2NhbEhvb2tzKTtcblxuZXhwb3J0IHtFeHByZXNzaW9uTW9kaWZpZXJ9OyIsImV4cG9ydCBjb25zdCBFUlJPUiA9ICdFUlJPUic7XG5leHBvcnQgY29uc3QgRVJST1JfRElWX1pFUk8gPSAnRElWLzAnO1xuZXhwb3J0IGNvbnN0IEVSUk9SX05BTUUgPSAnTkFNRSc7XG5leHBvcnQgY29uc3QgRVJST1JfTkVFRF9VUERBVEUgPSAnTkVFRF9VUERBVEUnO1xuZXhwb3J0IGNvbnN0IEVSUk9SX05PVF9BVkFJTEFCTEUgPSAnTi9BJztcbmV4cG9ydCBjb25zdCBFUlJPUl9OVUxMID0gJ05VTEwnO1xuZXhwb3J0IGNvbnN0IEVSUk9SX05VTSA9ICdOVU0nO1xuZXhwb3J0IGNvbnN0IEVSUk9SX1JFRiA9ICdSRUYnO1xuZXhwb3J0IGNvbnN0IEVSUk9SX1ZBTFVFID0gJ1ZBTFVFJztcblxuY29uc3QgZXJyb3JzID0ge1xuICBbRVJST1JdOiAnI0VSUk9SIScsXG4gIFtFUlJPUl9ESVZfWkVST106ICcjRElWLzAhJyxcbiAgW0VSUk9SX05BTUVdOiAnI05BTUU/JyxcbiAgW0VSUk9SX05FRURfVVBEQVRFXTogJyNORUVEX1VQREFURSEnLFxuICBbRVJST1JfTk9UX0FWQUlMQUJMRV06ICcjTi9BJyxcbiAgW0VSUk9SX05VTExdOiAnI05VTEwhJyxcbiAgW0VSUk9SX05VTV06ICcjTlVNIScsXG4gIFtFUlJPUl9SRUZdOiAnI1JFRiEnLFxuICBbRVJST1JfVkFMVUVdOiAnI1ZBTFVFISdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcbiAgbGV0IGVycm9yO1xuICB0eXBlID0gKHR5cGUgKyAnJykucmVwbGFjZSgvI3whfFxcPy9nLCAnJyk7XG5cbiAgaWYgKGVycm9yc1t0eXBlXSkge1xuICAgIGVycm9yID0gZXJyb3JzW3R5cGVdO1xuICB9XG4gIHJldHVybiBlcnJvciA/IGVycm9yIDogbnVsbDtcbn1cbiIsIi8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24gMC40LjE3ICovXG4vKlxuICBSZXR1cm5zIGEgUGFyc2VyIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcblxuICBQYXJzZXI6IHtcbiAgICB5eToge31cbiAgfVxuXG4gIFBhcnNlci5wcm90b3R5cGU6IHtcbiAgICB5eToge30sXG4gICAgdHJhY2U6IGZ1bmN0aW9uKCksXG4gICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICAgIHRlcm1pbmFsc186IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IG5hbWV9LFxuICAgIHByb2R1Y3Rpb25zXzogWy4uLl0sXG4gICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJCksXG4gICAgdGFibGU6IFsuLi5dLFxuICAgIGRlZmF1bHRBY3Rpb25zOiB7Li4ufSxcbiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCksXG5cbiAgICBsZXhlcjoge1xuICAgICAgICBFT0Y6IDEsXG4gICAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCksXG4gICAgICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAgICAgICAgbW9yZTogZnVuY3Rpb24oKSxcbiAgICAgICAgbGVzczogZnVuY3Rpb24obiksXG4gICAgICAgIHBhc3RJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCksXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIGxleDogZnVuY3Rpb24oKSxcbiAgICAgICAgYmVnaW46IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gICAgICAgIHBvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLFxuICAgICAgICB0b3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbihjb25kaXRpb24pLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJhbmdlczogYm9vbGVhbiAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiB0b2tlbiBsb2NhdGlvbiBpbmZvIHdpbGwgaW5jbHVkZSBhIC5yYW5nZVtdIG1lbWJlcilcbiAgICAgICAgICAgIGZsZXg6IGJvb2xlYW4gICAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZCBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaClcbiAgICAgICAgICAgIGJhY2t0cmFja19sZXhlcjogYm9vbGVhbiAgKG9wdGlvbmFsOiB0cnVlID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBlYWNoIG1hdGNoaW5nIHJlZ2V4IHRoZSBhY3Rpb24gY29kZSBpcyBpbnZva2VkOyB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlKVxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUKSxcbiAgICAgICAgcnVsZXM6IFsuLi5dLFxuICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAgICB9XG4gIH1cblxuXG4gIHRva2VuIGxvY2F0aW9uIGluZm8gKEAkLCBfJCwgZXRjLik6IHtcbiAgICBmaXJzdF9saW5lOiBuLFxuICAgIGxhc3RfbGluZTogbixcbiAgICBmaXJzdF9jb2x1bW46IG4sXG4gICAgbGFzdF9jb2x1bW46IG4sXG4gICAgcmFuZ2U6IFtzdGFydF9udW1iZXIsIGVuZF9udW1iZXJdICAgICAgICh3aGVyZSB0aGUgbnVtYmVycyBhcmUgaW5kZXhlcyBpbnRvIHRoZSBpbnB1dCBzdHJpbmcsIHJlZ3VsYXIgemVyby1iYXNlZClcbiAgfVxuXG5cbiAgdGhlIHBhcnNlRXJyb3IgZnVuY3Rpb24gcmVjZWl2ZXMgYSAnaGFzaCcgb2JqZWN0IHdpdGggdGhlc2UgbWVtYmVycyBmb3IgbGV4ZXIgYW5kIHBhcnNlciBlcnJvcnM6IHtcbiAgICB0ZXh0OiAgICAgICAgKG1hdGNoZWQgdGV4dClcbiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gIH1cbiAgd2hpbGUgcGFyc2VyIChncmFtbWFyKSBlcnJvcnMgd2lsbCBhbHNvIHByb3ZpZGUgdGhlc2UgbWVtYmVycywgaS5lLiBwYXJzZXIgZXJyb3JzIGRlbGl2ZXIgYSBzdXBlcnNldCBvZiBhdHRyaWJ1dGVzOiB7XG4gICAgbG9jOiAgICAgICAgICh5eWxsb2MpXG4gICAgZXhwZWN0ZWQ6ICAgIChzdHJpbmcgZGVzY3JpYmluZyB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucylcbiAgICByZWNvdmVyYWJsZTogKGJvb2xlYW46IFRSVUUgd2hlbiB0aGUgcGFyc2VyIGhhcyBhIGVycm9yIHJlY292ZXJ5IHJ1bGUgYXZhaWxhYmxlIGZvciB0aGlzIHBhcnRpY3VsYXIgZXJyb3IpXG4gIH1cbiovXG52YXIgZ3JhbW1hciA9IChmdW5jdGlvbigpe1xudmFyIG89ZnVuY3Rpb24oayx2LG8sbCl7Zm9yKG89b3x8e30sbD1rLmxlbmd0aDtsLS07b1trW2xdXT12KTtyZXR1cm4gb30sJFYwPVsxLDVdLCRWMT1bMSw4XSwkVjI9WzEsNl0sJFYzPVsxLDddLCRWND1bMSw5XSwkVjU9WzEsMTVdLCRWNj1bMSwxNl0sJFY3PVsxLDE3XSwkVjg9WzEsMThdLCRWOT1bMSwxM10sJFZhPVsxLDE0XSwkVmI9WzEsMTldLCRWYz1bMSwyMV0sJFZkPVsxLDIyXSwkVmU9WzEsMjNdLCRWZj1bMSwyNF0sJFZnPVsxLDI1XSwkVmg9WzEsMjZdLCRWaT1bMSwyN10sJFZqPVsxLDI4XSwkVms9WzEsMjldLCRWbD1bMSwzMF0sJFZtPVs1LDksMTAsMTEsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMzIsMzNdLCRWbj1bNSw5LDEwLDExLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDMyLDMzLDM1XSwkVm89WzEsMzldLCRWcD1bNSw5LDEwLDExLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDMyLDMzLDM3XSwkVnE9WzUsMTAsMTEsMTMsMTQsMTUsMTYsMTcsMzIsMzNdLCRWcj1bNSwxMCwxMywxNCwxNSwxNiwzMiwzM10sJFZzPVs1LDEwLDExLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDMyLDMzXSwkVnQ9WzEzLDMyLDMzXSwkVnU9WzUsOSwxMCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwzMiwzMywzNCwzOF07XG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCJlcnJvclwiOjIsXCJleHByZXNzaW9uc1wiOjMsXCJleHByZXNzaW9uXCI6NCxcIkVPRlwiOjUsXCJ2YXJpYWJsZVNlcXVlbmNlXCI6NixcIm51bWJlclwiOjcsXCJTVFJJTkdcIjo4LFwiJlwiOjksXCI9XCI6MTAsXCIrXCI6MTEsXCIoXCI6MTIsXCIpXCI6MTMsXCI8XCI6MTQsXCI+XCI6MTUsXCJOT1RcIjoxNixcIi1cIjoxNyxcIipcIjoxOCxcIi9cIjoxOSxcIl5cIjoyMCxcIkZVTkNUSU9OXCI6MjEsXCJleHBzZXFcIjoyMixcInNoZWV0XCI6MjMsXCJjZWxsXCI6MjQsXCJTSEVFVF9OQU1FXCI6MjUsXCIhXCI6MjYsXCJBQlNPTFVURV9DRUxMXCI6MjcsXCJSRUxBVElWRV9DRUxMXCI6MjgsXCJNSVhFRF9DRUxMXCI6MjksXCI6XCI6MzAsXCJBUlJBWVwiOjMxLFwiO1wiOjMyLFwiLFwiOjMzLFwiVkFSSUFCTEVcIjozNCxcIkRFQ0lNQUxcIjozNSxcIk5VTUJFUlwiOjM2LFwiJVwiOjM3LFwiI1wiOjM4LFwiJGFjY2VwdFwiOjAsXCIkZW5kXCI6MX0sXG50ZXJtaW5hbHNfOiB7NTpcIkVPRlwiLDg6XCJTVFJJTkdcIiw5OlwiJlwiLDEwOlwiPVwiLDExOlwiK1wiLDEyOlwiKFwiLDEzOlwiKVwiLDE0OlwiPFwiLDE1OlwiPlwiLDE2OlwiTk9UXCIsMTc6XCItXCIsMTg6XCIqXCIsMTk6XCIvXCIsMjA6XCJeXCIsMjE6XCJGVU5DVElPTlwiLDI1OlwiU0hFRVRfTkFNRVwiLDI2OlwiIVwiLDI3OlwiQUJTT0xVVEVfQ0VMTFwiLDI4OlwiUkVMQVRJVkVfQ0VMTFwiLDI5OlwiTUlYRURfQ0VMTFwiLDMwOlwiOlwiLDMxOlwiQVJSQVlcIiwzMjpcIjtcIiwzMzpcIixcIiwzNDpcIlZBUklBQkxFXCIsMzU6XCJERUNJTUFMXCIsMzY6XCJOVU1CRVJcIiwzNzpcIiVcIiwzODpcIiNcIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDJdLFs0LDFdLFs0LDFdLFs0LDFdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDJdLFs0LDJdLFs0LDNdLFs0LDRdLFs0LDFdLFs0LDFdLFs0LDFdLFs0LDJdLFsyMywzXSxbMjMsM10sWzIzLDNdLFsyMyw1XSxbMjMsNV0sWzIzLDVdLFsyMyw1XSxbMjMsNV0sWzIzLDVdLFsyMyw1XSxbMjMsNV0sWzIzLDVdLFsyNCwxXSxbMjQsMV0sWzI0LDFdLFsyNCwzXSxbMjQsM10sWzI0LDNdLFsyNCwzXSxbMjQsM10sWzI0LDNdLFsyNCwzXSxbMjQsM10sWzI0LDNdLFsyMiwxXSxbMjIsMV0sWzIyLDNdLFsyMiwzXSxbNiwxXSxbNiwzXSxbNywxXSxbNywzXSxbNywyXSxbMiwzXSxbMiw0XV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLywgXyQgLyogbHN0YWNrICovKSB7XG4vKiB0aGlzID09IHl5dmFsICovXG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTpcblxuICAgICAgICByZXR1cm4gJCRbJDAtMV07XG4gICAgXG5icmVhaztcbmNhc2UgMjpcblxuICAgICAgICB0aGlzLiQgPSB5eS5jYWxsVmFyaWFibGUoJCRbJDBdWzBdKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDM6XG5cbiAgICAgICAgdGhpcy4kID0geXkudG9OdW1iZXIoJCRbJDBdKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDQ6XG5cbiAgICAgICAgdGhpcy4kID0geXkudHJpbUVkZ2VzKCQkWyQwXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSA1OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignJicsIFskJFskMC0yXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSA2OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignPScsIFskJFskMC0yXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSA3OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignKycsIFskJFskMC0yXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSA4OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LnRvTnVtYmVyKCQkWyQwLTFdKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDk6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCc8PScsIFskJFskMC0zXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAxMDpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJz49JywgWyQkWyQwLTNdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDExOlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignPD4nLCBbJCRbJDAtM10sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTI6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCdOT1QnLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTM6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCc+JywgWyQkWyQwLTJdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDE0OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignPCcsIFskJFskMC0yXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAxNTpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJy0nLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTY6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCcqJywgWyQkWyQwLTJdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDE3OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignLycsIFskJFskMC0yXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAxODpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJ14nLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTk6XG5cbiAgICAgICAgdmFyIG4xID0geXkuaW52ZXJ0TnVtYmVyKCQkWyQwXSk7XG4gICAgICAgIHRoaXMuJCA9IG4xO1xuICAgICAgICBpZiAoaXNOYU4odGhpcy4kKSkge1xuICAgICAgICAgICAgdGhpcy4kID0gMDtcbiAgICAgICAgfVxuICAgICAgXG5icmVhaztcbmNhc2UgMjA6XG5cbiAgICAgICAgdmFyIG4xID0geXkudG9OdW1iZXIoJCRbJDBdKTtcbiAgICAgICAgdGhpcy4kID0gbjE7XG4gICAgICAgIGlmIChpc05hTih0aGlzLiQpKSB7XG4gICAgICAgICAgICB0aGlzLiQgPSAwO1xuICAgICAgICB9XG4gICAgICBcbmJyZWFrO1xuY2FzZSAyMTpcblxuICAgICAgICB0aGlzLiQgPSB5eS5jYWxsRnVuY3Rpb24oJCRbJDAtMl0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMjI6XG5cbiAgICAgICAgdGhpcy4kID0geXkuY2FsbEZ1bmN0aW9uKCQkWyQwLTNdLCAkJFskMC0xXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAyNzogY2FzZSAyODogY2FzZSAyOTpcblxuICAgICAgdGhpcy4kID0geXkuY2VsbFZhbHVlSW5TaGVldCgkJFskMC0yXSwgJCRbJDBdKTtcbiAgICBcbmJyZWFrO1xuY2FzZSAzMDogY2FzZSAzMTogY2FzZSAzMjogY2FzZSAzMzogY2FzZSAzNDogY2FzZSAzNTogY2FzZSAzNjogY2FzZSAzNzogY2FzZSAzODpcblxuICAgICAgdGhpcy4kID0geXkucmFuZ2VWYWx1ZUluU2hlZXQoJCRbJDAtNF0sICQkWyQwLTJdLCAkJFskMF0pO1xuICAgIFxuYnJlYWs7XG5jYXNlIDM5OiBjYXNlIDQwOiBjYXNlIDQxOlxuXG4gICAgICB0aGlzLiQgPSB5eS5jZWxsVmFsdWUoJCRbJDBdKTtcbiAgICBcbmJyZWFrO1xuY2FzZSA0MjogY2FzZSA0MzogY2FzZSA0NDogY2FzZSA0NTogY2FzZSA0NjogY2FzZSA0NzogY2FzZSA0ODogY2FzZSA0OTogY2FzZSA1MDpcblxuICAgICAgdGhpcy4kID0geXkucmFuZ2VWYWx1ZSgkJFskMC0yXSwgJCRbJDBdKTtcbiAgICBcbmJyZWFrO1xuY2FzZSA1MTogY2FzZSA1NTpcblxuICAgICAgdGhpcy4kID0gWyQkWyQwXV07XG4gICAgXG5icmVhaztcbmNhc2UgNTI6XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBhcnIgPSBldmFsKFwiW1wiICsgeXl0ZXh0ICsgXCJdXCIpO1xuXG4gICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJCA9IHJlc3VsdDtcbiAgICBcbmJyZWFrO1xuY2FzZSA1MzogY2FzZSA1NDpcblxuICAgICAgJCRbJDAtMl0ucHVzaCgkJFskMF0pO1xuICAgICAgdGhpcy4kID0gJCRbJDAtMl07XG4gICAgXG5icmVhaztcbmNhc2UgNTY6XG5cbiAgICAgIHRoaXMuJCA9IChBcnJheS5pc0FycmF5KCQkWyQwLTJdKSA/ICQkWyQwLTJdIDogWyQkWyQwLTJdXSk7XG4gICAgICB0aGlzLiQucHVzaCgkJFskMF0pO1xuICAgIFxuYnJlYWs7XG5jYXNlIDU3OlxuXG4gICAgICB0aGlzLiQgPSAkJFskMF07XG4gICAgXG5icmVhaztcbmNhc2UgNTg6XG5cbiAgICAgIHRoaXMuJCA9ICgkJFskMC0yXSArICcuJyArICQkWyQwXSkgKiAxO1xuICAgIFxuYnJlYWs7XG5jYXNlIDU5OlxuXG4gICAgICB0aGlzLiQgPSAkJFskMC0xXSAqIDAuMDE7XG4gICAgXG5icmVhaztcbmNhc2UgNjA6IGNhc2UgNjE6XG5cbiAgICAgIHRoaXMuJCA9IHl5LnRocm93RXJyb3IoJCRbJDAtMl0gKyAkJFskMC0xXSArICQkWyQwXSk7XG4gICAgXG5icmVhaztcbn1cbn0sXG50YWJsZTogW3syOjEyLDM6MSw0OjIsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MTpbM119LHs1OlsxLDIwXSw5OiRWYywxMDokVmQsMTE6JFZlLDE0OiRWZiwxNTokVmcsMTY6JFZoLDE3OiRWaSwxODokVmosMTk6JFZrLDIwOiRWbH0sbygkVm0sWzIsMl0sezM1OlsxLDMxXX0pLG8oJFZtLFsyLDNdLHszNzpbMSwzMl19KSxvKCRWbSxbMiw0XSksezI6MTIsNDozMyw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6MzQsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjM1LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezEyOlsxLDM2XX0sbygkVm0sWzIsMjNdKSxvKCRWbSxbMiwyNF0pLG8oJFZtLFsyLDI1XSx7MjozNywzNDpbMSwzOF0sMzg6JFZifSksbygkVm4sWzIsNTVdLHszODokVm99KSxvKCRWcCxbMiw1N10sezM1OlsxLDQwXX0pLHsyNjpbMSw0MV19LG8oJFZtLFsyLDM5XSx7MzA6WzEsNDJdfSksbygkVm0sWzIsNDBdLHszMDpbMSw0M119KSxvKCRWbSxbMiw0MV0sezMwOlsxLDQ0XX0pLHszNDpbMSw0NV19LHsxOlsyLDFdfSx7MjoxMiw0OjQ2LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo0Nyw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6NDgsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjUxLDY6Myw3OjQsODokVjAsMTA6WzEsNDldLDExOiRWMSwxMjokVjIsMTU6WzEsNTBdLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjUzLDY6Myw3OjQsODokVjAsMTA6WzEsNTJdLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6NTQsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjU1LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo1Niw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6NTcsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjU4LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezM0OlsxLDU5XX0sbygkVnAsWzIsNTldKSx7OTokVmMsMTA6JFZkLDExOiRWZSwxMzpbMSw2MF0sMTQ6JFZmLDE1OiRWZywxNjokVmgsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSxvKCRWcSxbMiwxOV0sezk6JFZjLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnEsWzIsMjBdLHs5OiRWYywxODokVmosMTk6JFZrLDIwOiRWbH0pLHsyOjEyLDQ6NjMsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDEzOlsxLDYxXSwxNzokVjMsMjE6JFY0LDIyOjYyLDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzMTpbMSw2NF0sMzQ6JFY5LDM2OiRWYSwzODokVmJ9LG8oJFZtLFsyLDI2XSksezM4OiRWb30sezM0OlsxLDY1XX0sezM2OlsxLDY2XX0sezI3OlsxLDY3XSwyODpbMSw2OF0sMjk6WzEsNjldfSx7Mjc6WzEsNzBdLDI4OlsxLDcxXSwyOTpbMSw3Ml19LHsyNzpbMSw3M10sMjg6WzEsNzRdLDI5OlsxLDc1XX0sezI3OlsxLDc2XSwyODpbMSw3N10sMjk6WzEsNzhdfSx7MjY6WzEsNzldfSxvKCRWbSxbMiw1XSksbyhbNSwxMCwxMywzMiwzM10sWzIsNl0sezk6JFZjLDExOiRWZSwxNDokVmYsMTU6JFZnLDE2OiRWaCwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWcSxbMiw3XSx7OTokVmMsMTg6JFZqLDE5OiRWaywyMDokVmx9KSx7MjoxMiw0OjgwLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo4MSw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LG8oJFZyLFsyLDE0XSx7OTokVmMsMTE6JFZlLDE3OiRWaSwxODokVmosMTk6JFZrLDIwOiRWbH0pLHsyOjEyLDQ6ODIsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSxvKCRWcixbMiwxM10sezk6JFZjLDExOiRWZSwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKFs1LDEwLDEzLDE2LDMyLDMzXSxbMiwxMl0sezk6JFZjLDExOiRWZSwxNDokVmYsMTU6JFZnLDE3OiRWaSwxODokVmosMTk6JFZrLDIwOiRWbH0pLG8oJFZxLFsyLDE1XSx7OTokVmMsMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWcyxbMiwxNl0sezk6JFZjLDIwOiRWbH0pLG8oJFZzLFsyLDE3XSx7OTokVmMsMjA6JFZsfSksbyhbNSwxMCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwzMiwzM10sWzIsMThdLHs5OiRWY30pLG8oJFZuLFsyLDU2XSksbygkVm0sWzIsOF0pLG8oJFZtLFsyLDIxXSksezEzOlsxLDgzXSwzMjpbMSw4NF0sMzM6WzEsODVdfSxvKCRWdCxbMiw1MV0sezk6JFZjLDEwOiRWZCwxMTokVmUsMTQ6JFZmLDE1OiRWZywxNjokVmgsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnQsWzIsNTJdKSx7MjY6WzEsODZdfSxvKCRWcCxbMiw1OF0pLG8oJFZtLFsyLDI3XSx7MzA6WzEsODddfSksbygkVm0sWzIsMjhdLHszMDpbMSw4OF19KSxvKCRWbSxbMiwyOV0sezMwOlsxLDg5XX0pLG8oJFZtLFsyLDQyXSksbygkVm0sWzIsNDNdKSxvKCRWbSxbMiw0NF0pLG8oJFZtLFsyLDQ1XSksbygkVm0sWzIsNDZdKSxvKCRWbSxbMiw0N10pLG8oJFZtLFsyLDQ4XSksbygkVm0sWzIsNDldKSxvKCRWbSxbMiw1MF0pLG8oJFZ1LFsyLDYwXSksbygkVnIsWzIsOV0sezk6JFZjLDExOiRWZSwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWcixbMiwxMV0sezk6JFZjLDExOiRWZSwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWcixbMiwxMF0sezk6JFZjLDExOiRWZSwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWbSxbMiwyMl0pLHsyOjEyLDQ6OTAsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjkxLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sbygkVnUsWzIsNjFdKSx7Mjc6WzEsOTJdLDI4OlsxLDkzXSwyOTpbMSw5NF19LHsyNzpbMSw5NV0sMjg6WzEsOTZdLDI5OlsxLDk3XX0sezI3OlsxLDk4XSwyODpbMSw5OV0sMjk6WzEsMTAwXX0sbygkVnQsWzIsNTNdLHs5OiRWYywxMDokVmQsMTE6JFZlLDE0OiRWZiwxNTokVmcsMTY6JFZoLDE3OiRWaSwxODokVmosMTk6JFZrLDIwOiRWbH0pLG8oJFZ0LFsyLDU0XSx7OTokVmMsMTA6JFZkLDExOiRWZSwxNDokVmYsMTU6JFZnLDE2OiRWaCwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWbSxbMiwzMF0pLG8oJFZtLFsyLDMxXSksbygkVm0sWzIsMzJdKSxvKCRWbSxbMiwzM10pLG8oJFZtLFsyLDM0XSksbygkVm0sWzIsMzVdKSxvKCRWbSxbMiwzNl0pLG8oJFZtLFsyLDM3XSksbygkVm0sWzIsMzhdKV0sXG5kZWZhdWx0QWN0aW9uczogezIwOlsyLDFdfSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmN0aW9uIF9wYXJzZUVycm9yIChtc2csIGhhc2gpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgX3BhcnNlRXJyb3IucHJvdG90eXBlID0gRXJyb3I7XG5cbiAgICAgICAgdGhyb3cgbmV3IF9wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgfVxufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgc3RhY2sgPSBbMF0sXG4gICAgICAgIHRzdGFjayA9IFtdLCAvLyB0b2tlbiBzdGFja1xuICAgICAgICB2c3RhY2sgPSBbbnVsbF0sIC8vIHNlbWFudGljIHZhbHVlIHN0YWNrXG4gICAgICAgIGxzdGFjayA9IFtdLCAvLyBsb2NhdGlvbiBzdGFja1xuICAgICAgICB0YWJsZSA9IHRoaXMudGFibGUsXG4gICAgICAgIHl5dGV4dCA9ICcnLFxuICAgICAgICB5eWxpbmVubyA9IDAsXG4gICAgICAgIHl5bGVuZyA9IDAsXG4gICAgICAgIHJlY292ZXJpbmcgPSAwLFxuICAgICAgICBURVJST1IgPSAyLFxuICAgICAgICBFT0YgPSAxO1xuXG4gICAgdmFyIGFyZ3MgPSBsc3RhY2suc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgLy90aGlzLnJlZHVjdGlvbkNvdW50ID0gdGhpcy5zaGlmdENvdW50ID0gMDtcblxuICAgIHZhciBsZXhlciA9IE9iamVjdC5jcmVhdGUodGhpcy5sZXhlcik7XG4gICAgdmFyIHNoYXJlZFN0YXRlID0geyB5eToge30gfTtcbiAgICAvLyBjb3B5IHN0YXRlXG4gICAgZm9yICh2YXIgayBpbiB0aGlzLnl5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgIHNoYXJlZFN0YXRlLnl5W2tdID0gdGhpcy55eVtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXhlci5zZXRJbnB1dChpbnB1dCwgc2hhcmVkU3RhdGUueXkpO1xuICAgIHNoYXJlZFN0YXRlLnl5LmxleGVyID0gbGV4ZXI7XG4gICAgc2hhcmVkU3RhdGUueXkucGFyc2VyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGxleGVyLnl5bGxvYyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsZXhlci55eWxsb2MgPSB7fTtcbiAgICB9XG4gICAgdmFyIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgIGxzdGFjay5wdXNoKHl5bG9jKTtcblxuICAgIHZhciByYW5nZXMgPSBsZXhlci5vcHRpb25zICYmIGxleGVyLm9wdGlvbnMucmFuZ2VzO1xuXG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wU3RhY2sgKG4pIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICAgICAgbHN0YWNrLmxlbmd0aCA9IGxzdGFjay5sZW5ndGggLSBuO1xuICAgIH1cblxuX3Rva2VuX3N0YWNrOlxuICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgdG9rZW4gPSBsZXhlci5sZXgoKSB8fCBFT0Y7XG4gICAgICAgIC8vIGlmIHRva2VuIGlzbid0IGl0cyBudW1lcmljIHZhbHVlLCBjb252ZXJ0XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICB2YXIgc3ltYm9sLCBwcmVFcnJvclN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgYSwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gcmV0cmVpdmUgc3RhdGUgbnVtYmVyIGZyb20gdG9wIG9mIHN0YWNrXG4gICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgLy8gdXNlIGRlZmF1bHQgYWN0aW9ucyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVhZCBhY3Rpb24gZm9yIGN1cnJlbnQgc3RhdGUgYW5kIGZpcnN0IGlucHV0XG4gICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgIH1cblxuX2hhbmRsZV9lcnJvcjpcbiAgICAgICAgLy8gaGFuZGxlIHBhcnNlIGVycm9yXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JfcnVsZV9kZXB0aDtcbiAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJztcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBydWxlIHN0YWNrIGRlcHRoIHdoZXJlIHRoZSBuZWFyZXN0IGVycm9yIHJ1bGUgY2FuIGJlIGZvdW5kLlxuICAgICAgICAgICAgLy8gUmV0dXJuIEZBTFNFIHdoZW4gbm8gZXJyb3IgcmVjb3ZlcnkgcnVsZSB3YXMgZm91bmQuXG4gICAgICAgICAgICBmdW5jdGlvbiBsb2NhdGVOZWFyZXN0RXJyb3JSZWNvdmVyeVJ1bGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tfcHJvYmUgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gcmVjb3ZlciBmcm9tIGVycm9yXG4gICAgICAgICAgICAgICAgZm9yKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBlcnJvciByZWNvdmVyeSBydWxlIGluIHRoaXMgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKChURVJST1IudG9TdHJpbmcoKSkgaW4gdGFibGVbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAwIHx8IHN0YWNrX3Byb2JlIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBzdWl0YWJsZSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFja19wcm9iZSAtPSAyOyAvLyBwb3BTdGFjaygxKTogW3N5bWJvbCwgYWN0aW9uXVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrX3Byb2JlXTtcbiAgICAgICAgICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmVjb3ZlcmluZykge1xuICAgICAgICAgICAgICAgIC8vIGZpcnN0IHNlZSBpZiB0aGVyZSdzIGFueSBjaGFuY2UgYXQgaGl0dGluZyBhbiBlcnJvciByZWNvdmVyeSBydWxlOlxuICAgICAgICAgICAgICAgIGVycm9yX3J1bGVfZGVwdGggPSBsb2NhdGVOZWFyZXN0RXJyb3JSZWNvdmVyeVJ1bGUoc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwb3J0IGVycm9yXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHAgaW4gdGFibGVbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IFRFUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaChcIidcIit0aGlzLnRlcm1pbmFsc19bcF0rXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJysoeXlsaW5lbm8rMSkrXCI6XFxuXCIrbGV4ZXIuc2hvd1Bvc2l0aW9uKCkrXCJcXG5FeHBlY3RpbmcgXCIrZXhwZWN0ZWQuam9pbignLCAnKSArIFwiLCBnb3QgJ1wiICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkrIFwiJ1wiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcrKHl5bGluZW5vKzEpK1wiOiBVbmV4cGVjdGVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3ltYm9sID09IEVPRiA/IFwiZW5kIG9mIGlucHV0XCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIidcIisodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKStcIidcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcbiAgICAgICAgICAgICAgICAgICAgbG9jOiB5eWxvYyxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICByZWNvdmVyYWJsZTogKGVycm9yX3J1bGVfZGVwdGggIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVFcnJvclN5bWJvbCAhPT0gRU9GKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JfcnVsZV9kZXB0aCA9IGxvY2F0ZU5lYXJlc3RFcnJvclJlY292ZXJ5UnVsZShzdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGp1c3QgcmVjb3ZlcmVkIGZyb20gYW5vdGhlciBlcnJvclxuICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPT0gMykge1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IEVPRiB8fCBwcmVFcnJvclN5bWJvbCA9PT0gRU9GKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJTdHIgfHwgJ1BhcnNpbmcgaGFsdGVkIHdoaWxlIHN0YXJ0aW5nIHRvIHJlY292ZXIgZnJvbSBhbm90aGVyIGVycm9yLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgY3VycmVudCBsb29rYWhlYWQgYW5kIGdyYWIgYW5vdGhlclxuICAgICAgICAgICAgICAgIHl5bGVuZyA9IGxleGVyLnl5bGVuZztcbiAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm8gPSBsZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdHJ5IHRvIHJlY292ZXIgZnJvbSBlcnJvclxuICAgICAgICAgICAgaWYgKGVycm9yX3J1bGVfZGVwdGggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyclN0ciB8fCAnUGFyc2luZyBoYWx0ZWQuIE5vIHN1aXRhYmxlIGVycm9yIHJlY292ZXJ5IHJ1bGUgYXZhaWxhYmxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9wU3RhY2soZXJyb3JfcnVsZV9kZXB0aCk7XG5cbiAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gKHN5bWJvbCA9PSBURVJST1IgPyBudWxsIDogc3ltYm9sKTsgLy8gc2F2ZSB0aGUgbG9va2FoZWFkIHRva2VuXG4gICAgICAgICAgICBzeW1ib2wgPSBURVJST1I7ICAgICAgICAgLy8gaW5zZXJ0IGdlbmVyaWMgZXJyb3Igc3ltYm9sIGFzIG5ldyBsb29rYWhlYWRcbiAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdO1xuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtURVJST1JdO1xuICAgICAgICAgICAgcmVjb3ZlcmluZyA9IDM7IC8vIGFsbG93IDMgcmVhbCBzeW1ib2xzIHRvIGJlIHNoaWZ0ZWQgYmVmb3JlIHJlcG9ydGluZyBhIG5ldyBlcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuLCB1bmxlc3MgcmVzb2x2ZSBkZWZhdWx0cyBhcmUgb2ZmXG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJytzdGF0ZSsnLCB0b2tlbjogJytzeW1ib2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgIGNhc2UgMTogLy8gc2hpZnRcbiAgICAgICAgICAgICAgICAvL3RoaXMuc2hpZnRDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICAgICAgbHN0YWNrLnB1c2gobGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7IC8vIHB1c2ggc3RhdGVcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJlRXJyb3JTeW1ib2wpIHsgLy8gbm9ybWFsIGV4ZWN1dGlvbi9ubyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB5eWxlbmcgPSBsZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgICAgICAgICAgeXlsaW5lbm8gPSBsZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3IganVzdCBvY2N1cnJlZCwgcmVzdW1lIG9sZCBsb29rYWhlYWQgZi8gYmVmb3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgLy8gcmVkdWNlXG4gICAgICAgICAgICAgICAgLy90aGlzLnJlZHVjdGlvbkNvdW50Kys7XG5cbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuXG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybSBzZW1hbnRpYyBhY3Rpb25cbiAgICAgICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGgtbGVuXTsgLy8gZGVmYXVsdCB0byAkJCA9ICQxXG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBsb2NhdGlvbiwgdXNlcyBmaXJzdCB0b2tlbiBmb3IgZmlyc3RzLCBsYXN0IGZvciBsYXN0c1xuICAgICAgICAgICAgICAgIHl5dmFsLl8kID0ge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aC0obGVufHwxKV0uZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aC0xXS5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGgtKGxlbnx8MSldLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoLTFdLmxhc3RfY29sdW1uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtsc3RhY2tbbHN0YWNrLmxlbmd0aC0obGVufHwxKV0ucmFuZ2VbMF0sIGxzdGFja1tsc3RhY2subGVuZ3RoLTFdLnJhbmdlWzFdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5hcHBseSh5eXZhbCwgW3l5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgc2hhcmVkU3RhdGUueXksIGFjdGlvblsxXSwgdnN0YWNrLCBsc3RhY2tdLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBvcCBvZmYgc3RhY2tcbiAgICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwtMSpsZW4qMik7XG4gICAgICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSpsZW4pO1xuICAgICAgICAgICAgICAgICAgICBsc3RhY2sgPSBsc3RhY2suc2xpY2UoMCwgLTEqbGVuKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pOyAgICAvLyBwdXNoIG5vbnRlcm1pbmFsIChyZWR1Y2UpXG4gICAgICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICAgICAgbHN0YWNrLnB1c2goeXl2YWwuXyQpO1xuICAgICAgICAgICAgICAgIC8vIGdvdG8gbmV3IHN0YXRlID0gdGFibGVbU1RBVEVdW05PTlRFUk1JTkFMXVxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoLTJdXVtzdGFja1tzdGFjay5sZW5ndGgtMV1dO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgLy8gYWNjZXB0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufX07XG5cbi8qIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC4zLjQgKi9cbnZhciBsZXhlciA9IChmdW5jdGlvbigpe1xudmFyIGxleGVyID0gKHtcblxuRU9GOjEsXG5cbnBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyKSB7XG4gICAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJlc2V0cyB0aGUgbGV4ZXIsIHNldHMgbmV3IGlucHV0XG5zZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQsIHl5KSB7XG4gICAgICAgIHRoaXMueXkgPSB5eSB8fCB0aGlzLnl5IHx8IHt9O1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fYmFja3RyYWNrID0gdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMueXlsaW5lbm8gPSB0aGlzLnl5bGVuZyA9IDA7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gWydJTklUSUFMJ107XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgICAgIGxhc3RfbGluZTogMSxcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLDBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gY29uc3VtZXMgYW5kIHJldHVybnMgb25lIGNoYXIgZnJvbSB0aGUgaW5wdXRcbmlucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcblxuLy8gdW5zaGlmdHMgb25lIGNoYXIgKG9yIGEgc3RyaW5nKSBpbnRvIHRoZSBpbnB1dFxudW5wdXQ6ZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pO1xuICAgICAgICAvL3RoaXMueXlsZW5nIC09IGxlbjtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcblxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XG5cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAobGluZXMubGVuZ3RoID09PSBvbGRMaW5lcy5sZW5ndGggPyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gOiAwKVxuICAgICAgICAgICAgICAgICArIG9sZExpbmVzW29sZExpbmVzLmxlbmd0aCAtIGxpbmVzLmxlbmd0aF0ubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIC0gbGVuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBjYWNoZXMgbWF0Y2hlZCB0ZXh0IGFuZCBhcHBlbmRzIGl0IG9uIG5leHQgYWN0aW9uXG5tb3JlOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBzaWduYWxzIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZSBuZXh0IG1hdGNoaW5nIHJ1bGUgKHJlZ2V4KSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG5yZWplY3Q6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFlvdSBjYW4gb25seSBpbnZva2UgcmVqZWN0KCkgaW4gdGhlIGxleGVyIHdoZW4gdGhlIGxleGVyIGlzIG9mIHRoZSBiYWNrdHJhY2tpbmcgcGVyc3Vhc2lvbiAob3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIgPSB0cnVlKS5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyByZXRhaW4gZmlyc3QgbiBjaGFyYWN0ZXJzIG9mIHRoZSBtYXRjaFxubGVzczpmdW5jdGlvbiAobikge1xuICAgICAgICB0aGlzLnVucHV0KHRoaXMubWF0Y2guc2xpY2UobikpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIGFscmVhZHkgbWF0Y2hlZCBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnBhc3RJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXN0ID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gdGhpcy5tYXRjaC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHBhc3QubGVuZ3RoID4gMjAgPyAnLi4uJzonJykgKyBwYXN0LnN1YnN0cigtMjApLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB1cGNvbWluZyBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnVwY29taW5nSW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XG4gICAgICAgIGlmIChuZXh0Lmxlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMC1uZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuZXh0LnN1YnN0cigwLDIwKSArIChuZXh0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZSBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5zaG93UG9zaXRpb246ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xuICAgICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KCkgKyBcIlxcblwiICsgYyArIFwiXlwiO1xuICAgIH0sXG5cbi8vIHRlc3QgdGhlIGxleGVkIHRva2VuOiByZXR1cm4gRkFMU0Ugd2hlbiBub3QgYSBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiB0b2tlblxudGVzdF9tYXRjaDpmdW5jdGlvbiAobWF0Y2gsIGluZGV4ZWRfcnVsZSkge1xuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgIGJhY2t1cDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgLy8gc2F2ZSBjb250ZXh0XG4gICAgICAgICAgICBiYWNrdXAgPSB7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcbiAgICAgICAgICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgICAgIGJhY2t1cC55eWxsb2MucmFuZ2UgPSB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSB0aGlzLnl5bGVuZ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgaW5kZXhlZF9ydWxlLCB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgIC8vIHJlY292ZXIgY29udGV4dFxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gYmFja3VwW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG5uZXh0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHRlbXBNYXRjaCxcbiAgICAgICAgICAgIGluZGV4O1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcbiAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgYSBydWxlIE1JU21hdGNoLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxubGV4OmZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhY3RpdmF0ZXMgYSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIChwdXNoZXMgdGhlIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgb250byB0aGUgY29uZGl0aW9uIHN0YWNrKVxuYmVnaW46ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHBvcCB0aGUgcHJldmlvdXNseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9mZiB0aGUgY29uZGl0aW9uIHN0YWNrXG5wb3BTdGF0ZTpmdW5jdGlvbiBwb3BTdGF0ZSgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHByb2R1Y2UgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG5fY3VycmVudFJ1bGVzOmZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXS5ydWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbXCJJTklUSUFMXCJdLnJ1bGVzO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZTsgd2hlbiBhbiBpbmRleCBhcmd1bWVudCBpcyBwcm92aWRlZCBpdCBwcm9kdWNlcyB0aGUgTi10aCBwcmV2aW91cyBjb25kaXRpb24gc3RhdGUsIGlmIGF2YWlsYWJsZVxudG9wU3RhdGU6ZnVuY3Rpb24gdG9wU3RhdGUobikge1xuICAgICAgICBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxIC0gTWF0aC5hYnMobiB8fCAwKTtcbiAgICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJTklUSUFMXCI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhbGlhcyBmb3IgYmVnaW4oY29uZGl0aW9uKVxucHVzaFN0YXRlOmZ1bmN0aW9uIHB1c2hTdGF0ZShjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG5zdGF0ZVN0YWNrU2l6ZTpmdW5jdGlvbiBzdGF0ZVN0YWNrU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoO1xuICAgIH0sXG5vcHRpb25zOiB7fSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eSx5eV8sJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucyxZWV9TVEFSVCkge1xudmFyIFlZU1RBVEU9WVlfU1RBUlQ7XG5zd2l0Y2goJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucykge1xuY2FzZSAwOi8qIOi3s+i/h+epuueZveespiAqL1xuYnJlYWs7XG5jYXNlIDE6cmV0dXJuIDI1O1xuYnJlYWs7XG5jYXNlIDI6cmV0dXJuIDg7XG5icmVhaztcbmNhc2UgMzpyZXR1cm4gODtcbmJyZWFrO1xuY2FzZSA0OnJldHVybiAyMTtcbmJyZWFrO1xuY2FzZSA1OnJldHVybiAyNTtcbmJyZWFrO1xuY2FzZSA2OnJldHVybiAyNztcbmJyZWFrO1xuY2FzZSA3OnJldHVybiAyOTtcbmJyZWFrO1xuY2FzZSA4OnJldHVybiAyOTtcbmJyZWFrO1xuY2FzZSA5OnJldHVybiAyODtcbmJyZWFrO1xuY2FzZSAxMDpyZXR1cm4gMjE7XG5icmVhaztcbmNhc2UgMTE6cmV0dXJuIDM0O1xuYnJlYWs7XG5jYXNlIDEyOnJldHVybiAzNDtcbmJyZWFrO1xuY2FzZSAxMzpyZXR1cm4gMzY7XG5icmVhaztcbmNhc2UgMTQ6cmV0dXJuIDMxO1xuYnJlYWs7XG5jYXNlIDE1OlxuYnJlYWs7XG5jYXNlIDE2OnJldHVybiA5O1xuYnJlYWs7XG5jYXNlIDE3OnJldHVybiAnICc7XG5icmVhaztcbmNhc2UgMTg6cmV0dXJuIDM1O1xuYnJlYWs7XG5jYXNlIDE5OnJldHVybiAzMDtcbmJyZWFrO1xuY2FzZSAyMDpyZXR1cm4gMzI7XG5icmVhaztcbmNhc2UgMjE6cmV0dXJuIDMzO1xuYnJlYWs7XG5jYXNlIDIyOnJldHVybiAxODtcbmJyZWFrO1xuY2FzZSAyMzpyZXR1cm4gMTk7XG5icmVhaztcbmNhc2UgMjQ6cmV0dXJuIDE3O1xuYnJlYWs7XG5jYXNlIDI1OnJldHVybiAxMTtcbmJyZWFrO1xuY2FzZSAyNjpyZXR1cm4gMjA7XG5icmVhaztcbmNhc2UgMjc6cmV0dXJuIDEyO1xuYnJlYWs7XG5jYXNlIDI4OnJldHVybiAxMztcbmJyZWFrO1xuY2FzZSAyOTpyZXR1cm4gMTU7XG5icmVhaztcbmNhc2UgMzA6cmV0dXJuIDE0O1xuYnJlYWs7XG5jYXNlIDMxOnJldHVybiAxNjtcbmJyZWFrO1xuY2FzZSAzMjpyZXR1cm4gJ1wiJztcbmJyZWFrO1xuY2FzZSAzMzpyZXR1cm4gXCInXCI7XG5icmVhaztcbmNhc2UgMzQ6cmV0dXJuIFwiIVwiO1xuYnJlYWs7XG5jYXNlIDM1OnJldHVybiAxMDtcbmJyZWFrO1xuY2FzZSAzNjpyZXR1cm4gMzc7XG5icmVhaztcbmNhc2UgMzc6cmV0dXJuIDM4O1xuYnJlYWs7XG5jYXNlIDM4OnJldHVybiA1O1xuYnJlYWs7XG59XG59LFxucnVsZXM6IFsvXig/OlxccyspLywvXig/OicoW15cXFxcL1xcP1xcKlxcW1xcXVxcISdcIl0rKScoPz1bIV0pKS8sL14oPzpcIihcXFxcW1wiXXxbXlwiXSkqXCIpLywvXig/OicoXFxcXFsnXXxbXiddKSonKS8sL14oPzpbQS1aYS16XXsxLH1bQS1aYS16XzAtOVxcLl0rKD89WyhdKSkvLC9eKD86W15cXFxcL1xcP1xcKlxcW1xcXSdcIlxcISxcXCldKyg/PVshXSkpLywvXig/OlxcJFtBLVphLXpdK1xcJFswLTldKykvLC9eKD86XFwkW0EtWmEtel0rWzAtOV0rKS8sL14oPzpbQS1aYS16XStcXCRbMC05XSspLywvXig/OltBLVphLXpdK1swLTldKykvLC9eKD86W0EtWmEtelxcLl0rKD89WyhdKSkvLC9eKD86W0EtWmEtel17MSx9W0EtWmEtel8wLTldKykvLC9eKD86W0EtWmEtel9dKykvLC9eKD86WzAtOV0rKS8sL14oPzpcXFsoLiopP1xcXSkvLC9eKD86XFwkKS8sL14oPzomKS8sL14oPzogKS8sL14oPzpbLl0pLywvXig/OjopLywvXig/OjspLywvXig/OiwpLywvXig/OlxcKikvLC9eKD86XFwvKS8sL14oPzotKS8sL14oPzpcXCspLywvXig/OlxcXikvLC9eKD86XFwoKS8sL14oPzpcXCkpLywvXig/Oj4pLywvXig/OjwpLywvXig/Ok5PVFxcYikvLC9eKD86XCIpLywvXig/OicpLywvXig/OiEpLywvXig/Oj0pLywvXig/OiUpLywvXig/OlsjXSkvLC9eKD86JCkvXSxcbmNvbmRpdGlvbnM6IHtcIklOSVRJQUxcIjp7XCJydWxlc1wiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4XSxcImluY2x1c2l2ZVwiOnRydWV9fVxufSk7XG5yZXR1cm4gbGV4ZXI7XG59KSgpO1xucGFyc2VyLmxleGVyID0gbGV4ZXI7XG5mdW5jdGlvbiBQYXJzZXIgKCkge1xuICB0aGlzLnl5ID0ge307XG59XG5QYXJzZXIucHJvdG90eXBlID0gcGFyc2VyO3BhcnNlci5QYXJzZXIgPSBQYXJzZXI7XG5yZXR1cm4gbmV3IFBhcnNlcjtcbn0pKCk7XG5cbmV4cG9ydCB2YXIgUGFyc2VyID0gZ3JhbW1hci5QYXJzZXI7XG4iLCJpbXBvcnQge3RvTnVtYmVyfSBmcm9tICcuLy4uL3V0aWxzJztcbmltcG9ydCB7RVJST1JfVkFMVUV9IGZyb20gJy4vLi4vZXJyb3InO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gJysnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGZpcnN0LCAuLi5yZXN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlc3QucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgKyB0b051bWJlcih2YWx1ZSksIHRvTnVtYmVyKGZpcnN0KSk7XG5cbiAgaWYgKE51bWJlci5pc05hTihyZXN1bHQpKSB7XG4gICAgdGhyb3cgRXJyb3IoRVJST1JfVkFMVUUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmMuU1lNQk9MID0gU1lNQk9MO1xuIiwiZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICcmJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyguLi5wYXJhbXMpIHtcbiAgcmV0dXJuIHBhcmFtcy5yZWR1Y2UoKGFjYywgdmFsdWUpID0+IGFjYyArIHZhbHVlLnRvU3RyaW5nKCksICcnKTtcbn07XG5cbmZ1bmMuU1lNQk9MID0gU1lNQk9MO1xuIiwiaW1wb3J0IHt0b051bWJlcn0gZnJvbSAnLi8uLi91dGlscyc7XG5pbXBvcnQge0VSUk9SX0RJVl9aRVJPLCBFUlJPUl9WQUxVRX0gZnJvbSAnLi8uLi9lcnJvcic7XG5cbmV4cG9ydCBjb25zdCBTWU1CT0wgPSAnLyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoZmlyc3QsIC4uLnJlc3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gcmVzdC5yZWR1Y2UoKGFjYywgdmFsdWUpID0+IGFjYyAvIHRvTnVtYmVyKHZhbHVlKSwgdG9OdW1iZXIoZmlyc3QpKTtcblxuICBpZiAocmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgIHRocm93IEVycm9yKEVSUk9SX0RJVl9aRVJPKTtcbiAgfVxuICBpZiAoTnVtYmVyLmlzTmFOKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBFcnJvcihFUlJPUl9WQUxVRSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJleHBvcnQgY29uc3QgU1lNQk9MID0gJz0nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGV4cDEsIGV4cDIpIHtcbiAgcmV0dXJuIGV4cDEgPT09IGV4cDI7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsIi8qKlxuICogRXhjZWwg5YWs5byP5Lit55qE5Ye95pWw77yM55SxIGZvcm11bGFqcyDlrp7njrDjgIJcbiAqXG4gKi9cblxuaW1wb3J0IFNVUFBPUlRFRF9GT1JNVUxBUyBmcm9tICcuLy4uL3N1cHBvcnRlZC1mb3JtdWxhcyc7XG5pbXBvcnQge0VSUk9SX05BTUV9IGZyb20gJy4vLi4vZXJyb3InO1xuaW1wb3J0ICogYXMgZm9ybXVsYWpzIGZyb20gJ2Zvcm11bGFqcyc7XG5cbmV4cG9ydCBjb25zdCBTWU1CT0wgPSBTVVBQT1JURURfRk9STVVMQVM7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoc3ltYm9sKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5wYXJhbXMpIHtcbiAgICAgICAgc3ltYm9sID0gc3ltYm9sLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgY29uc3Qgc3ltYm9sUGFydHMgPSBzeW1ib2wuc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IGZvdW5kRm9ybXVsYSA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgIGlmIChzeW1ib2xQYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChmb3JtdWxhanNbc3ltYm9sUGFydHNbMF1dKSB7XG4gICAgICAgICAgICAgICAgZm91bmRGb3JtdWxhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmb3JtdWxhanNbc3ltYm9sUGFydHNbMF1dKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBzeW1ib2xQYXJ0cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IG5lc3RlZEZvcm11bGEgPSBmb3JtdWxhanM7XG5cbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5lc3RlZEZvcm11bGEgPSBuZXN0ZWRGb3JtdWxhW3N5bWJvbFBhcnRzW2luZGV4XV07XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcblxuICAgICAgICAgICAgICAgIGlmICghbmVzdGVkRm9ybXVsYSkge1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRGb3JtdWxhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lc3RlZEZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEZvcm11bGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5lc3RlZEZvcm11bGEoLi4ucGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm91bmRGb3JtdWxhKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJPUl9OQU1FKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG5cbmZ1bmMuaXNGYWN0b3J5ID0gdHJ1ZTtcbmZ1bmMuU1lNQk9MID0gU1lNQk9MO1xuIiwiZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICc+PSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoZXhwMSwgZXhwMikge1xuICByZXR1cm4gZXhwMSA+PSBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJleHBvcnQgY29uc3QgU1lNQk9MID0gJz4nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGV4cDEsIGV4cDIpIHtcbiAgcmV0dXJuIGV4cDEgPiBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJleHBvcnQgY29uc3QgU1lNQk9MID0gJzw9JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyhleHAxLCBleHAyKSB7XG4gIHJldHVybiBleHAxIDw9IGV4cDI7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImV4cG9ydCBjb25zdCBTWU1CT0wgPSAnPCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoZXhwMSwgZXhwMikge1xuICByZXR1cm4gZXhwMSA8IGV4cDI7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImltcG9ydCB7dG9OdW1iZXJ9IGZyb20gJy4vLi4vdXRpbHMnO1xuaW1wb3J0IHtFUlJPUl9WQUxVRX0gZnJvbSAnLi8uLi9lcnJvcic7XG5cbmV4cG9ydCBjb25zdCBTWU1CT0wgPSAnLSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoZmlyc3QsIC4uLnJlc3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gcmVzdC5yZWR1Y2UoKGFjYywgdmFsdWUpID0+IGFjYyAtIHRvTnVtYmVyKHZhbHVlKSwgdG9OdW1iZXIoZmlyc3QpKTtcblxuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHRocm93IEVycm9yKEVSUk9SX1ZBTFVFKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImltcG9ydCB7dG9OdW1iZXJ9IGZyb20gJy4vLi4vdXRpbHMnO1xuaW1wb3J0IHtFUlJPUl9WQUxVRX0gZnJvbSAnLi8uLi9lcnJvcic7XG5cbmV4cG9ydCBjb25zdCBTWU1CT0wgPSAnKic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoZmlyc3QsIC4uLnJlc3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gcmVzdC5yZWR1Y2UoKGFjYywgdmFsdWUpID0+IGFjYyAqIHRvTnVtYmVyKHZhbHVlKSwgdG9OdW1iZXIoZmlyc3QpKTtcblxuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHRocm93IEVycm9yKEVSUk9SX1ZBTFVFKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImV4cG9ydCBjb25zdCBTWU1CT0wgPSAnPD4nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGV4cDEsIGV4cDIpIHtcbiAgcmV0dXJuIGV4cDEgIT09IGV4cDI7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImltcG9ydCB7dG9OdW1iZXJ9IGZyb20gJy4vLi4vdXRpbHMnO1xuaW1wb3J0IHtFUlJPUl9WQUxVRX0gZnJvbSAnLi8uLi9lcnJvcic7XG5cbmV4cG9ydCBjb25zdCBTWU1CT0wgPSAnXic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoZXhwMSwgZXhwMikge1xuICBjb25zdCByZXN1bHQgPSBNYXRoLnBvdyh0b051bWJlcihleHAxKSwgdG9OdW1iZXIoZXhwMikpO1xuXG4gIGlmIChOdW1iZXIuaXNOYU4ocmVzdWx0KSkge1xuICAgIHRocm93IEVycm9yKEVSUk9SX1ZBTFVFKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImltcG9ydCB7ZGVmYXVsdCBhcyBhZGR9IGZyb20gJy4vb3BlcmF0b3IvYWRkJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBhbXBlcnNhbmR9IGZyb20gJy4vb3BlcmF0b3IvYW1wZXJzYW5kJztcbi8vIGltcG9ydCB7ZGVmYXVsdCBhcyBjcm9zc1NoZWV0fSBmcm9tICcuL29wZXJhdG9yL2Nyb3NzLXNoZWV0JztcbmltcG9ydCB7ZGVmYXVsdCBhcyBkaXZpZGV9IGZyb20gJy4vb3BlcmF0b3IvZGl2aWRlJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBlcXVhbH0gZnJvbSAnLi9vcGVyYXRvci9lcXVhbCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgZm9ybXVsYUZ1bmN0aW9ufSBmcm9tICcuL29wZXJhdG9yL2Zvcm11bGEtZnVuY3Rpb24nO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGdyZWF0ZXJUaGFufSBmcm9tICcuL29wZXJhdG9yL2dyZWF0ZXItdGhhbic7XG5pbXBvcnQge2RlZmF1bHQgYXMgZ3JlYXRlclRoYW5PckVxdWFsfSBmcm9tICcuL29wZXJhdG9yL2dyZWF0ZXItdGhhbi1vci1lcXVhbCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgbGVzc1RoYW59IGZyb20gJy4vb3BlcmF0b3IvbGVzcy10aGFuJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBsZXNzVGhhbk9yRXF1YWx9IGZyb20gJy4vb3BlcmF0b3IvbGVzcy10aGFuLW9yLWVxdWFsJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBtaW51c30gZnJvbSAnLi9vcGVyYXRvci9taW51cyc7XG5pbXBvcnQge2RlZmF1bHQgYXMgbXVsdGlwbHl9IGZyb20gJy4vb3BlcmF0b3IvbXVsdGlwbHknO1xuaW1wb3J0IHtkZWZhdWx0IGFzIG5vdEVxdWFsfSBmcm9tICcuL29wZXJhdG9yL25vdC1lcXVhbCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgcG93ZXJ9IGZyb20gJy4vb3BlcmF0b3IvcG93ZXInO1xuaW1wb3J0IHtFUlJPUl9OQU1FfSBmcm9tICcuL2Vycm9yJztcblxuY29uc3QgYXZhaWxhYmxlT3BlcmF0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxucmVnaXN0ZXJPcGVyYXRpb24oYWRkLlNZTUJPTCwgYWRkKTtcbnJlZ2lzdGVyT3BlcmF0aW9uKGFtcGVyc2FuZC5TWU1CT0wsIGFtcGVyc2FuZCk7XG4vLyByZWdpc3Rlck9wZXJhdGlvbihjcm9zc1NoZWV0LlNZTUJPTCwgY3Jvc3NTaGVldCk7XG5yZWdpc3Rlck9wZXJhdGlvbihkaXZpZGUuU1lNQk9MLCBkaXZpZGUpO1xucmVnaXN0ZXJPcGVyYXRpb24oZXF1YWwuU1lNQk9MLCBlcXVhbCk7XG5yZWdpc3Rlck9wZXJhdGlvbihwb3dlci5TWU1CT0wsIHBvd2VyKTtcbnJlZ2lzdGVyT3BlcmF0aW9uKGZvcm11bGFGdW5jdGlvbi5TWU1CT0wsIGZvcm11bGFGdW5jdGlvbik7XG5yZWdpc3Rlck9wZXJhdGlvbihncmVhdGVyVGhhbi5TWU1CT0wsIGdyZWF0ZXJUaGFuKTtcbnJlZ2lzdGVyT3BlcmF0aW9uKGdyZWF0ZXJUaGFuT3JFcXVhbC5TWU1CT0wsIGdyZWF0ZXJUaGFuT3JFcXVhbCk7XG5yZWdpc3Rlck9wZXJhdGlvbihsZXNzVGhhbi5TWU1CT0wsIGxlc3NUaGFuKTtcbnJlZ2lzdGVyT3BlcmF0aW9uKGxlc3NUaGFuT3JFcXVhbC5TWU1CT0wsIGxlc3NUaGFuT3JFcXVhbCk7XG5yZWdpc3Rlck9wZXJhdGlvbihtdWx0aXBseS5TWU1CT0wsIG11bHRpcGx5KTtcbnJlZ2lzdGVyT3BlcmF0aW9uKG5vdEVxdWFsLlNZTUJPTCwgbm90RXF1YWwpO1xucmVnaXN0ZXJPcGVyYXRpb24obWludXMuU1lNQk9MLCBtaW51cyk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV2YWx1YXRlQnlPcGVyYXRvcihvcGVyYXRvciwgcGFyYW1zID0gW10pIHtcbiAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBpZiAoIWF2YWlsYWJsZU9wZXJhdG9yc1tvcGVyYXRvcl0pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoRVJST1JfTkFNRSk7XG4gICAgfVxuICAgIHJldHVybiBhdmFpbGFibGVPcGVyYXRvcnNbb3BlcmF0b3JdKC4uLnBhcmFtcyk7XG59XG5cbi8qKlxuICog5rOo5YaMXG4gKiBAcGFyYW0gc3ltYm9sXG4gKiBAcGFyYW0gZnVuY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJPcGVyYXRpb24oc3ltYm9sLCBmdW5jKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHN5bWJvbCkpIHtcbiAgICAgICAgc3ltYm9sID0gW3N5bWJvbC50b1VwcGVyQ2FzZSgpXTtcbiAgICB9XG4gICAgc3ltYm9sLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgaWYgKGZ1bmMuaXNGYWN0b3J5KSB7XG4gICAgICAgICAgICBhdmFpbGFibGVPcGVyYXRvcnNbc10gPSBmdW5jKHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXZhaWxhYmxlT3BlcmF0b3JzW3NdID0gZnVuYztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwiLyoqXG4gKiDlhazlvI/op6PmnpDlmajjgIJcbiAqIOW6leWxgueahOivreazleino+aekOWZqOS9v+eUqCBqaXNvbiDnlJ/miJDvvIzlj4Lop4EgaHR0cDovL3phYS5jaC9qaXNvbi9cbiAqXG4gKiDms6jmhI86IGppc29uIOeUn+aIkOeahOS7o+eggeS9v+eUqCBBTUQg5pa55byP5a+85Ye65Y+Y6YeP77yM6YeN5paw55Sf5oiQ5ZCO6K6w5b6X5pS55oiQIEVTNiDnmoTmlrnlvI86XG4gKiAgICAgIGBleHBvcnQgdmFyIFBhcnNlciA9IGdyYW1tYXIuUGFyc2VyO2BcbiAqXG4gKiBAY2xhc3MgUGFyc2VyXG4gKiBAZmlyZXMgUGFyc2VyI2NhbGxWYXJpYWJsZVxuICogQGZpcmVzIFBhcnNlciNjYWxsQ2VsbFZhbHVlXG4gKiBAZmlyZXMgUGFyc2VyI2NhbGxSYW5nZVZhbHVlXG4gKi9cblxuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnLi4vLi4vLi4vdXRpbHMvRW1pdHRlcic7XG5pbXBvcnQgZXZhbHVhdGVCeU9wZXJhdG9yIGZyb20gJy4vb3BlcmF0b3JzJztcbmltcG9ydCB7UGFyc2VyIGFzIEdyYW1tYXJQYXJzZXJ9IGZyb20gJy4vZ3JhbW1hcic7XG5pbXBvcnQge3RyaW1FZGdlcywgdG9OdW1iZXIsIGludmVydE51bWJlciwgZXh0cmFjdExhYmVsLCB0b0xhYmVsfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBlcnJvclBhcnNlciwgRVJST1IsIEVSUk9SX05BTUV9IGZyb20gJy4vZXJyb3InO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNVUFBPUlRFRF9GT1JNVUxBU30gZnJvbSAnLi9zdXBwb3J0ZWQtZm9ybXVsYXMnO1xuXG5jbGFzcyBQYXJzZXIgZXh0ZW5kcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgR3JhbW1hclBhcnNlcigpO1xuICAgICAgICB0aGlzLnBhcnNlci55eSA9IHtcbiAgICAgICAgICAgIHRvTnVtYmVyLFxuICAgICAgICAgICAgdHJpbUVkZ2VzLFxuICAgICAgICAgICAgaW52ZXJ0TnVtYmVyLFxuICAgICAgICAgICAgdGhyb3dFcnJvcjogKGVycm9yTmFtZSkgPT4gdGhpcy5fdGhyb3dFcnJvcihlcnJvck5hbWUpLFxuICAgICAgICAgICAgY2FsbFZhcmlhYmxlOiAodmFyaWFibGUpID0+IHRoaXMuX2NhbGxWYXJpYWJsZSh2YXJpYWJsZSksXG4gICAgICAgICAgICBldmFsdWF0ZUJ5T3BlcmF0b3IsXG4gICAgICAgICAgICBjYWxsRnVuY3Rpb246IGV2YWx1YXRlQnlPcGVyYXRvcixcbiAgICAgICAgICAgIGNlbGxWYWx1ZTogKHZhbHVlKSA9PiB0aGlzLl9jYWxsQ2VsbFZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgIHJhbmdlVmFsdWU6IChzdGFydCwgZW5kKSA9PiB0aGlzLl9jYWxsUmFuZ2VWYWx1ZShzdGFydCwgZW5kKSxcbiAgICAgICAgICAgIGNlbGxWYWx1ZUluU2hlZXQ6IChzaGVldE5hbWUsIHZhbHVlKSA9PiB0aGlzLl9jYWxsQ2VsbFZhbHVlSW5TaGVldChzaGVldE5hbWUsIHZhbHVlKSxcbiAgICAgICAgICAgIHJhbmdlVmFsdWVJblNoZWV0OiAoc2hlZXROYW1lLCBzdGFydCwgZW5kKSA9PiB0aGlzLl9jYWxsUmFuZ2VWYWx1ZUluU2hlZXQoc2hlZXROYW1lLCBzdGFydCwgZW5kKSxcbiAgICAgICAgICAgIHBhcnNlRXJyb3I6ICguLi5hcmdzKSA9PiB0aGlzLl9wYXJzZUVycm9yKC4uLmFyZ3MpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICB0aGlzLnNldFZhcmlhYmxlKCdUUlVFJywgdHJ1ZSlcbiAgICAgICAgICAgIC5zZXRWYXJpYWJsZSgnRkFMU0UnLCBmYWxzZSlcbiAgICAgICAgICAgIC5zZXRWYXJpYWJsZSgnTlVMTCcsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOino+aekOihqOi+vuW8j1xuICAgICAqIEBwYXJhbSBleHByZXNzaW9uXG4gICAgICogQHJldHVybnMge3tlcnJvcjogKiwgcmVzdWx0OiAqfX1cbiAgICAgKi9cbiAgICBwYXJzZShleHByZXNzaW9uKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlci5wYXJzZShleHByZXNzaW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvclBhcnNlcihleC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yUGFyc2VyKEVSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBlcnJvclBhcnNlcihyZXN1bHQubWVzc2FnZSkgfHwgZXJyb3JQYXJzZXIoRVJST1IpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuvue9ruWPmOmHj1xuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge1BhcnNlcn1cbiAgICAgKi9cbiAgICBzZXRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXRWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDosIPnlKjlj5jph4/lgLxcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGxWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0VmFyaWFibGUobmFtZSk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdjYWxsVmFyaWFibGUnLCBuYW1lLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKEVSUk9SX05BTUUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiwg+eUqOWNleWFg+agvOeahOWAvFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCAtIOS+i+WmgiBgQjNgLCBgQiQzYCwgYEIkM2AsIGAkQiQzYFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGxDZWxsVmFsdWUobGFiZWwpIHtcbiAgICAgICAgY29uc3QgW3JvdywgY29sdW1uXSA9IGV4dHJhY3RMYWJlbChsYWJlbCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZvaWQgMDtcblxuICAgICAgICB0aGlzLmVtaXQoJ2NhbGxDZWxsVmFsdWUnLCB7bGFiZWwsIHJvdywgY29sdW1ufSwgKF92YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDosIPnlKjmjIflrpogc2hlZXQg5Lit5Y2V5YWD5qC855qE5YC8XG4gICAgICogQHBhcmFtIHNoZWV0TmFtZVxuICAgICAqIEBwYXJhbSBsYWJlbFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGxDZWxsVmFsdWVJblNoZWV0KHNoZWV0TmFtZSwgbGFiZWwpIHtcbiAgICAgICAgY29uc3QgW3JvdywgY29sdW1uXSA9IGV4dHJhY3RMYWJlbChsYWJlbCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZvaWQgMDtcblxuICAgICAgICB0aGlzLmVtaXQoJ2NhbGxDZWxsVmFsdWVJblNoZWV0Jywge3NoZWV0TmFtZSwgbGFiZWwsIHJvdywgY29sdW1ufSwgKF92YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGljIF9leHBsYWluQ2VsbChzdGFydExhYmVsLCBlbmRMYWJlbCkge1xuICAgICAgICBjb25zdCBbc3RhcnRSb3csIHN0YXJ0Q29sdW1uXSA9IGV4dHJhY3RMYWJlbChzdGFydExhYmVsKTtcbiAgICAgICAgY29uc3QgW2VuZFJvdywgZW5kQ29sdW1uXSA9IGV4dHJhY3RMYWJlbChlbmRMYWJlbCk7XG4gICAgICAgIGxldCBzdGFydENlbGwgPSB7fTtcbiAgICAgICAgbGV0IGVuZENlbGwgPSB7fTtcblxuICAgICAgICBpZiAoc3RhcnRSb3cuaW5kZXggPD0gZW5kUm93LmluZGV4KSB7XG4gICAgICAgICAgICBzdGFydENlbGwucm93ID0gc3RhcnRSb3c7XG4gICAgICAgICAgICBlbmRDZWxsLnJvdyA9IGVuZFJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0Q2VsbC5yb3cgPSBlbmRSb3c7XG4gICAgICAgICAgICBlbmRDZWxsLnJvdyA9IHN0YXJ0Um93O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0Q29sdW1uLmluZGV4IDw9IGVuZENvbHVtbi5pbmRleCkge1xuICAgICAgICAgICAgc3RhcnRDZWxsLmNvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgZW5kQ2VsbC5jb2x1bW4gPSBlbmRDb2x1bW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydENlbGwuY29sdW1uID0gZW5kQ29sdW1uO1xuICAgICAgICAgICAgZW5kQ2VsbC5jb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0Q2VsbC5sYWJlbCA9IHRvTGFiZWwoc3RhcnRDZWxsLnJvdywgc3RhcnRDZWxsLmNvbHVtbik7XG4gICAgICAgIGVuZENlbGwubGFiZWwgPSB0b0xhYmVsKGVuZENlbGwucm93LCBlbmRDZWxsLmNvbHVtbik7XG4gICAgICAgIHJldHVybiB7c3RhcnRDZWxsLCBlbmRDZWxsfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDosIPnlKjmn5DojIPlm7TnmoTljZXlhYPmoLzlgLzvvIzlpoIgYEIzOkExYFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydExhYmVsIC0g6LW35aeL5qCH562+77yM5aaCIGBCM2BcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kTGFiZWwgLSDnu5PmnZ/moIfnrb7vvIzlpoIgYEExYFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxsUmFuZ2VWYWx1ZShzdGFydExhYmVsLCBlbmRMYWJlbCkge1xuICAgICAgICB2YXIge3N0YXJ0Q2VsbCwgZW5kQ2VsbH0gPSBQYXJzZXIuX2V4cGxhaW5DZWxsKHN0YXJ0TGFiZWwsIGVuZExhYmVsKTtcbiAgICAgICAgbGV0IHZhbHVlID0gW107XG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbFJhbmdlVmFsdWUnLCBzdGFydENlbGwsIGVuZENlbGwsIChfdmFsdWUgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6LCD55So5oyH5a6aIHNoZWV0IOS4reafkOiMg+WbtOeahOWNleWFg+agvOWAvO+8jOWmgiBg5bel5L2c6KGoMSFCMzpBMWBcbiAgICAgKiBAcGFyYW0gc2hlZXROYW1lXG4gICAgICogQHBhcmFtIHN0YXJ0TGFiZWxcbiAgICAgKiBAcGFyYW0gZW5kTGFiZWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsbFJhbmdlVmFsdWVJblNoZWV0KHNoZWV0TmFtZSwgc3RhcnRMYWJlbCwgZW5kTGFiZWwpIHtcbiAgICAgICAgdmFyIHtzdGFydENlbGwsIGVuZENlbGx9ID0gUGFyc2VyLl9leHBsYWluQ2VsbChzdGFydExhYmVsLCBlbmRMYWJlbCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLmVtaXQoJ2NhbGxSYW5nZVZhbHVlSW5TaGVldCcsIHNoZWV0TmFtZSwgc3RhcnRDZWxsLCBlbmRDZWxsLCAoX3ZhbHVlID0gW10pID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gX3ZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yTmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Rocm93RXJyb3IoZXJyb3JOYW1lKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEVycm9yID0gZXJyb3JQYXJzZXIoZXJyb3JOYW1lKTtcbiAgICAgICAgaWYgKHBhcnNlZEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihwYXJzZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yTmFtZTtcbiAgICB9XG5cblxuICAgIC8vIFRPRE8g6Kej5p6Q5aSx6LSl5pe277yM57uZ55So5oi35o+Q5L6b5ZCI6YCC55qE6ZSZ6K+v5L+h5oGv44CCXG4gICAgX3BhcnNlRXJyb3IoLi4uYXJncykge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmdzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7UGFyc2VyfTtcbiIsImNvbnN0IFNVUFBPUlRFRF9GT1JNVUxBUyA9IFtcbiAgJ0FCUycsXG4gICdBQ0NSSU5UJyxcbiAgJ0FDT1MnLFxuICAnQUNPU0gnLFxuICAnQUNPVCcsXG4gICdBQ09USCcsXG4gICdBREQnLFxuICAnQUdHUkVHQVRFJyxcbiAgJ0FORCcsXG4gICdBUkFCSUMnLFxuICAnQVJHUzJBUlJBWScsXG4gICdBU0lOJyxcbiAgJ0FTSU5IJyxcbiAgJ0FUQU4nLFxuICAnQVRBTjInLFxuICAnQVRBTkgnLFxuICAnQVZFREVWJyxcbiAgJ0FWRVJBR0UnLFxuICAnQVZFUkFHRUEnLFxuICAnQVZFUkFHRUlGJyxcbiAgJ0FWRVJBR0VJRlMnLFxuICAnQkFTRScsXG4gICdCRVNTRUxJJyxcbiAgJ0JFU1NFTEonLFxuICAnQkVTU0VMSycsXG4gICdCRVNTRUxZJyxcbiAgJ0JFVEEuRElTVCcsXG4gICdCRVRBLklOVicsXG4gICdCRVRBRElTVCcsXG4gICdCRVRBSU5WJyxcbiAgJ0JJTjJERUMnLFxuICAnQklOMkhFWCcsXG4gICdCSU4yT0NUJyxcbiAgJ0JJTk9NLkRJU1QnLFxuICAnQklOT00uRElTVC5SQU5HRScsXG4gICdCSU5PTS5JTlYnLFxuICAnQklOT01ESVNUJyxcbiAgJ0JJVEFORCcsXG4gICdCSVRMU0hJRlQnLFxuICAnQklUT1InLFxuICAnQklUUlNISUZUJyxcbiAgJ0JJVFhPUicsXG4gICdDRUlMSU5HJyxcbiAgJ0NFSUxJTkdNQVRIJyxcbiAgJ0NFSUxJTkdQUkVDSVNFJyxcbiAgJ0NIQVInLFxuICAnQ0hJU1EuRElTVCcsXG4gICdDSElTUS5ESVNULlJUJyxcbiAgJ0NISVNRLklOVicsXG4gICdDSElTUS5JTlYuUlQnLFxuICAnQ0hPT1NFJyxcbiAgJ0NIT09TRScsXG4gICdDTEVBTicsXG4gICdDT0RFJyxcbiAgJ0NPTFVNTicsXG4gICdDT0xVTU5TJyxcbiAgJ0NPTUJJTicsXG4gICdDT01CSU5BJyxcbiAgJ0NPTVBMRVgnLFxuICAnQ09OQ0FURU5BVEUnLFxuICAnQ09ORklERU5DRScsXG4gICdDT05GSURFTkNFLk5PUk0nLFxuICAnQ09ORklERU5DRS5UJyxcbiAgJ0NPTlZFUlQnLFxuICAnQ09SUkVMJyxcbiAgJ0NPUycsXG4gICdDT1NIJyxcbiAgJ0NPVCcsXG4gICdDT1RIJyxcbiAgJ0NPVU5UJyxcbiAgJ0NPVU5UQScsXG4gICdDT1VOVEJMQU5LJyxcbiAgJ0NPVU5USUYnLFxuICAnQ09VTlRJRlMnLFxuICAnQ09VTlRJTicsXG4gICdDT1VOVFVOSVFVRScsXG4gICdDT1ZBUklBTkNFLlAnLFxuICAnQ09WQVJJQU5DRS5TJyxcbiAgJ0NTQycsXG4gICdDU0NIJyxcbiAgJ0NVTUlQTVQnLFxuICAnQ1VNUFJJTkMnLFxuICAnREFURScsXG4gICdEQVRFVkFMVUUnLFxuICAnREFZJyxcbiAgJ0RBWVMnLFxuICAnREFZUzM2MCcsXG4gICdEQicsXG4gICdEREInLFxuICAnREVDMkJJTicsXG4gICdERUMySEVYJyxcbiAgJ0RFQzJPQ1QnLFxuICAnREVDSU1BTCcsXG4gICdERUdSRUVTJyxcbiAgJ0RFTFRBJyxcbiAgJ0RFVlNRJyxcbiAgJ0RJVklERScsXG4gICdET0xMQVInLFxuICAnRE9MTEFSREUnLFxuICAnRE9MTEFSRlInLFxuICAnRScsXG4gICdFREFURScsXG4gICdFRkZFQ1QnLFxuICAnRU9NT05USCcsXG4gICdFUScsXG4gICdFUkYnLFxuICAnRVJGQycsXG4gICdFVkVOJyxcbiAgJ0VYQUNUJyxcbiAgJ0VYUE9OLkRJU1QnLFxuICAnRVhQT05ESVNUJyxcbiAgJ0YuRElTVCcsXG4gICdGLkRJU1QuUlQnLFxuICAnRi5JTlYnLFxuICAnRi5JTlYuUlQnLFxuICAnRkFDVCcsXG4gICdGQUNURE9VQkxFJyxcbiAgJ0ZBTFNFJyxcbiAgJ0ZESVNUJyxcbiAgJ0ZESVNUUlQnLFxuICAnRklORCcsXG4gICdGSU5WJyxcbiAgJ0ZJTlZSVCcsXG4gICdGSVNIRVInLFxuICAnRklTSEVSSU5WJyxcbiAgJ0ZJWEVEJyxcbiAgJ0ZMQVRURU4nLFxuICAnRkxPT1InLFxuICAnRk9SRUNBU1QnLFxuICAnRlJFUVVFTkNZJyxcbiAgJ0ZWJyxcbiAgJ0ZWU0NIRURVTEUnLFxuICAnR0FNTUEnLFxuICAnR0FNTUEuRElTVCcsXG4gICdHQU1NQS5JTlYnLFxuICAnR0FNTUFESVNUJyxcbiAgJ0dBTU1BSU5WJyxcbiAgJ0dBTU1BTE4nLFxuICAnR0FNTUFMTi5QUkVDSVNFJyxcbiAgJ0dBVVNTJyxcbiAgJ0dDRCcsXG4gICdHRU9NRUFOJyxcbiAgJ0dFU1RFUCcsXG4gICdHUk9XVEgnLFxuICAnR1RFJyxcbiAgJ0hBUk1FQU4nLFxuICAnSEVYMkJJTicsXG4gICdIRVgyREVDJyxcbiAgJ0hFWDJPQ1QnLFxuICAnSE9VUicsXG4gICdIVE1MMlRFWFQnLFxuICAnSFlQR0VPTS5ESVNUJyxcbiAgJ0hZUEdFT01ESVNUJyxcbiAgJ0lGJyxcbiAgJ0lNQUJTJyxcbiAgJ0lNQUdJTkFSWScsXG4gICdJTUFSR1VNRU5UJyxcbiAgJ0lNQ09OSlVHQVRFJyxcbiAgJ0lNQ09TJyxcbiAgJ0lNQ09TSCcsXG4gICdJTUNPVCcsXG4gICdJTUNTQycsXG4gICdJTUNTQ0gnLFxuICAnSU1ESVYnLFxuICAnSU1FWFAnLFxuICAnSU1MTicsXG4gICdJTUxPRzEwJyxcbiAgJ0lNTE9HMicsXG4gICdJTVBPV0VSJyxcbiAgJ0lNUFJPRFVDVCcsXG4gICdJTVJFQUwnLFxuICAnSU1TRUMnLFxuICAnSU1TRUNIJyxcbiAgJ0lNU0lOJyxcbiAgJ0lNU0lOSCcsXG4gICdJTVNRUlQnLFxuICAnSU1TVUInLFxuICAnSU1TVU0nLFxuICAnSU1UQU4nLFxuICAnSU5UJyxcbiAgJ0lOVEVSQ0VQVCcsXG4gICdJTlRFUlZBTCcsXG4gICdJUE1UJyxcbiAgJ0lSUicsXG4gICdJU0JJTkFSWScsXG4gICdJU0JMQU5LJyxcbiAgJ0lTRVZFTicsXG4gICdJU0xPR0lDQUwnLFxuICAnSVNOT05URVhUJyxcbiAgJ0lTTlVNQkVSJyxcbiAgJ0lTT0REJyxcbiAgJ0lTT0REJyxcbiAgJ0lTT1dFRUtOVU0nLFxuICAnSVNQTVQnLFxuICAnSVNURVhUJyxcbiAgJ0pPSU4nLFxuICAnS1VSVCcsXG4gICdMQVJHRScsXG4gICdMQ00nLFxuICAnTEVGVCcsXG4gICdMRU4nLFxuICAnTElORVNUJyxcbiAgJ0xOJyxcbiAgJ0xPRycsXG4gICdMT0cxMCcsXG4gICdMT0dFU1QnLFxuICAnTE9HTk9STS5ESVNUJyxcbiAgJ0xPR05PUk0uSU5WJyxcbiAgJ0xPR05PUk1ESVNUJyxcbiAgJ0xPR05PUk1JTlYnLFxuICAnTE9XRVInLFxuICAnTFQnLFxuICAnTFRFJyxcbiAgJ01BVENIJyxcbiAgJ01BWCcsXG4gICdNQVhBJyxcbiAgJ01FRElBTicsXG4gICdNSUQnLFxuICAnTUlOJyxcbiAgJ01JTkEnLFxuICAnTUlOVVMnLFxuICAnTUlOVVRFJyxcbiAgJ01JUlInLFxuICAnTU9EJyxcbiAgJ01PREUuTVVMVCcsXG4gICdNT0RFLlNOR0wnLFxuICAnTU9ERU1VTFQnLFxuICAnTU9ERVNOR0wnLFxuICAnTU9OVEgnLFxuICAnTVJPVU5EJyxcbiAgJ01VTFRJTk9NSUFMJyxcbiAgJ01VTFRJUExZJyxcbiAgJ05FJyxcbiAgJ05FR0JJTk9NLkRJU1QnLFxuICAnTkVHQklOT01ESVNUJyxcbiAgJ05FVFdPUktEQVlTJyxcbiAgJ05PTUlOQUwnLFxuICAnTk9STS5ESVNUJyxcbiAgJ05PUk0uSU5WJyxcbiAgJ05PUk0uUy5ESVNUJyxcbiAgJ05PUk0uUy5JTlYnLFxuICAnTk9STURJU1QnLFxuICAnTk9STUlOVicsXG4gICdOT1JNU0RJU1QnLFxuICAnTk9STVNJTlYnLFxuICAnTk9UJyxcbiAgJ05PVycsXG4gICdOUEVSJyxcbiAgJ05QVicsXG4gICdOVU1CRVJTJyxcbiAgJ05VTUVSQUwnLFxuICAnT0NUMkJJTicsXG4gICdPQ1QyREVDJyxcbiAgJ09DVDJIRVgnLFxuICAnT0REJyxcbiAgJ09SJyxcbiAgJ1BEVVJBVElPTicsXG4gICdQRUFSU09OJyxcbiAgJ1BFUkNFTlRJTEVFWEMnLFxuICAnUEVSQ0VOVElMRUlOQycsXG4gICdQRVJDRU5UUkFOS0VYQycsXG4gICdQRVJDRU5UUkFOS0lOQycsXG4gICdQRVJNVVQnLFxuICAnUEVSTVVUQVRJT05BJyxcbiAgJ1BISScsXG4gICdQSScsXG4gICdQTVQnLFxuICAnUE9JU1NPTi5ESVNUJyxcbiAgJ1BPSVNTT05ESVNUJyxcbiAgJ1BPVycsXG4gICdQT1dFUicsXG4gICdQUE1UJyxcbiAgJ1BST0InLFxuICAnUFJPRFVDVCcsXG4gICdQUk9QRVInLFxuICAnUFYnLFxuICAnUVVBUlRJTEUuRVhDJyxcbiAgJ1FVQVJUSUxFLklOQycsXG4gICdRVUFSVElMRUVYQycsXG4gICdRVUFSVElMRUlOQycsXG4gICdRVU9USUVOVCcsXG4gICdSQURJQU5TJyxcbiAgJ1JBTkQnLFxuICAnUkFOREJFVFdFRU4nLFxuICAnUkFOSy5BVkcnLFxuICAnUkFOSy5FUScsXG4gICdSQU5LQVZHJyxcbiAgJ1JBTktFUScsXG4gICdSQVRFJyxcbiAgJ1JFRkVSRU5DRScsXG4gICdSRUdFWEVYVFJBQ1QnLFxuICAnUkVHRVhNQVRDSCcsXG4gICdSRUdFWFJFUExBQ0UnLFxuICAnUkVQTEFDRScsXG4gICdSRVBUJyxcbiAgJ1JJR0hUJyxcbiAgJ1JPTUFOJyxcbiAgJ1JPVU5EJyxcbiAgJ1JPVU5ERE9XTicsXG4gICdST1VORFVQJyxcbiAgJ1JPVycsXG4gICdST1dTJyxcbiAgJ1JSSScsXG4gICdSU1EnLFxuICAnU0VBUkNIJyxcbiAgJ1NFQycsXG4gICdTRUNIJyxcbiAgJ1NFQ09ORCcsXG4gICdTRVJJRVNTVU0nLFxuICAnU0lHTicsXG4gICdTSU4nLFxuICAnU0lOSCcsXG4gICdTS0VXJyxcbiAgJ1NLRVcuUCcsXG4gICdTS0VXUCcsXG4gICdTTE4nLFxuICAnU0xPUEUnLFxuICAnU01BTEwnLFxuICAnU1BMSVQnLFxuICAnU1BMSVQnLFxuICAnU1FSVCcsXG4gICdTUVJUUEknLFxuICAnU1RBTkRBUkRJWkUnLFxuICAnU1RERVYuUCcsXG4gICdTVERFVi5TJyxcbiAgJ1NUREVWQScsXG4gICdTVERFVlAnLFxuICAnU1RERVZQQScsXG4gICdTVERFVlMnLFxuICAnU1RFWVgnLFxuICAnU1VCU1RJVFVURScsXG4gICdTVUJUT1RBTCcsXG4gICdTVU0nLFxuICAnU1VNSUYnLFxuICAnU1VNSUZTJyxcbiAgJ1NVTVBST0RVQ1QnLFxuICAnU1VNU1EnLFxuICAnU1VNWDJNWTInLFxuICAnU1VNWDJQWTInLFxuICAnU1VNWE1ZMicsXG4gICdTV0lUQ0gnLFxuICAnU1lEJyxcbiAgJ1QnLFxuICAnVC5ESVNUJyxcbiAgJ1QuRElTVC4yVCcsXG4gICdULkRJU1QuUlQnLFxuICAnVC5JTlYnLFxuICAnVC5JTlYuMlQnLFxuICAnVEFOJyxcbiAgJ1RBTkgnLFxuICAnVEJJTExFUScsXG4gICdUQklMTFBSSUNFJyxcbiAgJ1RCSUxMWUlFTEQnLFxuICAnVERJU1QnLFxuICAnVERJU1QyVCcsXG4gICdURElTVFJUJyxcbiAgJ1RFWFQnLFxuICAnVElNRScsXG4gICdUSU1FVkFMVUUnLFxuICAnVElOVicsXG4gICdUSU5WMlQnLFxuICAnVE9EQVknLFxuICAnVFJBTlNQT1NFJyxcbiAgJ1RSRU5EJyxcbiAgJ1RSSU0nLFxuICAnVFJJTU1FQU4nLFxuICAnVFJVRScsXG4gICdUUlVOQycsXG4gICdVTklDSEFSJyxcbiAgJ1VOSUNPREUnLFxuICAnVU5JUVVFJyxcbiAgJ1VQUEVSJyxcbiAgJ1ZBTFVFJyxcbiAgJ1ZBUi5QJyxcbiAgJ1ZBUi5TJyxcbiAgJ1ZBUkEnLFxuICAnVkFSUCcsXG4gICdWQVJQQScsXG4gICdWQVJTJyxcbiAgJ1dFRUtEQVknLFxuICAnV0VFS05VTScsXG4gICdXRUlCVUxMLkRJU1QnLFxuICAnV0VJQlVMTERJU1QnLFxuICAnV09SS0RBWScsXG4gICdYSVJSJyxcbiAgJ1hOUFYnLFxuICAnWE9SJyxcbiAgJ1lFQVInLFxuICAnWUVBUkZSQUMnXG5dO1xuXG5leHBvcnQge1NVUFBPUlRFRF9GT1JNVUxBUyBhcyBkZWZhdWx0fTtcbiIsIi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqXFxcbiAqICAgICAgICAgICAgICAgICAg5Y2V5YWD5qC855u45YWzXG4gKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuY29uc3QgTEFCRUxfRVhUUkFDVF9SRUdFWFAgPSAvXihbJF0pPyhbQS1aYS16XSspKFskXSk/KFswLTldKykkLztcblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RMYWJlbChsYWJlbCkge1xuICAgIGlmICghTEFCRUxfRVhUUkFDVF9SRUdFWFAudGVzdChsYWJlbCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBbLCBjb2x1bW5BYnMsIGNvbHVtbiwgcm93QWJzLCByb3ddID0gbGFiZWwubWF0Y2goTEFCRUxfRVhUUkFDVF9SRUdFWFApO1xuXG4gICAgcmV0dXJuIFt7XG4gICAgICAgIGluZGV4OiByb3dMYWJlbFRvSW5kZXgocm93KSxcbiAgICAgICAgbGFiZWw6IHJvdyxcbiAgICAgICAgaXNBYnNvbHV0ZTogcm93QWJzID09PSAnJCdcbiAgICB9LCB7XG4gICAgICAgIGluZGV4OiBjb2x1bW5MYWJlbFRvSW5kZXgoY29sdW1uKSxcbiAgICAgICAgbGFiZWw6IGNvbHVtbixcbiAgICAgICAgaXNBYnNvbHV0ZTogY29sdW1uQWJzID09PSAnJCdcbiAgICB9XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvTGFiZWwocm93LCBjb2x1bW4pIHtcbiAgICBjb25zdCByb3dMYWJlbCA9IChyb3cuaXNBYnNvbHV0ZSA/ICckJyA6ICcnKSArIHJvd0luZGV4VG9MYWJlbChyb3cuaW5kZXgpO1xuICAgIGNvbnN0IGNvbHVtbkxhYmVsID0gKGNvbHVtbi5pc0Fic29sdXRlID8gJyQnIDogJycpICsgY29sdW1uSW5kZXhUb0xhYmVsKGNvbHVtbi5pbmRleCk7XG4gICAgcmV0dXJuIGNvbHVtbkxhYmVsICsgcm93TGFiZWw7XG59XG5cbmNvbnN0IENPTFVNTl9MQUJFTF9CQVNFID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJztcbmNvbnN0IENPTFVNTl9MQUJFTF9CQVNFX0xFTkdUSCA9IENPTFVNTl9MQUJFTF9CQVNFLmxlbmd0aDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbHVtbkxhYmVsVG9JbmRleChsYWJlbCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gbGFiZWwubGVuZ3RoIC0gMTsgaSA8IGxhYmVsLmxlbmd0aDsgaSArPSAxLCBqIC09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBNYXRoLnBvdyhDT0xVTU5fTEFCRUxfQkFTRV9MRU5HVEgsIGopICogKENPTFVNTl9MQUJFTF9CQVNFLmluZGV4T2YobGFiZWxbaV0pICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLS1yZXN1bHQ7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb2x1bW5JbmRleFRvTGFiZWwoY29sdW1uKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgd2hpbGUgKGNvbHVtbiA+PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29sdW1uICUgQ09MVU1OX0xBQkVMX0JBU0VfTEVOR1RIICsgOTcpICsgcmVzdWx0O1xuICAgICAgICBjb2x1bW4gPSBNYXRoLmZsb29yKGNvbHVtbiAvIENPTFVNTl9MQUJFTF9CQVNFX0xFTkdUSCkgLSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQudG9VcHBlckNhc2UoKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcm93TGFiZWxUb0luZGV4KGxhYmVsKSB7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnNlSW50KGxhYmVsLCAxMCk7XG5cbiAgICBpZiAoTnVtYmVyLmlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5tYXgocmVzdWx0IC0gMSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm93SW5kZXhUb0xhYmVsKHJvdykge1xuICAgIHJldHVybiByb3cgPj0gMCA/IGAke3JvdyArIDF9YCA6ICcnO1xufVxuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqXFxcbiAqICAgICAgICAgICAgICAgICAgbnVtYmVyXG4gKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKG51bWJlcikge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCA9IG51bWJlcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdCA9IG51bWJlci5pbmRleE9mKCcuJykgPiAtMSA/IHBhcnNlRmxvYXQobnVtYmVyKSA6IHBhcnNlSW50KG51bWJlciwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIOWPlui0n+aVsFxuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydE51bWJlcihudW1iZXIpIHtcbiAgICByZXR1cm4gLTEgKiB0b051bWJlcihudW1iZXIpO1xufVxuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqXFxcbiAqICAgICAgICAgICAgICAgICAgc3RyaW5nXG4gKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyaW1FZGdlcyhzdHJpbmcsIG1hcmdpbiA9IDEpIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKG1hcmdpbiwgc3RyaW5nLmxlbmd0aCAtIG1hcmdpbik7XG4gICAgcmV0dXJuIHN0cmluZztcbn0iLCJcbi8qKlxuICogQ2hlY2sgaWYgcHJvdmlkZWQgZXhwcmVzc2lvbiBpcyB2YWxpZCBmb3JtdWxhIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHsqfSBleHByZXNzaW9uIEV4cHJlc3Npb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRm9ybXVsYUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uICYmIChleHByZXNzaW9uICsgJycpLmNoYXJBdCgwKSA9PT0gJz0nID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHByb3ZpZGVkIGZvcm11bGEgZXhwcmVzc2lvbiBpcyBlc2NhcGVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gZXhwcmVzc2lvbiBFeHByZXNzaW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Zvcm11bGFFeHByZXNzaW9uRXNjYXBlZChleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24gJiYgKChleHByZXNzaW9uICsgJycpLmNoYXJBdCgwKSA9PT0gJ1xcJycgJiYgKChleHByZXNzaW9uICsgJycpLmNoYXJBdCgxKSA9PT0gJz0nKSkgPyB0cnVlIDogZmFsc2U7XG59XG5cbi8qKlxuICogUmVwbGFjZSBlc2NhcGVkIGZvcm11bGEgZXhwcmVzc2lvbiBpbnRvIHZhbGlkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBFeHByZXNzaW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5lc2NhcGVGb3JtdWxhRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGlzRm9ybXVsYUV4cHJlc3Npb25Fc2NhcGVkKGV4cHJlc3Npb24pID8gZXhwcmVzc2lvbi5zdWJzdHIoMSkgOiBleHByZXNzaW9uO1xufVxuXG4vKipcbiAqIFVwcGVyIGNhc2UgZm9ybXVsYSBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uIEZvcm11bGEgZXhwcmVzc2lvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1VwcGVyQ2FzZUZvcm11bGEoZXhwcmVzc2lvbikge1xuICAgIGNvbnN0IFBBVFRFUk4gPSAvKFxcXFxcInxcIig/OlxcXFxcInxbXlwiXSkqXCJ8KFxcKykpfChcXFxcJ3wnKD86XFxcXCd8W14nXSkqJ3woXFwrKSkvZztcbiAgICBjb25zdCBzdHJpbmdzID0gZXhwcmVzc2lvbi5tYXRjaChQQVRURVJOKSB8fCBbXTtcbiAgICBsZXQgaW5kZXggPSAtMTtcblxuICAgIHJldHVybiBleHByZXNzaW9uLnRvVXBwZXJDYXNlKCkucmVwbGFjZShQQVRURVJOLCBmdW5jdGlvbigpIHtcbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICByZXR1cm4gc3RyaW5nc1tpbmRleF07XG4gICAgfSk7XG59XG4iLCIvKipcbiAqIGVzNiBwb2x5ZmlsbFxuICogQHBhcmFtIF9nIOWFqOWxgOWPmOmHj++8iOWNs+a1j+iniOWZqOeOr+Wig+S4i+eahCB3aW5kb3cg5a+56LGh77yJXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvbHlmaWxsKF9nKSB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTnVtYmVyXG5cbiAgICBpZiAoIV9nLk51bWJlci5pc05hTikge1xuICAgICAgICBfZy5OdW1iZXIuaXNOYU4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggIT09IHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9nLlN0cmluZy5wcm90b3R5cGUuY29udGFpbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9nLlN0cmluZy5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gISF+dGhpcy5pbmRleE9mKHN0cik7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG5cblxuXG4iLCIvKipcbiAqIOWFqOWxgOmFjee9ruOAglxuICovXG52YXIgZ2xvYmFsU2V0dGluZ3MgPSB7XG4gICAgaWRQcmVmaXg6ICdicmljay1zc2QtJyxcbiAgICBpZFN1ZmZpeDRXb3JrYm9vazogJy13b3JrYm9vaycsXG5cbiAgICBzaGVldDoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rliqjnlJ/miJDlt6XkvZzooajlkI3np7Dml7bnmoTliY3nvIAo5bel5L2c6KGoMSwg5bel5L2c6KGoMi4uLilcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9QcmVmaXg6ICflt6XkvZzooagnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzaGVldCDlkI3np7DkuK3nmoTpnZ7ms5XlrZfnrKbjgILlvq7ova/msqHmnInnm7jlhbPmlofmoaPvvIzku6XkuIvmmK8gQXBhY2hlIFBPSSDnmoTor7TmmI7vvJpcbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IHNoZWV0IG5hbWUgaW4gRXhjZWwgbXVzdCBub3QgZXhjZWVkIDMxIGNoYXJhY3RlcnNcbiAgICAgICAgICogYW5kIG11c3Qgbm90IGNvbnRhaW4gYW55IG9mIHRoZSBhbnkgb2YgdGhlIGZvbGxvd2luZyBjaGFyYWN0ZXJzOlxuICAgICAgICAgKiAgICAtIDB4MDAwMFxuICAgICAgICAgKiAgICAtIDB4MDAwM1xuICAgICAgICAgKiAgICAtIGNvbG9uICg6KVxuICAgICAgICAgKiAgICAtIGJhY2tzbGFzaCAoXFwpXG4gICAgICAgICAqICAgIC0gYXN0ZXJpc2sgKCopXG4gICAgICAgICAqICAgIC0gcXVlc3Rpb24gbWFyayAoPylcbiAgICAgICAgICogICAgLSBmb3J3YXJkIHNsYXNoICgvKVxuICAgICAgICAgKiAgICAtIG9wZW5pbmcgc3F1YXJlIGJyYWNrZXQgKFspXG4gICAgICAgICAqICAgIC0gY2xvc2luZyBzcXVhcmUgYnJhY2tldCAoXSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHNoZWV0TmFtZTogL1tcXFxcL1xcP1xcKjpcXFtcXF0nXCJdLyxcblxuICAgICAgICBhbmltYXRlZDogZmFsc2VcbiAgICB9XG5cbn07XG5cblxuLyoqXG4gKiDpu5jorqTphY3nva5cbiAqL1xudmFyIGRlZmF1bHRTZXR0aW5ncyA9IHtcblxuICAgIHdvcmtib29rOiB7XG4gICAgICAgIGFjdGl2ZVNoZWV0OiAn5bel5L2c6KGoMScsXG4gICAgICAgIHNoZWV0czogW3tcbiAgICAgICAgICAgIG5hbWU6ICflt6XkvZzooagxJ1xuICAgICAgICB9XVxuICAgIH0sXG5cbiAgICBwZXJzaXN0ZW50OiB0cnVlXG5cbn07XG5cbmV4cG9ydCB7Z2xvYmFsU2V0dGluZ3MsIGRlZmF1bHRTZXR0aW5nc307IiwiLyoqXG4gKiDkuovku7blj5HlsITlmahcbiAqXG4gKiBQUzogbm9kZWpzIOeahOezu+e7n+exu+W6kyBFbWl0dGVyIOi/h+Wkp++8jOS4jemAguWQiOWcqOa1j+iniOWZqOeOr+Wig+S9v+eUqOOAguaVheW8leWFpeS4gOS4queugOaYk+WunueOsOOAglxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gICAgLy8g5L+d5oyB5q2k5Ye95pWw5Li656m677yM5Lul5L6/5LqO57un5om/XG59XG5cbkVtaXR0ZXIucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICog6K6i6ZiF5LqL5Lu2XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSDkuovku7blkI1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIOS6i+S7tuWbnuiwg+WHveaVsFxuICAgICAqIEBwYXJhbSBbY3R4XSAtIOiuvue9ruiwg+eUqCBjYWxsYmFjayDml7bnmoTkuIrkuIvmlodcbiAgICAgKiBAcmV0dXJucyB7RW1pdHRlcn1cbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcblxuICAgICAgICAoZVtuYW1lXSB8fCAoZVtuYW1lXSA9IFtdKSkucHVzaCh7XG4gICAgICAgICAgICBmbjogY2FsbGJhY2ssXG4gICAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog6K6i6ZiF5LiA5qyh5oCn5LqL5Lu2XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSDkuovku7blkI1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIOS6i+S7tuWbnuiwg+WHveaVsFxuICAgICAqIEBwYXJhbSBjdHggLSDorr7nva7osIPnlKggY2FsbGJhY2sg5pe255qE5LiK5LiL5paHXG4gICAgICogQHJldHVybnMgeyp8RW1pdHRlcn1cbiAgICAgKi9cbiAgICBvbmNlOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICAgICAgICBzZWxmLm9mZihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lci5fID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIGxpc3RlbmVyLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDlj5HlsITmjIflrprkuovku7ZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOS6i+S7tuWQjVxuICAgICAqIEByZXR1cm5zIHtFbWl0dGVyfVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBkYXRhID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgZXZ0QXJyID0gKCh0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KSlbbmFtZV0gfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGV2dEFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGV2dEFycltpXS5mbi5hcHBseShldnRBcnJbaV0uY3R4LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDms6jplIDkuovku7ZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOS6i+S7tuWQjVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gLSDnu5Hlrprkuovku7bml7bnmoTlm57osIPlh73mlbDvvIzlpoLmnpzkuI3mjIflrprliJnms6jplIDmiYDmnIkgYG5hbWVgIOS6i+S7tlxuICAgICAqIEByZXR1cm5zIHtFbWl0dGVyfVxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5lIHx8ICh0aGlzLmUgPSB7fSk7XG4gICAgICAgIHZhciBldnRzID0gZVtuYW1lXTtcbiAgICAgICAgdmFyIGxpdmVFdmVudHMgPSBbXTtcblxuICAgICAgICBpZiAoZXZ0cyAmJiBjYWxsYmFjaykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2dHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0c1tpXS5mbiAhPT0gY2FsbGJhY2sgJiYgZXZ0c1tpXS5mbi5fICE9PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBsaXZlRXZlbnRzLnB1c2goZXZ0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g6Ziy5q2i5YaF5a2Y5rqi5Ye6XG4gICAgICAgIChsaXZlRXZlbnRzLmxlbmd0aClcbiAgICAgICAgICAgID8gZVtuYW1lXSA9IGxpdmVFdmVudHNcbiAgICAgICAgICAgIDogZGVsZXRlIGVbbmFtZV07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOiOt+WPluWFqOWxgOWUr+S4gOS6i+S7tuWPkeWwhOWZqFxuICAgICAqL1xuICAgIGdldEdsb2JhbEVtaXR0ZXI6ICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gKCkgPT4gaW5zdGFuY2U7XG4gICAgfSgpKVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRW1pdHRlcjtcblxuLyoqXG4gKiDlhajlsYDllK/kuIDkuovku7blj5HlsITlmahcbiAqL1xuZXhwb3J0IGNvbnN0IEdsb2JhbEVtaXR0ZXIgPSBFbWl0dGVyLnByb3RvdHlwZS5nZXRHbG9iYWxFbWl0dGVyKCk7IiwiXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gb2JqZWN0XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBleHRlbnNpb24pIHtcbiAgICBvYmplY3RFYWNoKGV4dGVuc2lvbiwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0RWFjaChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIW9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCAob2JqZWN0Lmhhc093blByb3BlcnR5ICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSkge1xuICAgICAgICAgICAgaWYgKGl0ZXJhdGVlKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBmdW5jdGlvblxuXG52YXIgX2VtcHR5Rm4gPSBmdW5jdGlvbiAoKSB7XG59O1xuXG4vKipcbiAqIOiOt+WPluepuuWHveaVsOOAglxuICogQHBhcmFtIG5ld09uZSDpu5jorqQgYGZhbHNlYO+8jOW9k+S4uiBgdHJ1ZWAg5pe25bCG6L+U5Zue5LiA5Liq5paw55qE56m65Ye95pWw44CCXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKG5ld09uZSA9IGZhbHNlKSB7XG4gICAgaWYgKG5ld09uZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2VtcHR5Rm47XG59XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBzdHJpbmdcblxuXG5leHBvcnQgZnVuY3Rpb24gdXBwZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXBwZXJDYXNlRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxTL2csIGYgPT4gdXBwZXJDYXNlKGYpKTtcbn1cblxuXG5cblxuLyoqXG4gKiDnlJ/miJDkuIDkuKrplb/luqbkuLogMTYg55qE6ZqP5py65a2X56ym5LiyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgICBmdW5jdGlvbiBzNCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXR1cm4gczQoKSArIHM0KCkgKyBzNCgpICsgczQoKTtcbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1peGVkXG5cbi8qKlxuICog5Yik5pat5piv5ZCm5Li6YOepumDlgLzjgIJcbiAqIFBT77ya5q2k5pa55rOV55qE5Yik5pat6YC76L6R5L2c5Li65Y2V5YWD5qC85piv5ZCm5Li656m655qE5L6d5o2u44CCXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKTtcbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGNvb3JkaW5hdGVcblxuXG52YXIgY19pc0VxdWFsID0gZnVuY3Rpb24gKHIxLCByMikge1xuICAgIHJldHVybiByMVswXSA9PT0gcjJbMF0gJiYgcjFbMV0gPT09IHIyWzFdICYmIHIxWzJdID09PSByMlsyXSAmJiByMVszXSA9PT0gcjJbM107XG59O1xuXG52YXIgY19pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgdmFyIHgxID0gTWF0aC5tYXgocjFbMF0sIHIyWzBdKTtcbiAgICB2YXIgeTEgPSBNYXRoLm1heChyMVsxXSwgcjJbMV0pO1xuICAgIHZhciB4MiA9IE1hdGgubWluKHIxWzJdLCByMlsyXSk7XG4gICAgdmFyIHkyID0gTWF0aC5taW4ocjFbM10sIHIyWzNdKTtcblxuICAgIGlmICh4MSA8PSB4MiAmJiB5MSA8PSB5Mikge1xuICAgICAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGNfc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHIxLCByMikge1xuICAgICAgICB2YXIgaW5zID0gY19pbnRlcnNlY3Rpb24ocjEsIHIyKTtcbiAgICAgICAgaWYgKGlucykge1xuICAgICAgICAgICAgcmV0dXJuIGNfaXNFcXVhbChpbnMsIHQgPT09ICdzdWInID8gcjEgOiByMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59O1xuXG5leHBvcnQgdmFyIENvb3JkaW5hdGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiDliKTmlq3lnZDmoIfojIPlm7QgcjEg5piv5ZCm5LiOIHIyIOebuOetieOAglxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHIxXG4gICAgICogQHBhcmFtIHtpbnR9IHIxWzBdIC0g5Z2Q5qCH6IyD5Zu0IHIxIOeahOi1t+Wni+ihjOWdkOagh1xuICAgICAqIEBwYXJhbSB7aW50fSByMVsxXSAtIOWdkOagh+iMg+WbtCByMSDnmoTotbflp4vliJflnZDmoIdcbiAgICAgKiBAcGFyYW0ge2ludH0gcjFbMl0gLSDlnZDmoIfojIPlm7QgcjEg55qE57uI5q2i6KGM5Z2Q5qCHXG4gICAgICogQHBhcmFtIHtpbnR9IHIxWzNdIC0g5Z2Q5qCH6IyD5Zu0IHIxIOeahOe7iOatouWIl+WdkOagh1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHIyXG4gICAgICogQHBhcmFtIHtpbnR9IHIyWzBdIC0g5Z2Q5qCH6IyD5Zu0IHIyIOeahOi1t+Wni+ihjOWdkOagh1xuICAgICAqIEBwYXJhbSB7aW50fSByMlsxXSAtIOWdkOagh+iMg+WbtCByMiDnmoTotbflp4vliJflnZDmoIdcbiAgICAgKiBAcGFyYW0ge2ludH0gcjJbMl0gLSDlnZDmoIfojIPlm7QgcjIg55qE57uI5q2i6KGM5Z2Q5qCHXG4gICAgICogQHBhcmFtIHtpbnR9IHIyWzNdIC0g5Z2Q5qCH6IyD5Zu0IHIyIOeahOe7iOatouWIl+WdkOagh1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRXF1YWw6IGNfaXNFcXVhbCxcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreWdkOagh+iMg+WbtCByMSDmmK/lkKbkuI4gcjIg5a2Y5Zyo5Lqk6ZuG44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaW50ZXJzZWN0aW9uOiBjX2ludGVyc2VjdGlvbixcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreWdkOagh+iMg+WbtCByMSDmmK/lkKbmmK8gcjIg55qE5a2Q6ZuG44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdWJzZXQ6IGNfc2V0KCdzdWInKSxcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreWdkOagh+iMg+WbtCByMSDmmK/lkKbmmK8gcjIg55qE6LaF6ZuG44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdXBlcnNldDogY19zZXQoJ3N1cCcpXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIiwiaW1wb3J0IHt1cHBlckNhc2V9IGZyb20gJy4vY29tbW9uLmpzJ1xuXG4vKipcbiAqIOWkp+Wwj+WGmeS4jeaVj+aEn+eahCBNYXBcbiAqL1xuY2xhc3MgQ2FzZUluc2Vuc2l0aXZlTWFwIHtcblxuICAgIGNvbnN0cnVjdG9yKGl0ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoaXRlcmFibGUpO1xuICAgICAgICB0aGlzLl9rZXlzID0ge307XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICB2YXIgYWNLZXkgPSB0aGlzLl9rZXlzW3VwcGVyQ2FzZShrZXkpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoYWNLZXkpO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2tleXNbdXBwZXJDYXNlKGtleSldID0ga2V5O1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzW3VwcGVyQ2FzZShrZXkpXTtcbiAgICB9XG5cbiAgICBoYXNFeGFjdChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fa2V5cyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICB2YXIgYWNLZXkgPSB0aGlzLl9rZXlzW3VwcGVyQ2FzZShrZXkpXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2tleXNbdXBwZXJDYXNlKGtleSldO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmRlbGV0ZShhY0tleSk7XG4gICAgfVxuXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgfVxuXG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtJdGVyYXRvci48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgICB9XG5cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudmFsdWVzKCk7XG4gICAgfVxuXG4gICAgdG9NYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXA7XG4gICAgfVxuXG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFN0YWNrXG4gKi9cbmNsYXNzIFN0YWNrIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsID0gW10pIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGluaXRpYWw7XG4gICAgfVxuXG4gICAgcHVzaCguLi5pdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgfVxuXG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdm9pZCAwIDogdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5zaXplKCk7XG4gICAgfVxuXG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cblxufVxuXG5leHBvcnQge0Nhc2VJbnNlbnNpdGl2ZU1hcCwgU3RhY2t9O1xuXG4iLCJ2YXIgdGV4dENvbnRleHRTdXBwb3J0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3Rlc3QnKS50ZXh0Q29udGVudCA/IHRydWUgOiBmYWxzZTtcbnZhciBjbGFzc0xpc3RTdXBwb3J0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdCA/IHRydWUgOiBmYWxzZTtcblxudmFyIFJFR19IVE1MX0NIQVJBQ1RFUlMgPSAvKDwoLiopPnwmKC4qKTspLztcblxuLyoqXG4gKiDog73lkIzml7blhbzlrrnmlofmnKzoioLngrnnmoQgaW5uZXJIVE1MIOaWueazleOAglxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5uZXJIVE1MKGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgICBpZiAoUkVHX0hUTUxfQ0hBUkFDVEVSUy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiBjaGlsZC5uZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRleHRDb250ZXh0U3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGF0YSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbXB0eShlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIOWcqOaMh+WumuiKgueCueWQjuaPkuWFpeiKgueCuVxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEBwYXJhbSBjb250ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRBZnRlcihlbGVtZW50LCBjb250ZW50KSB7XG4gICAgaWYgKFJFR19IVE1MX0NIQVJBQ1RFUlMudGVzdChjb250ZW50KSkge1xuICAgICAgICBlbGVtZW50Lmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJlbmQnLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29udGVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0O1xuICAgIGRvIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgKHJldCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiDmuIXnqbrmjIflrprlhYPntKDnmoTmiYDmnInlrZDoioLngrnjgIJcbiAqXG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbGVtZW50KSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCA9IGVsZW1lbnQubGFzdENoaWxkKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8g5pqC5pe26L+Z5qC35aSE55CGIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU1OTU2MVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIOi/lOWbnuaMh+WumuWFg+e0oOeahOWklumrmOW6pu+8iOWMheaLrCBwYWRkaW5n44CBYm9yZGVyIOWPiuWPr+mAieeahCBtYXJnaW4g5YC877yJ44CCXG4gKlxuICogQHBhcmFtIGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhNYXJnaW4gLSDpq5jluqbkuK3mmK/lkKbljIXmi6wgbWFyZ2luIOWAvFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dGVySGVpZ2h0KGVsLCB3aXRoTWFyZ2luID0gdHJ1ZSkge1xuICAgIHZhciBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIHN0eWxlO1xuXG4gICAgaWYgKHdpdGhNYXJnaW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICAgIHJldHVybiBoZWlnaHQ7XG59XG5cblxuLyoqXG4gKiDov5Tlm57mjIflrprlhYPntKDnmoTlpJblrr3luqbvvIjljIXmi6wgcGFkZGluZ+OAgWJvcmRlciDlj4rlj6/pgInnmoQgbWFyZ2luIOWAvO+8ieOAglxuICpcbiAqIEBwYXJhbSBlbFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoTWFyZ2luIC0g5a695bqm5Lit5piv5ZCm5YyF5ousIG1hcmdpbiDlgLxcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlcldpZHRoKGVsLCB3aXRoTWFyZ2luID0gdHJ1ZSkge1xuICAgIHZhciB3aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICAgIHZhciBzdHlsZTtcblxuICAgIGlmICh3aXRoTWFyZ2luID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgd2lkdGggKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCk7XG4gICAgcmV0dXJuIHdpZHRoO1xufVxuXG4iLCIvKipcbiAqIOmYu+atouWFtuWug+ebkeWQrOiiq+iwg+eUqOOAglxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihldmVudCkge1xuICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiDpmLvmraLkuovku7blhpLms6HjgIJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cbn0iXX0=
