(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("numeric"), require("numeral"), require("jStat"));
	else if(typeof define === 'function' && define.amd)
		define(["numeric", "numeral", "jStat"], factory);
	else if(typeof exports === 'object')
		exports["formulajs"] = factory(require("numeric"), require("numeral"), require("jStat"));
	else
		root["formulajs"] = factory(root["numeric"], root["numeral"], root["jStat"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var categories = [
	  __webpack_require__(1),
	  __webpack_require__(15),
	  __webpack_require__(12),
	  __webpack_require__(16),
	  __webpack_require__(2),
	  __webpack_require__(7),
	  __webpack_require__(14),
	  __webpack_require__(17),
	  __webpack_require__(11),
	  __webpack_require__(18),
	  __webpack_require__(6),
	  __webpack_require__(10)
	];

	for (var c in categories) {
	  var category = categories[c];
	  for (var f in category) {
	    exports[f] = exports[f] || category[f];
	  }
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var mathTrig = __webpack_require__(2);
	var statistical = __webpack_require__(6);
	var engineering = __webpack_require__(12);
	var dateTime = __webpack_require__(14);

	function set(fn, root) {
	  if (root) {
	    for (var i in root) {
	      fn[i] = root[i];
	    }
	  }
	  return fn;
	}

	exports.BETADIST = statistical.BETA.DIST;
	exports.BETAINV = statistical.BETA.INV;
	exports.BINOMDIST = statistical.BINOM.DIST;
	exports.CEILING = exports.ISOCEILING = set(mathTrig.CEILING.MATH, mathTrig.CEILING);
	exports.CEILINGMATH = mathTrig.CEILING.MATH;
	exports.CEILINGPRECISE = mathTrig.CEILING.PRECISE;
	exports.CHIDIST = statistical.CHISQ.DIST;
	exports.CHIDISTRT = statistical.CHISQ.DIST.RT;
	exports.CHIINV = statistical.CHISQ.INV;
	exports.CHIINVRT = statistical.CHISQ.INV.RT;
	exports.CHITEST = statistical.CHISQ.TEST;
	exports.CONFIDENCE = set(statistical.CONFIDENCE.NORM, statistical.CONFIDENCE);
	exports.COVAR = statistical.COVARIANCE.P;
	exports.COVARIANCEP = statistical.COVARIANCE.P;
	exports.COVARIANCES = statistical.COVARIANCE.S;
	exports.CRITBINOM = statistical.BINOM.INV;
	exports.EXPONDIST = statistical.EXPON.DIST;
	exports.ERFCPRECISE = engineering.ERFC.PRECISE;
	exports.ERFPRECISE = engineering.ERF.PRECISE;
	exports.FDIST = statistical.F.DIST;
	exports.FDISTRT = statistical.F.DIST.RT;
	exports.FINVRT = statistical.F.INV.RT;
	exports.FINV = statistical.F.INV;
	exports.FLOOR = set(mathTrig.FLOOR.MATH, mathTrig.FLOOR);
	exports.FLOORMATH = mathTrig.FLOOR.MATH;
	exports.FLOORPRECISE = mathTrig.FLOOR.PRECISE;
	exports.FTEST = statistical.F.TEST;
	exports.GAMMADIST = statistical.GAMMA.DIST;
	exports.GAMMAINV = statistical.GAMMA.INV;
	exports.GAMMALNPRECISE = statistical.GAMMALN.PRECISE;
	exports.HYPGEOMDIST = statistical.HYPGEOM.DIST;
	exports.LOGINV = statistical.LOGNORM.INV;
	exports.LOGNORMINV = statistical.LOGNORM.INV;
	exports.LOGNORMDIST = statistical.LOGNORM.DIST;
	exports.MODE = set(statistical.MODE.SNGL, statistical.MODE);
	exports.MODEMULT = statistical.MODE.MULT;
	exports.MODESNGL = statistical.MODE.SNGL;
	exports.NEGBINOMDIST = statistical.NEGBINOM.DIST;
	exports.NETWORKDAYSINTL = dateTime.NETWORKDAYS.INTL;
	exports.NORMDIST = statistical.NORM.DIST;
	exports.NORMINV = statistical.NORM.INV;
	exports.NORMSDIST = statistical.NORM.S.DIST;
	exports.NORMSINV = statistical.NORM.S.INV;
	exports.PERCENTILE = set(statistical.PERCENTILE.EXC, statistical.PERCENTILE);
	exports.PERCENTILEEXC = statistical.PERCENTILE.EXC;
	exports.PERCENTILEINC = statistical.PERCENTILE.INC;
	exports.PERCENTRANK = set(statistical.PERCENTRANK.INC, statistical.PERCENTRANK);
	exports.PERCENTRANKEXC = statistical.PERCENTRANK.EXC;
	exports.PERCENTRANKINC = statistical.PERCENTRANK.INC;
	exports.POISSON = set(statistical.POISSON.DIST, statistical.POISSON);
	exports.POISSONDIST = statistical.POISSON.DIST;
	exports.QUARTILE = set(statistical.QUARTILE.INC, statistical.QUARTILE);
	exports.QUARTILEEXC = statistical.QUARTILE.EXC;
	exports.QUARTILEINC = statistical.QUARTILE.INC;
	exports.RANK = set(statistical.RANK.EQ, statistical.RANK);
	exports.RANKAVG = statistical.RANK.AVG;
	exports.RANKEQ = statistical.RANK.EQ;
	exports.SKEWP = statistical.SKEW.P;
	exports.STDEV = set(statistical.STDEV.S, statistical.STDEV);
	exports.STDEVP = statistical.STDEV.P;
	exports.STDEVS = statistical.STDEV.S;
	exports.TDIST = statistical.T.DIST;
	exports.TDISTRT = statistical.T.DIST.RT;
	exports.TINV = statistical.T.INV;
	exports.TTEST = statistical.T.TEST;
	exports.VAR = set(statistical.VAR.S, statistical.VAR);
	exports.VARP = statistical.VAR.P;
	exports.VARS = statistical.VAR.S;
	exports.WEIBULL = set(statistical.WEIBULL.DIST, statistical.WEIBULL);
	exports.WEIBULLDIST = statistical.WEIBULL.DIST;
	exports.WORKDAYINTL = dateTime.WORKDAY.INTL;
	exports.ZTEST = statistical.Z.TEST;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var numeric = __webpack_require__(3);
	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var statistical = __webpack_require__(6);
	var information = __webpack_require__(11);

	exports.ABS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.abs(utils.parseNumber(number));
	};

	exports.ACOS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.acos(number);
	};

	exports.ACOSH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number + Math.sqrt(number * number - 1));
	};

	exports.ACOT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.atan(1 / number);
	};

	exports.ACOTH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 0.5 * Math.log((number + 1) / (number - 1));
	};

	//TODO: use options
	exports.AGGREGATE = function(function_num, options, ref1, ref2) {
	  function_num = utils.parseNumber(function_num);
	  options = utils.parseNumber(function_num);
	  if (utils.anyIsError(function_num, options)) {
	    return error.value;
	  }
	  switch (function_num) {
	    case 1:
	      return statistical.AVERAGE(ref1);
	    case 2:
	      return statistical.COUNT(ref1);
	    case 3:
	      return statistical.COUNTA(ref1);
	    case 4:
	      return statistical.MAX(ref1);
	    case 5:
	      return statistical.MIN(ref1);
	    case 6:
	      return exports.PRODUCT(ref1);
	    case 7:
	      return statistical.STDEV.S(ref1);
	    case 8:
	      return statistical.STDEV.P(ref1);
	    case 9:
	      return exports.SUM(ref1);
	    case 10:
	      return statistical.VAR.S(ref1);
	    case 11:
	      return statistical.VAR.P(ref1);
	    case 12:
	      return statistical.MEDIAN(ref1);
	    case 13:
	      return statistical.MODE.SNGL(ref1);
	    case 14:
	      return statistical.LARGE(ref1, ref2);
	    case 15:
	      return statistical.SMALL(ref1, ref2);
	    case 16:
	      return statistical.PERCENTILE.INC(ref1, ref2);
	    case 17:
	      return statistical.QUARTILE.INC(ref1, ref2);
	    case 18:
	      return statistical.PERCENTILE.EXC(ref1, ref2);
	    case 19:
	      return statistical.QUARTILE.EXC(ref1, ref2);
	  }
	};

	exports.ARABIC = function(text) {
	  // Credits: Rafa? Kukawski
	  if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {
	    return error.value;
	  }
	  var r = 0;
	  text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i) {
	    r += {
	      M: 1000,
	      CM: 900,
	      D: 500,
	      CD: 400,
	      C: 100,
	      XC: 90,
	      L: 50,
	      XL: 40,
	      X: 10,
	      IX: 9,
	      V: 5,
	      IV: 4,
	      I: 1
	    }[i];
	  });
	  return r;
	};

	exports.ASIN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.asin(number);
	};

	exports.ASINH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number + Math.sqrt(number * number + 1));
	};

	exports.ATAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.atan(number);
	};

	exports.ATAN2 = function(number_x, number_y) {
	  number_x = utils.parseNumber(number_x);
	  number_y = utils.parseNumber(number_y);
	  if (utils.anyIsError(number_x, number_y)) {
	    return error.value;
	  }
	  return Math.atan2(number_x, number_y);
	};

	exports.ATANH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log((1 + number) / (1 - number)) / 2;
	};

	exports.BASE = function(number, radix, min_length) {
	  min_length = min_length || 0;

	  number = utils.parseNumber(number);
	  radix = utils.parseNumber(radix);
	  min_length = utils.parseNumber(min_length);
	  if (utils.anyIsError(number, radix, min_length)) {
	    return error.value;
	  }
	  min_length = (min_length === undefined) ? 0 : min_length;
	  var result = number.toString(radix);
	  return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result;
	};

	exports.CEILING = function(number, significance, mode) {
	  significance = (significance === undefined) ? 1 : Math.abs(significance);
	  mode = mode || 0;

	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  mode = utils.parseNumber(mode);
	  if (utils.anyIsError(number, significance, mode)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.ceil(number / significance) * significance, precision);
	  } else {
	    if (mode === 0) {
	      return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
	    } else {
	      return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
	    }
	  }
	};

	exports.CEILING.MATH = exports.CEILING;

	exports.CEILING.PRECISE = exports.CEILING;

	exports.COMBIN = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return exports.FACT(number) / (exports.FACT(number_chosen) * exports.FACT(number - number_chosen));
	};

	exports.COMBINA = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return (number === 0 && number_chosen === 0) ? 1 : exports.COMBIN(number + number_chosen - 1, number - 1);
	};

	exports.COS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.cos(number);
	};

	exports.COSH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return (Math.exp(number) + Math.exp(-number)) / 2;
	};

	exports.COT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.tan(number);
	};

	exports.COTH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var e2 = Math.exp(2 * number);
	  return (e2 + 1) / (e2 - 1);
	};

	exports.CSC = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.sin(number);
	};

	exports.CSCH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 2 / (Math.exp(number) - Math.exp(-number));
	};

	exports.DECIMAL = function(number, radix) {
	  if (arguments.length < 1) {
	    return error.value;
	  }


	  return parseInt(number, radix);
	};

	exports.DEGREES = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return number * 180 / Math.PI;
	};

	exports.EVEN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return exports.CEILING(number, -2, -1);
	};

	exports.EXP = Math.exp;

	var MEMOIZED_FACT = [];
	exports.FACT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var n = Math.floor(number);
	  if (n === 0 || n === 1) {
	    return 1;
	  } else if (MEMOIZED_FACT[n] > 0) {
	    return MEMOIZED_FACT[n];
	  } else {
	    MEMOIZED_FACT[n] = exports.FACT(n - 1) * n;
	    return MEMOIZED_FACT[n];
	  }
	};

	exports.FACTDOUBLE = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var n = Math.floor(number);
	  if (n <= 0) {
	    return 1;
	  } else {
	    return n * exports.FACTDOUBLE(n - 2);
	  }
	};

	exports.FLOOR = function(number, significance) {
	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(number, significance)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }

	  if (!(number > 0 && significance > 0) && !(number < 0 && significance < 0)) {
	    return error.num;
	  }

	  significance = Math.abs(significance);
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.floor(number / significance) * significance, precision);
	  } else {
	    return -exports.ROUND(Math.ceil(Math.abs(number) / significance), precision);
	  }
	};

	//TODO: Verify
	exports.FLOOR.MATH = function(number, significance, mode) {
	  significance = (significance === undefined) ? 1 : significance;
	  mode = (mode === undefined) ? 0 : mode;

	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  mode = utils.parseNumber(mode);
	  if (utils.anyIsError(number, significance, mode)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }

	  significance = significance ? Math.abs(significance) : 1;
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.floor(number / significance) * significance, precision);
	  } else if (mode === 0 || mode === undefined) {
	    return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
	  }
	  return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
	};

	// Deprecated
	exports.FLOOR.PRECISE = exports.FLOOR.MATH;

	// adapted http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
	exports.GCD = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var r0 = range[0];
	  var x = r0 < 0 ? -r0 : r0;
	  for (var i = 1; i < n; i++) {
	    var ri = range[i];
	    var y = ri < 0 ? -ri : ri;
	    while (x && y) {
	      if (x > y) {
	        x %= y;
	      } else {
	        y %= x;
	      }
	    }
	    x += y;
	  }
	  return x;
	};


	exports.INT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.floor(number);
	};

	//TODO: verify
	exports.ISO = {
	  CEILING: exports.CEILING
	};

	exports.LCM = function() {
	  // Credits: Jonas Raoni Soares Silva
	  var o = utils.parseNumberArray(utils.flatten(arguments));
	  if (o instanceof Error) {
	    return o;
	  }
	  for (var i, j, n, d, r = 1;
	    (n = o.pop()) !== undefined;) {
	    while (n > 1) {
	      if (n % 2) {
	        for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
	          //empty
	        }
	        d = (i <= j) ? i : n;
	      } else {
	        d = 2;
	      }
	      for (n /= d, r *= d, i = o.length; i;
	        (o[--i] % d) === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {
	        //empty
	      }
	    }
	  }
	  return r;
	};

	exports.LN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number);
	};

	exports.LOG = function(number, base) {
	  number = utils.parseNumber(number);
	  base = utils.parseNumber(base);
	  if (utils.anyIsError(number, base)) {
	    return error.value;
	  }
	  base = (base === undefined) ? 10 : base;
	  return Math.log(number) / Math.log(base);
	};

	exports.LOG10 = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number) / Math.log(10);
	};

	exports.MDETERM = function(matrix) {
	  matrix = utils.parseMatrix(matrix);
	  if (matrix instanceof Error) {
	    return matrix;
	  }
	  return numeric.det(matrix);
	};

	exports.MINVERSE = function(matrix) {
	  matrix = utils.parseMatrix(matrix);
	  if (matrix instanceof Error) {
	    return matrix;
	  }
	  return numeric.inv(matrix);
	};

	exports.MMULT = function(matrix1, matrix2) {
	  matrix1 = utils.parseMatrix(matrix1);
	  matrix2 = utils.parseMatrix(matrix2);
	  if (utils.anyIsError(matrix1, matrix2)) {
	    return error.value;
	  }
	  return numeric.dot(matrix1, matrix2);
	};

	exports.MOD = function(dividend, divisor) {
	  dividend = utils.parseNumber(dividend);
	  divisor = utils.parseNumber(divisor);
	  if (utils.anyIsError(dividend, divisor)) {
	    return error.value;
	  }
	  if (divisor === 0) {
	    return error.div0;
	  }
	  var modulus = Math.abs(dividend % divisor);
	  return (divisor > 0) ? modulus : -modulus;
	};

	  exports.MROUND = function(number, multiple) {
	  number = utils.parseNumber(number);
	  multiple = utils.parseNumber(multiple);
	  if (utils.anyIsError(number, multiple)) {
	    return error.value;
	  }
	  if (number * multiple < 0) {
	    return error.num;
	  }

	  return Math.round(number / multiple) * multiple;
	};

	exports.MULTINOMIAL = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  var sum = 0;
	  var divisor = 1;
	  for (var i = 0; i < args.length; i++) {
	    sum += args[i];
	    divisor *= exports.FACT(args[i]);
	  }
	  return exports.FACT(sum) / divisor;
	};

	exports.MUNIT = function(dimension) {
	  dimension = utils.parseNumber(dimension);
	  if (dimension instanceof Error) {
	    return dimension;
	  }
	  return numeric.identity(dimension);
	};

	exports.ODD = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var temp = Math.ceil(Math.abs(number));
	  temp = (temp & 1) ? temp : temp + 1;
	  return (number > 0) ? temp : -temp;
	};

	exports.PI = function() {
	  return Math.PI;
	};

	exports.POWER = function(number, power) {
	  number = utils.parseNumber(number);
	  power = utils.parseNumber(power);
	  if (utils.anyIsError(number, power)) {
	    return error.value;
	  }
	  var result = Math.pow(number, power);
	  if (isNaN(result)) {
	    return error.num;
	  }

	  return result;
	};

	exports.PRODUCT = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  var result = 1;
	  for (var i = 0; i < args.length; i++) {
	    result *= args[i];
	  }
	  return result;
	};

	exports.QUOTIENT = function(numerator, denominator) {
	  numerator = utils.parseNumber(numerator);
	  denominator = utils.parseNumber(denominator);
	  if (utils.anyIsError(numerator, denominator)) {
	    return error.value;
	  }
	  return parseInt(numerator / denominator, 10);
	};

	exports.RADIANS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return number * Math.PI / 180;
	};

	exports.RAND = function() {
	  return Math.random();
	};

	exports.RANDBETWEEN = function(bottom, top) {
	  bottom = utils.parseNumber(bottom);
	  top = utils.parseNumber(top);
	  if (utils.anyIsError(bottom, top)) {
	    return error.value;
	  }
	  // Creative Commons Attribution 3.0 License
	  // Copyright (c) 2012 eqcode
	  return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
	};

	// TODO
	exports.ROMAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  // The MIT License
	  // Copyright (c) 2008 Steven Levithan
	  var digits = String(number).split('');
	  var key = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
	  var roman = '';
	  var i = 3;
	  while (i--) {
	    roman = (key[+digits.pop() + (i * 10)] || '') + roman;
	  }
	  return new Array(+digits.join('') + 1).join('M') + roman;
	};

	exports.ROUND = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
	};

	exports.ROUNDDOWN = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

	exports.ROUNDUP = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.ceil(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

	exports.SEC = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.cos(number);
	};

	exports.SECH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 2 / (Math.exp(number) + Math.exp(-number));
	};

	exports.SERIESSUM = function(x, n, m, coefficients) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  m = utils.parseNumber(m);
	  coefficients = utils.parseNumberArray(coefficients);
	  if (utils.anyIsError(x, n, m, coefficients)) {
	    return error.value;
	  }
	  var result = coefficients[0] * Math.pow(x, n);
	  for (var i = 1; i < coefficients.length; i++) {
	    result += coefficients[i] * Math.pow(x, n + i * m);
	  }
	  return result;
	};

	exports.SIGN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  if (number < 0) {
	    return -1;
	  } else if (number === 0) {
	    return 0;
	  } else {
	    return 1;
	  }
	};

	exports.SIN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.sin(number);
	};

	  exports.SINH = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    return (Math.exp(number) - Math.exp(-number)) / 2;
	  };

	  exports.SQRT = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    if (number < 0) {
	      return error.num;
	    }
	    return Math.sqrt(number);
	  };

	  exports.SQRTPI = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    return Math.sqrt(number * Math.PI);
	  };

	exports.SUBTOTAL = function(function_code, ref1) {
	  function_code = utils.parseNumber(function_code);
	  if (function_code instanceof Error) {
	    return function_code;
	  }
	  switch (function_code) {
	    case 1:
	      return statistical.AVERAGE(ref1);
	    case 2:
	      return statistical.COUNT(ref1);
	    case 3:
	      return statistical.COUNTA(ref1);
	    case 4:
	      return statistical.MAX(ref1);
	    case 5:
	      return statistical.MIN(ref1);
	    case 6:
	      return exports.PRODUCT(ref1);
	    case 7:
	      return statistical.STDEV.S(ref1);
	    case 8:
	      return statistical.STDEV.P(ref1);
	    case 9:
	      return exports.SUM(ref1);
	    case 10:
	      return statistical.VAR.S(ref1);
	    case 11:
	      return statistical.VAR.P(ref1);
	      // no hidden values for us
	    case 101:
	      return statistical.AVERAGE(ref1);
	    case 102:
	      return statistical.COUNT(ref1);
	    case 103:
	      return statistical.COUNTA(ref1);
	    case 104:
	      return statistical.MAX(ref1);
	    case 105:
	      return statistical.MIN(ref1);
	    case 106:
	      return exports.PRODUCT(ref1);
	    case 107:
	      return statistical.STDEV.S(ref1);
	    case 108:
	      return statistical.STDEV.P(ref1);
	    case 109:
	      return exports.SUM(ref1);
	    case 110:
	      return statistical.VAR.S(ref1);
	    case 111:
	      return statistical.VAR.P(ref1);

	  }
	};

	exports.ADD = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.value;
	  }

	  return num1 + num2;
	};

	exports.MINUS = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.value;
	  }

	  return num1 - num2;
	};

	exports.DIVIDE = function (dividend, divisor) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  dividend = utils.parseNumber(dividend);
	  divisor = utils.parseNumber(divisor);
	  if (utils.anyIsError(dividend, divisor)) {
	    return error.value;
	  }

	  if (divisor === 0) {
	    return error.div0;
	  }

	  return dividend / divisor;
	};

	exports.MULTIPLY = function (factor1, factor2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  factor1 = utils.parseNumber(factor1);
	  factor2 = utils.parseNumber(factor2);
	  if (utils.anyIsError(factor1, factor2)) {
	    return error.value;
	  }

	  return factor1 * factor2;
	};

	exports.GTE = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 >= num2;
	};

	exports.LT = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 < num2;
	};


	exports.LTE = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 <= num2;
	};

	exports.EQ = function (value1, value2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  return value1 === value2;
	};

	exports.NE = function (value1, value2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  return value1 !== value2;
	};

	exports.POW = function (base, exponent) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  base = utils.parseNumber(base);
	  exponent = utils.parseNumber(exponent);
	  if (utils.anyIsError(base, exponent)) {
	    return error.error;
	  }

	  return exports.POWER(base, exponent);
	};

	exports.SUM = function() {
	  var result = 0;
	  var argsKeys = Object.keys(arguments);
	  for (var i = 0; i < argsKeys.length; ++i) {
	    var elt = arguments[argsKeys[i]];
	    if (typeof elt === 'number') {
	      result += elt;
	    } else if (typeof elt === 'string') {
	      var parsed = parseFloat(elt);
	      !isNaN(parsed) && (result += parsed);
	    } else if (Array.isArray(elt)) {
	      result += exports.SUM.apply(null, elt);
	    }
	  }
	  return result;
	};

	exports.SUMIF = function(range, criteria) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (range instanceof Error) {
	    return range;
	  }
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    result += (eval(range[i] + criteria)) ? range[i] : 0; // jshint ignore:line
	  }
	  return result;
	};

	exports.SUMIFS = function() {
	  var args = utils.argsToArray(arguments);
	  var range = utils.parseNumberArray(utils.flatten(args.shift()));
	  if (range instanceof Error) {
	    return range;
	  }
	  var criteria = args;

	  var n_range_elements = range.length;
	  var n_criterias = criteria.length;

	  var result = 0;
	  for (var i = 0; i < n_range_elements; i++) {
	    var el = range[i];
	    var condition = '';
	    for (var c = 0; c < n_criterias; c++) {
	      condition += el + criteria[c];
	      if (c !== n_criterias - 1) {
	        condition += '&&';
	      }
	    }
	    if (eval(condition)) { // jshint ignore:line
	      result += el;
	    }
	  }
	  return result;
	};

	exports.SUMPRODUCT = function() {
	  if (!arguments || arguments.length === 0) {
	    return error.value;
	  }
	  var arrays = arguments.length + 1;
	  var result = 0;
	  var product;
	  var k;
	  var _i;
	  var _ij;
	  for (var i = 0; i < arguments[0].length; i++) {
	    if (!(arguments[0][i] instanceof Array)) {
	      product = 1;
	      for (k = 1; k < arrays; k++) {
	        _i = utils.parseNumber(arguments[k - 1][i]);
	        if (_i instanceof Error) {
	          return _i;
	        }
	        product *= _i;
	      }
	      result += product;
	    } else {
	      for (var j = 0; j < arguments[0][i].length; j++) {
	        product = 1;
	        for (k = 1; k < arrays; k++) {
	          _ij = utils.parseNumber(arguments[k - 1][i][j]);
	          if (_ij instanceof Error) {
	            return _ij;
	          }
	          product *= _ij;
	        }
	        result += product;
	      }
	    }
	  }
	  return result;
	};

	exports.SUMSQ = function() {
	  var numbers = utils.parseNumberArray(utils.flatten(arguments));
	  if (numbers instanceof Error) {
	    return numbers;
	  }
	  var result = 0;
	  var length = numbers.length;
	  for (var i = 0; i < length; i++) {
	    result += (information.ISNUMBER(numbers[i])) ? numbers[i] * numbers[i] : 0;
	  }
	  return result;
	};

	exports.SUMX2MY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  for (var i = 0; i < array_x.length; i++) {
	    result += array_x[i] * array_x[i] - array_y[i] * array_y[i];
	  }
	  return result;
	};

	exports.SUMX2PY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  for (var i = 0; i < array_x.length; i++) {
	    result += array_x[i] * array_x[i] + array_y[i] * array_y[i];
	  }
	  return result;
	};

	exports.SUMXMY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  array_x = utils.flatten(array_x);
	  array_y = utils.flatten(array_y);
	  for (var i = 0; i < array_x.length; i++) {
	    result += Math.pow(array_x[i] - array_y[i], 2);
	  }
	  return result;
	};

	exports.TAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.tan(number);
	};

	exports.TANH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var e2 = Math.exp(2 * number);
	  return (e2 - 1) / (e2 + 1);
	};

	exports.TRUNC = function(number, digits) {
	  digits = (digits === undefined) ? 0 : digits;
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	function flattenShallow(array) {
	  if (!array || !array.reduce) { return array; }
	  return array.reduce(function(a, b) {
	    var aIsArray = Array.isArray(a);
	    var bIsArray = Array.isArray(b);
	    if (aIsArray && bIsArray ) {
	      return a.concat(b);
	    }
	    if (aIsArray) {
	      a.push(b);
	      return a;
	    }
	    if (bIsArray) {
	      return [a].concat(b);
	    }
	    return [a, b];
	  });
	}

	function isFlat(array) {
	  if (!array) { return false; }
	  for (var i = 0; i < array.length; ++i) {
	    if (Array.isArray(array[i])) {
	      return false;
	    }
	  }
	  return true;
	}

	exports.flatten = function() {
	  var result = exports.argsToArray.apply(null, arguments);
	  while (!isFlat(result)) {
	    result = flattenShallow(result);
	  }
	  return result;
	};

	exports.argsToArray = function(args) {
	  return Array.prototype.slice.call(args, 0);
	};

	exports.numbers = function() {
	  var possibleNumbers = this.flatten.apply(null, arguments);
	  return possibleNumbers.filter(function(el) {
	    return typeof el === 'number';
	  });
	};

	exports.cleanFloat = function(number) {
	  var power = 1e14;
	  return Math.round(number * power) / power;
	};

	exports.parseBool = function(bool) {
	  if (typeof bool === 'boolean') {
	    return bool;
	  }

	  if (bool instanceof Error) {
	    return bool;
	  }

	  if (typeof bool === 'number') {
	    return bool !== 0;
	  }

	  if (typeof bool === 'string') {
	    var up = bool.toUpperCase();
	    if (up === 'TRUE') {
	      return true;
	    }

	    if (up === 'FALSE') {
	      return false;
	    }
	  }

	  if (bool instanceof Date && !isNaN(bool)) {
	    return true;
	  }

	  return error.value;
	};

	exports.parseNumber = function(string) {
	  if (string === undefined || string === '') {
	    return error.value;
	  }
	  if (!isNaN(string)) {
	    return parseFloat(string);
	  }
	  return error.value;
	};

	exports.parseNumberArray = function(arr) {
	  var len;
	  if (!arr || (len = arr.length) === 0) {
	    return error.value;
	  }
	  var parsed;
	  while (len--) {
	    parsed = exports.parseNumber(arr[len]);
	    if (parsed === error.value) {
	      return parsed;
	    }
	    arr[len] = parsed;
	  }
	  return arr;
	};

	exports.parseMatrix = function(matrix) {
	  var n;
	  if (!matrix || (n = matrix.length) === 0) {
	    return error.value;
	  }
	  var pnarr;
	  for (var i = 0; i < matrix.length; i++) {
	    pnarr = exports.parseNumberArray(matrix[i]);
	    matrix[i] = pnarr;
	    if (pnarr instanceof Error) {
	      return pnarr;
	    }
	  }
	  return matrix;
	};

	var d1900 = new Date(1900, 0, 1);
	exports.parseDate = function(date) {
	  if (!isNaN(date)) {
	    if (date instanceof Date) {
	      return new Date(date);
	    }
	    var d = parseInt(date, 10);
	    if (d < 0) {
	      return error.num;
	    }
	    if (d <= 60) {
	      return new Date(d1900.getTime() + (d - 1) * 86400000);
	    }
	    return new Date(d1900.getTime() + (d - 2) * 86400000);
	  }
	  if (typeof date === 'string') {
	    date = new Date(date);
	    if (!isNaN(date)) {
	      return date;
	    }
	  }
	  return error.value;
	};

	exports.parseDateArray = function(arr) {
	  var len = arr.length;
	  var parsed;
	  while (len--) {
	    parsed = this.parseDate(arr[len]);
	    if (parsed === error.value) {
	      return parsed;
	    }
	    arr[len] = parsed;
	  }
	  return arr;
	};

	exports.anyIsError = function() {
	  var n = arguments.length;
	  while (n--) {
	    if (arguments[n] instanceof Error) {
	      return true;
	    }
	  }
	  return false;
	};

	exports.arrayValuesToNumbers = function(arr) {
	  var n = arr.length;
	  var el;
	  while (n--) {
	    el = arr[n];
	    if (typeof el === 'number') {
	      continue;
	    }
	    if (el === true) {
	      arr[n] = 1;
	      continue;
	    }
	    if (el === false) {
	      arr[n] = 0;
	      continue;
	    }
	    if (typeof el === 'string') {
	      var number = this.parseNumber(el);
	      if (number instanceof Error) {
	        arr[n] = 0;
	      } else {
	        arr[n] = number;
	      }
	    }
	  }
	  return arr;
	};

	exports.rest = function(array, idx) {
	  idx = idx || 1;
	  if (!array || typeof array.slice !== 'function') {
	    return array;
	  }
	  return array.slice(idx);
	};

	exports.initial = function(array, idx) {
	  idx = idx || 1;
	  if (!array || typeof array.slice !== 'function') {
	    return array;
	  }
	  return array.slice(0, array.length - idx);
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	exports.nil = new Error('#NULL!');
	exports.div0 = new Error('#DIV/0!');
	exports.value = new Error('#VALUE?');
	exports.ref = new Error('#REF!');
	exports.name = new Error('#NAME?');
	exports.num = new Error('#NUM!');
	exports.na = new Error('#N/A');
	exports.error = new Error('#ERROR!');
	exports.data = new Error('#GETTING_DATA');


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var mathTrig = __webpack_require__(2);
	var text = __webpack_require__(7);
	var jStat = __webpack_require__(9).jStat;
	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var misc = __webpack_require__(10);

	var SQRT2PI = 2.5066282746310002;

	exports.AVEDEV = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  return jStat.sum(jStat(range).subtract(jStat.mean(range)).abs()[0]) / range.length;
	};

	exports.AVERAGE = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sum = 0;
	  var count = 0;
	  for (var i = 0; i < n; i++) {
	    sum += range[i];
	    count += 1;
	  }
	  return sum / count;
	};

	exports.AVERAGEA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sum = 0;
	  var count = 0;
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sum += el;
	    }
	    if (el === true) {
	      sum++;
	    }
	    if (el !== null) {
	      count++;
	    }
	  }
	  return sum / count;
	};

	exports.AVERAGEIF = function(range, criteria, average_range) {
	  average_range = average_range || range;
	  range = utils.flatten(range);
	  average_range = utils.parseNumberArray(utils.flatten(average_range));
	  if (average_range instanceof Error) {
	    return average_range;
	  }
	  var average_count = 0;
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (eval(range[i] + criteria)) { // jshint ignore:line
	      result += average_range[i];
	      average_count++;
	    }
	  }
	  return result / average_count;
	};

	exports.AVERAGEIFS = function() {
	  // Does not work with multi dimensional ranges yet!
	  //http://office.microsoft.com/en-001/excel-help/averageifs-function-HA010047493.aspx
	  var args = utils.argsToArray(arguments);
	  var criteria = (args.length - 1) / 2;
	  var range = utils.flatten(args[0]);
	  var count = 0;
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    var condition = '';
	    for (var j = 0; j < criteria; j++) {
	      condition += args[2 * j + 1][i] + args[2 * j + 2];
	      if (j !== criteria - 1) {
	        condition += '&&';
	      }
	    }
	    if (eval(condition)) { // jshint ignore:line
	      result += range[i];
	      count++;
	    }
	  }

	  var average = result / count;
	  if (isNaN(average)) {
	    return 0;
	  } else {
	    return average;
	  }
	};

	exports.BETA = {};

	exports.BETA.DIST = function(x, alpha, beta, cumulative, A, B) {
	  if (arguments.length < 4) {
	    return error.value;
	  }

	  A = (A === undefined) ? 0 : A;
	  B = (B === undefined) ? 1 : B;

	  x = utils.parseNumber(x);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  A = utils.parseNumber(A);
	  B = utils.parseNumber(B);
	  if (utils.anyIsError(x, alpha, beta, A, B)) {
	    return error.value;
	  }

	  x = (x - A) / (B - A);
	  return (cumulative) ? jStat.beta.cdf(x, alpha, beta) : jStat.beta.pdf(x, alpha, beta);
	};

	exports.BETA.INV = function(probability, alpha, beta, A, B) {
	  A = (A === undefined) ? 0 : A;
	  B = (B === undefined) ? 1 : B;

	  probability = utils.parseNumber(probability);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  A = utils.parseNumber(A);
	  B = utils.parseNumber(B);
	  if (utils.anyIsError(probability, alpha, beta, A, B)) {
	    return error.value;
	  }

	  return jStat.beta.inv(probability, alpha, beta) * (B - A) + A;
	};

	exports.BINOM = {};

	exports.BINOM.DIST = function(successes, trials, probability, cumulative) {
	  successes = utils.parseNumber(successes);
	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  cumulative = utils.parseNumber(cumulative);
	  if (utils.anyIsError(successes, trials, probability, cumulative)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.binomial.cdf(successes, trials, probability) : jStat.binomial.pdf(successes, trials, probability);
	};

	exports.BINOM.DIST.RANGE = function(trials, probability, successes, successes2) {
	  successes2 = (successes2 === undefined) ? successes : successes2;

	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  successes = utils.parseNumber(successes);
	  successes2 = utils.parseNumber(successes2);
	  if (utils.anyIsError(trials, probability, successes, successes2)) {
	    return error.value;
	  }

	  var result = 0;
	  for (var i = successes; i <= successes2; i++) {
	    result += mathTrig.COMBIN(trials, i) * Math.pow(probability, i) * Math.pow(1 - probability, trials - i);
	  }
	  return result;
	};

	exports.BINOM.INV = function(trials, probability, alpha) {
	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  alpha = utils.parseNumber(alpha);
	  if (utils.anyIsError(trials, probability, alpha)) {
	    return error.value;
	  }

	  var x = 0;
	  while (x <= trials) {
	    if (jStat.binomial.cdf(x, trials, probability) >= alpha) {
	      return x;
	    }
	    x++;
	  }
	};

	exports.CHISQ = {};

	exports.CHISQ.DIST = function(x, k, cumulative) {
	  x = utils.parseNumber(x);
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(x, k)) {
	    return error.value;
	  }

	  return (cumulative) ? jStat.chisquare.cdf(x, k) : jStat.chisquare.pdf(x, k);
	};

	exports.CHISQ.DIST.RT = function(x, k) {
	  if (!x | !k) {
	    return error.na;
	  }

	  if (x < 1 || k > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof k !== 'number')) {
	    return error.value;
	  }

	  return 1 -  jStat.chisquare.cdf(x, k);
	};

	exports.CHISQ.INV = function(probability, k) {
	  probability = utils.parseNumber(probability);
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(probability, k)) {
	    return error.value;
	  }
	  return jStat.chisquare.inv(probability, k);
	};

	exports.CHISQ.INV.RT = function(p, k) {
	  if (!p | !k) {
	    return error.na;
	  }

	  if (p < 0 || p > 1 || k < 1 || k > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof p !== 'number') || (typeof k !== 'number')) {
	    return error.value;
	  }

	  return jStat.chisquare.inv(1.0 - p, k);
	};

	exports.CHISQ.TEST = function(observed, expected) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if ((!(observed instanceof Array)) || (!(expected instanceof Array))) {
	    return error.value;
	  }

	  if (observed.length !== expected.length) {
	    return error.value;
	  }

	  if (observed[0] && expected[0] &&
	      observed[0].length !== expected[0].length) {
	    return error.value;
	  }

	  var row = observed.length;
	  var tmp, i, j;

	  // Convert single-dimension array into two-dimension array
	  for (i = 0; i < row; i ++) {
	    if (!(observed[i] instanceof Array)) {
	      tmp = observed[i];
	      observed[i] = [];
	      observed[i].push(tmp);
	    }
	    if (!(expected[i] instanceof Array)) {
	      tmp = expected[i];
	      expected[i] = [];
	      expected[i].push(tmp);
	    }
	  }

	  var col = observed[0].length;
	  var dof = (col === 1) ? row-1 : (row-1)*(col-1);
	  var xsqr = 0;
	  var Pi =Math.PI;

	  for (i = 0; i < row; i ++) {
	    for (j = 0; j < col; j ++) {
	      xsqr += Math.pow((observed[i][j] - expected[i][j]), 2) / expected[i][j];
	    }
	  }

	  // Get independency by X square and its degree of freedom
	  function ChiSq(xsqr, dof) {
	    var p = Math.exp(-0.5 * xsqr);
	    if((dof%2) === 1) {
	      p = p * Math.sqrt(2 * xsqr/Pi);
	    }
	    var k = dof;
	    while(k >= 2) {
	      p = p * xsqr/k;
	      k = k - 2;
	    }
	    var t = p;
	    var a = dof;
	    while (t > 0.0000000001*p) {
	      a = a + 2;
	      t = t * xsqr/a;
	      p = p + t;
	    }
	    return 1-p;
	  }

	  return Math.round(ChiSq(xsqr, dof) * 1000000) / 1000000;
	};

	exports.COLUMN = function(matrix, index) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (index < 0) {
	    return error.num;
	  }

	  if (!(matrix instanceof Array) || (typeof index !== 'number')) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return undefined;
	  }

	  return jStat.col(matrix, index);
	};

	exports.COLUMNS = function(matrix) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (!(matrix instanceof Array)) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return 0;
	  }

	  return jStat.cols(matrix);
	};

	exports.CONFIDENCE = {};

	exports.CONFIDENCE.NORM = function(alpha, sd, n) {
	  alpha = utils.parseNumber(alpha);
	  sd = utils.parseNumber(sd);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(alpha, sd, n)) {
	    return error.value;
	  }
	  return jStat.normalci(1, alpha, sd, n)[1] - 1;
	};

	exports.CONFIDENCE.T = function(alpha, sd, n) {
	  alpha = utils.parseNumber(alpha);
	  sd = utils.parseNumber(sd);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(alpha, sd, n)) {
	    return error.value;
	  }
	  return jStat.tci(1, alpha, sd, n)[1] - 1;
	};

	exports.CORREL = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  return jStat.corrcoeff(array1, array2);
	};

	exports.COUNT = function() {
	  return utils.numbers(utils.flatten(arguments)).length;
	};

	exports.COUNTA = function() {
	  var range = utils.flatten(arguments);
	  return range.length - exports.COUNTBLANK(range);
	};

	exports.COUNTIN = function (range, value) {
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (range[i] === value) {
	      result++;
	    }
	  }
	  return result;
	};


	exports.COUNTBLANK = function() {
	  var range = utils.flatten(arguments);
	  var blanks = 0;
	  var element;
	  for (var i = 0; i < range.length; i++) {
	    element = range[i];
	    if (element === null || element === '') {
	      blanks++;
	    }
	  }
	  return blanks;
	};

	exports.COUNTIF = function(range, criteria) {
	  range = utils.flatten(range);
	  if (!/[<>=!]/.test(criteria)) {
	    criteria = '=="' + criteria + '"';
	  }
	  var matches = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (typeof range[i] !== 'string') {
	      if (eval(range[i] + criteria)) { // jshint ignore:line
	        matches++;
	      }
	    } else {
	      if (eval('"' + range[i] + '"' + criteria)) { // jshint ignore:line
	        matches++;
	      }
	    }
	  }
	  return matches;
	};

	exports.COUNTIFS = function() {
	  var args = utils.argsToArray(arguments);
	  var results = new Array(utils.flatten(args[0]).length);
	  for (var i = 0; i < results.length; i++) {
	    results[i] = true;
	  }
	  for (i = 0; i < args.length; i += 2) {
	    var range = utils.flatten(args[i]);
	    var criteria = args[i + 1];
	    if (!/[<>=!]/.test(criteria)) {
	      criteria = '=="' + criteria + '"';
	    }
	    for (var j = 0; j < range.length; j++) {
	      if (typeof range[j] !== 'string') {
	        results[j] = results[j] && eval(range[j] + criteria); // jshint ignore:line
	      } else {
	        results[j] = results[j] && eval('"' + range[j] + '"' + criteria); // jshint ignore:line
	      }
	    }
	  }
	  var result = 0;
	  for (i = 0; i < results.length; i++) {
	    if (results[i]) {
	      result++;
	    }
	  }
	  return result;
	};

	exports.COUNTUNIQUE = function () {
	  return misc.UNIQUE.apply(null, utils.flatten(arguments)).length;
	};

	exports.COVARIANCE = {};

	exports.COVARIANCE.P = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  var mean1 = jStat.mean(array1);
	  var mean2 = jStat.mean(array2);
	  var result = 0;
	  var n = array1.length;
	  for (var i = 0; i < n; i++) {
	    result += (array1[i] - mean1) * (array2[i] - mean2);
	  }
	  return result / n;
	};

	exports.COVARIANCE.S = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  return jStat.covariance(array1, array2);
	};

	exports.DEVSQ = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    result += Math.pow((range[i] - mean), 2);
	  }
	  return result;
	};

	exports.EXPON = {};

	exports.EXPON.DIST = function(x, lambda, cumulative) {
	  x = utils.parseNumber(x);
	  lambda = utils.parseNumber(lambda);
	  if (utils.anyIsError(x, lambda)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.exponential.cdf(x, lambda) : jStat.exponential.pdf(x, lambda);
	};

	exports.F = {};

	exports.F.DIST = function(x, d1, d2, cumulative) {
	  x = utils.parseNumber(x);
	  d1 = utils.parseNumber(d1);
	  d2 = utils.parseNumber(d2);
	  if (utils.anyIsError(x, d1, d2)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.centralF.cdf(x, d1, d2) : jStat.centralF.pdf(x, d1, d2);
	};

	exports.F.DIST.RT = function(x, d1, d2) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (x < 0 || d1 < 1 || d2 < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {
	    return error.value;
	  }

	  return 1 - jStat.centralF.cdf(x, d1, d2);
	};

	exports.F.INV = function(probability, d1, d2) {
	  probability = utils.parseNumber(probability);
	  d1 = utils.parseNumber(d1);
	  d2 = utils.parseNumber(d2);
	  if (utils.anyIsError(probability, d1, d2)) {
	    return error.value;
	  }
	  if (probability <= 0.0 || probability > 1.0) {
	    return error.num;
	  }

	  return jStat.centralF.inv(probability, d1, d2);
	};

	exports.F.INV.RT = function(p, d1, d2) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (p < 0 || p > 1 || d1 < 1 || d1 > Math.pow(10, 10) || d2 < 1 || d2 > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof p !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {
	    return error.value;
	  }

	  return jStat.centralF.inv(1.0 - p, d1, d2);
	};

	exports.F.TEST = function(array1, array2) {
	  if (!array1 || !array2) {
	    return error.na;
	  }

	  if (!(array1 instanceof Array) || !(array2 instanceof Array)) {
	    return error.na;
	  }

	  if (array1.length < 2 || array2.length < 2) {
	    return error.div0;
	  }

	  var sumOfSquares = function(values, x1) {
	    var sum = 0;
	    for (var i = 0; i < values.length; i++) {
	      sum +=Math.pow((values[i] - x1), 2);
	    }
	    return sum;
	  };

	  var x1 = mathTrig.SUM(array1) / array1.length;
	  var x2 = mathTrig.SUM(array2) / array2.length;
	  var sum1 = sumOfSquares(array1, x1) / (array1.length - 1);
	  var sum2 = sumOfSquares(array2, x2) / (array2.length - 1);

	  return sum1 / sum2;
	};

	exports.FISHER = function(x) {
	  x = utils.parseNumber(x);
	  if (x instanceof Error) {
	    return x;
	  }
	  return Math.log((1 + x) / (1 - x)) / 2;
	};

	exports.FISHERINV = function(y) {
	  y = utils.parseNumber(y);
	  if (y instanceof Error) {
	    return y;
	  }
	  var e2y = Math.exp(2 * y);
	  return (e2y - 1) / (e2y + 1);
	};

	exports.FORECAST = function(x, data_y, data_x) {
	  x = utils.parseNumber(x);
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(x, data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  var b = num / den;
	  var a = ymean - b * xmean;
	  return a + b * x;
	};

	exports.FREQUENCY = function(data, bins) {
	  data = utils.parseNumberArray(utils.flatten(data));
	  bins = utils.parseNumberArray(utils.flatten(bins));
	  if (utils.anyIsError(data, bins)) {
	    return error.value;
	  }
	  var n = data.length;
	  var b = bins.length;
	  var r = [];
	  for (var i = 0; i <= b; i++) {
	    r[i] = 0;
	    for (var j = 0; j < n; j++) {
	      if (i === 0) {
	        if (data[j] <= bins[0]) {
	          r[0] += 1;
	        }
	      } else if (i < b) {
	        if (data[j] > bins[i - 1] && data[j] <= bins[i]) {
	          r[i] += 1;
	        }
	      } else if (i === b) {
	        if (data[j] > bins[b - 1]) {
	          r[b] += 1;
	        }
	      }
	    }
	  }
	  return r;
	};


	exports.GAMMA = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  if (number === 0) {
	    return error.num;
	  }

	  if (parseInt(number, 10) === number && number < 0) {
	    return error.num;
	  }

	  return jStat.gammafn(number);
	};

	exports.GAMMA.DIST = function(value, alpha, beta, cumulative) {
	  if (arguments.length !== 4) {
	    return error.na;
	  }

	  if (value < 0 || alpha <= 0 || beta <= 0) {
	    return error.value;
	  }

	  if ((typeof value !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {
	    return error.value;
	  }

	  return cumulative ? jStat.gamma.cdf(value, alpha, beta, true) : jStat.gamma.pdf(value, alpha, beta, false);
	};

	exports.GAMMA.INV = function(probability, alpha, beta) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {
	    return error.num;
	  }

	  if ((typeof probability !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {
	    return error.value;
	  }

	  return jStat.gamma.inv(probability, alpha, beta);
	};

	exports.GAMMALN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return jStat.gammaln(number);
	};

	exports.GAMMALN.PRECISE = function(x) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (x <= 0) {
	    return error.num;
	  }

	  if (typeof x !== 'number') {
	    return error.value;
	  }

	  return jStat.gammaln(x);
	};

	exports.GAUSS = function(z) {
	  z = utils.parseNumber(z);
	  if (z instanceof Error) {
	    return z;
	  }
	  return jStat.normal.cdf(z, 0, 1) - 0.5;
	};

	exports.GEOMEAN = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  return jStat.geomean(args);
	};

	exports.GROWTH = function(known_y, known_x, new_x, use_const) {
	  // Credits: Ilmari Karonen (http://stackoverflow.com/questions/14161990/how-to-implement-growth-function-in-javascript)

	  known_y = utils.parseNumberArray(known_y);
	  if (known_y instanceof Error) {
	    return known_y;
	  }

	  // Default values for optional parameters:
	  var i;
	  if (known_x === undefined) {
	    known_x = [];
	    for (i = 1; i <= known_y.length; i++) {
	      known_x.push(i);
	    }
	  }
	  if (new_x === undefined) {
	    new_x = [];
	    for (i = 1; i <= known_y.length; i++) {
	      new_x.push(i);
	    }
	  }

	  known_x = utils.parseNumberArray(known_x);
	  new_x = utils.parseNumberArray(new_x);
	  if (utils.anyIsError(known_x, new_x)) {
	    return error.value;
	  }


	  if (use_const === undefined) {
	    use_const = true;
	  }

	  // Calculate sums over the data:
	  var n = known_y.length;
	  var avg_x = 0;
	  var avg_y = 0;
	  var avg_xy = 0;
	  var avg_xx = 0;
	  for (i = 0; i < n; i++) {
	    var x = known_x[i];
	    var y = Math.log(known_y[i]);
	    avg_x += x;
	    avg_y += y;
	    avg_xy += x * y;
	    avg_xx += x * x;
	  }
	  avg_x /= n;
	  avg_y /= n;
	  avg_xy /= n;
	  avg_xx /= n;

	  // Compute linear regression coefficients:
	  var beta;
	  var alpha;
	  if (use_const) {
	    beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);
	    alpha = avg_y - beta * avg_x;
	  } else {
	    beta = avg_xy / avg_xx;
	    alpha = 0;
	  }

	  // Compute and return result array:
	  var new_y = [];
	  for (i = 0; i < new_x.length; i++) {
	    new_y.push(Math.exp(alpha + beta * new_x[i]));
	  }
	  return new_y;
	};

	exports.HARMEAN = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    den += 1 / range[i];
	  }
	  return n / den;
	};

	exports.HYPGEOM = {};

	exports.HYPGEOM.DIST = function(x, n, M, N, cumulative) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  M = utils.parseNumber(M);
	  N = utils.parseNumber(N);
	  if (utils.anyIsError(x, n, M, N)) {
	    return error.value;
	  }

	  function pdf(x, n, M, N) {
	    return mathTrig.COMBIN(M, x) * mathTrig.COMBIN(N - M, n - x) / mathTrig.COMBIN(N, n);
	  }

	  function cdf(x, n, M, N) {
	    var result = 0;
	    for (var i = 0; i <= x; i++) {
	      result += pdf(i, n, M, N);
	    }
	    return result;
	  }

	  return (cumulative) ? cdf(x, n, M, N) : pdf(x, n, M, N);
	};

	exports.INTERCEPT = function(known_y, known_x) {
	  known_y = utils.parseNumberArray(known_y);
	  known_x = utils.parseNumberArray(known_x);
	  if (utils.anyIsError(known_y, known_x)) {
	    return error.value;
	  }
	  if (known_y.length !== known_x.length) {
	    return error.na;
	  }
	  return exports.FORECAST(0, known_y, known_x);
	};

	exports.KURT = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var sigma = 0;
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 4);
	  }
	  sigma = sigma / Math.pow(jStat.stdev(range, true), 4);
	  return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sigma - 3 * (n - 1) * (n - 1) / ((n - 2) * (n - 3));
	};

	exports.LARGE = function(range, k) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(range, k)) {
	    return range;
	  }
	  return range.sort(function(a, b) {
	    return b - a;
	  })[k - 1];
	};

	exports.LINEST = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var ymean = jStat.mean(data_y);
	  var xmean = jStat.mean(data_x);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  var m = num / den;
	  var b = ymean - m * xmean;
	  return [m, b];
	};

	// According to Microsoft:
	// http://office.microsoft.com/en-us/starter-help/logest-function-HP010342665.aspx
	// LOGEST returns are based on the following linear model:
	// ln y = x1 ln m1 + ... + xn ln mn + ln b
	exports.LOGEST = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  for (var i = 0; i < data_y.length; i ++) {
	    data_y[i] = Math.log(data_y[i]);
	  }

	  var result = exports.LINEST(data_y, data_x);
	  result[0] = Math.round(Math.exp(result[0])*1000000)/1000000;
	  result[1] = Math.round(Math.exp(result[1])*1000000)/1000000;
	  return result;
	};

	exports.LOGNORM = {};

	exports.LOGNORM.DIST = function(x, mean, sd, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.lognormal.cdf(x, mean, sd) : jStat.lognormal.pdf(x, mean, sd);
	};

	exports.LOGNORM.INV = function(probability, mean, sd) {
	  probability = utils.parseNumber(probability);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(probability, mean, sd)) {
	    return error.value;
	  }
	  return jStat.lognormal.inv(probability, mean, sd);
	};

	exports.MAX = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.max.apply(Math, range);
	};

	exports.MAXA = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.max.apply(Math, range);
	};

	exports.MEDIAN = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return jStat.median(range);
	};

	exports.MIN = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.min.apply(Math, range);
	};

	exports.MINA = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.min.apply(Math, range);
	};

	exports.MODE = {};

	exports.MODE.MULT = function() {
	  // Credits: Roönaän
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var count = {};
	  var maxItems = [];
	  var max = 0;
	  var currentItem;

	  for (var i = 0; i < n; i++) {
	    currentItem = range[i];
	    count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;
	    if (count[currentItem] > max) {
	      max = count[currentItem];
	      maxItems = [];
	    }
	    if (count[currentItem] === max) {
	      maxItems[maxItems.length] = currentItem;
	    }
	  }
	  return maxItems;
	};

	exports.MODE.SNGL = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  return exports.MODE.MULT(range).sort(function(a, b) {
	    return a - b;
	  })[0];
	};

	exports.NEGBINOM = {};

	exports.NEGBINOM.DIST = function(k, r, p, cumulative) {
	  k = utils.parseNumber(k);
	  r = utils.parseNumber(r);
	  p = utils.parseNumber(p);
	  if (utils.anyIsError(k, r, p)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.negbin.cdf(k, r, p) : jStat.negbin.pdf(k, r, p);
	};

	exports.NORM = {};

	exports.NORM.DIST = function(x, mean, sd, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  if (sd <= 0) {
	    return error.num;
	  }

	  // Return normal distribution computed by jStat [http://jstat.org]
	  return (cumulative) ? jStat.normal.cdf(x, mean, sd) : jStat.normal.pdf(x, mean, sd);
	};

	exports.NORM.INV = function(probability, mean, sd) {
	  probability = utils.parseNumber(probability);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(probability, mean, sd)) {
	    return error.value;
	  }
	  return jStat.normal.inv(probability, mean, sd);
	};

	exports.NORM.S = {};

	exports.NORM.S.DIST = function(z, cumulative) {
	  z = utils.parseNumber(z);
	  if (z instanceof Error) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.normal.cdf(z, 0, 1) : jStat.normal.pdf(z, 0, 1);
	};

	exports.NORM.S.INV = function(probability) {
	  probability = utils.parseNumber(probability);
	  if (probability instanceof Error) {
	    return error.value;
	  }
	  return jStat.normal.inv(probability, 0, 1);
	};

	exports.PEARSON = function(data_x, data_y) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den1 = 0;
	  var den2 = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den1 += Math.pow(data_x[i] - xmean, 2);
	    den2 += Math.pow(data_y[i] - ymean, 2);
	  }
	  return num / Math.sqrt(den1 * den2);
	};

	exports.PERCENTILE = {};

	exports.PERCENTILE.EXC = function(array, k) {
	  array = utils.parseNumberArray(utils.flatten(array));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(array, k)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    {
	      return a - b;
	    }
	  });
	  var n = array.length;
	  if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {
	    return error.num;
	  }
	  var l = k * (n + 1) - 1;
	  var fl = Math.floor(l);
	  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
	};

	exports.PERCENTILE.INC = function(array, k) {
	  array = utils.parseNumberArray(utils.flatten(array));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(array, k)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var n = array.length;
	  var l = k * (n - 1);
	  var fl = Math.floor(l);
	  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
	};

	exports.PERCENTRANK = {};

	exports.PERCENTRANK.EXC = function(array, x, significance) {
	  significance = (significance === undefined) ? 3 : significance;
	  array = utils.parseNumberArray(utils.flatten(array));
	  x = utils.parseNumber(x);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(array, x, significance)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var uniques = misc.UNIQUE.apply(null, array);
	  var n = array.length;
	  var m = uniques.length;
	  var power = Math.pow(10, significance);
	  var result = 0;
	  var match = false;
	  var i = 0;
	  while (!match && i < m) {
	    if (x === uniques[i]) {
	      result = (array.indexOf(uniques[i]) + 1) / (n + 1);
	      match = true;
	    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
	      result = (array.indexOf(uniques[i]) + 1 + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n + 1);
	      match = true;
	    }
	    i++;
	  }
	  return Math.floor(result * power) / power;
	};

	exports.PERCENTRANK.INC = function(array, x, significance) {
	  significance = (significance === undefined) ? 3 : significance;
	  array = utils.parseNumberArray(utils.flatten(array));
	  x = utils.parseNumber(x);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(array, x, significance)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var uniques = misc.UNIQUE.apply(null, array);
	  var n = array.length;
	  var m = uniques.length;
	  var power = Math.pow(10, significance);
	  var result = 0;
	  var match = false;
	  var i = 0;
	  while (!match && i < m) {
	    if (x === uniques[i]) {
	      result = array.indexOf(uniques[i]) / (n - 1);
	      match = true;
	    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
	      result = (array.indexOf(uniques[i]) + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n - 1);
	      match = true;
	    }
	    i++;
	  }
	  return Math.floor(result * power) / power;
	};

	exports.PERMUT = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return mathTrig.FACT(number) / mathTrig.FACT(number - number_chosen);
	};

	exports.PERMUTATIONA = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return Math.pow(number, number_chosen);
	};

	exports.PHI = function(x) {
	  x = utils.parseNumber(x);
	  if (x instanceof Error) {
	    return error.value;
	  }
	  return Math.exp(-0.5 * x * x) / SQRT2PI;
	};

	exports.POISSON = {};

	exports.POISSON.DIST = function(x, mean, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  if (utils.anyIsError(x, mean)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.poisson.cdf(x, mean) : jStat.poisson.pdf(x, mean);
	};

	exports.PROB = function(range, probability, lower, upper) {
	  if (lower === undefined) {
	    return 0;
	  }
	  upper = (upper === undefined) ? lower : upper;

	  range = utils.parseNumberArray(utils.flatten(range));
	  probability = utils.parseNumberArray(utils.flatten(probability));
	  lower = utils.parseNumber(lower);
	  upper = utils.parseNumber(upper);
	  if (utils.anyIsError(range, probability, lower, upper)) {
	    return error.value;
	  }

	  if (lower === upper) {
	    return (range.indexOf(lower) >= 0) ? probability[range.indexOf(lower)] : 0;
	  }

	  var sorted = range.sort(function(a, b) {
	    return a - b;
	  });
	  var n = sorted.length;
	  var result = 0;
	  for (var i = 0; i < n; i++) {
	    if (sorted[i] >= lower && sorted[i] <= upper) {
	      result += probability[range.indexOf(sorted[i])];
	    }
	  }
	  return result;
	};

	exports.QUARTILE = {};

	exports.QUARTILE.EXC = function(range, quart) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  quart = utils.parseNumber(quart);
	  if (utils.anyIsError(range, quart)) {
	    return error.value;
	  }
	  switch (quart) {
	    case 1:
	      return exports.PERCENTILE.EXC(range, 0.25);
	    case 2:
	      return exports.PERCENTILE.EXC(range, 0.5);
	    case 3:
	      return exports.PERCENTILE.EXC(range, 0.75);
	    default:
	      return error.num;
	  }
	};

	exports.QUARTILE.INC = function(range, quart) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  quart = utils.parseNumber(quart);
	  if (utils.anyIsError(range, quart)) {
	    return error.value;
	  }
	  switch (quart) {
	    case 1:
	      return exports.PERCENTILE.INC(range, 0.25);
	    case 2:
	      return exports.PERCENTILE.INC(range, 0.5);
	    case 3:
	      return exports.PERCENTILE.INC(range, 0.75);
	    default:
	      return error.num;
	  }
	};

	exports.RANK = {};

	exports.RANK.AVG = function(number, range, order) {
	  number = utils.parseNumber(number);
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (utils.anyIsError(number, range)) {
	    return error.value;
	  }
	  range = utils.flatten(range);
	  order = order || false;
	  var sort = (order) ? function(a, b) {
	    return a - b;
	  } : function(a, b) {
	    return b - a;
	  };
	  range = range.sort(sort);

	  var length = range.length;
	  var count = 0;
	  for (var i = 0; i < length; i++) {
	    if (range[i] === number) {
	      count++;
	    }
	  }

	  return (count > 1) ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1;
	};

	exports.RANK.EQ = function(number, range, order) {
	  number = utils.parseNumber(number);
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (utils.anyIsError(number, range)) {
	    return error.value;
	  }
	  order = order || false;
	  var sort = (order) ? function(a, b) {
	    return a - b;
	  } : function(a, b) {
	    return b - a;
	  };
	  range = range.sort(sort);
	  return range.indexOf(number) + 1;
	};

	exports.ROW = function(matrix, index) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (index < 0) {
	    return error.num;
	  }

	  if (!(matrix instanceof Array) || (typeof index !== 'number')) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return undefined;
	  }

	  return jStat.row(matrix, index);
	};

	exports.ROWS = function(matrix) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (!(matrix instanceof Array)) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return 0;
	  }

	  return jStat.rows(matrix);
	};

	exports.RSQ = function(data_x, data_y) { // no need to flatten here, PEARSON will take care of that
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  if (utils.anyIsError(data_x, data_y)) {
	    return error.value;
	  }
	  return Math.pow(exports.PEARSON(data_x, data_y), 2);
	};

	exports.SKEW = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var sigma = 0;
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 3);
	  }
	  return n * sigma / ((n - 1) * (n - 2) * Math.pow(jStat.stdev(range, true), 3));
	};

	exports.SKEW.P = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var m2 = 0;
	  var m3 = 0;
	  for (var i = 0; i < n; i++) {
	    m3 += Math.pow(range[i] - mean, 3);
	    m2 += Math.pow(range[i] - mean, 2);
	  }
	  m3 = m3 / n;
	  m2 = m2 / n;
	  return m3 / Math.pow(m2, 3 / 2);
	};

	exports.SLOPE = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  return num / den;
	};

	exports.SMALL = function(range, k) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(range, k)) {
	    return range;
	  }
	  return range.sort(function(a, b) {
	    return a - b;
	  })[k - 1];
	};

	exports.STANDARDIZE = function(x, mean, sd) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  return (x - mean) / sd;
	};

	exports.STDEV = {};

	exports.STDEV.P = function() {
	  var v = exports.VAR.P.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEV.S = function() {
	  var v = exports.VAR.S.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEVA = function() {
	  var v = exports.VARA.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEVPA = function() {
	  var v = exports.VARPA.apply(this, arguments);
	  return Math.sqrt(v);
	};


	exports.STEYX = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var lft = 0;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    lft += Math.pow(data_y[i] - ymean, 2);
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  return Math.sqrt((lft - num * num / den) / (n - 2));
	};

	exports.TRANSPOSE = function(matrix) {
	  if (!matrix) {
	    return error.na;
	  }
	  return jStat.transpose(matrix);
	};

	exports.T = text.T;

	exports.T.DIST = function(x, df, cumulative) {
	  x = utils.parseNumber(x);
	  df = utils.parseNumber(df);
	  if (utils.anyIsError(x, df)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.studentt.cdf(x, df) : jStat.studentt.pdf(x, df);
	};

	exports.T.DIST['2T'] = function(x, df) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (x < 0 || df < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof df !== 'number')) {
	    return error.value;
	  }

	  return (1 - jStat.studentt.cdf(x , df)) * 2;
	};

	exports.T.DIST.RT = function(x, df) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (x < 0 || df < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof df !== 'number')) {
	    return error.value;
	  }

	  return 1 - jStat.studentt.cdf(x , df);
	};

	exports.T.INV = function(probability, df) {
	  probability = utils.parseNumber(probability);
	  df = utils.parseNumber(df);
	  if (utils.anyIsError(probability, df)) {
	    return error.value;
	  }
	  return jStat.studentt.inv(probability, df);
	};

	exports.T.INV['2T'] = function(probability, df) {
	  probability = utils.parseNumber(probability);
	  df = utils.parseNumber(df);
	  if (probability <= 0 || probability > 1 || df < 1) {
	    return error.num;
	  }
	  if (utils.anyIsError(probability, df)) {
	    return error.value;
	  }
	  return Math.abs(jStat.studentt.inv(probability/2, df));
	};

	// The algorithm can be found here:
	// http://www.chem.uoa.gr/applets/AppletTtest/Appl_Ttest2.html
	exports.T.TEST = function(data_x, data_y) {
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  if (utils.anyIsError(data_x, data_y)) {
	    return error.value;
	  }

	  var mean_x = jStat.mean(data_x);
	  var mean_y = jStat.mean(data_y);
	  var s_x = 0;
	  var s_y = 0;
	  var i;

	  for (i = 0; i < data_x.length; i++) {
	    s_x += Math.pow(data_x[i] - mean_x, 2);
	  }
	  for (i = 0; i < data_y.length; i++) {
	    s_y += Math.pow(data_y[i] - mean_y, 2);
	  }

	  s_x = s_x / (data_x.length-1);
	  s_y = s_y / (data_y.length-1);

	  var t = Math.abs(mean_x - mean_y) / Math.sqrt(s_x/data_x.length + s_y/data_y.length);

	  return exports.T.DIST['2T'](t, data_x.length+data_y.length-2);
	};

	exports.TREND = function(data_y, data_x, new_data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  new_data_x = utils.parseNumberArray(utils.flatten(new_data_x));
	  if (utils.anyIsError(data_y, data_x, new_data_x)) {
	    return error.value;
	  }
	  var linest = exports.LINEST(data_y, data_x);
	  var m = linest[0];
	  var b = linest[1];
	  var result = [];

	  new_data_x.forEach(function(x) {
	    result.push(m * x + b);
	  });

	  return result;
	};

	exports.TRIMMEAN = function(range, percent) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  percent = utils.parseNumber(percent);
	  if (utils.anyIsError(range, percent)) {
	    return error.value;
	  }
	  var trim = mathTrig.FLOOR(range.length * percent, 2) / 2;
	  return jStat.mean(utils.initial(utils.rest(range.sort(function(a, b) {
	    return a - b;
	  }), trim), trim));
	};

	exports.VAR = {};

	exports.VAR.P = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sigma = 0;
	  var mean = exports.AVERAGE(range);
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 2);
	  }
	  return sigma / n;
	};

	exports.VAR.S = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sigma = 0;
	  var mean = exports.AVERAGE(range);
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 2);
	  }
	  return sigma / (n - 1);
	};

	exports.VARA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sigma = 0;
	  var count = 0;
	  var mean = exports.AVERAGEA(range);
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sigma += Math.pow(el - mean, 2);
	    } else if (el === true) {
	      sigma += Math.pow(1 - mean, 2);
	    } else {
	      sigma += Math.pow(0 - mean, 2);
	    }

	    if (el !== null) {
	      count++;
	    }
	  }
	  return sigma / (count - 1);
	};

	exports.VARPA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sigma = 0;
	  var count = 0;
	  var mean = exports.AVERAGEA(range);
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sigma += Math.pow(el - mean, 2);
	    } else if (el === true) {
	      sigma += Math.pow(1 - mean, 2);
	    } else {
	      sigma += Math.pow(0 - mean, 2);
	    }

	    if (el !== null) {
	      count++;
	    }
	  }
	  return sigma / count;
	};

	exports.WEIBULL = {};

	exports.WEIBULL.DIST = function(x, alpha, beta, cumulative) {
	  x = utils.parseNumber(x);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  if (utils.anyIsError(x, alpha, beta)) {
	    return error.value;
	  }
	  return (cumulative) ? 1 - Math.exp(-Math.pow(x / beta, alpha)) : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);
	};

	exports.Z = {};

	exports.Z.TEST = function(range, x, sd) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  x = utils.parseNumber(x);
	  if (utils.anyIsError(range, x)) {
	    return error.value;
	  }

	  sd = sd || exports.STDEV.S(range);
	  var n = range.length;
	  return 1 - exports.NORM.S.DIST((exports.AVERAGE(range) - x) / (sd / Math.sqrt(n)), true);
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var numeral = __webpack_require__(8);

	//TODO
	exports.ASC = function() {
	 throw new Error('ASC is not implemented');
	};

	//TODO
	exports.BAHTTEXT = function() {
	 throw new Error('BAHTTEXT is not implemented');
	};

	exports.CHAR = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return String.fromCharCode(number);
	};

	exports.CLEAN = function(text) {
	  text = text || '';
	  var re = /[\0-\x1F]/g;
	  return text.replace(re, "");
	};

	exports.CODE = function(text) {
	  text = text || '';
	  return text.charCodeAt(0);
	};

	exports.CONCATENATE = function() {
	  var args = utils.flatten(arguments);

	  var trueFound = 0;
	  while ((trueFound = args.indexOf(true)) > -1) {
	    args[trueFound] = 'TRUE';
	  }

	  var falseFound = 0;
	  while ((falseFound = args.indexOf(false)) > -1) {
	    args[falseFound] = 'FALSE';
	  }

	  return args.join('');
	};

	//TODO
	exports.DBCS = function() {
	 throw new Error('DBCS is not implemented');
	};

	exports.DOLLAR = function(number, decimals) {
	  decimals = (decimals === undefined) ? 2 : decimals;

	  number = utils.parseNumber(number);
	  decimals = utils.parseNumber(decimals);
	  if (utils.anyIsError(number, decimals)) {
	    return error.value;
	  }
	  var format = '';
	  if (decimals <= 0) {
	    number = Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    format = '($0,0)';
	  } else if (decimals > 0) {
	    format = '($0,0.' + new Array(decimals + 1).join('0') + ')';
	  }
	  return numeral(number).format(format);
	};

	exports.EXACT = function(text1, text2) {
	  return text1 === text2;
	};

	exports.FIND = function(find_text, within_text, position) {
	  position = (position === undefined) ? 0 : position;
	  return within_text ? within_text.indexOf(find_text, position - 1) + 1 : null;
	};

	exports.FIXED = function(number, decimals, no_commas) {
	  decimals = (decimals === undefined) ? 2 : decimals;
	  no_commas = (no_commas === undefined) ? false : no_commas;

	  number = utils.parseNumber(number);
	  decimals = utils.parseNumber(decimals);
	  if (utils.anyIsError(number, decimals)) {
	    return error.value;
	  }

	  var format = no_commas ? '0' : '0,0';
	  if (decimals <= 0) {
	    number = Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	  } else if (decimals > 0) {
	    format += '.' + new Array(decimals + 1).join('0');
	  }
	  return numeral(number).format(format);
	};

	exports.HTML2TEXT = function (value) {
	  var result = '';

	  if (value) {
	    if (value instanceof Array) {
	      value.forEach(function (line) {
	        if (result !== '') {
	          result += '\n';
	        }
	        result += (line.replace(/<(?:.|\n)*?>/gm, ''));
	      });
	    } else {
	      result = value.replace(/<(?:.|\n)*?>/gm, '');
	    }
	  }

	  return result;
	};

	exports.LEFT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = utils.parseNumber(number);
	  if (number instanceof Error || typeof text !== 'string') {
	    return error.value;
	  }
	  return text ? text.substring(0, number) : null;
	};

	exports.LEN = function(text) {
	  if (arguments.length === 0) {
	    return error.error;
	  }

	  if (typeof text === 'string') {
	    return text ? text.length : 0;
	  }

	  if (text.length) {
	    return text.length;
	  }

	  return error.value;
	};

	exports.LOWER = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text ? text.toLowerCase() : text;
	};

	exports.MID = function(text, start, number) {
	  start = utils.parseNumber(start);
	  number = utils.parseNumber(number);
	  if (utils.anyIsError(start, number) || typeof text !== 'string') {
	    return number;
	  }

	  var begin = start - 1;
	  var end = begin + number;

	  return text.substring(begin, end);
	};

	// TODO
	exports.NUMBERVALUE = function (text, decimal_separator, group_separator)  {
	  decimal_separator = (typeof decimal_separator === 'undefined') ? '.' : decimal_separator;
	  group_separator = (typeof group_separator === 'undefined') ? ',' : group_separator;
	  return Number(text.replace(decimal_separator, '.').replace(group_separator, ''));
	};

	// TODO
	exports.PRONETIC = function() {
	 throw new Error('PRONETIC is not implemented');
	};

	exports.PROPER = function(text) {
	  if (text === undefined || text.length === 0) {
	    return error.value;
	  }
	  if (text === true) {
	    text = 'TRUE';
	  }
	  if (text === false) {
	    text = 'FALSE';
	  }
	  if (isNaN(text) && typeof text === 'number') {
	    return error.value;
	  }
	  if (typeof text === 'number') {
	    text = '' + text;
	  }

	  return text.replace(/\w\S*/g, function(txt) {
	    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
	  });
	};

	exports.REGEXEXTRACT = function (text, regular_expression) {
	  var match = text.match(new RegExp(regular_expression));
	  return match ? (match[match.length > 1 ? match.length - 1 : 0]) : null;
	};

	exports.REGEXMATCH = function (text, regular_expression, full) {
	  var match = text.match(new RegExp(regular_expression));
	  return full ? match : !!match;
	};

	exports.REGEXREPLACE = function (text, regular_expression, replacement) {
	  return text.replace(new RegExp(regular_expression), replacement);
	};

	exports.REPLACE = function(text, position, length, new_text) {
	  position = utils.parseNumber(position);
	  length = utils.parseNumber(length);
	  if (utils.anyIsError(position, length) ||
	    typeof text !== 'string' ||
	    typeof new_text !== 'string') {
	    return error.value;
	  }
	  return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
	};

	exports.REPT = function(text, number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return new Array(number + 1).join(text);
	};

	exports.RIGHT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return text ? text.substring(text.length - number) : null;
	};

	exports.SEARCH = function(find_text, within_text, position) {
	  var foundAt;
	  if (typeof find_text !== 'string' || typeof within_text !== 'string') {
	    return error.value;
	  }
	  position = (position === undefined) ? 0 : position;
	  foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1)+1;
	  return (foundAt === 0)?error.value:foundAt;
	};

	exports.SPLIT = function (text, separator) {
	  return text.split(separator);
	};

	exports.SUBSTITUTE = function(text, old_text, new_text, occurrence) {
	  if (!text || !old_text || !new_text) {
	    return text;
	  } else if (occurrence === undefined) {
	    return text.replace(new RegExp(old_text, 'g'), new_text);
	  } else {
	    var index = 0;
	    var i = 0;
	    while (text.indexOf(old_text, index) > 0) {
	      index = text.indexOf(old_text, index + 1);
	      i++;
	      if (i === occurrence) {
	        return text.substring(0, index) + new_text + text.substring(index + old_text.length);
	      }
	    }
	  }
	};

	exports.T = function(value) {
	  return (typeof value === "string") ? value : '';
	};

	// TODO incomplete implementation
	exports.TEXT = function(value, format) {
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(value)) {
	    return error.na;
	  }

	  return numeral(value).format(format);
	};

	exports.TRIM = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text.replace(/ +/g, ' ').trim();
	};

	exports.UNICHAR = this.CHAR;

	exports.UNICODE = this.CODE;

	exports.UPPER = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text.toUpperCase();
	};

	exports.VALUE = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return numeral().unformat(text);
	};


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var utils   = __webpack_require__(4);
	var numeral = __webpack_require__(8);

	exports.UNIQUE = function () {
	  var result = [];
	  for (var i = 0; i < arguments.length; ++i) {
	    var hasElement = false;
	    var element    = arguments[i];

	    // Check if we've already seen this element.
	    for (var j = 0; j < result.length; ++j) {
	      hasElement = result[j] === element;
	      if (hasElement) { break; }
	    }

	    // If we did not find it, add it to the result.
	    if (!hasElement) {
	      result.push(element);
	    }
	  }
	  return result;
	};

	exports.FLATTEN = utils.flatten;

	exports.ARGS2ARRAY = function () {
	  return Array.prototype.slice.call(arguments, 0);
	};

	exports.REFERENCE = function (context, reference) {
	  try {
	    var path = reference.split('.');
	    var result = context;
	    for (var i = 0; i < path.length; ++i) {
	      var step = path[i];
	      if (step[step.length - 1] === ']') {
	        var opening = step.indexOf('[');
	        var index = step.substring(opening + 1, step.length - 1);
	        result = result[step.substring(0, opening)][index];
	      } else {
	        result = result[step];
	      }
	    }
	    return result;
	  } catch (error) {}
	};

	exports.JOIN = function (array, separator) {
	  return array.join(separator);
	};

	exports.NUMBERS = function () {
	  var possibleNumbers = utils.flatten(arguments);
	  return possibleNumbers.filter(function (el) {
	    return typeof el === 'number';
	  });
	};

	exports.NUMERAL = function (number, format) {
	  return numeral(number).format(format);
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	// TODO
	exports.CELL = function() {
	 throw new Error('CELL is not implemented');
	};

	exports.ERROR = {};
	exports.ERROR.TYPE = function(error_val) {
	  switch (error_val) {
	    case error.nil: return 1;
	    case error.div0: return 2;
	    case error.value: return 3;
	    case error.ref: return 4;
	    case error.name: return 5;
	    case error.num: return 6;
	    case error.na: return 7;
	    case error.data: return 8;
	  }
	  return error.na;
	};

	// TODO
	exports.INFO = function() {
	 throw new Error('INFO is not implemented');
	};

	exports.ISBLANK = function(value) {
	  return value === null;
	};

	exports.ISBINARY = function (number) {
	  return (/^[01]{1,10}$/).test(number);
	};

	exports.ISERR = function(value) {
	  return ([error.value, error.ref, error.div0, error.num, error.name, error.nil]).indexOf(value) >= 0 ||
	    (typeof value === 'number' && (isNaN(value) || !isFinite(value)));
	};

	exports.ISERROR = function(value) {
	  return exports.ISERR(value) || value === error.na;
	};

	exports.ISEVEN = function(number) {
	  return (Math.floor(Math.abs(number)) & 1) ? false : true;
	};

	// TODO
	exports.ISFORMULA = function() {
	  throw new Error('ISFORMULA is not implemented');
	};

	exports.ISLOGICAL = function(value) {
	  return value === true || value === false;
	};

	exports.ISNA = function(value) {
	  return value === error.na;
	};

	exports.ISNONTEXT = function(value) {
	  return typeof(value) !== 'string';
	};

	exports.ISNUMBER = function(value) {
	  return typeof(value) === 'number' && !isNaN(value) && isFinite(value);
	};

	exports.ISODD = function(number) {
	  return (Math.floor(Math.abs(number)) & 1) ? true : false;
	};

	// TODO
	exports.ISREF = function() {
	  throw new Error('ISREF is not implemented');
	};

	exports.ISTEXT = function(value) {
	  return typeof(value) === 'string';
	};

	exports.N = function(value) {
	  if (this.ISNUMBER(value)) {
	    return value;
	  }
	  if (value instanceof Date) {
	    return value.getTime();
	  }
	  if (value === true) {
	    return 1;
	  }
	  if (value === false) {
	    return 0;
	  }
	  if (this.ISERROR(value)) {
	    return value;
	  }
	  return 0;
	};

	exports.NA = function() {
	  return error.na;
	};


	// TODO
	exports.SHEET = function() {
	  throw new Error('SHEET is not implemented');
	};

	// TODO
	exports.SHEETS = function() {
	  throw new Error('SHEETS is not implemented');
	};

	exports.TYPE = function(value) {
	  if (this.ISNUMBER(value)) {
	    return 1;
	  }
	  if (this.ISTEXT(value)) {
	    return 2;
	  }
	  if (this.ISLOGICAL(value)) {
	    return 4;
	  }
	  if (this.ISERROR(value)) {
	    return 16;
	  }
	  if (Array.isArray(value)) {
	    return 64;
	  }
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var jStat = __webpack_require__(9).jStat;
	var text = __webpack_require__(7);
	var utils = __webpack_require__(4);
	var bessel = __webpack_require__(13);

	function isValidBinaryNumber(number) {
	  return (/^[01]{1,10}$/).test(number);
	}

	exports.BESSELI = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besseli(x, n);
	};

	exports.BESSELJ = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besselj(x, n);
	};

	exports.BESSELK = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besselk(x, n);
	};

	exports.BESSELY = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.bessely(x, n);
	};

	exports.BIN2DEC = function(number) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Convert binary number to decimal
	  var result = parseInt(number, 2);

	  // Handle negative numbers
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return parseInt(stringified.substring(1), 2) - 512;
	  } else {
	    return result;
	  }
	};


	exports.BIN2HEX = function(number, places) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character hexadecimal number if number is negative
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);
	  }

	  // Convert binary number to hexadecimal
	  var result = parseInt(number, 2).toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.BIN2OCT = function(number, places) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
	  }

	  // Convert binary number to octal
	  var result = parseInt(number, 2).toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.BITAND = function(number1, number2) {
	  // Return error if either number is a non-numeric value
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise AND of two numbers
	  return number1 & number2;
	};

	exports.BITLSHIFT = function(number, shift) {
	  number = utils.parseNumber(number);
	  shift = utils.parseNumber(shift);
	  if (utils.anyIsError(number, shift)) {
	    return error.value;
	  }

	  // Return error if number is less than 0
	  if (number < 0) {
	    return error.num;
	  }

	  // Return error if number is a non-integer
	  if (Math.floor(number) !== number) {
	    return error.num;
	  }

	  // Return error if number is greater than (2^48)-1
	  if (number > 281474976710655) {
	    return error.num;
	  }

	  // Return error if the absolute value of shift is greater than 53
	  if (Math.abs(shift) > 53) {
	    return error.num;
	  }

	  // Return number shifted by shift bits to the left or to the right if shift is negative
	  return (shift >= 0) ? number << shift : number >> -shift;
	};

	exports.BITOR = function(number1, number2) {
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise OR of two numbers
	  return number1 | number2;
	};

	exports.BITRSHIFT = function(number, shift) {
	  number = utils.parseNumber(number);
	  shift = utils.parseNumber(shift);
	  if (utils.anyIsError(number, shift)) {
	    return error.value;
	  }

	  // Return error if number is less than 0
	  if (number < 0) {
	    return error.num;
	  }

	  // Return error if number is a non-integer
	  if (Math.floor(number) !== number) {
	    return error.num;
	  }

	  // Return error if number is greater than (2^48)-1
	  if (number > 281474976710655) {
	    return error.num;
	  }

	  // Return error if the absolute value of shift is greater than 53
	  if (Math.abs(shift) > 53) {
	    return error.num;
	  }

	  // Return number shifted by shift bits to the right or to the left if shift is negative
	  return (shift >= 0) ? number >> shift : number << -shift;
	};

	exports.BITXOR = function(number1, number2) {
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise XOR of two numbers
	  return number1 ^ number2;
	};

	exports.COMPLEX = function(real, imaginary, suffix) {
	  real = utils.parseNumber(real);
	  imaginary = utils.parseNumber(imaginary);
	  if (utils.anyIsError(real, imaginary)) {
	    return real;
	  }

	  // Set suffix
	  suffix = (suffix === undefined) ? 'i' : suffix;

	  // Return error if suffix is neither "i" nor "j"
	  if (suffix !== 'i' && suffix !== 'j') {
	    return error.value;
	  }

	  // Return complex number
	  if (real === 0 && imaginary === 0) {
	    return 0;
	  } else if (real === 0) {
	    return (imaginary === 1) ? suffix : imaginary.toString() + suffix;
	  } else if (imaginary === 0) {
	    return real.toString();
	  } else {
	    var sign = (imaginary > 0) ? '+' : '';
	    return real.toString() + sign + ((imaginary === 1) ? suffix : imaginary.toString() + suffix);
	  }
	};

	exports.CONVERT = function(number, from_unit, to_unit) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // List of units supported by CONVERT and units defined by the International System of Units
	  // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion ratio]
	  var units = [
	    ["a.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
	    ["a.u. of charge", "e", null, "electric_charge", false, false, 1.60217653141414e-19],
	    ["a.u. of energy", "Eh", null, "energy", false, false, 4.35974417757576e-18],
	    ["a.u. of length", "a?", null, "length", false, false, 5.29177210818182e-11],
	    ["a.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
	    ["a.u. of time", "?/Eh", null, "time", false, false, 2.41888432650516e-17],
	    ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
	    ["ampere", "A", null, "electric_current", true, false, 1],
	    ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
	    ["ångström", "Å", ["ang"], "length", false, true, 1e-10],
	    ["are", "ar", null, "area", false, true, 100],
	    ["astronomical unit", "ua", null, "length", false, false, 1.49597870691667e-11],
	    ["bar", "bar", null, "pressure", false, false, 100000],
	    ["barn", "b", null, "area", false, false, 1e-28],
	    ["becquerel", "Bq", null, "radioactivity", true, false, 1],
	    ["bit", "bit", ["b"], "information", false, true, 1],
	    ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
	    ["byte", "byte", null, "information", false, true, 8],
	    ["candela", "cd", null, "luminous_intensity", true, false, 1],
	    ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
	    ["coulomb", "C", null, "electric_charge", true, false, 1],
	    ["cubic ångström", "ang3", ["ang^3"], "volume", false, true, 1e-30],
	    ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
	    ["cubic inch", "in3", ["in^3"], "volume", false, true, 0.000016387064],
	    ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 8.46786664623715e-47],
	    ["cubic metre", "m?", null, "volume", true, true, 1],
	    ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 4168181825.44058],
	    ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
	    ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 7.58660370370369e-8],
	    ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
	    ["cup", "cup", null, "volume", false, true, 0.0002365882365],
	    ["dalton", "Da", ["u"], "mass", false, false, 1.66053886282828e-27],
	    ["day", "d", ["day"], "time", false, true, 86400],
	    ["degree", "°", null, "angle", false, false, 0.0174532925199433],
	    ["degrees Rankine", "Rank", null, "temperature", false, true, 0.555555555555556],
	    ["dyne", "dyn", ["dy"], "force", false, true, 0.00001],
	    ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
	    ["ell", "ell", null, "length", false, true, 1.143],
	    ["erg", "erg", ["e"], "energy", false, true, 1e-7],
	    ["farad", "F", null, "electric_capacitance", true, false, 1],
	    ["fluid ounce", "oz", null, "volume", false, true, 0.0000295735295625],
	    ["foot", "ft", null, "length", false, true, 0.3048],
	    ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
	    ["gal", "Gal", null, "acceleration", false, false, 0.01],
	    ["gallon", "gal", null, "volume", false, true, 0.003785411784],
	    ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
	    ["grain", "grain", null, "mass", false, true, 0.0000647989],
	    ["gram", "g", null, "mass", false, true, 0.001],
	    ["gray", "Gy", null, "absorbed_dose", true, false, 1],
	    ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
	    ["hectare", "ha", null, "area", false, true, 10000],
	    ["henry", "H", null, "inductance", true, false, 1],
	    ["hertz", "Hz", null, "frequency", true, false, 1],
	    ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
	    ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519.538],
	    ["hour", "h", ["hr"], "time", false, true, 3600],
	    ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 0.00454609],
	    ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
	    ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
	    ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
	    ["inch", "in", null, "length", false, true, 0.0254],
	    ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
	    ["IT calorie", "cal", null, "energy", false, true, 4.1868],
	    ["joule", "J", null, "energy", true, true, 1],
	    ["katal", "kat", null, "catalytic_activity", true, false, 1],
	    ["kelvin", "K", ["kel"], "temperature", true, true, 1],
	    ["kilogram", "kg", null, "mass", true, true, 1],
	    ["knot", "kn", null, "speed", false, true, 0.514444444444444],
	    ["light-year", "ly", null, "length", false, true, 9460730472580800],
	    ["litre", "L", ["l", "lt"], "volume", false, true, 0.001],
	    ["lumen", "lm", null, "luminous_flux", true, false, 1],
	    ["lux", "lx", null, "illuminance", true, false, 1],
	    ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
	    ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
	    ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 0.00027777777777778],
	    ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
	    ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
	    ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
	    ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
	    ["metre", "m", null, "length", true, true, 1],
	    ["miles per hour", "mph", null, "speed", false, true, 0.44704],
	    ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
	    ["minute", "?", null, "angle", false, false, 0.000290888208665722],
	    ["minute", "min", ["mn"], "time", false, true, 60],
	    ["modern teaspoon", "tspm", null, "volume", false, true, 0.000005],
	    ["mole", "mol", null, "amount_of_substance", true, false, 1],
	    ["morgen", "Morgen", null, "area", false, true, 2500],
	    ["n.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
	    ["n.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
	    ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
	    ["n.u. of time", "?/(me?c??)", null, "time", false, false, 1.28808866778687e-21],
	    ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
	    ["newton", "N", null, "force", true, true, 1],
	    ["œrsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
	    ["ohm", "Ω", null, "electric_resistance", true, false, 1],
	    ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
	    ["pascal", "Pa", null, "pressure", true, false, 1],
	    ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
	    ["pferdestärke", "PS", null, "power", false, true, 735.49875],
	    ["phot", "ph", null, "illuminance", false, false, 0.0001],
	    ["pica (1/6 inch)", "pica", null, "length", false, true, 0.00035277777777778],
	    ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
	    ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
	    ["pond", "pond", null, "force", false, true, 0.00980665],
	    ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
	    ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
	    ["quart", "qt", null, "volume", false, true, 0.000946352946],
	    ["radian", "rad", null, "angle", true, false, 1],
	    ["second", "?", null, "angle", false, false, 0.00000484813681109536],
	    ["second", "s", ["sec"], "time", true, true, 1],
	    ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
	    ["siemens", "S", null, "electrical_conductance", true, false, 1],
	    ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
	    ["slug", "sg", null, "mass", false, true, 14.59390294],
	    ["square ångström", "ang2", ["ang^2"], "area", false, true, 1e-20],
	    ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
	    ["square inch", "in2", ["in^2"], "area", false, true, 0.00064516],
	    ["square light-year", "ly2", ["ly^2"], "area", false, true, 8.95054210748189e+31],
	    ["square meter", "m?", null, "area", true, true, 1],
	    ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988.110336],
	    ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
	    ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 0.00001792111111111],
	    ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
	    ["statute mile", "mi", null, "length", false, true, 1609.344],
	    ["steradian", "sr", null, "solid_angle", true, false, 1],
	    ["stilb", "sb", null, "luminance", false, false, 0.0001],
	    ["stokes", "St", null, "kinematic_viscosity", false, false, 0.0001],
	    ["stone", "stone", null, "mass", false, true, 6.35029318],
	    ["tablespoon", "tbs", null, "volume", false, true, 0.0000147868],
	    ["teaspoon", "tsp", null, "volume", false, true, 0.00000492892],
	    ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
	    ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
	    ["ton", "ton", null, "mass", false, true, 907.18474],
	    ["tonne", "t", null, "mass", false, false, 1000],
	    ["U.K. pint", "uk_pt", null, "volume", false, true, 0.00056826125],
	    ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
	    ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
	    ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 0.000473176473],
	    ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
	    ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
	    ["volt", "V", null, "voltage", true, false, 1],
	    ["watt", "W", null, "power", true, true, 1],
	    ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
	    ["weber", "Wb", null, "magnetic_flux", true, false, 1],
	    ["yard", "yd", null, "length", false, true, 0.9144],
	    ["year", "yr", null, "time", false, true, 31557600]
	  ];

	  // Binary prefixes
	  // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived from]
	  var binary_prefixes = {
	    Yi: ["yobi", 80, 1208925819614629174706176, "Yi", "yotta"],
	    Zi: ["zebi", 70, 1180591620717411303424, "Zi", "zetta"],
	    Ei: ["exbi", 60, 1152921504606846976, "Ei", "exa"],
	    Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
	    Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
	    Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
	    Mi: ["mebi", 20, 1048576, "Mi", "mega"],
	    ki: ["kibi", 10, 1024, "ki", "kilo"]
	  };

	  // Unit prefixes
	  // [Name, Multiplier, Abbreviation]
	  var unit_prefixes = {
	    Y: ["yotta", 1e+24, "Y"],
	    Z: ["zetta", 1e+21, "Z"],
	    E: ["exa", 1e+18, "E"],
	    P: ["peta", 1e+15, "P"],
	    T: ["tera", 1e+12, "T"],
	    G: ["giga", 1e+09, "G"],
	    M: ["mega", 1e+06, "M"],
	    k: ["kilo", 1e+03, "k"],
	    h: ["hecto", 1e+02, "h"],
	    e: ["dekao", 1e+01, "e"],
	    d: ["deci", 1e-01, "d"],
	    c: ["centi", 1e-02, "c"],
	    m: ["milli", 1e-03, "m"],
	    u: ["micro", 1e-06, "u"],
	    n: ["nano", 1e-09, "n"],
	    p: ["pico", 1e-12, "p"],
	    f: ["femto", 1e-15, "f"],
	    a: ["atto", 1e-18, "a"],
	    z: ["zepto", 1e-21, "z"],
	    y: ["yocto", 1e-24, "y"]
	  };

	  // Initialize units and multipliers
	  var from = null;
	  var to = null;
	  var base_from_unit = from_unit;
	  var base_to_unit = to_unit;
	  var from_multiplier = 1;
	  var to_multiplier = 1;
	  var alt;

	  // Lookup from and to units
	  for (var i = 0; i < units.length; i++) {
	    alt = (units[i][2] === null) ? [] : units[i][2];
	    if (units[i][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
	      from = units[i];
	    }
	    if (units[i][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
	      to = units[i];
	    }
	  }

	  // Lookup from prefix
	  if (from === null) {
	    var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
	    var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];

	    // Handle dekao unit prefix (only unit prefix with two characters)
	    if (from_unit.substring(0, 2) === 'da') {
	      from_unit_prefix = ["dekao", 1e+01, "da"];
	    }

	    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
	    if (from_binary_prefix) {
	      from_multiplier = from_binary_prefix[2];
	      base_from_unit = from_unit.substring(2);
	    } else if (from_unit_prefix) {
	      from_multiplier = from_unit_prefix[1];
	      base_from_unit = from_unit.substring(from_unit_prefix[2].length);
	    }

	    // Lookup from unit
	    for (var j = 0; j < units.length; j++) {
	      alt = (units[j][2] === null) ? [] : units[j][2];
	      if (units[j][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
	        from = units[j];
	      }
	    }
	  }

	  // Lookup to prefix
	  if (to === null) {
	    var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
	    var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];

	    // Handle dekao unit prefix (only unit prefix with two characters)
	    if (to_unit.substring(0, 2) === 'da') {
	      to_unit_prefix = ["dekao", 1e+01, "da"];
	    }

	    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
	    if (to_binary_prefix) {
	      to_multiplier = to_binary_prefix[2];
	      base_to_unit = to_unit.substring(2);
	    } else if (to_unit_prefix) {
	      to_multiplier = to_unit_prefix[1];
	      base_to_unit = to_unit.substring(to_unit_prefix[2].length);
	    }

	    // Lookup to unit
	    for (var k = 0; k < units.length; k++) {
	      alt = (units[k][2] === null) ? [] : units[k][2];
	      if (units[k][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
	        to = units[k];
	      }
	    }
	  }

	  // Return error if a unit does not exist
	  if (from === null || to === null) {
	    return error.na;
	  }

	  // Return error if units represent different quantities
	  if (from[3] !== to[3]) {
	    return error.na;
	  }

	  // Return converted number
	  return number * from[6] * from_multiplier / (to[6] * to_multiplier);
	};

	exports.DEC2BIN = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -512, or is greater than 511
	  if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (number < 0) {
	    return '1' + text.REPT('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = parseInt(number, 10).toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DEC2HEX = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
	  if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character hexadecimal number if number is negative
	  if (number < 0) {
	    return (1099511627776 + number).toString(16);
	  }

	  // Convert decimal number to hexadecimal
	  var result = parseInt(number, 10).toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DEC2OCT = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
	  if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  if (number < 0) {
	    return (1073741824 + number).toString(8);
	  }

	  // Convert decimal number to octal
	  var result = parseInt(number, 10).toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DELTA = function(number1, number2) {
	  // Set number2 to zero if undefined
	  number2 = (number2 === undefined) ? 0 : number2;
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return delta
	  return (number1 === number2) ? 1 : 0;
	};

	// TODO: why is upper_bound not used ? The excel documentation has no examples with upper_bound
	exports.ERF = function(lower_bound, upper_bound) {
	  // Set number2 to zero if undefined
	  upper_bound = (upper_bound === undefined) ? 0 : upper_bound;

	  lower_bound = utils.parseNumber(lower_bound);
	  upper_bound = utils.parseNumber(upper_bound);
	  if (utils.anyIsError(lower_bound, upper_bound)) {
	    return error.value;
	  }

	  return jStat.erf(lower_bound);
	};

	// TODO
	exports.ERF.PRECISE = function() {
	 throw new Error('ERF.PRECISE is not implemented');
	};

	exports.ERFC = function(x) {
	  // Return error if x is not a number
	  if (isNaN(x)) {
	    return error.value;
	  }

	  return jStat.erfc(x);
	};

	// TODO
	exports.ERFC.PRECISE = function() {
	 throw new Error('ERFC.PRECISE is not implemented');
	};

	exports.GESTEP = function(number, step) {
	  step = step || 0;
	  number = utils.parseNumber(number);
	  if (utils.anyIsError(step, number)) {
	    return number;
	  }

	  // Return delta
	  return (number >= step) ? 1 : 0;
	};

	exports.HEX2BIN = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Check if number is negative
	  var negative = (number.length === 10 && number.substring(0, 1).toLowerCase() === 'f') ? true : false;

	  // Convert hexadecimal number to decimal
	  var decimal = (negative) ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);

	  // Return error if number is lower than -512 or greater than 511
	  if (decimal < -512 || decimal > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (negative) {
	    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = decimal.toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.HEX2DEC = function(number) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert hexadecimal number to decimal
	  var decimal = parseInt(number, 16);

	  // Return decimal number
	  return (decimal >= 549755813888) ? decimal - 1099511627776 : decimal;
	};

	exports.HEX2OCT = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert hexadecimal number to decimal
	  var decimal = parseInt(number, 16);

	  // Return error if number is positive and greater than 0x1fffffff (536870911)
	  if (decimal > 536870911 && decimal < 1098974756864) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  if (decimal >= 1098974756864) {
	    return (decimal - 1098437885952).toString(8);
	  }

	  // Convert decimal number to octal
	  var result = decimal.toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.IMABS = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return absolute value of complex number
	  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
	};

	exports.IMAGINARY = function(inumber) {
	  if (inumber === undefined || inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Return 0 if inumber is equal to 0
	  if (inumber === 0 || inumber === '0') {
	    return 0;
	  }

	  // Handle special cases
	  if (['i', 'j'].indexOf(inumber) >= 0) {
	    return 1;
	  }

	  // Normalize imaginary coefficient
	  inumber = inumber.replace('+i', '+1i').replace('-i', '-1i').replace('+j', '+1j').replace('-j', '-1j');

	  // Lookup sign
	  var plus = inumber.indexOf('+');
	  var minus = inumber.indexOf('-');
	  if (plus === 0) {
	    plus = inumber.indexOf('+', 1);
	  }

	  if (minus === 0) {
	    minus = inumber.indexOf('-', 1);
	  }

	  // Lookup imaginary unit
	  var last = inumber.substring(inumber.length - 1, inumber.length);
	  var unit = (last === 'i' || last === 'j');

	  if (plus >= 0 || minus >= 0) {
	    // Return error if imaginary unit is neither i nor j
	    if (!unit) {
	      return error.num;
	    }

	    // Return imaginary coefficient of complex number
	    if (plus >= 0) {
	      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(plus + 1, inumber.length - 1));
	    } else {
	      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
	        error.num :
	        -Number(inumber.substring(minus + 1, inumber.length - 1));
	    }
	  } else {
	    if (unit) {
	      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : inumber.substring(0, inumber.length - 1);
	    } else {
	      return (isNaN(inumber)) ? error.num : 0;
	    }
	  }
	};

	exports.IMARGUMENT = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return error if inumber is equal to zero
	  if (x === 0 && y === 0) {
	    return error.div0;
	  }

	  // Return PI/2 if x is equal to zero and y is positive
	  if (x === 0 && y > 0) {
	    return Math.PI / 2;
	  }

	  // Return -PI/2 if x is equal to zero and y is negative
	  if (x === 0 && y < 0) {
	    return -Math.PI / 2;
	  }

	  // Return zero if x is negative and y is equal to zero
	  if (y === 0 && x > 0) {
	    return 0;
	  }

	  // Return zero if x is negative and y is equal to zero
	  if (y === 0 && x < 0) {
	    return -Math.PI;
	  }

	  // Return argument of complex number
	  if (x > 0) {
	    return Math.atan(y / x);
	  } else if (x < 0 && y >= 0) {
	    return Math.atan(y / x) + Math.PI;
	  } else {
	    return Math.atan(y / x) - Math.PI;
	  }
	};

	exports.IMCONJUGATE = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return conjugate of complex number
	  return (y !== 0) ? exports.COMPLEX(x, -y, unit) : inumber;
	};

	exports.IMCOS = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return cosine of complex number
	  return exports.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
	};

	exports.IMCOSH = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return hyperbolic cosine of complex number
	  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
	};

	exports.IMCOT = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return cotangent of complex number
	  return exports.IMDIV(exports.IMCOS(inumber), exports.IMSIN(inumber));
	};

	exports.IMDIV = function(inumber1, inumber2) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var a = exports.IMREAL(inumber1);
	  var b = exports.IMAGINARY(inumber1);
	  var c = exports.IMREAL(inumber2);
	  var d = exports.IMAGINARY(inumber2);

	  if (utils.anyIsError(a, b, c, d)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit1 = inumber1.substring(inumber1.length - 1);
	  var unit2 = inumber2.substring(inumber2.length - 1);
	  var unit = 'i';
	  if (unit1 === 'j') {
	    unit = 'j';
	  } else if (unit2 === 'j') {
	    unit = 'j';
	  }

	  // Return error if inumber2 is null
	  if (c === 0 && d === 0) {
	    return error.num;
	  }

	  // Return exponential of complex number
	  var den = c * c + d * d;
	  return exports.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);
	};

	exports.IMEXP = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  var e = Math.exp(x);
	  return exports.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);
	};

	exports.IMLN = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);
	};

	exports.IMLOG10 = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);
	};

	exports.IMLOG2 = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);
	};

	exports.IMPOWER = function(inumber, number) {
	  number = utils.parseNumber(number);
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);
	  if (utils.anyIsError(number, x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Calculate power of modulus
	  var p = Math.pow(exports.IMABS(inumber), number);

	  // Calculate argument
	  var t = exports.IMARGUMENT(inumber);

	  // Return exponential of complex number
	  return exports.COMPLEX(p * Math.cos(number * t), p * Math.sin(number * t), unit);
	};

	exports.IMPRODUCT = function() {
	  // Initialize result
	  var result = arguments[0];

	  // Loop on all numbers
	  for (var i = 1; i < arguments.length; i++) {
	    // Lookup coefficients of two complex numbers
	    var a = exports.IMREAL(result);
	    var b = exports.IMAGINARY(result);
	    var c = exports.IMREAL(arguments[i]);
	    var d = exports.IMAGINARY(arguments[i]);

	    if (utils.anyIsError(a, b, c, d)) {
	      return error.value;
	    }

	    // Complute product of two complex numbers
	    result = exports.COMPLEX(a * c - b * d, a * d + b * c);
	  }

	  // Return product of complex numbers
	  return result;
	};

	exports.IMREAL = function(inumber) {
	  if (inumber === undefined || inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Return 0 if inumber is equal to 0
	  if (inumber === 0 || inumber === '0') {
	    return 0;
	  }

	  // Handle special cases
	  if (['i', '+i', '1i', '+1i', '-i', '-1i', 'j', '+j', '1j', '+1j', '-j', '-1j'].indexOf(inumber) >= 0) {
	    return 0;
	  }

	  // Lookup sign
	  var plus = inumber.indexOf('+');
	  var minus = inumber.indexOf('-');
	  if (plus === 0) {
	    plus = inumber.indexOf('+', 1);
	  }
	  if (minus === 0) {
	    minus = inumber.indexOf('-', 1);
	  }

	  // Lookup imaginary unit
	  var last = inumber.substring(inumber.length - 1, inumber.length);
	  var unit = (last === 'i' || last === 'j');

	  if (plus >= 0 || minus >= 0) {
	    // Return error if imaginary unit is neither i nor j
	    if (!unit) {
	      return error.num;
	    }

	    // Return real coefficient of complex number
	    if (plus >= 0) {
	      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(0, plus));
	    } else {
	      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(0, minus));
	    }
	  } else {
	    if (unit) {
	      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : 0;
	    } else {
	      return (isNaN(inumber)) ? error.num : inumber;
	    }
	  }
	};

	exports.IMSEC = function(inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return secant of complex number
	  return exports.IMDIV('1', exports.IMCOS(inumber));
	};

	exports.IMSECH = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return hyperbolic secant of complex number
	  return exports.IMDIV('1', exports.IMCOSH(inumber));
	};

	exports.IMSIN = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return sine of complex number
	  return exports.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
	};

	exports.IMSINH = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return hyperbolic sine of complex number
	  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
	};

	exports.IMSQRT = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Calculate power of modulus
	  var s = Math.sqrt(exports.IMABS(inumber));

	  // Calculate argument
	  var t = exports.IMARGUMENT(inumber);

	  // Return exponential of complex number
	  return exports.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
	};

	exports.IMCSC = function (inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.num;
	  }

	  // Return cosecant of complex number
	  return exports.IMDIV('1', exports.IMSIN(inumber));
	};

	exports.IMCSCH = function (inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.num;
	  }

	  // Return hyperbolic cosecant of complex number
	  return exports.IMDIV('1', exports.IMSINH(inumber));
	};

	exports.IMSUB = function(inumber1, inumber2) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var a = this.IMREAL(inumber1);
	  var b = this.IMAGINARY(inumber1);
	  var c = this.IMREAL(inumber2);
	  var d = this.IMAGINARY(inumber2);

	  if (utils.anyIsError(a, b, c, d)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit1 = inumber1.substring(inumber1.length - 1);
	  var unit2 = inumber2.substring(inumber2.length - 1);
	  var unit = 'i';
	  if (unit1 === 'j') {
	    unit = 'j';
	  } else if (unit2 === 'j') {
	    unit = 'j';
	  }

	  // Return _ of two complex numbers
	  return this.COMPLEX(a - c, b - d, unit);
	};

	exports.IMSUM = function() {
	  var args = utils.flatten(arguments);

	  // Initialize result
	  var result = args[0];

	  // Loop on all numbers
	  for (var i = 1; i < args.length; i++) {
	    // Lookup coefficients of two complex numbers
	    var a = this.IMREAL(result);
	    var b = this.IMAGINARY(result);
	    var c = this.IMREAL(args[i]);
	    var d = this.IMAGINARY(args[i]);

	    if (utils.anyIsError(a, b, c, d)) {
	      return error.value;
	    }

	    // Complute product of two complex numbers
	    result = this.COMPLEX(a + c, b + d);
	  }

	  // Return sum of complex numbers
	  return result;
	};

	exports.IMTAN = function(inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return tangent of complex number
	  return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));
	};

	exports.OCT2BIN = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Check if number is negative
	  var negative = (number.length === 10 && number.substring(0, 1) === '7') ? true : false;

	  // Convert octal number to decimal
	  var decimal = (negative) ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);

	  // Return error if number is lower than -512 or greater than 511
	  if (decimal < -512 || decimal > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (negative) {
	    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = decimal.toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.OCT2DEC = function(number) {
	  // Return error if number is not octal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert octal number to decimal
	  var decimal = parseInt(number, 8);

	  // Return decimal number
	  return (decimal >= 536870912) ? decimal - 1073741824 : decimal;
	};

	exports.OCT2HEX = function(number, places) {
	  // Return error if number is not octal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert octal number to decimal
	  var decimal = parseInt(number, 8);

	  // Ignore places and return a 10-character octal number if number is negative
	  if (decimal >= 536870912) {
	    return 'ff' + (decimal + 3221225472).toString(16);
	  }

	  // Convert decimal number to hexadecimal
	  var result = decimal.toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var M = Math;
	function _horner(arr, v) { return arr.reduce(function(z,w){return v * z + w;},0); };
	function _bessel_iter(x, n, f0, f1, sign) {
	  if(!sign) sign = -1;
	  var tdx = 2 / x, f2;
	  if(n === 0) return f0;
	  if(n === 1) return f1;
	  for(var o = 1; o != n; ++o) {
	    f2 = f1 * o * tdx + sign * f0;
	    f0 = f1; f1 = f2;
	  }
	  return f1;
	}
	function _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {
	  return function bessel(x,n) {
	    if(n === 0) return bessel0(x);
	    if(n === 1) return bessel1(x);
	    if(n < 0) throw name + ': Order (' + n + ') must be nonnegative';
	    if(nonzero == 1 && x === 0) throw name + ': Undefined when x == 0';
	    if(nonzero == 2 && x <= 0) throw name + ': Undefined when x <= 0';
	    var b0 = bessel0(x), b1 = bessel1(x);
	    return _bessel_iter(x, n, b0, b1, sign);
	  };
	}
	var besselj = (function() {
	  var b0_a1a = [57568490574.0,-13362590354.0,651619640.7,-11214424.18,77392.33017,-184.9052456].reverse();
	  var b0_a2a = [57568490411.0,1029532985.0,9494680.718,59272.64853,267.8532712,1.0].reverse();
	  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
	  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934935152e-7].reverse();
	  var W = 0.636619772; // 2 / Math.PI

	  function bessel0(x) {
	    var a, a1, a2, y = x * x, xx = M.abs(x) - 0.785398164;
	    if(M.abs(x) < 8) {
	      a1 = _horner(b0_a1a, y);
	      a2 = _horner(b0_a2a, y);
	      a = a1/a2;
	    }
	    else {
	      y = 64 / y;
	      a1 = _horner(b0_a1b, y);
	      a2 = _horner(b0_a2b, y);
	      a = M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));
	    }
	    return a;
	  }
	  var b1_a1a = [72362614232.0,-7895059235.0,242396853.1,-2972611.439, 15704.48260, -30.16036606].reverse();
	  var b1_a2a = [144725228442.0, 2300535178.0, 18583304.74, 99447.43394, 376.9991397, 1.0].reverse();
	  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
	  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
	  function bessel1(x) {
	    var a, a1, a2, y = x*x, xx = M.abs(x) - 2.356194491;
	    if(Math.abs(x)< 8) {
	      a1 = x*_horner(b1_a1a, y);
	      a2 = _horner(b1_a2a, y);
	      a = a1 / a2;
	    } else {
	      y = 64 / y;
	      a1=_horner(b1_a1b, y);
	      a2=_horner(b1_a2b, y);
	      a=M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));
	      if(x < 0) a = -a;
	    }
	    return a;
	  }
	  return function besselj(x, n) {
	    n = Math.round(n);
	    if(n === 0) return bessel0(M.abs(x));
	    if(n === 1) return bessel1(M.abs(x));
	    if(n < 0) throw 'BESSELJ: Order (' + n + ') must be nonnegative';
	    if(M.abs(x) === 0) return 0;

	    var ret, j, tox = 2 / M.abs(x), m, jsum, sum, bjp, bj, bjm;
	    if(M.abs(x) > n) {
	      ret = _bessel_iter(x, n, bessel0(M.abs(x)), bessel1(M.abs(x)),-1);
	    } else {
	      m=2*M.floor((n+M.floor(M.sqrt(40*n)))/2);
	      jsum=0;
	      bjp=ret=sum=0.0;
	      bj=1.0;
	      for (j=m;j>0;j--) {
	        bjm=j*tox*bj-bjp;
	        bjp=bj;
	        bj=bjm;
	        if (M.abs(bj) > 1E10) {
	          bj *= 1E-10;
	          bjp *= 1E-10;
	          ret *= 1E-10;
	          sum *= 1E-10;
	        }
	        if (jsum) sum += bj;
	        jsum=!jsum;
	        if (j == n) ret=bjp;
	      }
	      sum=2.0*sum-bj;
	      ret /= sum;
	    }
	    return x < 0 && (n%2) ? -ret : ret;
	  };
	})();
	var bessely = (function() {
	  var b0_a1a = [-2957821389.0, 7062834065.0, -512359803.6, 10879881.29, -86327.92757, 228.4622733].reverse();
	  var b0_a2a = [40076544269.0, 745249964.8, 7189466.438, 47447.26470, 226.1030244, 1.0].reverse();
	  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
	  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934945152e-7].reverse();

	  var W = 0.636619772;
	  function bessel0(x) {
	    var a, a1, a2, y = x * x, xx = x - 0.785398164;
	    if(x < 8) {
	      a1 = _horner(b0_a1a, y);
	      a2 = _horner(b0_a2a, y);
	      a = a1/a2 + W * besselj(x,0) * M.log(x);
	    } else {
	      y = 64 / y;
	      a1 = _horner(b0_a1b, y);
	      a2 = _horner(b0_a2b, y);
	      a = M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);
	    }
	    return a;
	  }

	  var b1_a1a = [-0.4900604943e13, 0.1275274390e13, -0.5153438139e11, 0.7349264551e9, -0.4237922726e7, 0.8511937935e4].reverse();
	  var b1_a2a = [0.2499580570e14, 0.4244419664e12, 0.3733650367e10, 0.2245904002e8, 0.1020426050e6, 0.3549632885e3, 1].reverse();
	  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
	  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
	  function bessel1(x) {
	    var a, a1, a2, y = x*x, xx = x - 2.356194491;
	    if(x < 8) {
	      a1 = x*_horner(b1_a1a, y);
	      a2 = _horner(b1_a2a, y);
	      a = a1/a2 + W * (besselj(x,1) * M.log(x) - 1 / x);
	    } else {
	      y = 64 / y;
	      a1=_horner(b1_a1b, y);
	      a2=_horner(b1_a2b, y);
	      a=M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);
	    }
	    return a;
	  }

	  return _bessel_wrap(bessel0, bessel1, 'BESSELY', 1, -1);
	})();
	var besseli = (function() {
	  var b0_a = [1.0, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.360768e-1, 0.45813e-2].reverse();
	  var b0_b = [0.39894228, 0.1328592e-1, 0.225319e-2, -0.157565e-2, 0.916281e-2, -0.2057706e-1, 0.2635537e-1, -0.1647633e-1, 0.392377e-2].reverse();
	  function bessel0(x) {
	    if(x <= 3.75) return _horner(b0_a, x*x/(3.75*3.75));
	    return M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b0_b, 3.75/M.abs(x));
	  }

	  var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.2658733e-1, 0.301532e-2, 0.32411e-3].reverse();
	  var b1_b = [0.39894228, -0.3988024e-1, -0.362018e-2, 0.163801e-2, -0.1031555e-1, 0.2282967e-1, -0.2895312e-1, 0.1787654e-1, -0.420059e-2].reverse();
	  function bessel1(x) {
	    if(x < 3.75) return x * _horner(b1_a, x*x/(3.75*3.75));
	    return (x < 0 ? -1 : 1) * M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b1_b, 3.75/M.abs(x));
	  }

	  return function besseli(x, n) {
	    n = Math.round(n);
	    if(n === 0) return bessel0(x);
	    if(n == 1) return bessel1(x);
	    if(n < 0) throw 'BESSELI Order (' + n + ') must be nonnegative';
	    if(M.abs(x) === 0) return 0;

	    var ret, j, tox = 2 / M.abs(x), m, bip, bi, bim;
	    m=2*M.round((n+M.round(M.sqrt(40*n)))/2);
	    bip=ret=0.0;
	    bi=1.0;
	    for (j=m;j>0;j--) {
	      bim=j*tox*bi + bip;
	      bip=bi; bi=bim;
	      if (M.abs(bi) > 1E10) {
	        bi *= 1E-10;
	        bip *= 1E-10;
	        ret *= 1E-10;
	      }
	      if(j == n) ret = bip;
	    }
	    ret *= besseli(x, 0) / bi;
	    return x < 0 && (n%2) ? -ret : ret;
	  };

	})();

	var besselk = (function() {
	  var b0_a = [-0.57721566, 0.42278420, 0.23069756, 0.3488590e-1, 0.262698e-2, 0.10750e-3, 0.74e-5].reverse();
	  var b0_b = [1.25331414, -0.7832358e-1, 0.2189568e-1, -0.1062446e-1, 0.587872e-2, -0.251540e-2, 0.53208e-3].reverse();
	  function bessel0(x) {
	    if(x <= 2) return -M.log(x/2)*besseli(x,0) + _horner(b0_a, x*x/4);
	    return M.exp(-x)/M.sqrt(x)*_horner(b0_b, 2/x);
	  }

	  var b1_a = [1.0, 0.15443144, -0.67278579, -0.18156897, -0.1919402e-1, -0.110404e-2, -0.4686e-4].reverse();
	  var b1_b = [1.25331414, 0.23498619, -0.3655620e-1, 0.1504268e-1, -0.780353e-2, 0.325614e-2, -0.68245e-3].reverse();
	  function bessel1(x) {
	    if(x <= 2) return M.log(x/2)*besseli(x,1) + (1/x)*_horner(b1_a, x*x/4);
	    return M.exp(-x)/M.sqrt(x)*_horner(b1_b, 2/x);
	  }

	  return _bessel_wrap(bessel0, bessel1, 'BESSELK', 2, 1);
	})();
	if(true) {
	  exports.besselj = besselj;
	  exports.bessely = bessely;
	  exports.besseli = besseli;
	  exports.besselk = besselk;
	}



/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var utils = __webpack_require__(4);

	var d1900 = new Date(1900, 0, 1);
	var WEEK_STARTS = [
	  undefined,
	  0,
	  1,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  1,
	  2,
	  3,
	  4,
	  5,
	  6,
	  0
	];
	var WEEK_TYPES = [
	  [],
	  [1, 2, 3, 4, 5, 6, 7],
	  [7, 1, 2, 3, 4, 5, 6],
	  [6, 0, 1, 2, 3, 4, 5],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [7, 1, 2, 3, 4, 5, 6],
	  [6, 7, 1, 2, 3, 4, 5],
	  [5, 6, 7, 1, 2, 3, 4],
	  [4, 5, 6, 7, 1, 2, 3],
	  [3, 4, 5, 6, 7, 1, 2],
	  [2, 3, 4, 5, 6, 7, 1],
	  [1, 2, 3, 4, 5, 6, 7]
	];
	var WEEKEND_TYPES = [
	  [],
	  [6, 0],
	  [0, 1],
	  [1, 2],
	  [2, 3],
	  [3, 4],
	  [4, 5],
	  [5, 6],
	  undefined,
	  undefined,
	  undefined, [0, 0],
	  [1, 1],
	  [2, 2],
	  [3, 3],
	  [4, 4],
	  [5, 5],
	  [6, 6]
	];

	exports.DATE = function(year, month, day) {
	  year = utils.parseNumber(year);
	  month = utils.parseNumber(month);
	  day = utils.parseNumber(day);
	  if (utils.anyIsError(year, month, day)) {
	    return error.value;
	  }
	  if (year < 0 || month < 0 || day < 0) {
	    return error.num;
	  }
	  var date = new Date(year, month - 1, day);
	  return date;
	};

	exports.DATEVALUE = function(date_text) {
	  if (typeof date_text !== 'string') {
	    return error.value;
	  }
	  var date = Date.parse(date_text);
	  if (isNaN(date)) {
	    return error.value;
	  }
	  if (date <= -2203891200000) {
	    return (date - d1900) / 86400000 + 1;
	  }
	  return (date - d1900) / 86400000 + 2;
	};

	exports.DAY = function(serial_number) {
	  var date = utils.parseDate(serial_number);
	  if (date instanceof Error) {
	    return date;
	  }
	  return date.getDate();
	};

	exports.DAYS = function(end_date, start_date) {
	  end_date = utils.parseDate(end_date);
	  start_date = utils.parseDate(start_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  return serial(end_date) - serial(start_date);
	};

	exports.DAYS360 = function(start_date, end_date, method) {
	  method = utils.parseBool(method);
	  start_date = utils.parseDate(start_date);
	  end_date = utils.parseDate(end_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (method instanceof Error) {
	    return method;
	  }
	  var sm = start_date.getMonth();
	  var em = end_date.getMonth();
	  var sd, ed;
	  if (method) {
	    sd = start_date.getDate() === 31 ? 30 : start_date.getDate();
	    ed = end_date.getDate() === 31 ? 30 : end_date.getDate();
	  } else {
	    var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
	    var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
	    sd = start_date.getDate() === smd ? 30 : start_date.getDate();
	    if (end_date.getDate() === emd) {
	      if (sd < 30) {
	        em++;
	        ed = 1;
	      } else {
	        ed = 30;
	      }
	    } else {
	      ed = end_date.getDate();
	    }
	  }
	  return 360 * (end_date.getFullYear() - start_date.getFullYear()) +
	    30 * (em - sm) + (ed - sd);
	};

	exports.EDATE = function(start_date, months) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (isNaN(months)) {
	    return error.value;
	  }
	  months = parseInt(months, 10);
	  start_date.setMonth(start_date.getMonth() + months);
	  return serial(start_date);
	};

	exports.EOMONTH = function(start_date, months) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (isNaN(months)) {
	    return error.value;
	  }
	  months = parseInt(months, 10);
	  return serial(new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0));
	};

	exports.HOUR = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getHours();
	};

	exports.INTERVAL = function (second) {
	  if (typeof second !== 'number' && typeof second !== 'string') {
	    return error.value;
	  } else {
	    second = parseInt(second, 10);
	  }

	  var year  = Math.floor(second/946080000);
	  second    = second%946080000;
	  var month = Math.floor(second/2592000);
	  second    = second%2592000;
	  var day   = Math.floor(second/86400);
	  second    = second%86400;

	  var hour  = Math.floor(second/3600);
	  second    = second%3600;
	  var min   = Math.floor(second/60);
	  second    = second%60;
	  var sec   = second;

	  year  = (year  > 0) ? year  + 'Y' : '';
	  month = (month > 0) ? month + 'M' : '';
	  day   = (day   > 0) ? day   + 'D' : '';
	  hour  = (hour  > 0) ? hour  + 'H' : '';
	  min   = (min   > 0) ? min   + 'M' : '';
	  sec   = (sec   > 0) ? sec   + 'S' : '';

	  return 'P' + year + month + day +
	  'T' + hour + min + sec;
	};

	exports.ISOWEEKNUM = function(date) {
	  date = utils.parseDate(date);
	  if (date instanceof Error) {
	    return date;
	  }

	  date.setHours(0, 0, 0);
	  date.setDate(date.getDate() + 4 - (date.getDay() || 7));
	  var yearStart = new Date(date.getFullYear(), 0, 1);
	  return Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
	};

	exports.MINUTE = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getMinutes();
	};

	exports.MONTH = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getMonth() + 1;
	};

	exports.NETWORKDAYS = function(start_date, end_date, holidays) {
	  return this.NETWORKDAYS.INTL(start_date, end_date, 1, holidays);
	};

	exports.NETWORKDAYS.INTL = function(start_date, end_date, weekend, holidays) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  end_date = utils.parseDate(end_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (weekend === undefined) {
	    weekend = WEEKEND_TYPES[1];
	  } else {
	    weekend = WEEKEND_TYPES[weekend];
	  }
	  if (!(weekend instanceof Array)) {
	    return error.value;
	  }
	  if (holidays === undefined) {
	    holidays = [];
	  } else if (!(holidays instanceof Array)) {
	    holidays = [holidays];
	  }
	  for (var i = 0; i < holidays.length; i++) {
	    var h = utils.parseDate(holidays[i]);
	    if (h instanceof Error) {
	      return h;
	    }
	    holidays[i] = h;
	  }
	  var days = (end_date - start_date) / (1000 * 60 * 60 * 24) + 1;
	  var total = days;
	  var day = start_date;
	  for (i = 0; i < days; i++) {
	    var d = (new Date().getTimezoneOffset() > 0) ? day.getUTCDay() : day.getDay();
	    var dec = false;
	    if (d === weekend[0] || d === weekend[1]) {
	      dec = true;
	    }
	    for (var j = 0; j < holidays.length; j++) {
	      var holiday = holidays[j];
	      if (holiday.getDate() === day.getDate() &&
	        holiday.getMonth() === day.getMonth() &&
	        holiday.getFullYear() === day.getFullYear()) {
	        dec = true;
	        break;
	      }
	    }
	    if (dec) {
	      total--;
	    }
	    day.setDate(day.getDate() + 1);
	  }
	  return total;
	};

	exports.NOW = function() {
	  return new Date();
	};

	exports.SECOND = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getSeconds();
	};

	exports.TIME = function(hour, minute, second) {
	  hour = utils.parseNumber(hour);
	  minute = utils.parseNumber(minute);
	  second = utils.parseNumber(second);
	  if (utils.anyIsError(hour, minute, second)) {
	    return error.value;
	  }
	  if (hour < 0 || minute < 0 || second < 0) {
	    return error.num;
	  }
	  return (3600 * hour + 60 * minute + second) / 86400;
	};

	exports.TIMEVALUE = function(time_text) {
	  time_text = utils.parseDate(time_text);
	  if (time_text instanceof Error) {
	    return time_text;
	  }
	  return (3600 * time_text.getHours() +
	    60 * time_text.getMinutes() +
	    time_text.getSeconds()) / 86400;
	};

	exports.TODAY = function() {
	  return new Date();
	};

	exports.WEEKDAY = function(serial_number, return_type) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  if (return_type === undefined) {
	    return_type = 1;
	  }
	  var day = serial_number.getDay();
	  return WEEK_TYPES[return_type][day];
	};

	exports.WEEKNUM = function(serial_number, return_type) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  if (return_type === undefined) {
	    return_type = 1;
	  }
	  if (return_type === 21) {
	    return this.ISOWEEKNUM(serial_number);
	  }
	  var week_start = WEEK_STARTS[return_type];
	  var jan = new Date(serial_number.getFullYear(), 0, 1);
	  var inc = jan.getDay() < week_start ? 1 : 0;
	  jan -= Math.abs(jan.getDay() - week_start) * 24 * 60 * 60 * 1000;
	  return Math.floor(((serial_number - jan) / (1000 * 60 * 60 * 24)) / 7 + 1) + inc;
	};

	exports.WORKDAY = function(start_date, days, holidays) {
	  return this.WORKDAY.INTL(start_date, days, 1, holidays);
	};

	exports.WORKDAY.INTL = function(start_date, days, weekend, holidays) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  days = utils.parseNumber(days);
	  if (days instanceof Error) {
	    return days;
	  }
	  if (days < 0) {
	    return error.num;
	  }
	  if (weekend === undefined) {
	    weekend = WEEKEND_TYPES[1];
	  } else {
	    weekend = WEEKEND_TYPES[weekend];
	  }
	  if (!(weekend instanceof Array)) {
	    return error.value;
	  }
	  if (holidays === undefined) {
	    holidays = [];
	  } else if (!(holidays instanceof Array)) {
	    holidays = [holidays];
	  }
	  for (var i = 0; i < holidays.length; i++) {
	    var h = utils.parseDate(holidays[i]);
	    if (h instanceof Error) {
	      return h;
	    }
	    holidays[i] = h;
	  }
	  var d = 0;
	  while (d < days) {
	    start_date.setDate(start_date.getDate() + 1);
	    var day = start_date.getDay();
	    if (day === weekend[0] || day === weekend[1]) {
	      continue;
	    }
	    for (var j = 0; j < holidays.length; j++) {
	      var holiday = holidays[j];
	      if (holiday.getDate() === start_date.getDate() &&
	        holiday.getMonth() === start_date.getMonth() &&
	        holiday.getFullYear() === start_date.getFullYear()) {
	        d--;
	        break;
	      }
	    }
	    d++;
	  }
	  return start_date;
	};

	exports.YEAR = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getFullYear();
	};

	function isLeapYear(year) {
	  return new Date(year, 1, 29).getMonth() === 1;
	}

	// TODO : Use DAYS ?
	function daysBetween(start_date, end_date) {
	  return Math.ceil((end_date - start_date) / 1000 / 60 / 60 / 24);
	}

	exports.YEARFRAC = function(start_date, end_date, basis) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  end_date = utils.parseDate(end_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }

	  basis = basis || 0;
	  var sd = start_date.getDate();
	  var sm = start_date.getMonth() + 1;
	  var sy = start_date.getFullYear();
	  var ed = end_date.getDate();
	  var em = end_date.getMonth() + 1;
	  var ey = end_date.getFullYear();

	  switch (basis) {
	    case 0:
	      // US (NASD) 30/360
	      if (sd === 31 && ed === 31) {
	        sd = 30;
	        ed = 30;
	      } else if (sd === 31) {
	        sd = 30;
	      } else if (sd === 30 && ed === 31) {
	        ed = 30;
	      }
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	    case 1:
	      // Actual/actual
	      var feb29Between = function(date1, date2) {
	        var year1 = date1.getFullYear();
	        var mar1year1 = new Date(year1, 2, 1);
	        if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
	          return true;
	        }
	        var year2 = date2.getFullYear();
	        var mar1year2 = new Date(year2, 2, 1);
	        return (isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2);
	      };
	      var ylength = 365;
	      if (sy === ey || ((sy + 1) === ey) && ((sm > em) || ((sm === em) && (sd >= ed)))) {
	        if ((sy === ey && isLeapYear(sy)) ||
	            feb29Between(start_date, end_date) ||
	            (em === 1 && ed === 29)) {
	          ylength = 366;
	        }
	        return daysBetween(start_date, end_date) / ylength;
	      }
	      var years = (ey - sy) + 1;
	      var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;
	      var average = days / years;
	      return daysBetween(start_date, end_date) / average;
	    case 2:
	      // Actual/360
	      return daysBetween(start_date, end_date) / 360;
	    case 3:
	      // Actual/365
	      return daysBetween(start_date, end_date) / 365;
	    case 4:
	      // European 30/360
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	  }
	};

	function serial(date) {
	  var addOn = (date > -2203891200000)?2:1;
	  return (date - d1900) / 86400000 + addOn;
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var stats = __webpack_require__(6);
	var maths = __webpack_require__(2);
	var utils = __webpack_require__(4);

	function compact(array) {
	  if (!array) { return array; }
	  var result = [];
	  for (var i = 0; i < array.length; ++i) {
	    if (!array[i]) { continue; }
	    result.push(array[i]);
	  }
	  return result;
	}

	exports.FINDFIELD = function(database, title) {
	  var index = null;
	  for (var i = 0; i < database.length; i++) {
	    if (database[i][0] === title) {
	      index = i;
	      break;
	    }
	  }

	  // Return error if the input field title is incorrect
	  if (index == null) {
	    return error.value;
	  }
	  return index;
	};

	function findResultIndex(database, criterias) {
	  var matches = {};
	  for (var i = 1; i < database[0].length; ++i) {
	    matches[i] = true;
	  }
	  var maxCriteriaLength = criterias[0].length;
	  for (i = 1; i < criterias.length; ++i) {
	    if (criterias[i].length > maxCriteriaLength) {
	      maxCriteriaLength = criterias[i].length;
	    }
	  }

	  for (var k = 1; k < database.length; ++k) {
	    for (var l = 1; l < database[k].length; ++l) {
	      var currentCriteriaResult = false;
	      var hasMatchingCriteria   = false;
	      for (var j = 0; j < criterias.length; ++j) {
	        var criteria = criterias[j];
	        if (criteria.length < maxCriteriaLength) {
	          continue;
	        }

	        var criteriaField = criteria[0];
	        if (database[k][0] !== criteriaField) {
	          continue;
	        }
	        hasMatchingCriteria = true;
	        for (var p = 1; p < criteria.length; ++p) {
	          currentCriteriaResult = currentCriteriaResult || eval(database[k][l] + criteria[p]);  // jshint ignore:line
	        }
	      }
	      if (hasMatchingCriteria) {
	        matches[l] = matches[l] && currentCriteriaResult;
	      }
	    }
	  }

	  var result = [];
	  for (var n = 0; n < database[0].length; ++n) {
	    if (matches[n]) {
	      result.push(n - 1);
	    }
	  }
	  return result;
	}

	// Database functions
	exports.DAVERAGE = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var sum = 0;
	  for (var i = 0; i < resultIndexes.length; i++) {
	    sum += targetFields[resultIndexes[i]];
	  }
	  return resultIndexes.length === 0 ? error.div0 : sum / resultIndexes.length;
	};

	exports.DCOUNT = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.COUNT(targetValues);
	};

	exports.DCOUNTA = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.COUNTA(targetValues);
	};

	exports.DGET = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  // Return error if no record meets the criteria
	  if (resultIndexes.length === 0) {
	    return error.value;
	  }
	  // Returns the #NUM! error value because more than one record meets the
	  // criteria
	  if (resultIndexes.length > 1) {
	    return error.num;
	  }

	  return targetFields[resultIndexes[0]];
	};

	exports.DMAX = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var maxValue = targetFields[resultIndexes[0]];
	  for (var i = 1; i < resultIndexes.length; i++) {
	    if (maxValue < targetFields[resultIndexes[i]]) {
	      maxValue = targetFields[resultIndexes[i]];
	    }
	  }
	  return maxValue;
	};

	exports.DMIN = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var minValue = targetFields[resultIndexes[0]];
	  for (var i = 1; i < resultIndexes.length; i++) {
	    if (minValue > targetFields[resultIndexes[i]]) {
	      minValue = targetFields[resultIndexes[i]];
	    }
	  }
	  return minValue;
	};

	exports.DPRODUCT = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  var result = 1;
	  for (i = 0; i < targetValues.length; i++) {
	    result *= targetValues[i];
	  }
	  return result;
	};

	exports.DSTDEV = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  return stats.STDEV.S(targetValues);
	};

	exports.DSTDEVP = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  return stats.STDEV.P(targetValues);
	};

	exports.DSUM = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return maths.SUM(targetValues);
	};

	exports.DVAR = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.VAR.S(targetValues);
	};

	exports.DVARP = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.VAR.P(targetValues);
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var utils = __webpack_require__(4);
	var information = __webpack_require__(11);

	exports.AND = function() {
	  var args = utils.flatten(arguments);
	  var result = true;
	  for (var i = 0; i < args.length; i++) {
	    if (!args[i]) {
	      result = false;
	    }
	  }
	  return result;
	};

	exports.CHOOSE = function() {
	  if (arguments.length < 2) {
	    return error.na;
	  }

	  var index = arguments[0];
	  if (index < 1 || index > 254) {
	    return error.value;
	  }

	  if (arguments.length < index + 1) {
	    return error.value;
	  }

	  return arguments[index];
	};

	exports.FALSE = function() {
	  return false;
	};

	exports.IF = function(test, then_value, otherwise_value) {
	  return test ? then_value : otherwise_value;
	};

	exports.IFERROR = function(value, valueIfError) {
	  if (information.ISERROR(value)) {
	    return valueIfError;
	  }
	  return value;
	};

	exports.IFNA = function(value, value_if_na) {
	  return value === error.na ? value_if_na : value;
	};

	exports.NOT = function(logical) {
	  return !logical;
	};

	exports.OR = function() {
	  var args = utils.flatten(arguments);
	  var result = false;
	  for (var i = 0; i < args.length; i++) {
	    if (args[i]) {
	      result = true;
	    }
	  }
	  return result;
	};

	exports.TRUE = function() {
	  return true;
	};

	exports.XOR = function() {
	  var args = utils.flatten(arguments);
	  var result = 0;
	  for (var i = 0; i < args.length; i++) {
	    if (args[i]) {
	      result++;
	    }
	  }
	  return (Math.floor(Math.abs(result)) & 1) ? true : false;
	};

	exports.SWITCH = function () {
	  var result;
	  if (arguments.length > 0)  {
	    var targetValue = arguments[0];
	    var argc = arguments.length - 1;
	    var switchCount = Math.floor(argc / 2);
	    var switchSatisfied = false;
	    var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];

	    if (switchCount) {
	      for (var index = 0; index < switchCount; index++) {
	        if (targetValue === arguments[index * 2 + 1]) {
	          result = arguments[index * 2 + 2];
	          switchSatisfied = true;
	          break;
	        }
	      }
	    }

	    if (!switchSatisfied && defaultClause) {
	      result = defaultClause;
	    }
	  }

	  return result;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var dateTime = __webpack_require__(14);
	var utils = __webpack_require__(4);

	function validDate(d) {
	  return d && d.getTime && !isNaN(d.getTime());
	}

	function ensureDate(d) {
	  return (d instanceof Date)?d:new Date(d);
	}

	exports.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
	  // Return error if either date is invalid
	  issue      = ensureDate(issue);
	  first      = ensureDate(first);
	  settlement = ensureDate(settlement);
	  if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {
	    return '#VALUE!';
	  }

	  // Return error if either rate or par are lower than or equal to zero
	  if (rate <= 0 || par <= 0) {
	    return '#NUM!';
	  }

	  // Return error if frequency is neither 1, 2, or 4
	  if ([1, 2, 4].indexOf(frequency) === -1) {
	    return '#NUM!';
	  }

	  // Return error if basis is neither 0, 1, 2, 3, or 4
	  if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
	    return '#NUM!';
	  }

	  // Return error if settlement is before or equal to issue
	  if (settlement <= issue) {
	    return '#NUM!';
	  }

	  // Set default values
	  par   = par   || 0;
	  basis = basis || 0;

	  // Compute accrued interest
	  return par * rate * dateTime.YEARFRAC(issue, settlement, basis);
	};

	// TODO
	exports.ACCRINTM = function() {
	 throw new Error('ACCRINTM is not implemented');
	};

	// TODO
	exports.AMORDEGRC = function() {
	 throw new Error('AMORDEGRC is not implemented');
	};

	// TODO
	exports.AMORLINC = function() {
	 throw new Error('AMORLINC is not implemented');
	};

	// TODO
	exports.COUPDAYBS = function() {
	 throw new Error('COUPDAYBS is not implemented');
	};

	// TODO
	exports.COUPDAYS = function() {
	 throw new Error('COUPDAYS is not implemented');
	};

	// TODO
	exports.COUPDAYSNC = function() {
	 throw new Error('COUPDAYSNC is not implemented');
	};

	// TODO
	exports.COUPNCD = function() {
	 throw new Error('COUPNCD is not implemented');
	};

	// TODO
	exports.COUPNUM = function() {
	 throw new Error('COUPNUM is not implemented');
	};

	// TODO
	exports.COUPPCD = function() {
	 throw new Error('COUPPCD is not implemented');
	};

	exports.CUMIPMT = function(rate, periods, value, start, end, type) {
	  // Credits: algorithm inspired by Apache OpenOffice
	  // Credits: Hannes Stiebitzhofer for the translations of function and variable names
	  // Requires exports.FV() and exports.PMT() from exports.js [http://stoic.com/exports/]

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, periods, value)) {
	    return error.value;
	  }

	  // Return error if either rate, periods, or value are lower than or equal to zero
	  if (rate <= 0 || periods <= 0 || value <= 0) {
	    return error.num;
	  }

	  // Return error if start < 1, end < 1, or start > end
	  if (start < 1 || end < 1 || start > end) {
	    return error.num;
	  }

	  // Return error if type is neither 0 nor 1
	  if (type !== 0 && type !== 1) {
	    return error.num;
	  }

	  // Compute cumulative interest
	  var payment = exports.PMT(rate, periods, value, 0, type);
	  var interest = 0;

	  if (start === 1) {
	    if (type === 0) {
	      interest = -value;
	      start++;
	    }
	  }

	  for (var i = start; i <= end; i++) {
	    if (type === 1) {
	      interest += exports.FV(rate, i - 2, payment, value, 1) - payment;
	    } else {
	      interest += exports.FV(rate, i - 1, payment, value, 0);
	    }
	  }
	  interest *= rate;

	  // Return cumulative interest
	  return interest;
	};

	exports.CUMPRINC = function(rate, periods, value, start, end, type) {
	  // Credits: algorithm inspired by Apache OpenOffice
	  // Credits: Hannes Stiebitzhofer for the translations of function and variable names

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, periods, value)) {
	    return error.value;
	  }

	  // Return error if either rate, periods, or value are lower than or equal to zero
	  if (rate <= 0 || periods <= 0 || value <= 0) {
	    return error.num;
	  }

	  // Return error if start < 1, end < 1, or start > end
	  if (start < 1 || end < 1 || start > end) {
	    return error.num;
	  }

	  // Return error if type is neither 0 nor 1
	  if (type !== 0 && type !== 1) {
	    return error.num;
	  }

	  // Compute cumulative principal
	  var payment = exports.PMT(rate, periods, value, 0, type);
	  var principal = 0;
	  if (start === 1) {
	    if (type === 0) {
	      principal = payment + value * rate;
	    } else {
	      principal = payment;
	    }
	    start++;
	  }
	  for (var i = start; i <= end; i++) {
	    if (type > 0) {
	      principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;
	    } else {
	      principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;
	    }
	  }

	  // Return cumulative principal
	  return principal;
	};

	exports.DB = function(cost, salvage, life, period, month) {
	  // Initialize month
	  month = (month === undefined) ? 12 : month;

	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  month = utils.parseNumber(month);
	  if (utils.anyIsError(cost, salvage, life, period, month)) {
	    return error.value;
	  }

	  // Return error if any of the parameters is negative
	  if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
	    return error.num;
	  }

	  // Return error if month is not an integer between 1 and 12
	  if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
	    return error.num;
	  }

	  // Return error if period is greater than life
	  if (period > life) {
	    return error.num;
	  }

	  // Return 0 (zero) if salvage is greater than or equal to cost
	  if (salvage >= cost) {
	    return 0;
	  }

	  // Rate is rounded to three decimals places
	  var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);

	  // Compute initial depreciation
	  var initial = cost * rate * month / 12;

	  // Compute total depreciation
	  var total = initial;
	  var current = 0;
	  var ceiling = (period === life) ? life - 1 : period;
	  for (var i = 2; i <= ceiling; i++) {
	    current = (cost - total) * rate;
	    total += current;
	  }

	  // Depreciation for the first and last periods are special cases
	  if (period === 1) {
	    // First period
	    return initial;
	  } else if (period === life) {
	    // Last period
	    return (cost - total) * rate;
	  } else {
	    return current;
	  }
	};

	exports.DDB = function(cost, salvage, life, period, factor) {
	  // Initialize factor
	  factor = (factor === undefined) ? 2 : factor;

	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  factor = utils.parseNumber(factor);
	  if (utils.anyIsError(cost, salvage, life, period, factor)) {
	    return error.value;
	  }

	  // Return error if any of the parameters is negative or if factor is null
	  if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
	    return error.num;
	  }

	  // Return error if period is greater than life
	  if (period > life) {
	    return error.num;
	  }

	  // Return 0 (zero) if salvage is greater than or equal to cost
	  if (salvage >= cost) {
	    return 0;
	  }

	  // Compute depreciation
	  var total = 0;
	  var current = 0;
	  for (var i = 1; i <= period; i++) {
	    current = Math.min((cost - total) * (factor / life), (cost - salvage - total));
	    total += current;
	  }

	  // Return depreciation
	  return current;
	};

	// TODO
	exports.DISC = function() {
	 throw new Error('DISC is not implemented');
	};

	exports.DOLLARDE = function(dollar, fraction) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  dollar = utils.parseNumber(dollar);
	  fraction = utils.parseNumber(fraction);
	  if (utils.anyIsError(dollar, fraction)) {
	    return error.value;
	  }

	  // Return error if fraction is negative
	  if (fraction < 0) {
	    return error.num;
	  }

	  // Return error if fraction is greater than or equal to 0 and less than 1
	  if (fraction >= 0 && fraction < 1) {
	    return error.div0;
	  }

	  // Truncate fraction if it is not an integer
	  fraction = parseInt(fraction, 10);

	  // Compute integer part
	  var result = parseInt(dollar, 10);

	  // Add decimal part
	  result += (dollar % 1) * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;

	  // Round result
	  var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
	  result = Math.round(result * power) / power;

	  // Return converted dollar price
	  return result;
	};

	exports.DOLLARFR = function(dollar, fraction) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  dollar = utils.parseNumber(dollar);
	  fraction = utils.parseNumber(fraction);
	  if (utils.anyIsError(dollar, fraction)) {
	    return error.value;
	  }

	  // Return error if fraction is negative
	  if (fraction < 0) {
	    return error.num;
	  }

	  // Return error if fraction is greater than or equal to 0 and less than 1
	  if (fraction >= 0 && fraction < 1) {
	    return error.div0;
	  }

	  // Truncate fraction if it is not an integer
	  fraction = parseInt(fraction, 10);

	  // Compute integer part
	  var result = parseInt(dollar, 10);

	  // Add decimal part
	  result += (dollar % 1) * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;

	  // Return converted dollar price
	  return result;
	};

	// TODO
	exports.DURATION = function() {
	 throw new Error('DURATION is not implemented');
	};

	exports.EFFECT = function(rate, periods) {
	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  if (utils.anyIsError(rate, periods)) {
	    return error.value;
	  }

	  // Return error if rate <=0 or periods < 1
	  if (rate <= 0 || periods < 1) {
	    return error.num;
	  }

	  // Truncate periods if it is not an integer
	  periods = parseInt(periods, 10);

	  // Return effective annual interest rate
	  return Math.pow(1 + rate / periods, periods) - 1;
	};

	exports.FV = function(rate, periods, payment, value, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  value = value || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  value = utils.parseNumber(value);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, payment, value, type)) {
	    return error.value;
	  }

	  // Return future value
	  var result;
	  if (rate === 0) {
	    result = value + payment * periods;
	  } else {
	    var term = Math.pow(1 + rate, periods);
	    if (type === 1) {
	      result = value * term + payment * (1 + rate) * (term - 1) / rate;
	    } else {
	      result = value * term + payment * (term - 1) / rate;
	    }
	  }
	  return -result;
	};

	exports.FVSCHEDULE = function(principal, schedule) {
	  principal = utils.parseNumber(principal);
	  schedule = utils.parseNumberArray(utils.flatten(schedule));
	  if (utils.anyIsError(principal, schedule)) {
	    return error.value;
	  }

	  var n = schedule.length;
	  var future = principal;

	  // Apply all interests in schedule
	  for (var i = 0; i < n; i++) {
	    // Apply scheduled interest
	    future *= 1 + schedule[i];
	  }

	  // Return future value
	  return future;
	};

	// TODO
	exports.INTRATE = function() {
	 throw new Error('INTRATE is not implemented');
	};

	exports.IPMT = function(rate, period, periods, present, future, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  period = utils.parseNumber(period);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, period, periods, present, future, type)) {
	    return error.value;
	  }

	  // Compute payment
	  var payment = exports.PMT(rate, periods, present, future, type);

	  // Compute interest
	  var interest;
	  if (period === 1) {
	    if (type === 1) {
	      interest = 0;
	    } else {
	      interest = -present;
	    }
	  } else {
	    if (type === 1) {
	      interest = exports.FV(rate, period - 2, payment, present, 1) - payment;
	    } else {
	      interest = exports.FV(rate, period - 1, payment, present, 0);
	    }
	  }

	  // Return interest
	  return interest * rate;
	};

	exports.IRR = function(values, guess) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  guess = guess || 0;

	  values = utils.parseNumberArray(utils.flatten(values));
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(values, guess)) {
	    return error.value;
	  }

	  // Calculates the resulting amount
	  var irrResult = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = values[0];
	    for (var i = 1; i < values.length; i++) {
	      result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);
	    }
	    return result;
	  };

	  // Calculates the first derivation
	  var irrResultDeriv = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = 0;
	    for (var i = 1; i < values.length; i++) {
	      var frac = (dates[i] - dates[0]) / 365;
	      result -= frac * values[i] / Math.pow(r, frac + 1);
	    }
	    return result;
	  };

	  // Initialize dates and check that values contains at least one positive value and one negative value
	  var dates = [];
	  var positive = false;
	  var negative = false;
	  for (var i = 0; i < values.length; i++) {
	    dates[i] = (i === 0) ? 0 : dates[i - 1] + 365;
	    if (values[i] > 0) {
	      positive = true;
	    }
	    if (values[i] < 0) {
	      negative = true;
	    }
	  }

	  // Return error if values does not contain at least one positive value and one negative value
	  if (!positive || !negative) {
	    return error.num;
	  }

	  // Initialize guess and resultRate
	  guess = (guess === undefined) ? 0.1 : guess;
	  var resultRate = guess;

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-10;

	  // Implement Newton's method
	  var newRate, epsRate, resultValue;
	  var contLoop = true;
	  do {
	    resultValue = irrResult(values, dates, resultRate);
	    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
	    epsRate = Math.abs(newRate - resultRate);
	    resultRate = newRate;
	    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
	  } while (contLoop);

	  // Return internal rate of return
	  return resultRate;
	};

	exports.ISPMT = function(rate, period, periods, value) {
	  rate = utils.parseNumber(rate);
	  period = utils.parseNumber(period);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, period, periods, value)) {
	    return error.value;
	  }

	  // Return interest
	  return value * rate * (period / periods - 1);
	};

	// TODO
	exports.MDURATION = function() {
	 throw new Error('MDURATION is not implemented');
	};

	exports.MIRR = function(values, finance_rate, reinvest_rate) {
	  values = utils.parseNumberArray(utils.flatten(values));
	  finance_rate = utils.parseNumber(finance_rate);
	  reinvest_rate = utils.parseNumber(reinvest_rate);
	  if (utils.anyIsError(values, finance_rate, reinvest_rate)) {
	    return error.value;
	  }

	  // Initialize number of values
	  var n = values.length;

	  // Lookup payments (negative values) and incomes (positive values)
	  var payments = [];
	  var incomes = [];
	  for (var i = 0; i < n; i++) {
	    if (values[i] < 0) {
	      payments.push(values[i]);
	    } else {
	      incomes.push(values[i]);
	    }
	  }

	  // Return modified internal rate of return
	  var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);
	  var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);
	  return Math.pow(num / den, 1 / (n - 1)) - 1;
	};

	exports.NOMINAL = function(rate, periods) {
	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  if (utils.anyIsError(rate, periods)) {
	    return error.value;
	  }

	  // Return error if rate <=0 or periods < 1
	  if (rate <= 0 || periods < 1) {
	    return error.num;
	  }

	  // Truncate periods if it is not an integer
	  periods = parseInt(periods, 10);

	  // Return nominal annual interest rate
	  return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
	};

	exports.NPER = function(rate, payment, present, future, type) {
	  type = (type === undefined) ? 0 : type;
	  future = (future === undefined) ? 0 : future;

	  rate = utils.parseNumber(rate);
	  payment = utils.parseNumber(payment);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, payment, present, future, type)) {
	    return error.value;
	  }

	  // Return number of periods
	  var num = payment * (1 + rate * type) - future * rate;
	  var den = (present * rate + payment * (1 + rate * type));
	  return Math.log(num / den) / Math.log(1 + rate);
	};

	exports.NPV = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }

	  // Lookup rate
	  var rate = args[0];

	  // Initialize net present value
	  var value = 0;

	  // Loop on all values
	  for (var j = 1; j < args.length; j++) {
	    value += args[j] / Math.pow(1 + rate, j);
	  }

	  // Return net present value
	  return value;
	};

	// TODO
	exports.ODDFPRICE = function() {
	 throw new Error('ODDFPRICE is not implemented');
	};

	// TODO
	exports.ODDFYIELD = function() {
	 throw new Error('ODDFYIELD is not implemented');
	};

	// TODO
	exports.ODDLPRICE = function() {
	 throw new Error('ODDLPRICE is not implemented');
	};

	// TODO
	exports.ODDLYIELD = function() {
	 throw new Error('ODDLYIELD is not implemented');
	};

	exports.PDURATION = function(rate, present, future) {
	  rate = utils.parseNumber(rate);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  if (utils.anyIsError(rate, present, future)) {
	    return error.value;
	  }

	  // Return error if rate <=0
	  if (rate <= 0) {
	    return error.num;
	  }

	  // Return number of periods
	  return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
	};

	exports.PMT = function(rate, periods, present, future, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, present, future, type)) {
	    return error.value;
	  }

	  // Return payment
	  var result;
	  if (rate === 0) {
	    result = (present + future) / periods;
	  } else {
	    var term = Math.pow(1 + rate, periods);
	    if (type === 1) {
	      result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
	    } else {
	      result = future * rate / (term - 1) + present * rate / (1 - 1 / term);
	    }
	  }
	  return -result;
	};

	exports.PPMT = function(rate, period, periods, present, future, type) {
	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, present, future, type)) {
	    return error.value;
	  }

	  return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);
	};

	// TODO
	exports.PRICE = function() {
	 throw new Error('PRICE is not implemented');
	};

	// TODO
	exports.PRICEDISC = function() {
	 throw new Error('PRICEDISC is not implemented');
	};

	// TODO
	exports.PRICEMAT = function() {
	 throw new Error('PRICEMAT is not implemented');
	};

	exports.PV = function(rate, periods, payment, future, type) {
	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, payment, future, type)) {
	    return error.value;
	  }

	  // Return present value
	  if (rate === 0) {
	    return -payment * periods - future;
	  } else {
	    return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
	  }
	};

	exports.RATE = function(periods, payment, present, future, type, guess) {
	  // Credits: rabugento

	  guess = (guess === undefined) ? 0.01 : guess;
	  future = (future === undefined) ? 0 : future;
	  type = (type === undefined) ? 0 : type;

	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(periods, payment, present, future, type, guess)) {
	    return error.value;
	  }

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-6;

	  // Set maximum number of iterations
	  var iterMax = 100;
	  var iter = 0;
	  var close = false;
	  var rate = guess;

	  while (iter < iterMax && !close) {
	    var t1 = Math.pow(rate + 1, periods);
	    var t2 = Math.pow(rate + 1, periods - 1);

	    var f1 = future + t1 * present + payment * (t1 - 1) * (rate * type + 1) / rate;
	    var f2 = periods * t2 * present - payment * (t1 - 1) *(rate * type + 1) / Math.pow(rate,2);
	    var f3 = periods * payment * t2 * (rate * type + 1) / rate + payment * (t1 - 1) * type / rate;

	    var newRate = rate - f1 / (f2 + f3);

	    if (Math.abs(newRate - rate) < epsMax) close = true;
	    iter++
	    rate = newRate;
	  }

	  if (!close) return Number.NaN + rate;
	  return rate;
	};

	// TODO
	exports.RECEIVED = function() {
	 throw new Error('RECEIVED is not implemented');
	};

	exports.RRI = function(periods, present, future) {
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  if (utils.anyIsError(periods, present, future)) {
	    return error.value;
	  }

	  // Return error if periods or present is equal to 0 (zero)
	  if (periods === 0 || present === 0) {
	    return error.num;
	  }

	  // Return equivalent interest rate
	  return Math.pow(future / present, 1 / periods) - 1;
	};

	exports.SLN = function(cost, salvage, life) {
	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  if (utils.anyIsError(cost, salvage, life)) {
	    return error.value;
	  }

	  // Return error if life equal to 0 (zero)
	  if (life === 0) {
	    return error.num;
	  }

	  // Return straight-line depreciation
	  return (cost - salvage) / life;
	};

	exports.SYD = function(cost, salvage, life, period) {
	  // Return error if any of the parameters is not a number
	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  if (utils.anyIsError(cost, salvage, life, period)) {
	    return error.value;
	  }

	  // Return error if life equal to 0 (zero)
	  if (life === 0) {
	    return error.num;
	  }

	  // Return error if period is lower than 1 or greater than life
	  if (period < 1 || period > life) {
	    return error.num;
	  }

	  // Truncate period if it is not an integer
	  period = parseInt(period, 10);

	  // Return straight-line depreciation
	  return ((cost - salvage) * (life - period + 1) * 2) / (life * (life + 1));
	};

	exports.TBILLEQ = function(settlement, maturity, discount) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  discount = utils.parseNumber(discount);
	  if (utils.anyIsError(settlement, maturity, discount)) {
	    return error.value;
	  }

	  // Return error if discount is lower than or equal to zero
	  if (discount <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return (365 * discount) / (360 - discount * dateTime.DAYS360(settlement, maturity, false));
	};

	exports.TBILLPRICE = function(settlement, maturity, discount) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  discount = utils.parseNumber(discount);
	  if (utils.anyIsError(settlement, maturity, discount)) {
	    return error.value;
	  }

	  // Return error if discount is lower than or equal to zero
	  if (discount <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return 100 * (1 - discount * dateTime.DAYS360(settlement, maturity, false) / 360);
	};

	exports.TBILLYIELD = function(settlement, maturity, price) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  price = utils.parseNumber(price);
	  if (utils.anyIsError(settlement, maturity, price)) {
	    return error.value;
	  }

	  // Return error if price is lower than or equal to zero
	  if (price <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return (100 - price) * 360 / (price * dateTime.DAYS360(settlement, maturity, false));
	};

	// TODO
	exports.VDB = function() {
	 throw new Error('VDB is not implemented');
	};


	exports.XIRR = function(values, dates, guess) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  values = utils.parseNumberArray(utils.flatten(values));
	  dates = utils.parseDateArray(utils.flatten(dates));
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(values, dates, guess)) {
	    return error.value;
	  }

	  // Calculates the resulting amount
	  var irrResult = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = values[0];
	    for (var i = 1; i < values.length; i++) {
	      result += values[i] / Math.pow(r, dateTime.DAYS(dates[i], dates[0]) / 365);
	    }
	    return result;
	  };

	  // Calculates the first derivation
	  var irrResultDeriv = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = 0;
	    for (var i = 1; i < values.length; i++) {
	      var frac = dateTime.DAYS(dates[i], dates[0]) / 365;
	      result -= frac * values[i] / Math.pow(r, frac + 1);
	    }
	    return result;
	  };

	  // Check that values contains at least one positive value and one negative value
	  var positive = false;
	  var negative = false;
	  for (var i = 0; i < values.length; i++) {
	    if (values[i] > 0) {
	      positive = true;
	    }
	    if (values[i] < 0) {
	      negative = true;
	    }
	  }

	  // Return error if values does not contain at least one positive value and one negative value
	  if (!positive || !negative) {
	    return error.num;
	  }

	  // Initialize guess and resultRate
	  guess = guess || 0.1;
	  var resultRate = guess;

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-10;

	  // Implement Newton's method
	  var newRate, epsRate, resultValue;
	  var contLoop = true;
	  do {
	    resultValue = irrResult(values, dates, resultRate);
	    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
	    epsRate = Math.abs(newRate - resultRate);
	    resultRate = newRate;
	    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
	  } while (contLoop);

	  // Return internal rate of return
	  return resultRate;
	};

	exports.XNPV = function(rate, values, dates) {
	  rate = utils.parseNumber(rate);
	  values = utils.parseNumberArray(utils.flatten(values));
	  dates = utils.parseDateArray(utils.flatten(dates));
	  if (utils.anyIsError(rate, values, dates)) {
	    return error.value;
	  }

	  var result = 0;
	  for (var i = 0; i < values.length; i++) {
	    result += values[i] / Math.pow(1 + rate, dateTime.DAYS(dates[i], dates[0]) / 365);
	  }
	  return result;
	};

	// TODO
	exports.YIELD = function() {
	 throw new Error('YIELD is not implemented');
	};

	// TODO
	exports.YIELDDISC = function() {
	 throw new Error('YIELDDISC is not implemented');
	};

	// TODO
	exports.YIELDMAT = function() {
	 throw new Error('YIELDMAT is not implemented');
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	exports.MATCH = function(lookupValue, lookupArray, matchType) {
	  if (!lookupValue && !lookupArray) {
	    return error.na;
	  }

	  if (arguments.length === 2) {
	    matchType = 1;
	  }
	  if (!(lookupArray instanceof Array)) {
	    return error.na;
	  }

	  if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
	    return error.na;
	  }
	  var index;
	  var indexValue;
	  for (var idx = 0; idx < lookupArray.length; idx++) {
	    if (matchType === 1) {
	      if (lookupArray[idx] === lookupValue) {
	        return idx + 1;
	      } else if (lookupArray[idx] < lookupValue) {
	        if (!indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        } else if (lookupArray[idx] > indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        }
	      }
	    } else if (matchType === 0) {
	      if (typeof lookupValue === 'string') {
	        lookupValue = lookupValue.replace(/\?/g, '.');
	        if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
	          return idx + 1;
	        }
	      } else {
	        if (lookupArray[idx] === lookupValue) {
	          return idx + 1;
	        }
	      }
	    } else if (matchType === -1) {
	      if (lookupArray[idx] === lookupValue) {
	        return idx + 1;
	      } else if (lookupArray[idx] > lookupValue) {
	        if (!indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        } else if (lookupArray[idx] < indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        }
	      }
	    }
	  }

	  return index ? index : error.na;
	};

/***/ }
/******/ ])
});
;
},{"jStat":2,"numeral":3,"numeric":4}],2:[function(require,module,exports){
this.j$ = this.jStat = (function(Math, undefined) {

// For quick reference.
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

// Calculate correction for IEEE error
// TODO: This calculation can be improved.
function calcRdx(n, m) {
  var val = n > m ? n : m;
  return Math.pow(10,
                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));
}


var isArray = Array.isArray || function isArray(arg) {
  return toString.call(arg) === '[object Array]';
};


function isFunction(arg) {
  return toString.call(arg) === '[object Function]';
}


function isNumber(arg) {
  return typeof arg === 'number' && arg === arg;
}


// Converts the jStat matrix to vector.
function toVector(arr) {
  return concat.apply([], arr);
}


// The one and only jStat constructor.
function jStat() {
  return new jStat._init(arguments);
}


// TODO: Remove after all references in src files have been removed.
jStat.fn = jStat.prototype;


// By separating the initializer from the constructor it's easier to handle
// always returning a new instance whether "new" was used or not.
jStat._init = function _init(args) {
  var i;

  // If first argument is an array, must be vector or matrix.
  if (isArray(args[0])) {
    // Check if matrix.
    if (isArray(args[0][0])) {
      // See if a mapping function was also passed.
      if (isFunction(args[1]))
        args[0] = jStat.map(args[0], args[1]);
      // Iterate over each is faster than this.push.apply(this, args[0].
      for (i = 0; i < args[0].length; i++)
        this[i] = args[0][i];
      this.length = args[0].length;

    // Otherwise must be a vector.
    } else {
      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];
      this.length = 1;
    }

  // If first argument is number, assume creation of sequence.
  } else if (isNumber(args[0])) {
    this[0] = jStat.seq.apply(null, args);
    this.length = 1;

  // Handle case when jStat object is passed to jStat.
  } else if (args[0] instanceof jStat) {
    // Duplicate the object and pass it back.
    return jStat(args[0].toArray());

  // Unexpected argument value, return empty jStat object.
  // TODO: This is strange behavior. Shouldn't this throw or some such to let
  // the user know they had bad arguments?
  } else {
    this[0] = [];
    this.length = 1;
  }

  return this;
};
jStat._init.prototype = jStat.prototype;
jStat._init.constructor = jStat;


// Utility functions.
// TODO: for internal use only?
jStat.utils = {
  calcRdx: calcRdx,
  isArray: isArray,
  isFunction: isFunction,
  isNumber: isNumber,
  toVector: toVector
};


// Easily extend the jStat object.
// TODO: is this seriously necessary?
jStat.extend = function extend(obj) {
  var i, j;

  if (arguments.length === 1) {
    for (j in obj)
      jStat[j] = obj[j];
    return this;
  }

  for (i = 1; i < arguments.length; i++) {
    for (j in arguments[i])
      obj[j] = arguments[i][j];
  }

  return obj;
};


// Returns the number of rows in the matrix.
jStat.rows = function rows(arr) {
  return arr.length || 1;
};


// Returns the number of columns in the matrix.
jStat.cols = function cols(arr) {
  return arr[0].length || 1;
};


// Returns the dimensions of the object { rows: i, cols: j }
jStat.dimensions = function dimensions(arr) {
  return {
    rows: jStat.rows(arr),
    cols: jStat.cols(arr)
  };
};


// Returns a specified row as a vector
jStat.row = function row(arr, index) {
  return arr[index];
};


// Returns the specified column as a vector
jStat.col = function cols(arr, index) {
  var column = new Array(arr.length);
  for (var i = 0; i < arr.length; i++)
    column[i] = [arr[i][index]];
  return column;
};


// Returns the diagonal of the matrix
jStat.diag = function diag(arr) {
  var nrow = jStat.rows(arr);
  var res = new Array(nrow);
  for (var row = 0; row < nrow; row++)
    res[row] = [arr[row][row]];
  return res;
};


// Returns the anti-diagonal of the matrix
jStat.antidiag = function antidiag(arr) {
  var nrow = jStat.rows(arr) - 1;
  var res = new Array(nrow);
  for (var i = 0; nrow >= 0; nrow--, i++)
    res[i] = [arr[i][nrow]];
  return res;
};

// Transpose a matrix or array.
jStat.transpose = function transpose(arr) {
  var obj = [];
  var objArr, rows, cols, j, i;

  // Make sure arr is in matrix format.
  if (!isArray(arr[0]))
    arr = [arr];

  rows = arr.length;
  cols = arr[0].length;

  for (i = 0; i < cols; i++) {
    objArr = new Array(rows);
    for (j = 0; j < rows; j++)
      objArr[j] = arr[j][i];
    obj.push(objArr);
  }

  // If obj is vector, return only single array.
  return obj.length === 1 ? obj[0] : obj;
};


// Map a function to an array or array of arrays.
// "toAlter" is an internal variable.
jStat.map = function map(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    for (col = 0; col < ncol; col++)
      res[row][col] = func(arr[row][col], row, col);
  }

  return res.length === 1 ? res[0] : res;
};


// Destructively alter an array.
jStat.alter = function alter(arr, func) {
  return jStat.map(arr, func, true);
};


// Generate a rows x cols matrix according to the supplied function.
jStat.create = function  create(rows, cols, func) {
  var res = new Array(rows);
  var i, j;

  if (isFunction(cols)) {
    func = cols;
    cols = rows;
  }

  for (i = 0; i < rows; i++) {
    res[i] = new Array(cols);
    for (j = 0; j < cols; j++)
      res[i][j] = func(i, j);
  }

  return res;
};


function retZero() { return 0; }


// Generate a rows x cols matrix of zeros.
jStat.zeros = function zeros(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retZero);
};


function retOne() { return 1; }


// Generate a rows x cols matrix of ones.
jStat.ones = function ones(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retOne);
};


// Generate a rows x cols matrix of uniformly random numbers.
jStat.rand = function rand(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, Math.random);
};


function retIdent(i, j) { return i === j ? 1 : 0; }


// Generate an identity matrix of size row x cols.
jStat.identity = function identity(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retIdent);
};


// Tests whether a matrix is symmetric
jStat.symmetric = function symmetric(arr) {
  var issymmetric = true;
  var size = arr.length;
  var row, col;

  if (arr.length !== arr[0].length)
    return false;

  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++)
      if (arr[col][row] !== arr[row][col])
        return false;
  }

  return true;
};


// Set all values to zero.
jStat.clear = function clear(arr) {
  return jStat.alter(arr, retZero);
};


// Generate sequence.
jStat.seq = function seq(min, max, length, func) {
  if (!isFunction(func))
    func = false;

  var arr = [];
  var hival = calcRdx(min, max);
  var step = (max * hival - min * hival) / ((length - 1) * hival);
  var current = min;
  var cnt;

  // Current is assigned using a technique to compensate for IEEE error.
  // TODO: Needs better implementation.
  for (cnt = 0;
       current <= max;
       cnt++, current = (min * hival + step * hival * cnt) / hival) {
    arr.push((func ? func(current, cnt) : current));
  }

  return arr;
};


// TODO: Go over this entire implementation. Seems a tragic waste of resources
// doing all this work. Instead, and while ugly, use new Function() to generate
// a custom function for each static method.

// Quick reference.
var jProto = jStat.prototype;

// Default length.
jProto.length = 0;

// For internal use only.
// TODO: Check if they're actually used, and if they are then rename them
// to _*
jProto.push = Array.prototype.push;
jProto.sort = Array.prototype.sort;
jProto.splice = Array.prototype.splice;
jProto.slice = Array.prototype.slice;


// Return a clean array.
jProto.toArray = function toArray() {
  return this.length > 1 ? slice.call(this) : slice.call(this)[0];
};


// Map a function to a matrix or vector.
jProto.map = function map(func, toAlter) {
  return jStat(jStat.map(this, func, toAlter));
};


// Destructively alter an array.
jProto.alter = function alter(func) {
  jStat.alter(this, func);
  return this;
};


// Extend prototype with methods that have no argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(func) {
      var self = this,
      results;
      // Check for callback.
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self));
        });
        return this;
      }
      results = jStat[passfunc](this);
      return isArray(results) ? jStat(results) : results;
    };
  })(funcs[i]);
})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));


// Extend prototype with methods that have one argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(index, func) {
      var self = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self, index));
        });
        return this;
      }
      return jStat(jStat[passfunc](this, index));
    };
  })(funcs[i]);
})('row col'.split(' '));


// Extend prototype with simple shortcut methods.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = new Function(
        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');
  })(funcs[i]);
})('create zeros ones rand identity'.split(' '));


// Exposing jStat.
return jStat;

}(Math));
(function(jStat, Math) {

var isFunction = jStat.utils.isFunction;

// Ascending functions for sort
function ascNum(a, b) { return a - b; }

function clip(arg, min, max) {
  return Math.max(min, Math.min(arg, max));
}


// sum of an array
jStat.sum = function sum(arr) {
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};


// sum squared
jStat.sumsqrd = function sumsqrd(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i] * arr[i];
  return sum;
};


// sum of squared errors of prediction (SSE)
jStat.sumsqerr = function sumsqerr(arr) {
  var mean = jStat.mean(arr);
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0) {
    tmp = arr[i] - mean;
    sum += tmp * tmp;
  }
  return sum;
};


// product of an array
jStat.product = function product(arr) {
  var prod = 1;
  var i = arr.length;
  while (--i >= 0)
    prod *= arr[i];
  return prod;
};


// minimum value of an array
jStat.min = function min(arr) {
  var low = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] < low)
      low = arr[i];
  return low;
};


// maximum value of an array
jStat.max = function max(arr) {
  var high = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] > high)
      high = arr[i];
  return high;
};


// mean value of an array
jStat.mean = function mean(arr) {
  return jStat.sum(arr) / arr.length;
};


// mean squared error (MSE)
jStat.meansqerr = function meansqerr(arr) {
  return jStat.sumsqerr(arr) / arr.length;
};


// geometric mean of an array
jStat.geomean = function geomean(arr) {
  return Math.pow(jStat.product(arr), 1 / arr.length);
};


// median of an array
jStat.median = function median(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  // check if array is even or odd, then return the appropriate
  return !(arrlen & 1)
    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2
    : _arr[(arrlen / 2) | 0 ];
};


// cumulative sum of an array
jStat.cumsum = function cumsum(arr) {
  var len = arr.length;
  var sums = new Array(len);
  var i;
  sums[0] = arr[0];
  for (i = 1; i < len; i++)
    sums[i] = sums[i - 1] + arr[i];
  return sums;
};


// successive differences of a sequence
jStat.diff = function diff(arr) {
  var diffs = [];
  var arrLen = arr.length;
  var i;
  for (i = 1; i < arrLen; i++)
    diffs.push(arr[i] - arr[i - 1]);
  return diffs;
};


// mode of an array
// if there are multiple modes of an array, return all of them
// is this the appropriate way of handling it?
jStat.mode = function mode(arr) {
  var arrLen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  var count = 1;
  var maxCount = 0;
  var numMaxCount = 0;
  var mode_arr = [];
  var i;

  for (i = 0; i < arrLen; i++) {
    if (_arr[i] === _arr[i + 1]) {
      count++;
    } else {
      if (count > maxCount) {
        mode_arr = [_arr[i]];
        maxCount = count;
        numMaxCount = 0;
      }
      // are there multiple max counts
      else if (count === maxCount) {
        mode_arr.push(_arr[i]);
        numMaxCount++;
      }
      // resetting count for new value in array
      count = 1;
    }
  }

  return numMaxCount === 0 ? mode_arr[0] : mode_arr;
};


// range of an array
jStat.range = function range(arr) {
  return jStat.max(arr) - jStat.min(arr);
};

// variance of an array
// flag indicates population vs sample
jStat.variance = function variance(arr, flag) {
  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
};


// standard deviation of an array
// flag indicates population vs sample
jStat.stdev = function stdev(arr, flag) {
  return Math.sqrt(jStat.variance(arr, flag));
};


// mean deviation (mean absolute deviation) of an array
jStat.meandev = function meandev(arr) {
  var devSum = 0;
  var mean = jStat.mean(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - mean);
  return devSum / arr.length;
};


// median deviation (median absolute deviation) of an array
jStat.meddev = function meddev(arr) {
  var devSum = 0;
  var median = jStat.median(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - median);
  return devSum / arr.length;
};


// coefficient of variation
jStat.coeffvar = function coeffvar(arr) {
  return jStat.stdev(arr) / jStat.mean(arr);
};


// quartiles of an array
jStat.quartiles = function quartiles(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  return [
    _arr[ Math.round((arrlen) / 4) - 1 ],
    _arr[ Math.round((arrlen) / 2) - 1 ],
    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]
  ];
};


// Arbitary quantiles of an array. Direct port of the scipy.stats
// implementation by Pierre GF Gerard-Marchant.
jStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
  var sortedArray = arr.slice().sort(ascNum);
  var quantileVals = [quantilesArray.length];
  var n = arr.length;
  var i, p, m, aleph, k, gamma;

  if (typeof alphap === 'undefined')
    alphap = 3 / 8;
  if (typeof betap === 'undefined')
    betap = 3 / 8;

  for (i = 0; i < quantilesArray.length; i++) {
    p = quantilesArray[i];
    m = alphap + p * (1 - alphap - betap);
    aleph = n * p + m;
    k = Math.floor(clip(aleph, 1, n - 1));
    gamma = clip(aleph - k, 0, 1);
    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
  }

  return quantileVals;
};

// The percentile rank of score in a given array. Returns the percentage
// of all values in the input array that are less than (kind='strict') or
// less or equal than (kind='weak') score. Default is weak.
jStat.percentileOfScore = function percentileOfScore(arr, score, kind) {
  var counter = 0;
  var len = arr.length;
  var strict = false;
  var value, i;

  if (kind === 'strict')
    strict = true;

  for (i = 0; i < len; i++) {
    value = arr[i];
    if ((strict && value < score) ||
        (!strict && value <= score)) {
      counter++;
    }
  }

  return counter / len;
};

// covariance of two arrays
jStat.covariance = function covariance(arr1, arr2) {
  var u = jStat.mean(arr1);
  var v = jStat.mean(arr2);
  var arr1Len = arr1.length;
  var sq_dev = new Array(arr1Len);
  var i;

  for (i = 0; i < arr1Len; i++)
    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);

  return jStat.sum(sq_dev) / (arr1Len - 1);
};


// (pearson's) population correlation coefficient, rho
jStat.corrcoeff = function corrcoeff(arr1, arr2) {
  return jStat.covariance(arr1, arr2) /
      jStat.stdev(arr1, 1) /
      jStat.stdev(arr2, 1);
};


var jProto = jStat.prototype;


// Extend jProto with method for calculating cumulative sums, as it does not
// run again in case of true.
// If a matrix is passed, automatically assume operation should be done on the
// columns.
jProto.cumsum = function(fullbool, func) {
  var arr = [];
  var i = 0;
  var tmpthis = this;

  // Assignment reassignation depending on how parameters were passed in.
  if (isFunction(fullbool)) {
    func = fullbool;
    fullbool = false;
  }

  // Check if a callback was passed with the function.
  if (func) {
    setTimeout(function() {
      func.call(tmpthis, jProto.cumsum.call(tmpthis, fullbool));
    });
    return this;
  }

  // Check if matrix and run calculations.
  if (this.length > 1) {
    tmpthis = fullbool === true ? this : this.transpose();
    for (; i < tmpthis.length; i++)
      arr[i] = jStat.cumsum(tmpthis[i]);
    return arr;
  }

  return jStat.cumsum(this[0], fullbool);
};


// Extend jProto with methods which don't require arguments and work on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return fullbool === true
            ? jStat[passfunc](jStat.utils.toVector(arr))
            : arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('sum sumsqrd sumsqerr product min max mean meansqerr geomean median diff ' +
    'mode range variance stdev meandev meddev coeffvar quartiles').split(' '));


// Extend jProto with functions that take arguments. Operations on matrices are
// done on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function() {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      var args = Array.prototype.slice.call(arguments);

      // If the last argument is a function, we assume it's a callback; we
      // strip the callback out and call the function again.
      if (isFunction(args[args.length - 1])) {
        var callbackFunction = args[args.length - 1];
        var argsToPass = args.slice(0, args.length - 1);

        setTimeout(function() {
          callbackFunction.call(tmpthis,
                                jProto[passfunc].apply(tmpthis, argsToPass));
        });
        return this;

      // Otherwise we curry the function args and call normally.
      } else {
        var callbackFunction = undefined;
        var curriedFunction = function curriedFunction(vector) {
          return jStat[passfunc].apply(tmpthis, [vector].concat(args));
        }
      }

      // If this is a matrix, run column-by-column.
      if (this.length > 1) {
        tmpthis = tmpthis.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = curriedFunction(tmpthis[i]);
        return arr;
      }

      // Otherwise run on the vector.
      return curriedFunction(this[0]);
    };
  })(funcs[i]);
})('quantiles percentileOfScore'.split(' '));

}(this.jStat, Math));
// Special functions //
(function(jStat, Math) {

// Log-gamma function
jStat.gammaln = function gammaln(x) {
  var j = 0;
  var cof = [
    76.18009172947146, -86.50532032941677, 24.01409824083091,
    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
  ];
  var ser = 1.000000000190015;
  var xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++)
    ser += cof[j] / ++y;
  return Math.log(2.5066282746310005 * ser / xx) - tmp;
};


// gamma of x
jStat.gammafn = function gammafn(x) {
  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,
           629.3311553128184, 866.9662027904133, -31451.272968848367,
           -36144.413418691176, 66456.14382024054
  ];
  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,
           -3107.771671572311, 22538.118420980151, 4755.8462775278811,
           -134659.9598649693, -115132.2596755535];
  var fact = false;
  var n = 0;
  var xden = 0;
  var xnum = 0;
  var y = x;
  var i, z, yi, res, sum, ysq;
  if (y <= 0) {
    res = y % 1 + 3.6e-16;
    if (res) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  yi = y;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  for (i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
};


// lower incomplete gamma function P(a,x)
jStat.gammap = function gammap(a, x) {
  var aln = jStat.gammaln(a);
  var ap = a;
  var sum = 1 / a;
  var del = sum;
  var b = x + 1 - a;
  var c = 1 / 1.0e-30;
  var d = 1 / b;
  var h = d;
  var i = 1;
  // calculate maximum number of itterations required for a
  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  var an, endval;

  if (x < 0 || a <= 0) {
    return NaN;
  } else if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      sum += del *= x / ++ap;
    }
    return sum * Math.exp(-x + a * Math.log(x) - (aln));
  }

  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= d * c;
  }

  return 1 - h * Math.exp(-x + a * Math.log(x) - (aln));
};


// natural log factorial of n
jStat.factorialln = function factorialln(n) {
  return n < 0 ? NaN : jStat.gammaln(n + 1);
};

// factorial of n
jStat.factorial = function factorial(n) {
  return n < 0 ? NaN : jStat.gammafn(n + 1);
};

// combinations of n, m
jStat.combination = function combination(n, m) {
  // make sure n or m don't exceed the upper limit of usable values
  return (n > 170 || m > 170)
      ? Math.exp(jStat.combinationln(n, m))
      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);
};


jStat.combinationln = function combinationln(n, m){
  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);
};


// permutations of n, m
jStat.permutation = function permutation(n, m) {
  return jStat.factorial(n) / jStat.factorial(n - m);
};


// beta function
jStat.betafn = function betafn(x, y) {
  // ensure arguments are positive
  if (x <= 0 || y <= 0)
    return undefined;
  // make sure x + y doesn't exceed the upper limit of usable values
  return (x + y > 170)
      ? Math.exp(jStat.betaln(x, y))
      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);
};


// natural logarithm of beta function
jStat.betaln = function betaln(x, y) {
  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);
};


// Evaluates the continued fraction for incomplete beta function by modified
// Lentz's method.
jStat.betacf = function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;

  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h = d;

  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7)
      break;
  }

  return h;
};


// Returns the inverse incomplte gamma function
jStat.gammapinv = function gammapinv(p, a) {
  var j = 0;
  var a1 = a - 1;
  var EPS = 1e-8;
  var gln = jStat.gammaln(a);
  var x, err, t, u, pp, lna1, afac;

  if (p >= 1)
    return Math.max(100, a + 100 * Math.sqrt(a));
  if (p <= 0)
    return 0;
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    x = Math.max(1e-3,
                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t)
      x = Math.pow(p / t, 1 / a);
    else
      x = 1 - Math.log(1 - (p - t) / (1 - t));
  }

  for(; j < 12; j++) {
    if (x <= 0)
      return 0;
    err = jStat.gammap(a, x) - p;
    if (a > 1)
      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    else
      t = Math.exp(-x + a1 * Math.log(x) - gln);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (Math.abs(t) < EPS * x)
      break;
  }

  return x;
};


// Returns the error function erf(x)
jStat.erf = function erf(x) {
  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,
             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,
             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,
             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,
             -6.886027e-12, 8.94487e-13, 3.13092e-13,
             -1.12708e-13, 3.81e-16, 7.106e-15,
             -1.523e-15, -9.4e-17, 1.21e-16,
             -2.8e-17];
  var j = cof.length - 1;
  var isneg = false;
  var d = 0;
  var dd = 0;
  var t, ty, tmp, res;

  if (x < 0) {
    x = -x;
    isneg = true;
  }

  t = 2 / (2 + x);
  ty = 4 * t - 2;

  for(; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }

  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
  return isneg ? res - 1 : 1 - res;
};


// Returns the complmentary error function erfc(x)
jStat.erfc = function erfc(x) {
  return 1 - jStat.erf(x);
};


// Returns the inverse of the complementary error function
jStat.erfcinv = function erfcinv(p) {
  var j = 0;
  var x, err, t, pp;
  if (p >= 2)
    return -100;
  if (p <= 0)
    return 100;
  pp = (p < 1) ? p : 2 - p;
  t = Math.sqrt(-2 * Math.log(pp / 2));
  x = -0.70711 * ((2.30753 + t * 0.27061) /
                  (1 + t * (0.99229 + t * 0.04481)) - t);
  for (; j < 2; j++) {
    err = jStat.erfc(x) - pp;
    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
  }
  return (p < 1) ? x : -x;
};


// Returns the inverse of the incomplete beta function
jStat.ibetainv = function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0)
    return 0;
  if (p >= 1)
    return 1;
  if (a >= 1 && b >= 1) {
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));
    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *
        (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w)
      x = Math.pow(a * w * p, 1 / a);
    else
      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
  }
  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);
  for(; j < 10; j++) {
    if (x === 0 || x === 1)
      return x;
    err = jStat.ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (x >= 1)
      x = 0.5 * (x + t + 1);
    if (Math.abs(t) < EPS * x && j > 0)
      break;
  }
  return x;
};


// Returns the incomplete beta function I_x(a,b)
jStat.ibeta = function ibeta(x, a, b) {
  // Factors in front of the continued fraction.
  var bt = (x === 0 || x === 1) ?  0 :
    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -
             jStat.gammaln(b) + a * Math.log(x) + b *
             Math.log(1 - x));
  if (x < 0 || x > 1)
    return false;
  if (x < (a + 1) / (a + b + 2))
    // Use continued fraction directly.
    return bt * jStat.betacf(x, a, b) / a;
  // else use continued fraction after making the symmetry transformation.
  return 1 - bt * jStat.betacf(1 - x, b, a) / b;
};


// Returns a normal deviate (mu=0, sigma=1).
// If n and m are specified it returns a object of normal deviates.
jStat.randn = function randn(n, m) {
  var u, v, x, y, q, mat;
  if (!m)
    m = n;
  if (n)
    return jStat.create(n, m, function() { return jStat.randn(); });
  do {
    u = Math.random();
    v = 1.7156 * (Math.random() - 0.5);
    x = u - 0.449871;
    y = Math.abs(v) + 0.386595;
    q = x * x + y * (0.19600 * y - 0.25472 * x);
  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));
  return v / u;
};


// Returns a gamma deviate by the method of Marsaglia and Tsang.
jStat.randg = function randg(shape, n, m) {
  var oalph = shape;
  var a1, a2, u, v, x, mat;
  if (!m)
    m = n;
  if (!shape)
    shape = 1;
  if (n) {
    mat = jStat.zeros(n,m);
    mat.alter(function() { return jStat.randg(shape); });
    return mat;
  }
  if (shape < 1)
    shape += 1;
  a1 = shape - 1 / 3;
  a2 = 1 / Math.sqrt(9 * a1);
  do {
    do {
      x = jStat.randn();
      v = 1 + a2 * x;
    } while(v <= 0);
    v = v * v * v;
    u = Math.random();
  } while(u > 1 - 0.331 * Math.pow(x, 4) &&
          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));
  // alpha > 1
  if (shape == oalph)
    return a1 * v;
  // alpha < 1
  do {
    u = Math.random();
  } while(u === 0);
  return Math.pow(u, 1 / oalph) * a1 * v;
};


// making use of static methods on the instance
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(
          jStat.map(this, function(value) { return jStat[passfunc](value); }));
    }
  })(funcs[i]);
})('gammaln gammafn factorial factorialln'.split(' '));


(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(jStat[passfunc].apply(null, arguments));
    };
  })(funcs[i]);
})('randn'.split(' '));

}(this.jStat, Math));
(function(jStat, Math) {

// generate all distribution instance methods
(function(list) {
  for (var i = 0; i < list.length; i++) (function(func) {
    // distribution instance method
    jStat[func] = function(a, b, c) {
      if (!(this instanceof arguments.callee))
        return new arguments.callee(a, b, c);
      this._a = a;
      this._b = b;
      this._c = c;
      return this;
    };
    // distribution method to be used on a jStat instance
    jStat.fn[func] = function(a, b, c) {
      var newthis = jStat[func](a, b, c);
      newthis.data = this;
      return newthis;
    };
    // sample instance method
    jStat[func].prototype.sample = function(arr) {
      var a = this._a;
      var b = this._b;
      var c = this._c;
      if (arr)
        return jStat.alter(arr, function() {
          return jStat[func].sample(a, b, c);
        });
      else
        return jStat[func].sample(a, b, c);
    };
    // generate the pdf, cdf and inv instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function(x) {
          var a = this._a;
          var b = this._b;
          var c = this._c;
          if (!x && x !== 0)
            x = this.data;
          if (typeof x !== 'number') {
            return jStat.fn.map.call(x, function(x) {
              return jStat[func][fnfunc](x, a, b, c);
            });
          }
          return jStat[func][fnfunc](x, a, b, c);
        };
      })(vals[i]);
    })('pdf cdf inv'.split(' '));
    // generate the mean, median, mode and variance instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function() {
          return jStat[func][fnfunc](this._a, this._b, this._c);
        };
      })(vals[i]);
    })('mean median mode variance'.split(' '));
  })(list[i]);
})((
  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +
  'lognormal normal pareto studentt weibull uniform  binomial negbin hypgeom ' +
  'poisson triangular'
).split(' '));



// extend beta function with static methods
jStat.extend(jStat.beta, {
  pdf: function pdf(x, alpha, beta) {
    // PDF is zero outside the support
    if (x > 1 || x < 0)
      return 0;
    // PDF is one for the uniform case
    if (alpha == 1 && beta == 1)
      return 1;

    if (alpha < 512 || beta < 512) {
      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /
          jStat.betafn(alpha, beta);
    } else {
      return Math.exp((alpha - 1) * Math.log(x) +
                      (beta - 1) * Math.log(1 - x) -
                      jStat.betaln(alpha, beta));
    }
  },

  cdf: function cdf(x, alpha, beta) {
    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);
  },

  inv: function inv(x, alpha, beta) {
    return jStat.ibetainv(x, alpha, beta);
  },

  mean: function mean(alpha, beta) {
    return alpha / (alpha + beta);
  },

  median: function median(alpha, beta) {
    throw new Error('median not yet implemented');
  },

  mode: function mode(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  },

  // return a random sample
  sample: function sample(alpha, beta) {
    var u = jStat.randg(alpha);
    return u / (u + jStat.randg(beta));
  },

  variance: function variance(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  }
});

// extend F function with static methods
jStat.extend(jStat.centralF, {
  pdf: function pdf(x, df1, df2) {
    if (x < 0)
      return undefined;
    return Math.sqrt((Math.pow(df1 * x, df1) * Math.pow(df2, df2)) /
                     (Math.pow(df1 * x + df2, df1 + df2))) /
                     (x * jStat.betafn(df1/2, df2/2));

  },

  cdf: function cdf(x, df1, df2) {
    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);
  },

  inv: function inv(x, df1, df2) {
    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));
  },

  mean: function mean(df1, df2) {
    return (df2 > 2) ? df2 / (df2 - 2) : undefined;
  },

  mode: function mode(df1, df2) {
    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;
  },

  // return a random sample
  sample: function sample(df1, df2) {
    var x1 = jStat.randg(df1 / 2) * 2;
    var x2 = jStat.randg(df2 / 2) * 2;
    return (x1 / df1) / (x2 / df2);
  },

  variance: function variance(df1, df2) {
    if (df2 <= 4)
      return undefined;
    return 2 * df2 * df2 * (df1 + df2 - 2) /
        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
  }
});


// extend cauchy function with static methods
jStat.extend(jStat.cauchy, {
  pdf: function pdf(x, local, scale) {
    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;
  },

  cdf: function cdf(x, local, scale) {
    return Math.atan((x - local) / scale) / Math.PI + 0.5;
  },

  inv: function(p, local, scale) {
    return local + scale * Math.tan(Math.PI * (p - 0.5));
  },

  median: function median(local, scale) {
    return local;
  },

  mode: function mode(local, scale) {
    return local;
  },

  sample: function sample(local, scale) {
    return jStat.randn() *
        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;
  }
});



// extend chisquare function with static methods
jStat.extend(jStat.chisquare, {
  pdf: function pdf(x, dof) {
    return Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *
                    Math.log(2) - jStat.gammaln(dof / 2));
  },

  cdf: function cdf(x, dof) {
    return jStat.gammap(dof / 2, x / 2);
  },

  inv: function(p, dof) {
    return 2 * jStat.gammapinv(p, 0.5 * dof);
  },

  mean : function(dof) {
    return dof;
  },

  // TODO: this is an approximation (is there a better way?)
  median: function median(dof) {
    return dof * Math.pow(1 - (2 / (9 * dof)), 3);
  },

  mode: function mode(dof) {
    return (dof - 2 > 0) ? dof - 2 : 0;
  },

  sample: function sample(dof) {
    return jStat.randg(dof / 2) * 2;
  },

  variance: function variance(dof) {
    return 2 * dof;
  }
});



// extend exponential function with static methods
jStat.extend(jStat.exponential, {
  pdf: function pdf(x, rate) {
    return x < 0 ? 0 : rate * Math.exp(-rate * x);
  },

  cdf: function cdf(x, rate) {
    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
  },

  inv: function(p, rate) {
    return -Math.log(1 - p) / rate;
  },

  mean : function(rate) {
    return 1 / rate;
  },

  median: function (rate) {
    return (1 / rate) * Math.log(2);
  },

  mode: function mode(rate) {
    return 0;
  },

  sample: function sample(rate) {
    return -1 / rate * Math.log(Math.random());
  },

  variance : function(rate) {
    return Math.pow(rate, -2);
  }
});



// extend gamma function with static methods
jStat.extend(jStat.gamma, {
  pdf: function pdf(x, shape, scale) {
    return Math.exp((shape - 1) * Math.log(x) - x / scale -
                    jStat.gammaln(shape) - shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    return jStat.gammap(shape, x / scale);
  },

  inv: function(p, shape, scale) {
    return jStat.gammapinv(p, shape) * scale;
  },

  mean : function(shape, scale) {
    return shape * scale;
  },

  mode: function mode(shape, scale) {
    if(shape > 1) return (shape - 1) * scale;
    return undefined;
  },

  sample: function sample(shape, scale) {
    return jStat.randg(shape) * scale;
  },

  variance: function variance(shape, scale) {
    return shape * scale * scale;
  }
});

// extend inverse gamma function with static methods
jStat.extend(jStat.invgamma, {
  pdf: function pdf(x, shape, scale) {
    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -
                    jStat.gammaln(shape) + shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    return 1 - jStat.gammap(shape, scale / x);
  },

  inv: function(p, shape, scale) {
    return scale / jStat.gammapinv(1 - p, shape);
  },

  mean : function(shape, scale) {
    return (shape > 1) ? scale / (shape - 1) : undefined;
  },

  mode: function mode(shape, scale) {
    return scale / (shape + 1);
  },

  sample: function sample(shape, scale) {
    return scale / jStat.randg(shape);
  },

  variance: function variance(shape, scale) {
    if (shape <= 2)
      return undefined;
    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
  }
});


// extend kumaraswamy function with static methods
jStat.extend(jStat.kumaraswamy, {
  pdf: function pdf(x, alpha, beta) {
    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *
                    Math.log(x) + (beta - 1) *
                    Math.log(1 - Math.pow(x, alpha)));
  },

  cdf: function cdf(x, alpha, beta) {
    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));
  },

  mean : function(alpha, beta) {
    return (beta * jStat.gammafn(1 + 1 / alpha) *
            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));
  },

  median: function median(alpha, beta) {
    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);
  },

  mode: function mode(alpha, beta) {
    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
      return undefined;
    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
  },

  variance: function variance(alpha, beta) {
    throw new Error('variance not yet implemented');
    // TODO: complete this
  }
});



// extend lognormal function with static methods
jStat.extend(jStat.lognormal, {
  pdf: function pdf(x, mu, sigma) {
    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -
                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /
                    (2 * sigma * sigma));
  },

  cdf: function cdf(x, mu, sigma) {
    return 0.5 +
        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));
  },

  inv: function(p, mu, sigma) {
    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);
  },

  mean: function mean(mu, sigma) {
    return Math.exp(mu + sigma * sigma / 2);
  },

  median: function median(mu, sigma) {
    return Math.exp(mu);
  },

  mode: function mode(mu, sigma) {
    return Math.exp(mu - sigma * sigma);
  },

  sample: function sample(mu, sigma) {
    return Math.exp(jStat.randn() * sigma + mu);
  },

  variance: function variance(mu, sigma) {
    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);
  }
});



// extend normal function with static methods
jStat.extend(jStat.normal, {
  pdf: function pdf(x, mean, std) {
    return Math.exp(-0.5 * Math.log(2 * Math.PI) -
                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
  },

  cdf: function cdf(x, mean, std) {
    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));
  },

  inv: function(p, mean, std) {
    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;
  },

  mean : function(mean, std) {
    return mean;
  },

  median: function median(mean, std) {
    return mean;
  },

  mode: function (mean, std) {
    return mean;
  },

  sample: function sample(mean, std) {
    return jStat.randn() * std + mean;
  },

  variance : function(mean, std) {
    return std * std;
  }
});



// extend pareto function with static methods
jStat.extend(jStat.pareto, {
  pdf: function pdf(x, scale, shape) {
    if (x <= scale)
      return undefined;
    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);
  },

  cdf: function cdf(x, scale, shape) {
    return 1 - Math.pow(scale / x, shape);
  },

  mean: function mean(scale, shape) {
    if (shape <= 1)
      return undefined;
    return (shape * Math.pow(scale, shape)) / (shape - 1);
  },

  median: function median(scale, shape) {
    return scale * (shape * Math.SQRT2);
  },

  mode: function mode(scale, shape) {
    return scale;
  },

  variance : function(scale, shape) {
    if (shape <= 2)
      return undefined;
    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));
  }
});



// extend studentt function with static methods
jStat.extend(jStat.studentt, {
  pdf: function pdf(x, dof) {
    return (jStat.gammafn((dof + 1) / 2) / (Math.sqrt(dof * Math.PI) *
        jStat.gammafn(dof / 2))) *
        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));
  },

  cdf: function cdf(x, dof) {
    var dof2 = dof / 2;
    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /
                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);
  },

  inv: function(p, dof) {
    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
    x = Math.sqrt(dof * (1 - x) / x);
    return (p > 0.5) ? x : -x;
  },

  mean: function mean(dof) {
    return (dof > 1) ? 0 : undefined;
  },

  median: function median(dof) {
    return 0;
  },

  mode: function mode(dof) {
    return 0;
  },

  sample: function sample(dof) {
    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));
  },

  variance: function variance(dof) {
    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;
  }
});



// extend weibull function with static methods
jStat.extend(jStat.weibull, {
  pdf: function pdf(x, scale, shape) {
    if (x < 0)
      return 0;
    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *
        Math.exp(-(Math.pow((x / scale), shape)));
  },

  cdf: function cdf(x, scale, shape) {
    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));
  },

  inv: function(p, scale, shape) {
    return scale * Math.pow(-Math.log(1 - p), 1 / shape);
  },

  mean : function(scale, shape) {
    return scale * jStat.gammafn(1 + 1 / shape);
  },

  median: function median(scale, shape) {
    return scale * Math.pow(Math.log(2), 1 / shape);
  },

  mode: function mode(scale, shape) {
    if (shape <= 1)
      return undefined;
    return scale * Math.pow((shape - 1) / shape, 1 / shape);
  },

  sample: function sample(scale, shape) {
    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);
  },

  variance: function variance(scale, shape) {
    return scale * scale * jStat.gammafn(1 + 2 / shape) -
        Math.pow(this.mean(scale, shape), 2);
  }
});



// extend uniform function with static methods
jStat.extend(jStat.uniform, {
  pdf: function pdf(x, a, b) {
    return (x < a || x > b) ? 0 : 1 / (b - a);
  },

  cdf: function cdf(x, a, b) {
    if (x < a)
      return 0;
    else if (x < b)
      return (x - a) / (b - a);
    return 1;
  },

  mean: function mean(a, b) {
    return 0.5 * (a + b);
  },

  median: function median(a, b) {
    return jStat.mean(a, b);
  },

  mode: function mode(a, b) {
    throw new Error('mode is not yet implemented');
  },

  sample: function sample(a, b) {
    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);
  },

  variance: function variance(a, b) {
    return Math.pow(b - a, 2) / 12;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.binomial, {
  pdf: function pdf(k, n, p) {
    return (p === 0 || p === 1) ?
      ((n * p) === k ? 1 : 0) :
      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  },

  cdf: function cdf(x, n, p) {
    var binomarr = [],
    k = 0;
    if (x < 0) {
      return 0;
    }
    if (x < n) {
      for (; k <= x; k++) {
        binomarr[ k ] = jStat.binomial.pdf(k, n, p);
      }
      return jStat.sum(binomarr);
    }
    return 1;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.negbin, {
  pdf: function pdf(k, r, p) {
    return k !== k | 0
      ? false
      : k < 0
        ? 0
        : jStat.combination(k + r - 1, r - 1) * Math.pow(1 - p, k) * Math.pow(p, r);
  },

  cdf: function cdf(x, r, p) {
    var sum = 0,
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sum += jStat.negbin.pdf(k, r, p);
    }
    return sum;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.hypgeom, {
  pdf: function pdf(k, N, m, n) {
    // Hypergeometric PDF.

    // A simplification of the CDF algorithm below.

    // k = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(k !== k | 0) {
      return false;
    } else if(k < 0 || k < m - (N - n)) {
      // It's impossible to have this few successes drawn.
      return 0;
    } else if(k > n || k > m) {
      // It's impossible to have this many successes drawn.
      return 0;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return jStat.hypgeom.pdf(n - k, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return jStat.hypgeom.pdf(m - k, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.pdf(k, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate product to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < k; i++) {
        // For every possible number of successes up to that observed...

        while(scaledPDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          scaledPDF *= 1 - (m / (N - samplesDone));

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledPDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledPDF));
    }
  },

  cdf: function cdf(x, N, m, n) {
    // Hypergeometric CDF.

    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
    // and comes from his hypergeometric test calculator at
    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.

    // x = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(x < 0 || x < m - (N - n)) {
      // It's impossible to have this few successes drawn or fewer.
      return 0;
    } else if(x >= n || x >= m) {
      // We will always have this many successes or fewer.
      return 1;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.cdf(x, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate sum to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // Holds the intermediate, scaled total CDF.
      var scaledCDF = 1;

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < x; i++) {
        // For every possible number of successes up to that observed...

        while(scaledCDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          var factor = 1 - (m / (N - samplesDone));

          scaledPDF *= factor;
          scaledCDF *= factor;

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));

        // Add to the CDF answer.
        scaledCDF += scaledPDF;
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledCDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledCDF));
    }
  }
});



// extend uniform function with static methods
jStat.extend(jStat.poisson, {
  pdf: function pdf(k, l) {
    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);
  },

  cdf: function cdf(x, l) {
    var sumarr = [],
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sumarr.push(jStat.poisson.pdf(k, l));
    }
    return jStat.sum(sumarr);
  },

  mean : function(l) {
    return l;
  },

  variance : function(l) {
    return l;
  },

  sample: function sample(l) {
    var p = 1, k = 0, L = Math.exp(-l);
    do {
      k++;
      p *= Math.random();
    } while (p > L);
    return k - 1;
  }
});

// extend triangular function with static methods
jStat.extend(jStat.triangular, {
  pdf: function pdf(x, a, b, c) {
    return (b <= a || c < a || c > b)
      ? undefined
      : (x < a || x > b)
        ? 0
        : (x <= c)
          ? (2 * (x - a)) / ((b - a) * (c - a))
          : (2 * (b - x)) / ((b - a) * (b - c));
  },

  cdf: function cdf(x, a, b, c) {
    if (b <= a || c < a || c > b)
      return undefined;
    if (x < a) {
      return 0;
    } else {
      if (x <= c)
        return Math.pow(x - a, 2) / ((b - a) * (c - a));
      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));
    }
    // never reach this
    return 1;
  },

  mean: function mean(a, b, c) {
    return (a + b + c) / 3;
  },

  median: function median(a, b, c) {
    if (c <= (a + b) / 2) {
      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);
    } else if (c > (a + b) / 2) {
      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);
    }
  },

  mode: function mode(a, b, c) {
    return c;
  },

  sample: function sample(a, b, c) {
    var u = Math.random();
    if (u < ((c - a) / (b - a)))
      return a + Math.sqrt(u * (b - a) * (c - a))
    return b - Math.sqrt((1 - u) * (b - a) * (b - c));
  },

  variance: function variance(a, b, c) {
    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
  }
});

}(this.jStat, Math));
/* Provides functions for the solution of linear system of equations, integration, extrapolation,
 * interpolation, eigenvalue problems, differential equations and PCA analysis. */

(function(jStat, Math) {

var push = Array.prototype.push;
var isArray = jStat.utils.isArray;

jStat.extend({

  // add a vector/matrix to a vector/matrix or scalar
  add: function add(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value + arg[row][col];
      });
    }
    return jStat.map(arr, function(value) { return value + arg; });
  },

  // subtract a vector or scalar from the vector
  subtract: function subtract(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value - arg[row][col] || 0;
      });
    }
    return jStat.map(arr, function(value) { return value - arg; });
  },

  // matrix division
  divide: function divide(arr, arg) {
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.multiply(arr, jStat.inv(arg));
    }
    return jStat.map(arr, function(value) { return value / arg; });
  },

  // matrix multiplication
  multiply: function multiply(arr, arg) {
    var row, col, nrescols, sum,
    nrow = arr.length,
    ncol = arr[0].length,
    res = jStat.zeros(nrow, nrescols = (isArray(arg)) ? arg[0].length : ncol),
    rescols = 0;
    if (isArray(arg)) {
      for (; rescols < nrescols; rescols++) {
        for (row = 0; row < nrow; row++) {
          sum = 0;
          for (col = 0; col < ncol; col++)
          sum += arr[row][col] * arg[col][rescols];
          res[row][rescols] = sum;
        }
      }
      return (nrow === 1 && rescols === 1) ? res[0][0] : res;
    }
    return jStat.map(arr, function(value) { return value * arg; });
  },

  // Returns the dot product of two matricies
  dot: function dot(arr, arg) {
    if (!isArray(arr[0])) arr = [ arr ];
    if (!isArray(arg[0])) arg = [ arg ];
    // convert column to row vector
    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,
    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,
    res = [],
    row = 0,
    nrow = left.length,
    ncol = left[0].length,
    sum, col;
    for (; row < nrow; row++) {
      res[row] = [];
      sum = 0;
      for (col = 0; col < ncol; col++)
      sum += left[row][col] * right[row][col];
      res[row] = sum;
    }
    return (res.length === 1) ? res[0] : res;
  },

  // raise every element by a scalar
  pow: function pow(arr, arg) {
    return jStat.map(arr, function(value) { return Math.pow(value, arg); });
  },

  // generate the absolute values of the vector
  abs: function abs(arr) {
    return jStat.map(arr, function(value) { return Math.abs(value); });
  },

  // computes the p-norm of the vector
  // In the case that a matrix is passed, uses the first row as the vector
  norm: function norm(arr, p) {
    var nnorm = 0,
    i = 0;
    // check the p-value of the norm, and set for most common case
    if (isNaN(p)) p = 2;
    // check if multi-dimensional array, and make vector correction
    if (isArray(arr[0])) arr = arr[0];
    // vector norm
    for (; i < arr.length; i++) {
      nnorm += Math.pow(Math.abs(arr[i]), p);
    }
    return Math.pow(nnorm, 1 / p);
  },

  // TODO: make compatible with matrices
  // computes the angle between two vectors in rads
  angle: function angle(arr, arg) {
    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));
  },

  // augment one matrix by another
  aug: function aug(a, b) {
    var newarr = a.slice(),
    i = 0;
    for (; i < newarr.length; i++) {
      push.apply(newarr[i], b[i]);
    }
    return newarr;
  },

  inv: function inv(a) {
    var rows = a.length,
    cols = a[0].length,
    b = jStat.identity(rows, cols),
    c = jStat.gauss_jordan(a, b),
    obj = [],
    i = 0,
    j;
    for (; i < rows; i++) {
      obj[i] = [];
      for (j = cols - 1; j < c[0].length; j++)
      obj[i][j - cols] = c[i][j];
    }
    return obj;
  },

  // calculate the determinant of a matrix
  det: function det(a) {
    var alen = a.length,
    alend = alen * 2,
    vals = new Array(alend),
    rowshift = alen - 1,
    colshift = alend - 1,
    mrow = rowshift - alen + 1,
    mcol = colshift,
    i = 0,
    result = 0,
    j;
    // check for special 2x2 case
    if (alen === 2) {
      return a[0][0] * a[1][1] - a[0][1] * a[1][0];
    }
    for (; i < alend; i++) {
      vals[i] = 1;
    }
    for (i = 0; i < alen; i++) {
      for (j = 0; j < alen; j++) {
        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];
        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];
        mrow++;
        mcol--;
      }
      mrow = --rowshift - alen + 1;
      mcol = --colshift;
    }
    for (i = 0; i < alen; i++) {
      result += vals[i];
    }
    for (; i < alend; i++) {
      result -= vals[i];
    }
    return result;
  },

  gauss_elimination: function gauss_elimination(a, b) {
    var i = 0,
    j = 0,
    n = a.length,
    m = a[0].length,
    factor = 1,
    sum = 0,
    x = [],
    maug, pivot, temp, k;
    a = jStat.aug(a, b);
    maug = a[0].length;
    for(; i < n; i++) {
      pivot = a[i][i];
      j = i;
      for (k = i + 1; k < m; k++) {
        if (pivot < Math.abs(a[k][i])) {
          pivot = a[k][i];
          j = k;
        }
      }
      if (j != i) {
        for(k = 0; k < maug; k++) {
          temp = a[i][k];
          a[i][k] = a[j][k];
          a[j][k] = temp;
        }
      }
      for (j = i + 1; j < n; j++) {
        factor = a[j][i] / a[i][i];
        for(k = i; k < maug; k++) {
          a[j][k] = a[j][k] - factor * a[i][k];
        }
      }
    }
    for (i = n - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j<= n - 1; j++) {
        sum = x[j] * a[i][j];
      }
      x[i] =(a[i][maug - 1] - sum) / a[i][i];
    }
    return x;
  },

  gauss_jordan: function gauss_jordan(a, b) {
    var m = jStat.aug(a, b),
    h = m.length,
    w = m[0].length;
    // find max pivot
    for (var y = 0; y < h; y++) {
      var maxrow = y;
      for (var y2 = y+1; y2 < h; y2++) {
        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
          maxrow = y2;
      }
      var tmp = m[y];
      m[y] = m[maxrow];
      m[maxrow] = tmp
      for (var y2 = y+1; y2 < h; y2++) {
        c = m[y2][y] / m[y][y];
        for (var x = y; x < w; x++) {
          m[y2][x] -= m[y][x] * c;
        }
      }
    }
    // backsubstitute
    for (var y = h-1; y >= 0; y--) {
      c = m[y][y];
      for (var y2 = 0; y2 < y; y2++) {
        for (var x = w-1; x > y-1; x--) {
          m[y2][x] -= m[y][x] * m[y2][y] / c;
        }
      }
      m[y][y] /= c;
      for (var x = h; x < w; x++) {
        m[y][x] /= c;
      }
    }
    return m;
  },

  lu: function lu(a, b) {
    throw new Error('lu not yet implemented');
  },

  cholesky: function cholesky(a, b) {
    throw new Error('cholesky not yet implemented');
  },

  gauss_jacobi: function gauss_jacobi(a, b, x, r) {
    var i = 0;
    var j = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);
    c = jStat.multiply(jStat.inv(d), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  gauss_seidel: function gauss_seidel(a, b, x, r) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);
    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i = i + 1;
    }
    return xk;
  },

  SOR: function SOR(a, b, x, r, w) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),
                       jStat.subtract(jStat.multiply(d, 1 - w),
                                      jStat.multiply(u, w)));
    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,
        jStat.multiply(l, w))), b), w);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  householder: function householder(a) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var alpha, r, k, j, factor;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
      alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, jStat.multiply(a, p));
    }
    return a;
  },

  // TODO: not working properly.
  QR: function QR(a, b) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var x = [];
    var j, alpha, r, k, factor, sum;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
        alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++)
        w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, a);
      b = jStat.multiply(p, b);
    }
    for (i = m - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j <= n - 1; j++)
      sum = x[j] * a[i][j];
      x[i] = b[i][0] / a[i][i];
    }
    return x;
  },

  jacobi: function jacobi(a) {
    var condition = 1;
    var count = 0;
    var n = a.length;
    var e = jStat.identity(n, n);
    var ev = [];
    var b, i, j, p, q, maxim, theta, s;
    // condition === 1 only if tolerance is not reached
    while (condition === 1) {
      count++;
      maxim = a[0][1];
      p = 0;
      q = 1;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (i != j) {
            if (maxim < Math.abs(a[i][j])) {
              maxim = Math.abs(a[i][j]);
              p = i;
              q = j;
            }
          }
        }
      }
      if (a[p][p] === a[q][q])
        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;
      else
        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
      s = jStat.identity(n, n);
      s[p][p] = Math.cos(theta);
      s[p][q] = -Math.sin(theta);
      s[q][p] = Math.sin(theta);
      s[q][q] = Math.cos(theta);
      // eigen vector matrix
      e = jStat.multiply(e, s);
      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);
      a = b;
      condition = 0;
      for (i = 1; i < n; i++) {
        for (j = 1; j < n; j++) {
          if (i != j && Math.abs(a[i][j]) > 0.001) {
            condition = 1;
          }
        }
      }
    }
    for (i = 0; i < n; i++) ev.push(a[i][i]);
    //returns both the eigenvalue and eigenmatrix
    return [e, ev];
  },

  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
    var k1, k2, u_j1, k3, k4;
    if (order === 2) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h, u_j + k1);
        u_j1 = u_j + (k1 + k2) / 2;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    if (order === 4) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h / 2, u_j + k1 / 2);
        k3 = h * f(t_j + h / 2, u_j + k2 / 2);
        k4 = h * f(t_j +h, u_j + k3);
        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    return u_j;
  },

  romberg: function romberg(f, a, b, order) {
    var i = 0;
    var h = (b - a) / 2;
    var x = [];
    var h1 = [];
    var g = [];
    var m, a1, j, k, I, d;
    while (i < order / 2) {
      I = f(a);
      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
      m = x.length;
      for (j = 1; j < m - 1; j++) {
        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);
      }
      I = (h / 3) * (I + f(b));
      g[i] = I;
      h /= 2;
      i++;
    }
    a1 = g.length;
    m = 1;
    while (a1 !== 1) {
      for (j = 0; j < a1 - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a1 = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  richardson: function richardson(X, f, x, h) {
    function pos(X, x) {
      var i = 0;
      var n = X.length;
      var p;
      for (; i < n; i++)
        if (X[i] === x) p = i;
      return p;
    }
    var n = X.length,
    h_min = Math.abs(x - X[pos(X, x) + 1]),
    i = 0,
    g = [],
    h1 = [],
    y1, y2, m, a, j;
    while (h >= h_min) {
      y1 = pos(X, x + h);
      y2 = pos(X, x);
      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
      h /= 2;
      i++;
    }
    a = g.length;
    m = 1;
    while (a != 1) {
      for (j = 0; j < a - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  simpson: function simpson(f, a, b, n) {
    var h = (b - a) / n;
    var I = f(a);
    var x = [];
    var j = a;
    var k = 0;
    var i = 1;
    var m;
    for (; j <= b; j = j + h, k++)
      x[k] = j;
    m = x.length;
    for (; i < m - 1; i++) {
      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);
    }
    return (h / 3) * (I + f(b));
  },

  hermite: function hermite(X, F, dF, value) {
    var n = X.length;
    var p = 0;
    var i = 0;
    var l = [];
    var dl = [];
    var A = [];
    var B = [];
    var j;
    for (; i < n; i++) {
      l[i] = 1;
      for (j = 0; j < n; j++) {
        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
      }
      dl[i] = 0;
      for (j = 0; j < n; j++) {
        if (i != j) dl[i] += 1 / (X [i] - X[j]);
      }
      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
      B[i] = (value - X[i]) * (l[i] * l[i]);
      p += (A[i] * F[i] + B[i] * dF[i]);
    }
    return p;
  },

  lagrange: function lagrange(X, F, value) {
    var p = 0;
    var i = 0;
    var j, l;
    var n = X.length;
    for (; i < n; i++) {
      l = F[i];
      for (j = 0; j < n; j++) {
        // calculating the lagrange polynomial L_i
        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
      }
      // adding the lagrange polynomials found above
      p += l;
    }
    return p;
  },

  cubic_spline: function cubic_spline(X, F, value) {
    var n = X.length;
    var i = 0, j;
    var A = [];
    var B = [];
    var alpha = [];
    var c = [];
    var h = [];
    var b = [];
    var d = [];
    for (; i < n - 1; i++)
      h[i] = X[i + 1] - X[i];
    alpha[0] = 0;
    for (i = 1; i < n - 1; i++) {
      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -
          (3 / h[i-1]) * (F[i] - F[i-1]);
    }
    for (i = 1; i < n - 1; i++) {
      A[i] = [];
      B[i] = [];
      A[i][i-1] = h[i-1];
      A[i][i] = 2 * (h[i - 1] + h[i]);
      A[i][i+1] = h[i];
      B[i][0] = alpha[i];
    }
    c = jStat.multiply(jStat.inv(A), B);
    for (j = 0; j < n - 1; j++) {
      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
    }
    for (j = 0; j < n; j++) {
      if (X[j] > value) break;
    }
    j -= 1;
    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *
        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];
  },

  gauss_quadrature: function gauss_quadrature() {
    throw new Error('gauss_quadrature not yet implemented');
  },

  PCA: function PCA(X) {
    var m = X.length;
    var n = X[0].length;
    var flag = false;
    var i = 0;
    var j, temp1;
    var u = [];
    var D = [];
    var result = [];
    var temp2 = [];
    var Y = [];
    var Bt = [];
    var B = [];
    var C = [];
    var V = [];
    var Vt = [];
    for (i = 0; i < m; i++) {
      u[i] = jStat.sum(X[i]) / n;
    }
    for (i = 0; i < n; i++) {
      B[i] = [];
      for(j = 0; j < m; j++) {
        B[i][j] = X[j][i] - u[j];
      }
    }
    B = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      C[i] = [];
      for (j = 0; j < m; j++) {
        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);
      }
    }
    result = jStat.jacobi(C);
    V = result[0];
    D = result[1];
    Vt = jStat.transpose(V);
    for (i = 0; i < D.length; i++) {
      for (j = i; j < D.length; j++) {
        if(D[i] < D[j])  {
          temp1 = D[i];
          D[i] = D[j];
          D[j] = temp1;
          temp2 = Vt[i];
          Vt[i] = Vt[j];
          Vt[j] = temp2;
        }
      }
    }
    Bt = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      Y[i] = [];
      for (j = 0; j < Bt.length; j++) {
        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);
      }
    }
    return [X, D, Vt, Y];
  }
});

// extend jStat.fn with methods that require one argument
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function(arg, func) {
      var tmpthis = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));
        }, 15);
        return this;
      }
      if (typeof jStat[passfunc](this, arg) === 'number')
        return jStat[passfunc](this, arg);
      else
        return jStat(jStat[passfunc](this, arg));
    };
  }(funcs[i]));
}('add divide multiply subtract dot pow abs norm angle'.split(' ')));

}(this.jStat, Math));
(function(jStat, Math) {

var slice = [].slice;
var isNumber = jStat.utils.isNumber;

// flag==true denotes use of sample standard deviation
// Z Statistics
jStat.extend({
  // 2 different parameter lists:
  // (value, mean, sd)
  // (value, array, flag)
  zscore: function zscore() {
    var args = slice.call(arguments);
    if (isNumber(args[1])) {
      return (args[0] - args[1]) / args[2];
    }
    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);
  },

  // 3 different paramter lists:
  // (value, mean, sd, sides)
  // (zscore, sides)
  // (value, array, sides, flag)
  ztest: function ztest() {
    var args = slice.call(arguments);
    if (args.length === 4) {
      if(isNumber(args[1])) {
        var z = jStat.zscore(args[0],args[1],args[2])
        return (args[3] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);
      }
      var z = args[0]
      return (args[2] === 1) ?
        (jStat.normal.cdf(-Math.abs(z),0,1)) :
        (jStat.normal.cdf(-Math.abs(z),0,1)*2);
    }
    var z = jStat.zscore(args[0],args[1],args[3])
    return (args[1] === 1) ?
      (jStat.normal.cdf(-Math.abs(z), 0, 1)) :
      (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);
  }
});

jStat.extend(jStat.fn, {
  zscore: function zscore(value, flag) {
    return (value - this.mean()) / this.stdev(flag);
  },

  ztest: function ztest(value, sides, flag) {
    var zscore = Math.abs(this.zscore(value, flag));
    return (sides === 1) ?
      (jStat.normal.cdf(-zscore, 0, 1)) :
      (jStat.normal.cdf(-zscore, 0, 1) * 2);
  }
});

// T Statistics
jStat.extend({
  // 2 parameter lists
  // (value, mean, sd, n)
  // (value, array)
  tscore: function tscore() {
    var args = slice.call(arguments);
    return (args.length === 4) ?
      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :
      ((args[0] - jStat.mean(args[1])) /
       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));
  },

  // 3 different paramter lists:
  // (value, mean, sd, n, sides)
  // (tscore, n, sides)
  // (value, array, sides)
  ttest: function ttest() {
    var args = slice.call(arguments);
    var tscore;
    if (args.length === 5) {
      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));
      return (args[4] === 1) ?
        (jStat.studentt.cdf(-tscore, args[3]-1)) :
        (jStat.studentt.cdf(-tscore, args[3]-1)*2);
    }
    if (isNumber(args[1])) {
      tscore = Math.abs(args[0])
      return (args[2] == 1) ?
        (jStat.studentt.cdf(-tscore, args[1]-1)) :
        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);
    }
    tscore = Math.abs(jStat.tscore(args[0], args[1]))
    return (args[2] == 1) ?
      (jStat.studentt.cdf(-tscore, args[1].length-1)) :
      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);
  }
});

jStat.extend(jStat.fn, {
  tscore: function tscore(value) {
    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));
  },

  ttest: function ttest(value, sides) {
    return (sides === 1) ?
      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :
      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);
  }
});

// F Statistics
jStat.extend({
  // Paramter list is as follows:
  // (array1, array2, array3, ...)
  // or it is an array of arrays
  // array of arrays conversion
  anovafscore: function anovafscore() {
    var args = slice.call(arguments),
    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
    if (args.length === 1) {
      tmpargs = new Array(args[0].length);
      for (i = 0; i < args[0].length; i++) {
        tmpargs[i] = args[0][i];
      }
      args = tmpargs;
    }
    // 2 sample case
    if (args.length === 2) {
      return jStat.variance(args[0]) / jStat.variance(args[1]);
    }
    // Builds sample array
    sample = new Array();
    for (i = 0; i < args.length; i++) {
      sample = sample.concat(args[i]);
    }
    sampMean = jStat.mean(sample);
    // Computes the explained variance
    expVar = 0;
    for (i = 0; i < args.length; i++) {
      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);
    }
    expVar /= (args.length - 1);
    // Computes unexplained variance
    unexpVar = 0;
    for (i = 0; i < args.length; i++) {
      sampSampMean = jStat.mean(args[i]);
      for (j = 0; j < args[i].length; j++) {
        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);
      }
    }
    unexpVar /= (sample.length - args.length);
    return expVar / unexpVar;
  },

  // 2 different paramter setups
  // (array1, array2, array3, ...)
  // (anovafscore, df1, df2)
  anovaftest: function anovaftest() {
    var args = slice.call(arguments),
    df1, df2, n, i;
    if (isNumber(args[0])) {
      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);
    }
    anovafscore = jStat.anovafscore(args);
    df1 = args.length - 1;
    n = 0;
    for (i = 0; i < args.length; i++) {
      n = n + args[i].length;
    }
    df2 = n - df1 - 1;
    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);
  },

  ftest: function ftest(fscore, df1, df2) {
    return 1 - jStat.centralF.cdf(fscore, df1, df2);
  }
});

jStat.extend(jStat.fn, {
  anovafscore: function anovafscore() {
    return jStat.anovafscore(this.toArray());
  },

  anovaftes: function anovaftes() {
    var n = 0;
    var i;
    for (i = 0; i < this.length; i++) {
      n = n + this[i].length;
    }
    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);
  }
});

// Error Bounds
jStat.extend({
  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  normalci: function normalci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  tci: function tci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *
                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  significant: function significant(pvalue, alpha) {
    return pvalue < alpha;
  }
});

jStat.extend(jStat.fn, {
  normalci: function normalci(value, alpha) {
    return jStat.normalci(value, alpha, this.toArray());
  },

  tci: function tci(value, alpha) {
    return jStat.tci(value, alpha, this.toArray());
  }
});

}(this.jStat, Math));

},{}],3:[function(require,module,exports){
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;
            
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);
        
        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };
    
    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }
        
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        
        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';
            
            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            
            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }        


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this, 
                  inputString ? inputString : defaultFormat, 
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
                return inputString; 
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);            
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(this);

},{}],4:[function(require,module,exports){
(function (global){
"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sébastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
	var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
	var tolerance= 1.e-64/prec;
	var itmax= 50;
	var c=0;
	var i=0;
	var j=0;
	var k=0;
	var l=0;
	
	var u= numeric.clone(A);
	var m= u.length;
	
	var n= u[0].length;
	
	if (m < n) throw "Need more rows than columns"
	
	var e = new Array(n);
	var q = new Array(n);
	for (i=0; i<n; i++) e[i] = q[i] = 0.0;
	var v = numeric.rep([n,n],0);
//	v.zero();
	
 	function pythag(a,b)
 	{
		a = Math.abs(a)
		b = Math.abs(b)
		if (a > b)
			return a*Math.sqrt(1.0+(b*b/a/a))
		else if (b == 0.0) 
			return a
		return b*Math.sqrt(1.0+(a*a/b/b))
	}

	//Householder's reduction to bidiagonal form

	var f= 0.0;
	var g= 0.0;
	var h= 0.0;
	var x= 0.0;
	var y= 0.0;
	var z= 0.0;
	var s= 0.0;
	
	for (i=0; i < n; i++)
	{	
		e[i]= g;
		s= 0.0;
		l= i+1;
		for (j=i; j < m; j++) 
			s += (u[j][i]*u[j][i]);
		if (s <= tolerance)
			g= 0.0;
		else
		{	
			f= u[i][i];
			g= Math.sqrt(s);
			if (f >= 0.0) g= -g;
			h= f*g-s
			u[i][i]=f-g;
			for (j=l; j < n; j++)
			{
				s= 0.0
				for (k=i; k < m; k++) 
					s += u[k][i]*u[k][j]
				f= s/h
				for (k=i; k < m; k++) 
					u[k][j]+=f*u[k][i]
			}
		}
		q[i]= g
		s= 0.0
		for (j=l; j < n; j++) 
			s= s + u[i][j]*u[i][j]
		if (s <= tolerance)
			g= 0.0
		else
		{	
			f= u[i][i+1]
			g= Math.sqrt(s)
			if (f >= 0.0) g= -g
			h= f*g - s
			u[i][i+1] = f-g;
			for (j=l; j < n; j++) e[j]= u[i][j]/h
			for (j=l; j < m; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += (u[j][k]*u[i][k])
				for (k=l; k < n; k++) 
					u[j][k]+=s*e[k]
			}	
		}
		y= Math.abs(q[i])+Math.abs(e[i])
		if (y>x) 
			x=y
	}
	
	// accumulation of right hand gtransformations
	for (i=n-1; i != -1; i+= -1)
	{	
		if (g != 0.0)
		{
		 	h= g*u[i][i+1]
			for (j=l; j < n; j++) 
				v[j][i]=u[i][j]/h
			for (j=l; j < n; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += u[i][k]*v[k][j]
				for (k=l; k < n; k++) 
					v[k][j]+=(s*v[k][i])
			}	
		}
		for (j=l; j < n; j++)
		{
			v[i][j] = 0;
			v[j][i] = 0;
		}
		v[i][i] = 1;
		g= e[i]
		l= i
	}
	
	// accumulation of left hand transformations
	for (i=n-1; i != -1; i+= -1)
	{	
		l= i+1
		g= q[i]
		for (j=l; j < n; j++) 
			u[i][j] = 0;
		if (g != 0.0)
		{
			h= u[i][i]*g
			for (j=l; j < n; j++)
			{
				s=0.0
				for (k=l; k < m; k++) s += u[k][i]*u[k][j];
				f= s/h
				for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
			}
			for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
		}
		else
			for (j=i; j < m; j++) u[j][i] = 0;
		u[i][i] += 1;
	}
	
	// diagonalization of the bidiagonal form
	prec= prec*x
	for (k=n-1; k != -1; k+= -1)
	{
		for (var iteration=0; iteration < itmax; iteration++)
		{	// test f splitting
			var test_convergence = false
			for (l=k; l != -1; l+= -1)
			{	
				if (Math.abs(e[l]) <= prec)
				{	test_convergence= true
					break 
				}
				if (Math.abs(q[l-1]) <= prec)
					break 
			}
			if (!test_convergence)
			{	// cancellation of e[l] if l>0
				c= 0.0
				s= 1.0
				var l1= l-1
				for (i =l; i<k+1; i++)
				{	
					f= s*e[i]
					e[i]= c*e[i]
					if (Math.abs(f) <= prec)
						break
					g= q[i]
					h= pythag(f,g)
					q[i]= h
					c= g/h
					s= -f/h
					for (j=0; j < m; j++)
					{	
						y= u[j][l1]
						z= u[j][i]
						u[j][l1] =  y*c+(z*s)
						u[j][i] = -y*s+(z*c)
					} 
				}	
			}
			// test f convergence
			z= q[k]
			if (l== k)
			{	//convergence
				if (z<0.0)
				{	//q[k] is made non-negative
					q[k]= -z
					for (j=0; j < n; j++)
						v[j][k] = -v[j][k]
				}
				break  //break out of iteration loop and move on to next k value
			}
			if (iteration >= itmax-1)
				throw 'Error: no convergence.'
			// shift from bottom 2x2 minor
			x= q[l]
			y= q[k-1]
			g= e[k-1]
			h= e[k]
			f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
			g= pythag(f,1.0)
			if (f < 0.0)
				f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
			else
				f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
			// next QR transformation
			c= 1.0
			s= 1.0
			for (i=l+1; i< k+1; i++)
			{	
				g= e[i]
				y= q[i]
				h= s*g
				g= c*g
				z= pythag(f,h)
				e[i-1]= z
				c= f/z
				s= h/z
				f= x*c+g*s
				g= -x*s+g*c
				h= y*s
				y= y*c
				for (j=0; j < n; j++)
				{	
					x= v[j][i-1]
					z= v[j][i]
					v[j][i-1] = x*c+z*s
					v[j][i] = -x*s+z*c
				}
				z= pythag(f,h)
				q[i-1]= z
				c= f/z
				s= h/z
				f= c*g+s*y
				x= -s*g+c*y
				for (j=0; j < m; j++)
				{
					y= u[j][i-1]
					z= u[j][i]
					u[j][i-1] = y*c+z*s
					u[j][i] = -y*s+z*c
				}
			}
			e[l]= 0.0
			e[k]= f
			q[k]= x
		} 
	}
		
	//vt= transpose(v)
	//return (u,q,vt)
	for (i=0;i<q.length; i++) 
	  if (q[i] < prec) q[i] = 0
	  
	//sort eigenvalues	
	for (i=0; i< n; i++)
	{	 
	//writeln(q)
	 for (j=i-1; j >= 0; j--)
	 {
	  if (q[j] < q[i])
	  {
	//  writeln(i,'-',j)
	   c = q[j]
	   q[j] = q[i]
	   q[i] = c
	   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
	   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
	   i = j	   
	  }
	 }	
	}
	
	return {U:u,S:q,V:v}
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
function SpreadSheetError() {
    this.name = 'SpreadSheetError';
    this.message = '发生了错误';
}

SpreadSheetError.prototype = new Error();
SpreadSheetError.prototype.constructor = SpreadSheetError;
SpreadSheetError.prototype.toString = function () {
    return this.name + ' => ' + this.message;
};

exports.SpreadSheetError = SpreadSheetError;

},{}],6:[function(require,module,exports){
'use strict';

var _settings = require('./settings');

var _core = require('./core');

var _core2 = _interopRequireDefault(_core);

var _polyfill = require('./polyfill');

var _polyfill2 = _interopRequireDefault(_polyfill);

var _XFormulas = require('./plugins/xformulas/XFormulas');

var _XFormulas2 = _interopRequireDefault(_XFormulas);

var _Plugin = require('./plugins/Plugin');

var _Persistent = require('./plugins/persistent/Persistent');

var _Persistent2 = _interopRequireDefault(_Persistent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_core2.default.globalSettings = _settings.globalSettings;
//noinspection ES6UnusedImports 这个导入是为了构建时加载相应的包

_core2.default.defaultSettings = _settings.defaultSettings;
_core2.default.version = '@@_version_@@';

_core2.default.plugins = {
    Plugin: _Plugin.Plugin,
    registerPlugin: _Plugin.registerPlugin
};

// 内置插件
(0, _Plugin.registerPlugin)('persistent', _Persistent2.default);

// 浏览器环境下的全局变量名。
window.BrickSpreadSheet = _core2.default;
window._UIProvider = {};
(0, _polyfill2.default)(window);

// TODO 提供更改全局变量名的方法，以防止全局变量冲突。

},{"./core":7,"./plugins/Plugin":22,"./plugins/persistent/Persistent":24,"./plugins/xformulas/XFormulas":34,"./polyfill":56,"./settings":57}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Frame = require('./designer/Frame');

var _Frame2 = _interopRequireDefault(_Frame);

var _Workbook = require('./designer/Workbook');

var _Workbook2 = _interopRequireDefault(_Workbook);

var _common = require('./utils/common');

var _Plugin = require('./plugins/Plugin');

var _Emitter2 = require('./utils/Emitter');

var _Emitter3 = _interopRequireDefault(_Emitter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AUTO_ID = 1;

var SpreadSheet = function (_Emitter) {
    _inherits(SpreadSheet, _Emitter);

    /**
     * 类似 Excel 的电子表格。
     *
     * @constructor
     * @param rootElement
     * @param {object|string} userSettings - 电子表格的用户配置信息
     * @param {object} userSettings.workbook - Workbook 的配置
     * @param {object[]} userSettings.sheets - 配置所有初始 Sheet 页的数组
     * @param {boolean=} [displayMode=false] - 展示模式，不可编辑。
     */
    function SpreadSheet(rootElement, userSettings) {
        var displayMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        _classCallCheck(this, SpreadSheet);

        var _this = _possibleConstructorReturn(this, (SpreadSheet.__proto__ || Object.getPrototypeOf(SpreadSheet)).call(this));

        _this.rootElement = rootElement;
        _this.getUserSettings(userSettings);

        _this.settings = {};
        (0, _common.extend)(_this.settings, SpreadSheet.defaultSettings);
        (0, _common.extend)(_this.settings, _this.userSettings);

        _this.id = _this.settings.id || _this.getId();
        _this.displayMode = displayMode;

        _this._initPlugin();
        _this.frame = new _Frame2.default(_this, _this.settings.frame);
        _this.workbook = new _Workbook2.default(_this, _this.settings.workbook);
        _this._enablePlugin();
        return _this;
    }

    _createClass(SpreadSheet, [{
        key: 'getId',
        value: function getId() {
            // 不指定 id 时，尽量生成不可重复的 id（使用当前 iframe 自增变量配合随机字符串的方式）
            return this.id || SpreadSheet.globalSettings.idPrefix + AUTO_ID++ + '-' + (0, _common.randomString)();
        }
    }, {
        key: 'getRootElement',
        value: function getRootElement() {
            return this.rootElement;
        }
    }, {
        key: 'getDisplayMode',
        value: function getDisplayMode() {
            return this.displayMode;
        }

        /**
         * 获取用户传入的初始配置。
         * @param {string=} s - 表示用户配置的 JSON 字符串
         * @returns {Object}
         */

    }, {
        key: 'getUserSettings',
        value: function getUserSettings(s) {
            if (this.userSettings) {
                return this.userSettings;
            }
            if (s && typeof s === 'string') {
                this.userSettings = JSON.parse(s);
            } else {
                this.userSettings = s;
            }
            return this.userSettings;
        }

        /**
         * 获取 SpreadSheet 实际生效的配置信息。
         * @returns {Object}
         */

    }, {
        key: 'getSettings',
        value: function getSettings() {
            return this.settings;
        }

        /**
         * 获取可交换的中间数据，用于数据提交、解析转换等。
         * @param {boolean} [oragin=false] - 为 `true` 时获取原始 JavaScript 对象
         * @returns
         */

    }, {
        key: 'getExchangeData',
        value: function getExchangeData() {
            var oragin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            var w = this.workbook._getExchange();
            var f = this.frame._getExchange(); // TODO frame
            var o = {
                workbook: w,
                frame: f,
                id: this.getId()
            };
            return oragin ? o : JSON.stringify(o);
        }

        /**
         * 获取当前 SpreadSheet 对应的 Workbook 实例。
         * @returns {Workbook}
         */

    }, {
        key: 'getWorkbookInstance',
        value: function getWorkbookInstance() {
            return this.workbook;
        }

        /**
         * 获取当前 SpreadSheet 对应的 Frame 实例。
         * @returns {Frame}
         */

    }, {
        key: 'getFrameInstance',
        value: function getFrameInstance() {
            return this.frame;
        }
    }, {
        key: '_initPlugin',
        value: function _initPlugin() {
            var _this2 = this;

            this.plugins = new Map();
            (0, _Plugin.getAllPlugins)().forEach(function (P) {
                var p = new P(_this2);
                (0, _Plugin.validatePlugin)(p);
                _this2.plugins.set(p.__name__, p);
            });
        }
    }, {
        key: '_enablePlugin',
        value: function _enablePlugin() {
            this.plugins.forEach(function (p) {
                if (p.isEnable()) {
                    p.enable();
                }
            });
        }
    }]);

    return SpreadSheet;
}(_Emitter3.default);

exports.default = SpreadSheet;

},{"./designer/Frame":9,"./designer/Workbook":13,"./plugins/Plugin":22,"./utils/Emitter":58,"./utils/common":59}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 配置翻译类。
 * 框架内部使用，用户代码不应该调用它。
 *
 * @private
 */
var ConfigTranslator = function () {

    /**
     * 构造器
     *
     * @param {object} config
     * @param {Sheet} sheet
     */
    function ConfigTranslator(config, sheet) {
        _classCallCheck(this, ConfigTranslator);

        this.initialConfig = config;
        this.sheet = sheet;
        this.spreadSheet = sheet.workbook.spreadSheet;
    }

    /**
     * 翻译配置。
     * 中间数据格式的设计会尽量同时保证在 Excel 及 Web 页面中均便于处理，
     * 但不免存在一些 Web 中难以直接使用的数据格式，该方法即是完成此类数据格式
     * 的适配转换工作。
     *
     * @returns {object}
     */


    _createClass(ConfigTranslator, [{
        key: 'translate',
        value: function translate() {
            var settings = {};
            var proto = Object.getPrototypeOf(this);
            var property = Object.getOwnPropertyNames(proto);

            for (var i = 0; i < property.length; ++i) {
                if (property[i].startsWith('_trans')) {
                    this[property[i]].call(this, settings);
                }
            }
            return settings;
        }

        /**
         * handsontable 中的一些状态无法通过初始配置参数控制，
         * 只能在实例化之后调用相应的方法来恢复相应的状态，此方法
         * 即是完成该功能。
         */

    }, {
        key: 'initSheetState',
        value: function initSheetState() {
            var proto = Object.getPrototypeOf(this);
            var property = Object.getOwnPropertyNames(proto);

            for (var i = 0; i < property.length; ++i) {
                if (property[i].startsWith('_init')) {
                    this[property[i]].call(this);
                }
            }
        }

        // ------------------------ translate ------------------------------

    }, {
        key: '_transCell',
        value: function _transCell(settings) {
            var m = this.initialConfig.cellMetas;
            if (m) {
                settings.cell = [];
                for (var i = 0; i < m.length; ++i) {
                    var row = m[i];
                    for (var j = 0; j < row.length; ++j) {
                        var cellMeta = row[j];
                        if (cellMeta) {
                            var cell = {};
                            cell.row = cellMeta.row;
                            cell.col = cellMeta.col;

                            // dataType
                            if (cellMeta.dataType) {
                                for (var dt in cellMeta.dataType) {
                                    if (cellMeta.dataType.hasOwnProperty(dt)) {
                                        cell[dt] = cellMeta.dataType[dt];
                                    }
                                }
                                cell.type = cellMeta.dataType.typeName;
                                delete cell.typeName;
                            }

                            // styles
                            if (cellMeta.styles) {
                                if (cellMeta.styles.alignments) {
                                    var c = cellMeta.styles.alignments.join(' ht');
                                    cell.className = cell.className ? cell.className += ' ht' + c : 'ht' + c;
                                }
                                if (cellMeta.styles.fontFamily) {
                                    cell._style_fontFamily = cellMeta.styles.fontFamily;
                                }
                                if (cellMeta.styles.fontSize) {
                                    cell._style_fontSize = cellMeta.styles.fontSize;
                                }
                                if (cellMeta.styles.color) {
                                    cell._style_color = cellMeta.styles.color;
                                }
                                if (cellMeta.styles.backgroundColor) {
                                    cell._style_backgroundColor = cellMeta.styles.backgroundColor;
                                }
                                if (cellMeta.styles.fontStyle) {
                                    cell.className = cell.className ? cell.className += ' ssd-font-' + cellMeta.styles.fontStyle : 'ssd-font-' + cellMeta.styles.fontStyle;
                                }
                                if (cellMeta.styles.fontWeight) {
                                    cell.className = cell.className ? cell.className += ' ssd-font-bold' : 'ssd-font-bold';
                                }
                                if (cellMeta.styles.textDecoration) {
                                    cell.className = cell.className ? cell.className += ' ssd-font-underline' : 'ssd-font-underline';
                                }
                            }
                            settings.cell.push(cell);
                        }
                    }
                }
            }
        }
    }, {
        key: '_transData',
        value: function _transData(settings) {
            var s = this.initialConfig.data;
            if (s) {
                // hotTable 在有 data 的情况下只能显示有数据的行列，这对于设计器来说并不方便使用，
                // 故填充空数据以撑起表格至 initRows * initCols 的大小。
                //    if (s.length < this.sheet.initRows) {
                //        let formerCol = s.length;
                //        s.length = this.sheet.initRows;
                //        s.fill([], formerCol);
                //    }
                //    for (let i = 0; i < s.length; ++i) {
                //        let row = s[i];
                //        if (row.length < this.sheet.initCols) {
                //            let formerRow = row.length;
                //            row.length = this.sheet.initCols;
                //            row.fill('', formerRow);
                //        }
                //    }

                // 使用 hot API 完成上述功能
                if (!this.spreadSheet.displayMode) {
                    settings.minRows = this.sheet.initRows;
                    settings.minCols = this.sheet.initCols;
                }
                settings.data = s;
            }
        }

        // 列宽
        // NOTE: Handsontable 的 colWidths 有 BUG，设定后将不可以手工改变列宽，
        //       试图使用 manualColumnResize 在表格初始化之后来改宽度
        // _transColWidths(settings) {
        //     var w = this.initialConfig.colWidths;
        //     if (w) {
        //         settings.colWidths = w;
        //     }
        // }

        // 行高
        // NOTE: Handsontable 的 rowHeights 有 BUG，设定后将不可以手工改变列宽
        // _transRowHeights(settings) {
        //     var h = this.initialConfig.rowHeights;
        //     if (h) {
        //         settings.rowHeights = h;
        //     }
        // }

        // FIXME 边框 hot BUG

    }, {
        key: '_transBorders',
        value: function _transBorders(settings) {}
        // var s = this.initialConfig.borders;
        // if (s) {
        //     settings.customBorders = s;
        // }


        // 合并单元格

    }, {
        key: '_transMergeCells',
        value: function _transMergeCells(settings) {
            var s = this.initialConfig.mergeCells;
            if (s) {
                settings.mergeCells = s;
            }
        }

        // ------------------------ initState ------------------------------

        // 选区

    }, {
        key: '_initSelection',
        value: function _initSelection() {
            var s = this.initialConfig.selection;
            if (s) {
                this.sheet.select(s.row, s.col, s.endRow, s.endCol);
            } else {
                this.sheet.select(0, 0);
            }
        }

        // 列宽

    }, {
        key: '_initColWidths',
        value: function _initColWidths() {
            var w = this.initialConfig.colWidths;
            var mcr = this.sheet.handsontable.getPlugin('manualColumnResize');
            var i = void 0,
                len = void 0;

            if (w && w.length) {
                for (i = 0, len = w.length; i < len; ++i) {
                    mcr.setManualSize(i, w[i]);
                }
            }
        }

        // 行高

    }, {
        key: '_initRowHeights',
        value: function _initRowHeights() {
            var h = this.initialConfig.rowHeights;
            var mrr = this.sheet.handsontable.getPlugin('manualRowResize');
            var i = void 0,
                len = void 0;

            if (h && h.length) {
                for (i = 0, len = h.length; i < len; ++i) {
                    mrr.setManualSize(i, h[i]);
                }
            }
        }
    }]);

    return ConfigTranslator;
}();

exports.default = ConfigTranslator;

},{}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextMenu = require('./frame/ContextMenu');

var _ContextMenu2 = _interopRequireDefault(_ContextMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 电子表格设计器中，除了 Workbook 外的组件管理器，
 * 包含菜单栏、工具栏、侧边栏、右键菜单等等。
 */
var Frame = function () {
  function Frame(instance, config) {
    _classCallCheck(this, Frame);

    this.spreadSheet = instance;
    /**
     *
     * @type {ContextMenu}
     */
    this.contextMenu = new _ContextMenu2.default(instance);
  }

  _createClass(Frame, [{
    key: '_getExchange',
    value: function _getExchange() {}
  }]);

  return Frame;
}();

exports.default = Frame;

},{"./frame/ContextMenu":16}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _common = require("../utils/common.js");

var _ConfigTranslator = require("./ConfigTranslator.js");

var _ConfigTranslator2 = _interopRequireDefault(_ConfigTranslator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Handsontable 组件的适配类
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var HotTableAdaptor = function (_Handsontable) {
    _inherits(HotTableAdaptor, _Handsontable);

    /**
     *
     * @param {HTMLElement} rootElement
     * @param {object} config - 原始配置信息
     * @param {object} extConfig - 附加的配置信息
     * @param {Sheet} sheet - 对应的 sheet 实例
     */
    function HotTableAdaptor(rootElement, config, extConfig, sheet) {
        _classCallCheck(this, HotTableAdaptor);

        var hotSettings = {};
        var translator = new _ConfigTranslator2.default(config, sheet);
        var settings = translator.translate();
        var ss = sheet.workbook.spreadSheet;

        var frame = ss.getFrameInstance();
        var displayMode = ss.getDisplayMode();
        var menuItems = frame.contextMenu.menuItems;
        var contextMenu = {};

        contextMenu.items = frame.contextMenu.getMenuItems4HotTable();
        contextMenu.callback = function (sheet) {
            return function (key, options) {
                if (menuItems.has(key)) {
                    var item = menuItems.get(key);
                    if (item.handler) {
                        item.handler.call(this, sheet, options.start, options.end, options);
                    }
                }
            };
        }(sheet);

        !displayMode && (HotTableAdaptor._preference.contextMenu = contextMenu);
        displayMode && (HotTableAdaptor._preference.tableClassName += ' displaymode');

        (0, _common.extend)(hotSettings, HotTableAdaptor._preference);
        (0, _common.extend)(hotSettings, settings);
        (0, _common.extend)(hotSettings, extConfig);

        if (displayMode) {
            hotSettings.colHeaders = false;
            hotSettings.rowHeaders = false;
        }

        var _this = _possibleConstructorReturn(this, (HotTableAdaptor.__proto__ || Object.getPrototypeOf(HotTableAdaptor)).call(this, rootElement, hotSettings));

        _this._translator = translator;

        // handontable 每次 render 的时候，不保留 td 的状态，因此通过该事件重建一些样式。
        //noinspection ES6ModulesDependencies
        Handsontable.hooks.add('beforeRenderer', function (TD, row, col, prop, value, cellProperties) {
            TD.style.color = cellProperties._style_color || '';
            TD.style.fontFamily = cellProperties._style_fontFamily || '';
            TD.style.fontSize = cellProperties._style_fontSize || '';
            cellProperties._style_fontSize && (TD.style.lineHeight = cellProperties._style_fontSize);
            TD.style.backgroundColor = cellProperties._style_backgroundColor || '';
        }, _this);

        /*
         * 将 Handsontable 的所有事件都委托给 SpreadSheet 后会有些卡。
         * 只好将 Handsontable.hooks.getRegistered() 换成 ECP 项目需要的。
         */
        ['afterSelectionEnd'].forEach(function (hook) {
            //noinspection ES6ModulesDependencies
            Handsontable.hooks.add(hook, function () {
                var args = [];
                args.push(hook);
                args.push(sheet);
                args.push.apply(args, [].slice.call(arguments));
                var cxt = sheet.workbook.spreadSheet;
                cxt.emit.apply(cxt, args);
            }, _this);
        });
        return _this;
    }

    _createClass(HotTableAdaptor, [{
        key: "destroy",
        value: function destroy() {
            _get(HotTableAdaptor.prototype.__proto__ || Object.getPrototypeOf(HotTableAdaptor.prototype), "destroy", this).call(this);
            delete this._translator;
        }
    }]);

    return HotTableAdaptor;
}(Handsontable);

/**
 * 预设配置。
 * @private
 */


HotTableAdaptor._preference = {
    outsideClickDeselects: false,
    contextMenu: false,

    rowHeaders: true,
    colHeaders: true,

    manualColumnResize: true,
    manualRowResize: true,

    tableClassName: 'ssd-handsontable-table',

    customBorders: true,

    xFormulas: true
};

exports.default = HotTableAdaptor;

},{"../utils/common.js":59,"./ConfigTranslator.js":8}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _HotTableAdaptor = require('./HotTableAdaptor');

var _HotTableAdaptor2 = _interopRequireDefault(_HotTableAdaptor);

var _SheetError = require('./SheetError');

var _Sheet_exchange = require('./ext/Sheet_exchange');

var _Sheet_helper = require('./ext/Sheet_helper');

var _common = require('../utils/common');

var _Emitter = require('../utils/Emitter');

var _Emitter2 = _interopRequireDefault(_Emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var INIT_ROWS = 150; // Sheet 初始可显示的行数
var INIT_COLS = 50; // Sheet 初始可显示的列数

/**
 * 工作表
 *
 * @fires Sheet#afterRename
 * @fires Sheet#afterRenameCancel
 */

var Sheet = function (_SheetHelper) {
    _inherits(Sheet, _SheetHelper);

    /**
     * 构造 Sheet 实例，用户代码不应该直接调用它，
     * 而是使用 Workbook.createSheet() 方法构造。
     *
     * @param {Workbook} workbook
     * @param {object} config
     * @private
     */
    function Sheet(workbook, config) {
        _classCallCheck(this, Sheet);

        /**
         * sheet 所在的工作表
         * @type {Workbook}
         */
        var _this = _possibleConstructorReturn(this, (Sheet.__proto__ || Object.getPrototypeOf(Sheet)).call(this));

        _this.workbook = workbook;
        _this.$$view = workbook.$$view;
        _this.settings = config;
        _this.sheetName = config.name;

        _this.initRows = INIT_ROWS;
        _this.initCols = INIT_COLS;

        _this.fx = {}; // TODO

        _this._render();
        return _this;
    }

    /**
     * @private
     */


    _createClass(Sheet, [{
        key: '_render',
        value: function _render() {
            this.$$view.appendTab(this.sheetName);

            var _$$view$_hotTables$ge = this.$$view._hotTables.get(this.sheetName),
                container = _$$view$_hotTables$ge.container,
                width = _$$view$_hotTables$ge.width,
                height = _$$view$_hotTables$ge.height;

            /**
             * @type {Handsontable}
             */

            this.handsontable = new _HotTableAdaptor2.default(container, this.settings, {
                width: width,
                height: height,
                readOnly: this.workbook.spreadSheet.getDisplayMode(),
                startRows: this.initRows,
                startCols: this.initCols,
                _isHotTableAdaptor: true,
                _sheet: this
            }, this);
            this.handsontable._translator.initSheetState();
            this._hack();
            this.$$view.hideContent(this.getName());
        }

        /**
         * 获取当前 sheet 的名字
         * @returns {string}
         */

    }, {
        key: 'getName',
        value: function getName() {
            return this.sheetName;
        }

        /**
         * 激活当前 sheet 页
         */

    }, {
        key: 'active',
        value: function active() {
            this.workbook.activeSheet = this.getName();
            this.$$view.activeTab(this.getName());
            this.handsontable.render();
        }

        /**
         * 检测当前 sheet 是否被激活
         * @returns {boolean}
         */

    }, {
        key: 'isActive',
        value: function isActive() {
            return this.workbook.activeSheet === this.getName();
        }

        /**
         * 关闭 sheet 页
         */

    }, {
        key: 'close',
        value: function close() {
            this.workbook.closeSheet(this.getName());
        }

        /**
         * 销毁当前 sheet
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.handsontable.destroy();
            this.workbook.sheets.delete(this.getName());
            delete this.workbook;
            delete this.$$view;
        }

        /**
         * 给 sheet 页重命名
         * @param name - 新名字
         */

    }, {
        key: 'rename',
        value: function rename(name) {
            this.workbook.renameSheet(this.getName(), name);
        }

        /**
         * 选中 sheet 中的某区域。
         * 不指定 toRow 、toCol 时则选中对应的单元格。
         * @param {int} fromRow - 起始行
         * @param {int} fromCol - 起始列
         * @param {int} [toRow] - 终止行
         * @param {int} [toCol] - 终止列
         */

    }, {
        key: 'select',
        value: function select(fromRow, fromCol, toRow, toCol) {
            toRow = toRow || fromRow;
            toCol = toCol || fromCol;
            this.handsontable.selectCell(fromRow, fromCol, toRow, toCol, false);
        }

        /**
         * 获得当前 sheet 的选区
         * @returns {{row, col, endRow, endCol}}
         */

    }, {
        key: 'getSelection',
        value: function getSelection() {
            var selection = this.handsontable.getSelected();
            return {
                row: selection[0],
                col: selection[1],
                endRow: selection[2],
                endCol: selection[3]
            };
        }

        /**
         * 合并单元格
         * TIP: handsontable 官方合并功能不能正确处理已有的合并区域，故做重新计算。
         * @param {int} row - 起始行
         * @param {int} col - 起始列
         * @param {int} rowspan - 待合并的行数
         * @param {int} colspan - 待合并的列数
         */
        // TODO 最大行列数限制

    }, {
        key: 'mergeCells',
        value: function mergeCells(row, col, rowspan, colspan) {
            var r = 0;
            var cover = [];
            var mergeCells = this.handsontable.getSettings().mergeCells;

            var r1 = [row, col, row + rowspan - 1, col + colspan - 1];

            for (var i = mergeCells.length; i; --i) {
                var f = mergeCells[i - 1];
                var r2 = [f.row, f.col, f.row + f.rowspan - 1, f.col + f.colspan - 1];

                // 与原区域存在完全重叠
                if (_common.Coordinate.isEqual(r1, r2)) {
                    r = 1;
                    break;
                }
                // 是原区域的子集
                if (_common.Coordinate.isSubset(r1, r2)) {
                    r = 2;
                    break;
                }
                // 覆盖原区域（此时可能与另一个原区域交集或完全覆盖）
                if (_common.Coordinate.isSuperset(r1, r2)) {
                    cover.push(i - 1);
                    r = 3;
                    continue;
                }
                // 与原区域存在交集(不含子集、超集情况)
                if (_common.Coordinate.intersection(r1, r2)) {
                    r = 4;
                }
            }

            if (r === 0 || r === 3) {
                if (r === 3) {
                    // 这种情况下一定存在已经合并过的单元格
                    for (var _i = 0; _i < cover.length; ++_i) {
                        mergeCells.splice(cover[_i], 1);
                    }
                }
                mergeCells = mergeCells || [];
                mergeCells.push({
                    row: row,
                    col: col,
                    rowspan: rowspan,
                    colspan: colspan
                });
                this.handsontable.updateSettings({
                    mergeCells: mergeCells
                });
            } else if (r === 2 || r === 4) {
                throw new _SheetError.SheetError('\u7ED9\u5B9A\u7684\u5408\u5E76\u533A\u57DF\u4E0D\u5408\u6CD5: [' + row + ', ' + col + ', ' + rowspan + ', ' + colspan + ']');
            }
        }

        /**
         * 取消单元格合并
         * @param {int} row - 起始行
         * @param {int} col - 起始列
         * @param {int} rowspan - 待合并的行数
         * @param {int} colspan - 待合并的列数
         */

    }, {
        key: 'unMergeCells',
        value: function unMergeCells(row, col, rowspan, colspan) {
            var merged = this.handsontable.getSettings().mergeCells;
            var mergeCells = [];
            if (merged && merged.length) {
                for (var i = 0; i < merged.length; ++i) {
                    if (_common.Coordinate.isSubset([merged[i].row, merged[i].col, merged[i].row + merged[i].rowspan - 1, merged[i].col + merged[i].colspan - 1], [row, col, row + rowspan - 1, col + colspan - 1])) {
                        continue;
                    }
                    mergeCells.push(merged[i]);
                }
            }
            this.handsontable.updateSettings({
                mergeCells: mergeCells.length === 0 ? false : mergeCells
            });
        }
    }, {
        key: 'spliceClass',
        value: function spliceClass(selection, newClassName) {
            for (var _len = arguments.length, classNames = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                classNames[_key - 2] = arguments[_key];
            }

            var _this2 = this;

            this._walkonCellMetas(selection, function (row, col, cellMeta) {
                return {
                    className: (_this2._removeFormerClass(cellMeta.className, classNames) + ' ' + newClassName).trim()
                };
            }, { className: newClassName });
        }

        /**
         * 设置字体加粗
         * @param {boolean} [value=true] `true` 为加粗，`false` 取消加粗
         * @param {object} selection - 待设置的选区
         * @param {int} selection.row
         * @param {int} selection.col
         * @param {int} [selection.endRow]
         * @param {int} [selection.endCol]
         */

    }, {
        key: 'setFontBold',
        value: function setFontBold() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            if (value) {
                this.spliceClass(selection, 'ssd-font-bold', 'ssd-font-bold');
            } else {
                this.spliceClass(selection, '', 'ssd-font-bold');
            }
            this.handsontable.render();
        }

        /**
         * 设置斜体字
         * @param {boolean} [value=true]
         * @param {object} selection - 待设置的选区
         * @param {int} selection.row
         * @param {int} selection.col
         * @param {int} [selection.endRow]
         * @param {int} [selection.endCol]
         */

    }, {
        key: 'setFontItalic',
        value: function setFontItalic() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            if (value) {
                this.spliceClass(selection, 'ssd-font-italic', 'ssd-font-italic');
            } else {
                this.spliceClass(selection, '', 'ssd-font-italic');
            }
            this.handsontable.render();
        }

        /**
         * 设置字体下划线
         * @param {boolean} [value=true]
         * @param selection - 待设置的选区
         * @param {int} selection.row
         * @param {int} selection.col
         * @param {int} [selection.endRow]
         * @param {int} [selection.endCol]
         */

    }, {
        key: 'setFontUnderline',
        value: function setFontUnderline() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            if (value) {
                this.spliceClass(selection, 'ssd-font-underline', 'ssd-font-underline');
            } else {
                this.spliceClass(selection, '', 'ssd-font-underline');
            }
            this.handsontable.render();
        }

        /**
         * 设置字体颜色
         * TIP 如果 “handontable 直接通过 getCell 获得 TD 后设置样式”，当再次 render 时会失效。
         * @param value
         * @param selection
         */

    }, {
        key: 'setFontColor',
        value: function setFontColor() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_color: value
                };
            }, { _style_color: value });
            this.handsontable.render();
        }

        /**
         * 字体类型
         * @param value
         * @param selection
         */

    }, {
        key: 'setFontFamily',
        value: function setFontFamily() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_fontFamily: value
                };
            }, { _style_fontFamily: value });
            this.handsontable.render();
        }

        /**
         * 字体大小
         * @param value - 需要指定单位，如 12px
         * @param selection
         */

    }, {
        key: 'setFontSize',
        value: function setFontSize(value) {
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_fontSize: value
                };
            }, { _style_fontSize: value });
            this.handsontable.render();
        }

        /**
         * 设置背景色
         * @param value
         * @param selection
         */

    }, {
        key: 'setBackgroundColor',
        value: function setBackgroundColor() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_backgroundColor: value
                };
            }, { _style_backgroundColor: value });
            this.handsontable.render();
        }

        /**
         * FIXME handsontable 的 BUG 尚未处理，源码复杂，一时也不好扩展。
         * 设置边框
         * @param range - 边框范围，形如 `{form: {row: 1, col: 1}, to: {row: 3, col: 4}}` 的对象
         * @param top - 上边框，形如 `{width: 2, color: '#5292F7'}` 的对象
         * @param [right]
         * @param [bottom]
         * @param [left]
         */

    }, {
        key: 'setBorder',
        value: function setBorder(range, top, right, bottom, left) {
            var config = {
                range: range,
                top: top
            };
            config.right = right || top;
            config.bottom = bottom || top;
            config.left = left || config.right;

            var formerBorders = this.handsontable.getSettings().customBorders;
            if (formerBorders === true) {
                formerBorders = [];
            }
            formerBorders.push(config);

            // TODO customBorders cannot be updated via updateSettings
            // @see {@link https://github.com/handsontable/handsontable/issues/2002}
            this.handsontable.updateSettings({
                customBorders: formerBorders
            });
            //this.handsontable.runHooks('afterInit');
        }

        /**
         * 设置数据格式
         *
         * @param type - `text` | `date` | `numeric`
         * @param settings
         * @param selection
         */

    }, {
        key: 'setDataFormat',
        value: function setDataFormat() {
            var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'text';
            var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var selection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getSelection();

            this._walkonCellMetas(selection, function (row, col, cellMeta) {
                var fType = cellMeta.type;

                if (fType === 'date') {
                    delete cellMeta.dateFormat;
                    delete cellMeta.defaultDate;
                    delete cellMeta.correctFormat;
                } else if (fType === 'numeric') {
                    delete cellMeta.format;
                    delete cellMeta.language;
                }
                cellMeta.type = type;

                // https://github.com/handsontable/handsontable/issues/4360
                delete cellMeta.renderer;
                delete cellMeta.editor;
                delete cellMeta.validator;
                return (0, _common.extend)(cellMeta, settings);
            }, { type: type });
            this.handsontable.render();
        }
    }]);

    return Sheet;
}((0, _Sheet_helper.SheetHelper)((0, _Sheet_exchange.Exchange)(_Emitter2.default)));

exports.default = Sheet;

/**
 * afterRename 事件。
 *
 * @event Sheet#afterRename
 * @type {Sheet}
 * @type {string}
 * @type {string}
 */

/**
 * afterRenameCancel 事件。
 *
 * @event Sheet#afterRenameCancel
 * @type {Sheet}
 * @type {string}
 * @type {string}
 */

},{"../utils/Emitter":58,"../utils/common":59,"./HotTableAdaptor":10,"./SheetError":12,"./ext/Sheet_exchange":14,"./ext/Sheet_helper":15}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SheetError = SheetError;

var _SpreadSheetError = require('../SpreadSheetError');

function SheetError(value) {
    this.name = 'SheetError';
    this.message = value;
}
SheetError.prototype = new _SpreadSheetError.SpreadSheetError();
SheetError.prototype.constructor = SheetError;

},{"../SpreadSheetError":5}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tabs = require('./views/Tabs');

var _Tabs2 = _interopRequireDefault(_Tabs);

var _Sheet = require('./Sheet');

var _Sheet2 = _interopRequireDefault(_Sheet);

var _SheetError = require('./SheetError');

var _dataStructure = require('../utils/dataStructure');

var _common = require('../utils/common');

var _settings = require('../settings');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var regExp = _settings.globalSettings.sheet.sheetName;

/**
 * 工作簿。一个 Workbook 包含一个或多个 Sheet .
 */

var Workbook = function () {

    /**
     * Workbook 构造器
     * @param {SpreadSheet} instance
     * @param {object} config
     */
    function Workbook(instance, config) {
        var _this = this;

        _classCallCheck(this, Workbook);

        /**
         * @type {SpreadSheet}
         */
        this.spreadSheet = instance;
        /**
         * @type {CaseInsensitiveMap}
         */
        this.sheets = new _dataStructure.CaseInsensitiveMap();
        this.settings = config;

        this._initSettings(config);
        this.$$view = new _Tabs2.default(this);

        config.sheets.forEach(function (v) {
            return _this.createSheet(v);
        });

        // 根据初始化数据激活 sheet 页
        var toActive = this.getSheet(this.activeSheet);
        if (!toActive) {
            throw new _SheetError.SheetError('\u6307\u5B9A\u7684 activeSheet \u4E0D\u5B58\u5728: ' + this.activeSheet);
        }
        toActive.active();
    }

    /**
     *
     * @param settings
     * @private
     */


    _createClass(Workbook, [{
        key: '_initSettings',
        value: function _initSettings(settings) {
            var keys = Object.keys(settings);
            for (var i = 0, len = keys.length; i < len; ++i) {
                if (keys[i] === 'sheets') {
                    continue;
                }
                this[keys[i]] = settings[keys[i]];
            }
        }

        /**
         * 获取 Workbook 所属的电子表格的用户初始配置。
         * @returns {Object}
         */

    }, {
        key: 'getSettings',
        value: function getSettings() {
            return this.spreadSheet.getSettings();
        }

        /**
         * 获取当前 Workbook 的 id
         * @returns {string}
         */

    }, {
        key: 'getId',
        value: function getId() {
            return this.id || (this.id = this.spreadSheet.getId() + _settings.globalSettings.idSuffix4Workbook);
        }

        /**
         * 根据指定 sheet 名获取 sheet 实例
         * @param name
         * @returns {Sheet}
         */

    }, {
        key: 'getSheet',
        value: function getSheet(name) {
            return this.sheets.get(name);
        }

        /**
         * 获取当前 Workbook 下的所有 sheet 实例
         * @returns {CaseInsensitiveMap}
         */

    }, {
        key: 'getSheets',
        value: function getSheets() {
            return this.sheets;
        }

        /**
         * 获取所有 sheet 的名字
         * @returns {Iterator.<string>}
         */

    }, {
        key: 'getSheetNames',
        value: function getSheetNames() {
            return this.sheets.keys();
        }

        /**
         * 检验 sheet 是否已存在
         * @param name
         * @param {boolean} [exactly=false] - 是否使用精确大小写的 name
         * @returns {boolean}
         */

    }, {
        key: 'isSheetExist',
        value: function isSheetExist(name, exactly) {
            if (exactly) {
                return this.sheets.hasExact(name);
            }
            // return !!this.getSheet(name);
            return this.sheets.has(name);
        }

        /**
         * 生成 sheet 索引
         * @private
         * @returns {number}
         */

    }, {
        key: '_getAutoSheetIndex',
        value: function _getAutoSheetIndex() {
            if (!this.$$autoSheetIndex) {
                this.$$autoSheetIndex = 0;
            }
            return ++this.$$autoSheetIndex; // 从 1 开始
        }

        /**
         * 自动生成 sheet 名
         * @returns {string}
         * @private
         */

    }, {
        key: '_getAutoSheetName',
        value: function _getAutoSheetName() {
            var prefix = _settings.globalSettings.sheet.autoPrefix + ''; // 防止出现数字相加
            var name = prefix + this._getAutoSheetIndex();
            if (this.isSheetExist(name)) {
                return this._getAutoSheetName();
            }
            return name;
        }

        /**
         * 获取当前激活的 sheet 页
         * @returns {Sheet}
         */

    }, {
        key: 'getActiveSheet',
        value: function getActiveSheet() {
            return this.sheets.get(this.activeSheet);
        }

        /**
         * 创建新的 sheet 页
         * @param {object} [config] - sheet 页的配置信息
         * @returns {Sheet} 新创建的工作表
         */

    }, {
        key: 'createSheet',
        value: function createSheet(config) {
            if (config) {
                // 根据初始配置创建，name 不能为空
                this._validateSheetName(config.name);
            } else {
                // 用户操作创建，动态生成 name
                config = {};
                config.name = this._getAutoSheetName();
            }
            var newOne = new _Sheet2.default(this, config);
            this.sheets.set(config.name, newOne);
            return newOne;
        }

        /**
         * 销毁指定 sheet 页
         * @param {string | Sheet} sheet - sheet 名称或实例
         */

    }, {
        key: 'destroySheet',
        value: function destroySheet(sheet) {
            if (typeof sheet === 'string') {
                sheet = this.getSheet(sheet);
            }
            sheet.destroy();
        }

        /**
         * 给指定的 sheet 页重命名
         * @param {string} name1 - 待重命名的 sheet 页名字
         * @param {string} name2 - 新名字
         */
        // FIXME 编辑错位：
        // handsontable 在选中某单元格但没进入编辑时，会监听 document 上的 keydown 事件，
        // 造成修改 sheet 名时的文本框无法正确处理（会输入到表格中）
        // 暂时使用 input 的 select 代替 focus，迫使用户再次点击sheet名时才能修改。

    }, {
        key: 'renameSheet',
        value: function renameSheet(name1, name2) {
            var sheet = this.getSheet(name1);
            if (!sheet) {
                throw new _SheetError.SheetError('\u5DE5\u4F5C\u8868 "' + name1 + '" \u4E0D\u5B58\u5728');
            }
            if (name1 !== name2) {
                this._validateSheetName(name2, (0, _common.upperCase)(name1) === (0, _common.upperCase)(name2));
                sheet.sheetName = name2;
                if (this.activeSheet === name1) {
                    this.activeSheet = name2;
                }
                this.getSheets().delete(name1);
                this.getSheets().set(name2, sheet);
                this.$$view.tabRename(name1, name2);
            } else {
                this.$$view.tabRenameCancel(name1, name2);
            }
        }

        /**
         * 关闭指定 sheet 页
         */

    }, {
        key: 'closeSheet',
        value: function closeSheet(name) {
            var sheet = this.getSheet(name);
            if (!sheet) {
                throw new _SheetError.SheetError('\u65E0\u6CD5\u5173\u95ED\u4E0D\u5B58\u5728\u7684\u5DE5\u4F5C\u8868 "' + name + '" \u3002');
            }
            if (this.sheets.size() === 1) {
                throw new _SheetError.SheetError('\u65E0\u6CD5\u5173\u95ED\u4EC5\u6709\u7684\u4E00\u4E2A\u5DE5\u4F5C\u8868 "' + name + '" \u3002');
            }
            if (sheet.isActive()) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.sheets.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var k = _step.value;

                        if (k && k !== name) {
                            this.activeSheet = k;
                            this.getSheet(k).active();
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            this.sheets.delete(name);
            this.$$view.removeTab(name);
            this.destroySheet(sheet);
        }

        /**
         * 激活当前 workbook
         */

    }, {
        key: 'active',
        value: function active() {
            this.getActiveSheet().active();
        }

        /**
         * 激活指定 sheet
         * @param {string} sheetName
         */

    }, {
        key: 'activeSheet',
        value: function activeSheet(sheetName) {
            var sheet = this.getSheet(sheetName);
            if (sheet) {
                sheet.active();
            }
        }

        /**
         * 验证 sheet 名是否合法
         * @param {string} name
         * @param {boolean} exactly
         * @private
         */

    }, {
        key: '_validateSheetName',
        value: function _validateSheetName(name, exactly) {
            if (!name) {
                throw new _SheetError.SheetError('工作表的名称不能为空');
            }
            //  禁止一些特殊字符
            if (regExp.test(name)) {
                throw new _SheetError.SheetError('\u5DE5\u4F5C\u8868 "' + name + '" \u5305\u542B\u975E\u6CD5\u5B57\u7B26');
            }
            if (this.isSheetExist(name, exactly)) {
                throw new _SheetError.SheetError('\u5DE5\u4F5C\u8868 "' + name + '" \u5DF2\u5B58\u5728');
            }
        }
    }, {
        key: '_getExchange',
        value: function _getExchange() {
            var sheets = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.getSheets().toMap()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _step2$value = _slicedToArray(_step2.value, 2),
                        sheet = _step2$value[1];

                    sheet && sheets.push(sheet._getExchange());
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return {
                activeSheet: this.activeSheet,
                sheets: sheets
            };
        }
    }]);

    return Workbook;
}();

exports.default = Workbook;

},{"../settings":57,"../utils/common":59,"../utils/dataStructure":60,"./Sheet":11,"./SheetError":12,"./views/Tabs":20}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Exchange = exports.Exchange = function Exchange(Sup) {
    return function (_Sup) {
        _inherits(_class, _Sup);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: '_getExchange',
            value: function _getExchange() {
                var _getDataMeta2 = this._getDataMeta(),
                    data = _getDataMeta2.data,
                    cells = _getDataMeta2.cells;

                var _getSizeEx2 = this._getSizeEx(),
                    heights = _getSizeEx2.heights,
                    widths = _getSizeEx2.widths;

                var mergeCells = this.handsontable.getSettings().mergeCells;

                if (mergeCells === false) {
                    mergeCells = null; // 避免强类型语言解析时无法处理动态类型
                }

                return {
                    name: this.getName(),
                    selection: this.getSelection(),
                    data: data.length ? data : []._,
                    rowHeights: heights,
                    colWidths: widths,
                    mergeCells: mergeCells,
                    cellMetas: cells
                };
            }
        }, {
            key: '_getStylesEx',
            value: function _getStylesEx(meta) {
                var ret = {};
                var alignments = this._getAlignmentEx(meta.className);
                if (alignments) {
                    ret.alignments = alignments;
                }
                this._getFontEx(meta, ret);
                this._getBgColorEx(meta, ret);
                return ret;
            }
        }, {
            key: '_getBgColorEx',
            value: function _getBgColorEx(meta, ret) {
                if (meta._style_backgroundColor) {
                    ret.backgroundColor = meta._style_backgroundColor;
                }
            }
        }, {
            key: '_getFontEx',
            value: function _getFontEx(meta, ret) {
                if (meta._style_fontFamily) {
                    ret.fontFamily = meta._style_fontFamily;
                }
                if (meta._style_fontSize) {
                    ret.fontSize = meta._style_fontSize;
                }
                if (meta.className && meta.className.contains('ssd-font-italic')) {
                    ret.fontStyle = 'italic';
                }
                if (meta.className && meta.className.contains('ssd-font-bold')) {
                    ret.fontWeight = 'bold';
                }
                if (meta.className && meta.className.contains('ssd-font-underline')) {
                    ret.textDecoration = 'underline';
                }
                if (meta._style_color) {
                    ret.color = meta._style_color;
                }
            }
        }, {
            key: '_getAlignmentEx',
            value: function _getAlignmentEx(className) {
                var alignment = [];
                if (className) {
                    className.contains('htLeft') && alignment.push('Left');
                    className.contains('htCenter') && alignment.push('Center');
                    className.contains('htRight') && alignment.push('Right');
                    className.contains('htJustify') && alignment.push('Justify');
                    className.contains('htTop') && alignment.push('Top');
                    className.contains('htMiddle') && alignment.push('Middle');
                    className.contains('htBottom') && alignment.push('Bottom');
                }
                return alignment.length ? alignment : false;
            }
        }, {
            key: '_getSizeEx',
            value: function _getSizeEx() {
                var hot = this.handsontable;
                var cols = Math.max(hot.countCols() - hot.countEmptyCols(true), 20);
                var rows = Math.max(hot.countRows() - hot.countEmptyRows(true), 50);
                var heights = [];
                var widths = [];

                for (var i = 0; i < rows; ++i) {
                    var h = hot.getRowHeight(i);
                    if (i === 0 && !h) {
                        // handsontable bug
                        h = 24;
                    }
                    heights.push(h);
                }
                for (var _i = 0; _i < cols; ++_i) {
                    widths.push(hot.getColWidth(_i));
                }
                return { heights: heights, widths: widths };
            }
        }, {
            key: '_getDataMeta',
            value: function _getDataMeta() {
                var hot = this.handsontable;
                var cols = hot.countCols() - hot.countEmptyCols(true);
                var rows = hot.countRows() - hot.countEmptyRows(true);
                var data = [];
                var cells = [];

                for (var i = 0; i < rows; ++i) {
                    var rowResult = [];
                    var rowCellMeta = [];

                    for (var j = 0; j < cols; ++j) {
                        var _sourceData = hot.getSourceDataAtCell(i, j);
                        var _meta = hot.getCellMeta(i, j);
                        var _data = hot.getDataAtCell(i, j);
                        var _cellMata = {};

                        _cellMata.row = i;
                        _cellMata.col = j;
                        _cellMata.isFormula = !!(_sourceData && (_sourceData + '').charAt(0) === '=');
                        _cellMata.sourceValue = _sourceData;
                        _cellMata.value = _data;

                        (function (o, m) {
                            //noinspection JSUnusedLocalSymbols,LoopStatementThatDoesntLoopJS
                            for (var x in o) {
                                m.styles = o;
                                return;
                            }
                        })(this._getStylesEx(_meta), _cellMata);

                        this._getDataType(_meta, _cellMata);

                        rowResult.push(_sourceData);
                        rowCellMeta.push(_cellMata);
                    }
                    data.push(rowResult);
                    cells.push(rowCellMeta);
                }
                return { data: data, cells: cells };
            }

            // TODO

        }, {
            key: '_getBordersEx',
            value: function _getBordersEx() {}

            // 数据格式 numeric、date 等

        }, {
            key: '_getDataType',
            value: function _getDataType(_meta, _cellMata) {
                var t = _meta.type;
                _cellMata.dataType = {};
                _cellMata.dataType.typeName = t;

                if (t === 'date') {
                    _cellMata.dataType.dateFormat = _meta.dateFormat;
                    _meta.defaultDate && (_cellMata.dataType.defaultDate = _meta.defaultDate);
                    _meta.correctFormat && (_cellMata.dataType.correctFormat = _meta.correctFormat);
                } else if (t === 'numeric') {
                    _cellMata.dataType.format = _meta.format;
                    _meta.language && (_cellMata.dataType.language = _meta.language);
                }
            }
        }]);

        return _class;
    }(Sup);
};

},{}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SheetHelper = exports.SheetHelper = function SheetHelper(Sup) {
    return function (_Sup) {
        _inherits(_class, _Sup);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: '_hack',


            // 这个方法用来完成一些填坑操作
            value: function _hack() {
                var hot = this.handsontable;

                // BUG FIXED -> https://github.com/handsontable/handsontable/issues/4375
                hot.addHook('beforeRemoveCol', function (index, amount) {
                    var mcr = hot.getPlugin('manualColumnResize');
                    var colWidths = [];
                    var i = index + amount,
                        j = void 0;
                    var len = hot.countCols();
                    for (; i < len; ++i) {
                        colWidths.push(hot.getColWidth(i));
                    }
                    for (i = 0, j = index, len = colWidths.length; i < len; ++i, ++j) {
                        mcr.setManualSize(j, colWidths[i]);
                    }
                });
                hot.addHook('beforeRemoveRow', function (index, amount) {
                    var mrr = hot.getPlugin('manualRowResize');
                    var rowHeights = [];
                    var i = index + amount,
                        j = void 0;
                    var len = hot.countRows();
                    for (; i < len; ++i) {
                        rowHeights.push(hot.getRowHeight(i));
                    }
                    for (i = 0, j = index, len = rowHeights.length; i < len; ++i, ++j) {
                        mrr.setManualSize(j, rowHeights[i]);
                    }
                });
            }

            // 选区默认值
            //   1. 选区可能从右下往左上选，此时 row > endRow
            //   2. endRow 及 endCol 可能不存在
            //（不需要关注选区方向时调用此方法进行预处理）

        }, {
            key: '_defaultSelection',
            value: function _defaultSelection(s) {
                s.row > s.endRow && (s.row = [s.endRow, s.endRow = s.row][0]);
                s.col > s.endCol && (s.col = [s.endCol, s.endCol = s.col][0]);

                return {
                    startRow: s.row,
                    endRow: s.endRow || s.row,
                    startCol: s.col,
                    endCol: s.endCol || s.col
                };
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_removeFormerClass',
            value: function _removeFormerClass(current) {
                if (!current) {
                    return '';
                }

                for (var _len = arguments.length, supported = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    supported[_key - 1] = arguments[_key];
                }

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = supported[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var clazz = _step.value;

                        current = current.split(clazz).join('');
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return current.trim();
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_walkonCellMetas',
            value: function _walkonCellMetas(selection, callback, unhold) {
                var _defaultSelection2 = this._defaultSelection(selection),
                    startRow = _defaultSelection2.startRow,
                    endRow = _defaultSelection2.endRow,
                    startCol = _defaultSelection2.startCol,
                    endCol = _defaultSelection2.endCol;

                for (var i = startRow; i <= endRow; ++i) {
                    for (var j = startCol; j <= endCol; ++j) {
                        var cellMeta = this.handsontable.getCellMeta(i, j);
                        if (cellMeta) {
                            var newMeta = callback.call(this, i, j, cellMeta);
                            newMeta && this.handsontable.setCellMetaObject(i, j, newMeta);
                        } else {
                            unhold && this.handsontable.setCellMetaObject(i, j, unhold);
                        }
                    }
                }
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_walkonCells',
            value: function _walkonCells(selection, callback) {
                var _defaultSelection3 = this._defaultSelection(selection),
                    startRow = _defaultSelection3.startRow,
                    endRow = _defaultSelection3.endRow,
                    startCol = _defaultSelection3.startCol,
                    endCol = _defaultSelection3.endCol;

                for (var i = startRow; i <= endRow; ++i) {
                    for (var j = startCol; j <= endCol; ++j) {
                        var cellTD = this.handsontable.getCell(i, j, true);
                        if (cellTD) {
                            callback.call(this, i, j, cellTD);
                        }
                    }
                }
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_walkonSelection',
            value: function _walkonSelection(selection, callback) {
                var _defaultSelection4 = this._defaultSelection(selection),
                    startRow = _defaultSelection4.startRow,
                    endRow = _defaultSelection4.endRow,
                    startCol = _defaultSelection4.startCol,
                    endCol = _defaultSelection4.endCol;

                for (var i = startRow; i <= endRow; ++i) {
                    for (var j = startCol; j <= endCol; ++j) {
                        callback.call(this, i, j);
                    }
                }
            }
        }]);

        return _class;
    }(Sup);
};

},{}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ContextMenu_alignment = require('./ContextMenu_alignment');

var _ContextMenu_mergeCells = require('./ContextMenu_mergeCells');

var _ContextMenu_rowOrColumnResize = require('./ContextMenu_rowOrColumnResize');

/**
 * 电子表格右键菜单。
 */
function ContextMenu(spreadSheet) {
    this.spreadSheet = spreadSheet;
    /**
     *
     * @type {Map}
     */
    this.menuItems = new Map();
    this._init();
}

exports.default = ContextMenu;


ContextMenu.prototype.register = function (key, config, handler) {
    this.menuItems.set(key, {
        config: config,
        handler: handler
    });
};

/**
 * 获取 handsontable 需要的菜单配置项
 */
ContextMenu.prototype.getMenuItems4HotTable = function () {
    var _this = this;

    if (!this._hotTableItems) {
        this._hotTableItems = {};
        this.menuItems.forEach(function (_ref, key) {
            var config = _ref.config;
            return _this._hotTableItems[key] = config;
        });
    }
    return this._hotTableItems;
};

/*
 ### handsontable 自带右键功能：###
 row_above
 row_below
 hsep1
 col_left
 col_right
 hsep2
 remove_row
 remove_col
 hsep3
 undo
 redo
 make_read_only
 alignment
 borders
 */
ContextMenu.prototype._init = function () {
    var SEP = '---------';

    this.register('row_above', {
        name: '上方插入一行',
        disabled: function disabled() {
            // 调用者要确保此处 this  为当前 hotTable 实例
            // TODO 限制最大行数
            return false;
        }
    });

    this.register('row_below', {
        name: '下方插入一行'
    });

    this.register('col_left', {
        name: '左侧插入一列'
    });

    this.register('col_right', {
        name: '右侧插入一列'
    });

    this.register('hsep_bt_insert', SEP);

    // FIXME handsontable 自带的删除功能，在存在单元格合并时有BUG，改成自定义逻辑。
    this.register('remove_row', {
        name: '删除选中行',
        disabled: function disabled() {
            // TODO 限制最小行数
            return false;
        }
    });
    this.register('remove_col', {
        name: '删除选中列'
    });

    this.register('hsep_bt_remove', SEP);

    this.register('alignment', (0, _ContextMenu_alignment.alignmentItem)());
    this.register('row_resize', _ContextMenu_rowOrColumnResize.rowResize, _ContextMenu_rowOrColumnResize.rowResizeHandler);
    this.register('col_resize', _ContextMenu_rowOrColumnResize.colResize, _ContextMenu_rowOrColumnResize.colResizeHandler);

    this.register('hsep_bt_format', SEP);

    this.register('q_merge_cells', _ContextMenu_mergeCells.mergeCells, _ContextMenu_mergeCells.mergeCellsHandler);
    this.register('q_cancel_merge_cells', _ContextMenu_mergeCells.cancelMergeCells, _ContextMenu_mergeCells.cancelMergeCellsHandler);
};

},{"./ContextMenu_alignment":17,"./ContextMenu_mergeCells":18,"./ContextMenu_rowOrColumnResize":19}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.alignmentItem = alignmentItem;

var _i18n = require('../../i18n');

// https://github.com/handsontable/handsontable/issues/3807
function alignmentItem() {
    return {
        name: _i18n.MENU.S5,
        disabled: function disabled() {
            return !(this.getSelectedRange() && !this.selection.selectedHeader.corner);
        },
        submenu: {
            items: [{
                key: 'alignment:left',
                name: function name() {
                    var _this = this;

                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this.getCellMeta(row, col).className;
                        if (className && className.indexOf('htLeft') !== -1) {
                            return true;
                        }
                    });
                    return hasClass ? markLabelAsSelected(_i18n.MENU.S6) : _i18n.MENU.S6;
                },
                callback: function callback() {
                    var _this2 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this2.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htLeft';
                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this2.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:center',
                name: function name() {
                    var _this3 = this;

                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this3.getCellMeta(row, col).className;
                        if (className && className.indexOf('htCenter') !== -1) {
                            return true;
                        }
                    });
                    return hasClass ? markLabelAsSelected(_i18n.MENU.S7) : _i18n.MENU.S7;
                },
                callback: function callback() {
                    var _this4 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this4.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htCenter';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this4.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:right',
                name: function name() {
                    var _this5 = this;

                    var label = _i18n.MENU.S8;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this5.getCellMeta(row, col).className;

                        if (className && className.indexOf('htRight') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this6 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this6.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htRight';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this6.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:justify',
                name: function name() {
                    var _this7 = this;

                    var label = _i18n.MENU.S9;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this7.getCellMeta(row, col).className;

                        if (className && className.indexOf('htJustify') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this8 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this8.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htJustify';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this8.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                name: '---------'
            }, {
                key: 'alignment:top',
                name: function name() {
                    var _this9 = this;

                    var label = _i18n.MENU.S10;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this9.getCellMeta(row, col).className;
                        if (className && className.indexOf('htTop') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }
                    return label;
                },
                callback: function callback() {
                    var _this10 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this10.getCellMeta(row, col).className;
                    });
                    var type = 'vertical';
                    var alignment = 'htTop';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this10.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:middle',
                name: function name() {
                    var _this11 = this;

                    var label = _i18n.MENU.S11;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this11.getCellMeta(row, col).className;

                        if (className && className.indexOf('htMiddle') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this12 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this12.getCellMeta(row, col).className;
                    });
                    var type = 'vertical';
                    var alignment = 'htMiddle';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this12.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:bottom',
                name: function name() {
                    var _this13 = this;

                    var label = _i18n.MENU.S12;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this13.getCellMeta(row, col).className;

                        if (className && className.indexOf('htBottom') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this14 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this14.getCellMeta(row, col).className;
                    });
                    var type = 'vertical';
                    var alignment = 'htBottom';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this14.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }]
        }
    };
}

function checkSelectionConsistency(range, comparator) {
    var result = false;
    if (range) {
        range.forAll(function (row, col) {
            if (comparator(row, col)) {
                result = true;
                return false;
            }
        });
    }
    return result;
}

function markLabelAsSelected(label) {
    return '<span class="selected">' + String.fromCharCode(10003) + '</span>' + label;
}

function getAlignmentClasses(range, callback) {
    var classes = {};
    for (var row = range.from.row; row <= range.to.row; row++) {
        for (var col = range.from.col; col <= range.to.col; col++) {
            if (!classes[row]) {
                classes[row] = [];
            }
            classes[row][col] = callback(row, col);
        }
    }
    return classes;
}

function align(range, type, alignment, cellDescriptor) {
    if (range.from.row === range.to.row && range.from.col === range.to.col) {
        applyAlignClassName(range.from.row, range.from.col, type, alignment, cellDescriptor);
    } else {
        for (var row = range.from.row; row <= range.to.row; row++) {
            for (var col = range.from.col; col <= range.to.col; col++) {
                applyAlignClassName(row, col, type, alignment, cellDescriptor);
            }
        }
    }
}

function applyAlignClassName(row, col, type, alignment, cellDescriptor) {
    var cellMeta = cellDescriptor(row, col);
    var className = alignment;

    if (cellMeta.className) {
        if (type === 'vertical') {
            className = prepareVerticalAlignClass(cellMeta.className, alignment);
        } else {
            className = prepareHorizontalAlignClass(cellMeta.className, alignment);
        }
    }

    // 之前的样式名拼接方式，如果存在 hot 以外自定义样式时，会产生BUG # 8/14/2017
    // 代码是 copy Hansontable 后改的，其实用 classArray 来处理这类问题更方便一些
    cellMeta.className = className.trim().split(/^|\s+/).join(' ');
}

function prepareVerticalAlignClass(className, alignment) {
    if (className.indexOf(alignment) !== -1) {
        return className;
    }
    className = className.replace('htTop', '').replace('htMiddle', '').replace('htBottom', '');

    className += ' ' + alignment;
    return className;
}

function prepareHorizontalAlignClass(className, alignment) {
    if (className.indexOf(alignment) !== -1) {
        return className;
    }
    className = className.replace('htLeft', '').replace('htCenter', '').replace('htRight', '').replace('htJustify', '');

    className += ' ' + alignment;
    return className;
}

},{"../../i18n":21}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cancelMergeCells = exports.mergeCells = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.mergeCellsHandler = mergeCellsHandler;
exports.cancelMergeCellsHandler = cancelMergeCellsHandler;

var _common = require('../../utils/common');

var _i18n = require('../../i18n');

var mergeCells = exports.mergeCells = {
    name: _i18n.MENU.S3,
    disabled: function disabled() {
        var _getSelected = this.getSelected(),
            _getSelected2 = _slicedToArray(_getSelected, 4),
            r1 = _getSelected2[0],
            c1 = _getSelected2[1],
            r2 = _getSelected2[2],
            c2 = _getSelected2[3];

        if (r1 === r2 && c1 === c2) {
            return true;
        }
        return !mergeCompare.call(this, 'isEqual');
    }
};

function mergeCellsHandler(sheet, start, end) {
    sheet.mergeCells(start.row, start.col, end.row - start.row + 1, end.col - start.col + 1);
}

var cancelMergeCells = exports.cancelMergeCells = {
    name: _i18n.MENU.S4,
    disabled: function disabled() {
        return mergeCompare.call(this, 'isSubset');
    }
};

function cancelMergeCellsHandler(sheet, start, end) {
    sheet.unMergeCells(start.row, start.col, end.row - start.row + 1, end.col - start.col + 1);
}

function mergeCompare(type) {
    var merged = this.getSettings().mergeCells;
    if (merged && merged.length) {
        for (var i = 0; i < merged.length; ++i) {
            var _merged$i = merged[i],
                row = _merged$i.row,
                col = _merged$i.col,
                rowspan = _merged$i.rowspan,
                colspan = _merged$i.colspan;

            if (_common.Coordinate[type]([row, col, row + rowspan - 1, col + colspan - 1], convertSelection(this.getSelected()))) {
                return false;
            }
        }
    }
    return true;
}

function convertSelection(s) {
    s[0] > s[2] && (s[0] = [s[2], s[2] = s[0]][0]);
    s[1] > s[3] && (s[1] = [s[3], s[3] = s[1]][0]);
    return s;
}

},{"../../i18n":21,"../../utils/common":59}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.colResize = exports.rowResize = undefined;
exports.rowResizeHandler = rowResizeHandler;
exports.colResizeHandler = colResizeHandler;

var _i18n = require('../../i18n');

// FIXME hot 处理 rowHeights/colWidths 与 manualRowResize/manualColumnResize 时存在缺陷
// https://github.com/handsontable/handsontable/issues/3301
// https://github.com/handsontable/handsontable/issues/4371
var rowResize = exports.rowResize = {
    name: _i18n.MENU.S1,
    hidden: function hidden() {
        return !this.getSelectedRange() || !this.selection.selectedHeader.rows;
    }
};

function rowResizeHandler(sheet, start, end) {
    var height = []._;

    start.row > end.row && (start.row = [end.row, end.row = start.row][0]);

    for (var i = start.row; i <= end.row; ++i) {
        if (!height) {
            height = sheet.handsontable.getRowHeight(i);
        } else if (height !== sheet.handsontable.getRowHeight(i)) {
            height = false;
            break;
        }
    }

    var val = height === false ? '' : height || 24;

    if (_UIProvider.prompt) {
        _UIProvider.prompt(_i18n.MENU.S13, val, function (result) {
            if (result) {
                setRowHeights(sheet, start.row, end.row, result);
            }
        });
    } else {
        var contextMenu = sheet.handsontable.getPlugin('contextMenu');
        contextMenu.close();
        var result = prompt(_i18n.MENU.S13, val);
        if (result !== null) {
            setRowHeights(sheet, start.row, end.row, result);
        }
    }
}

var colResize = exports.colResize = {
    name: _i18n.MENU.S2,
    hidden: function hidden() {
        return !this.getSelectedRange() || !this.selection.selectedHeader.cols;
    }
};

function colResizeHandler(sheet, start, end) {
    var width = []._;

    start.col > end.col && (start.col = [end.col, end.col = start.col][0]);

    for (var i = start.col; i <= end.col; ++i) {
        if (!width) {
            width = sheet.handsontable.getColWidth(i);
        } else if (width !== sheet.handsontable.getColWidth(i)) {
            width = false;
            break;
        }
    }

    var val = width === false ? '' : width || 50;

    if (_UIProvider.prompt) {
        _UIProvider.prompt(_i18n.MENU.S14, val, function (result) {
            if (result) {
                setColWidths(sheet, start.col, end.col, result);
            }
        });
    } else {
        var contextMenu = sheet.handsontable.getPlugin('contextMenu');
        contextMenu.close();
        var result = prompt(_i18n.MENU.S14, val);
        if (result !== null) {
            setColWidths(sheet, start.col, end.col, result);
        }
    }
}

function setRowHeights(sheet, start, end, value) {
    value = numbro().unformat(value) || 24;
    var rowHeights = sheet.handsontable.getSettings().rowHeights || [];
    for (var i = start; i <= end; ++i) {
        rowHeights[i] = value;
    }
    sheet.handsontable.updateSettings({ rowHeights: rowHeights });
}

function setColWidths(sheet, start, end, value) {
    value = numbro().unformat(value) || 50;
    var colWidths = sheet.handsontable.getSettings().colWidths || [];
    for (var i = start; i <= end; ++i) {
        colWidths[i] = value;
    }
    sheet.handsontable.updateSettings({ colWidths: colWidths });
}

},{"../../i18n":21}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _domHelper = require('../../utils/domHelper.js');

var _common = require('../../utils/common.js');

var _dataStructure = require('../../utils/dataStructure.js');

var _eventHelper = require('../../utils/eventHelper.js');

var _settings = require('../../settings.js');

var _i18n = require('../../i18n');

var _SheetError = require('.././SheetError');

var CLASS_CURRENT = 'current';
var CLASS_TABS = 'ssd-tabs';
var CLASS_CONTENT = 'ssd-tabs-content';
var CLASS_SECTION = 'ssd-tabs-section';
var CLASS_NAV = 'ssd-tabs-nav';
var CLASS_UL = 'ssd-tabs-ul';
var CLASS_LI = 'ssd-tabs-li';
var CLASS_FX = 'ssd-tabs-fx';

var animated = _settings.globalSettings.sheet.animated;
var regExp = _settings.globalSettings.sheet.sheetName;

/**
 * workbook 对应的视图，实际的 DOM 构成。
 * @private
 * @param {Workbook} workbook
 * @constructor
 */
function Tabs(workbook) {
    this.workbook = workbook;
    /**
     * @type {CaseInsensitiveMap}
     */
    this.liItems = new _dataStructure.CaseInsensitiveMap();
    this.sectionItems = new _dataStructure.CaseInsensitiveMap();
    this._hotTables = new Map();
    this.rootElement = workbook.spreadSheet.getRootElement();
    this.displayMode = workbook.spreadSheet.getDisplayMode();

    this.initDOM();
    this.initBox();
    this.render();
}

Tabs.prototype.render = function () {
    this.rootElement.appendChild(this.TABS);
};

/**
 * @private
 */
Tabs.prototype.initDOM = function () {
    this.TABS = document.createElement('div');
    this.CONTENT = document.createElement('div');
    this.NAV = document.createElement('nav');
    this.UL = document.createElement('ul');

    this.TABS.classList.add(CLASS_TABS);
    this.TABS.id = this.workbook.getId();
    this.CONTENT.classList.add(CLASS_CONTENT);
    this.NAV.classList.add(CLASS_NAV);
    this.UL.classList.add(CLASS_UL);

    this.TABS.appendChild(this.CONTENT);
    this.TABS.appendChild(this.NAV);
    this.NAV.appendChild(this.UL);

    // 增加 sheet 页的 button
    this.appendAddButton();
};

/**
 * @private
 */
Tabs.prototype.initBox = function () {
    var rootEl = this.workbook.spreadSheet.getRootElement();
    this.width = this.workbook.width || (0, _domHelper.outerWidth)(rootEl, false);
    this.height = this.workbook.height || (0, _domHelper.outerHeight)(rootEl, false);

    this.TABS.style.width = this.width + 'px';
    this.TABS.style.height = this.height + 'px';
};

/**
 * 增加一个 tab 页
 * @param {string} sheetName - sheet 名， 即 tab 页的标题
 */
Tabs.prototype.appendTab = function (sheetName) {
    var that = this;
    var li = document.createElement('li');
    var clazz = this.displayMode ? '' : 'close hairline';

    li.innerHTML = '\n        <a href="javascript:;">\n            <span>' + sheetName + '</span>\n            <span class="' + clazz + '"></span>\n        </a>\n    ';
    li.classList.add(CLASS_LI);
    li.setAttribute('data-sheet', sheetName);

    var activeTab = this.TABS.querySelector('.' + CLASS_CURRENT + '.' + CLASS_LI);
    if (activeTab) {
        (0, _domHelper.insertAfter)(activeTab, li);
    } else {
        this.UL.appendChild(li);
    }
    this.liItems.set(sheetName, li);

    li.addEventListener('click', function (e) {
        var sheetName = this.dataset.sheet;
        var sheet = that.workbook.getSheet(sheetName);
        sheet.active();
        (0, _eventHelper.stopImmediatePropagation)(e);
    });

    if (!this.displayMode) {
        li.addEventListener('dblclick', function (e) {
            that._onTabDblclick.call(that, this);
            (0, _eventHelper.stopImmediatePropagation)(e);
        });

        li.querySelector('.close').addEventListener('click', function (e) {
            var sheetName = li.dataset.sheet;
            try {
                that.workbook.closeSheet(sheetName);
            } catch (e) {
                if (e instanceof _SheetError.SheetError) {
                    alert(e.message);
                } else {
                    throw e;
                }
            }
            (0, _eventHelper.stopImmediatePropagation)(e);
        });
    }

    this.appendContent(sheetName);
};

/**
 * 增加一个 tab 页
 * @param {string} sheetName - sheet 名， 即 tab 页的标题
 */
Tabs.prototype.removeTab = function (sheetName) {
    var li = this.liItems.get(sheetName);
    this.UL.removeChild(li);
    this.liItems.delete(sheetName);

    this.removeContent(sheetName);
};

Tabs.prototype.appendAddButton = function () {
    var that = this;
    var li = document.createElement('li');
    var innerHtml = this.displayMode ? '&nbsp;' : '+';

    li.innerHTML = '<a href="javascript:;"><span>' + innerHtml + '</span></a>';
    li.classList.add(CLASS_LI);
    if (!this.displayMode) {
        li.classList.add('add-tab');
    }
    this.UL.appendChild(li);

    if (!this.displayMode) {
        li.addEventListener('click', function () {
            try {
                var newSheet = that.workbook.createSheet();
                newSheet.active();
            } catch (e) {
                if (e instanceof _SheetError.SheetError) {
                    alert(e.message);
                } else {
                    throw e;
                }
            }
        });
    }
};

/**
 * @param {HTMLElement} li
 * @private
 */
Tabs.prototype._onTabDblclick = function (li) {
    var that = this;
    var sheetName = li.dataset.sheet;
    var span = li.getElementsByTagName('span')[0];
    var input = document.createElement('input');

    input.setAttribute('type', 'text');
    input.value = sheetName;
    input.classList.add('editorial');
    input.style.width = (0, _domHelper.outerWidth)(span) + 20 + 'px'; // 名字太短时不好输入，增补20px

    input.addEventListener('blur', function () {
        var check = that._checkTabName(sheetName, this.value);
        if (check === true) {
            that.workbook.renameSheet(sheetName, this.value);
        } else {
            alert(check); // TODO alert 太丑
            that.tabRenameCancel(sheetName, this.value);
        }
    });
    input.addEventListener('keypress', function (event) {
        if (event.keyCode === 13) {
            this.blur();
        }
    });

    (0, _domHelper.empty)(span);
    span.appendChild(input);
    input.select();
};

Tabs.prototype._checkTabName = function (name1, name2) {
    if ((0, _common.isEmptyValue)(name2)) {
        return _i18n.WARNS.S1;
    }
    if (regExp.test(name2)) {
        return _i18n.WARNS.S2;
    }
    // 改成其它已有的sheet名
    if ((0, _common.upperCase)(name1) !== (0, _common.upperCase)(name2) && this.workbook.isSheetExist(name2)) {
        return _i18n.WARNS.S3;
    }
    return true;
};

// 改名时，DOM上的一些操作，进入此方法时代表已经做了合法验证。
Tabs.prototype.tabRename = function (name1, name2) {
    var li = this.liItems.get(name1);
    var span = li.getElementsByTagName('span')[0];
    (0, _domHelper.innerHTML)(span, name2);
    li.dataset.sheet = name2;
    this.liItems.set(name2, li);
    var section = this.sectionItems.get(name1);
    section.dataset.sheet = name2;
    this.sectionItems.delete(name1);
    this.sectionItems.set(name2, section);

    var sheetNow = this.workbook.getSheet(name2);
    sheetNow.emit('afterRename', sheetNow, name1, name2);
};

// 更名失败，将名字设为 name1, name2为失败的名字
Tabs.prototype.tabRenameCancel = function (name1, name2) {
    var li = this.liItems.get(name1);
    var span = li.getElementsByTagName('span')[0];
    (0, _domHelper.innerHTML)(span, name1);

    var sheetNow = this.workbook.getSheet(name1);
    sheetNow.emit('afterRenameCancel', sheetNow, name1, name2);
};

/**
 * 增加标签页对应的内容
 * @param {string} sheetName
 */
Tabs.prototype.appendContent = function (sheetName) {
    var section = document.createElement('section');
    var fx = document.createElement('div');
    var hot = document.createElement('div');

    section.setAttribute('data-sheet', sheetName);
    section.appendChild(fx);
    section.appendChild(hot);
    section.classList.add(CLASS_SECTION);
    animated && section.classList.add('ssd-animated-fast');

    this.CONTENT.appendChild(section);
    this.sectionItems.set(sheetName, section);

    this.appendFx(fx, sheetName);
    this.appendTable(hot, sheetName);
};

Tabs.prototype.removeContent = function (sheetName) {
    var section = this.sectionItems.get(sheetName);
    this.CONTENT.removeChild(section);
    this.sectionItems.delete(sheetName);
};

/**
 *
 * @param {string} sheetName
 */
Tabs.prototype.hideContent = function (sheetName) {
    var section = this.sectionItems.get(sheetName);
    section.style.display = 'none';
};

/**
 * TODO 公式输入框
 * @private
 * @param {HTMLElement} fx
 * @param {string} sheetName
 */
Tabs.prototype.appendFx = function (fx, sheetName) {
    fx.classList.add(CLASS_FX);
    fx.classList.add(CLASS_FX + '-' + sheetName);
};

/**
 * 假渲染 Hansontable 组件。
 * handsontable 的设计无法在DOM中计算视图，必须渲染rootElement之后才能生效。
 * 导致延迟渲染难以实现，有渲染性能问题时再解决。
 * 另外，渲染到先隐藏后显示的元素中时，也无法正常显示。
 * @private
 * @param hot
 * @param sheetName
 */
Tabs.prototype.appendTable = function (hot, sheetName) {
    var _this = this;

    this._hotTables.set(sheetName, {
        container: hot,
        width: this.width,
        height: function height() {
            return _this.height - (0, _domHelper.outerHeight)(_this.NAV);
        }
    });
};

/**
 * 激活指定的标签页
 * @param {string} sheetName - sheet 名
 */
Tabs.prototype.activeTab = function (sheetName) {
    var former = this.TABS.querySelector('.' + CLASS_CURRENT + '.' + CLASS_LI);
    former && former.classList.remove(CLASS_CURRENT);
    var li = this.liItems.get(sheetName);
    li.classList.add(CLASS_CURRENT);
    this.activeContent(sheetName);
};

/**
 * @private
 * @param {string} sheetName - sheet 名
 */
Tabs.prototype.activeContent = function (sheetName) {
    var section = this.sectionItems.get(sheetName);
    var former = this._formerActiveContent;
    if (former) {
        animated && former.classList.remove('fadeIn');
        former.style.display = 'none';
    }
    section.style.display = 'block';
    animated && section.classList.add('fadeIn');

    this._formerActiveContent = section;
};

exports.default = Tabs;

},{"../../i18n":21,"../../settings.js":57,"../../utils/common.js":59,"../../utils/dataStructure.js":60,"../../utils/domHelper.js":61,"../../utils/eventHelper.js":62,".././SheetError":12}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var WARNS = exports.WARNS = {
    S1: '工作表名不能为空白。',
    S2: '\u5DE5\u4F5C\u8868\u540D\u79F0\u5305\u542B\u65E0\u6548\u5B57\u7B26: :  / ? * [ ]\u3002',
    S3: '该名称已被使用，请尝试其他名称。'
};

var MENU = exports.MENU = {
    S1: '行高...',
    S2: '列宽...',
    S3: '单元格合并',
    S4: '取消单元格合并',
    S5: '对齐',
    S6: '左对齐',
    S7: '水平居中',
    S8: '右对齐',
    S9: '两端对齐',
    S10: '顶部对齐',
    S11: '垂直居中',
    S12: '底部对齐',
    S13: '请输入行高',
    S14: '请输入列宽'
};

},{}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Plugin = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.validatePlugin = validatePlugin;
exports.registerPlugin = registerPlugin;
exports.getPlugin = getPlugin;
exports.getAllPlugins = getAllPlugins;

var _PluginError = require('./PluginError');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _plugins = new Map();

/**
 * 插件基类
 */

var Plugin = function () {

    /**
     *
     * @param {SpreadSheet} spreadSheet
     */
    function Plugin(spreadSheet) {
        _classCallCheck(this, Plugin);

        /**
         * @type {SpreadSheet}
         */
        this.spreadsheet = spreadSheet;
        this.enabled = false;
    }

    // 暂时不考虑开放这个方法，用户定义的插件不能扩展 SpreadSheet 的 API


    _createClass(Plugin, [{
        key: '_registerMethod',
        value: function _registerMethod(name) {
            var _this = this;

            var proto = this.spreadsheet.constructor.prototype;
            proto[name] = function () {
                return _this[name]();
            };
        }
    }, {
        key: 'isEnable',
        value: function isEnable() {
            return false;
        }
    }, {
        key: 'enable',
        value: function enable() {}
    }, {
        key: 'destroy',
        value: function destroy() {}
    }]);

    return Plugin;
}();

exports.Plugin = Plugin;
function validatePlugin(p) {
    if (!p.enable) {
        throw new _PluginError.PluginError('插件必须包含启用方法：enable');
    }
    if (!p.destroy) {
        throw new _PluginError.PluginError('插件必须包含销毁方法：destroy');
    }
}

function registerPlugin(name, plugin) {
    _plugins.set(name, plugin);
    plugin.prototype.__name__ = name;
}

function getPlugin(name) {
    var p = _plugins.get(name);
    if (!p) {
        throw new _PluginError.PluginError('插件不存在：' + name);
    }
    return p;
}

/**
 * 获取所有插件
 * @returns {Map}
 */
function getAllPlugins() {
    return _plugins;
}

},{"./PluginError":23}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PluginError = PluginError;

var _SpreadSheetError = require('../SpreadSheetError');

function PluginError(value) {
    this.name = 'PluginError';
    this.message = value;
}
PluginError.prototype = new _SpreadSheetError.SpreadSheetError();
PluginError.prototype.constructor = PluginError;

},{"../SpreadSheetError":5}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Plugin2 = require('../Plugin');

var _Storage = require('./Storage');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Persistent = function (_Plugin) {
    _inherits(Persistent, _Plugin);

    function Persistent(ssd) {
        _classCallCheck(this, Persistent);

        var _this = _possibleConstructorReturn(this, (Persistent.__proto__ || Object.getPrototypeOf(Persistent)).call(this, ssd));

        var settings = _this.spreadsheet.settings;

        if (settings.persistent === true) {
            // persistent 为 `true` 时，使用默认方案
            /**
             * 电子表格本地持久化时使用的 key
             */
            _this.persistentKey = ssd.getId();
        } else {
            // TODO persistent 为对象时，提供 localStorage、session 等方案及超时时间等相关配置
            _this.persistentKey = settings.persistent.key;
        }

        _this.spreadsheet.settings = _Storage.Storage.load(_this.persistentKey) || settings;

        _this._registerMethod('saveState');
        return _this;
    }

    _createClass(Persistent, [{
        key: 'isEnable',
        value: function isEnable() {
            return !!this.spreadsheet.getSettings().persistent;
        }
    }, {
        key: 'enable',
        value: function enable() {
            _get(Persistent.prototype.__proto__ || Object.getPrototypeOf(Persistent.prototype), 'enable', this).call(this);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            _get(Persistent.prototype.__proto__ || Object.getPrototypeOf(Persistent.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'saveState',
        value: function saveState() {
            var data = this.spreadsheet.getExchangeData();
            _Storage.Storage.save(this.persistentKey, data);
        }
    }]);

    return Persistent;
}(_Plugin2.Plugin);

exports.default = Persistent;

},{"../Plugin":22,"./Storage":25}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 存储方案
 */
var Storage = function () {
    function Storage() {
        _classCallCheck(this, Storage);
    }

    _createClass(Storage, null, [{
        key: 'save',
        value: function save(key, value) {
            if (typeof value !== 'string') {
                value = JSON.stringify(value);
            }
            window.localStorage.setItem(Storage.PREFIX + key, value);
        }
    }, {
        key: 'load',
        value: function load(key) {
            var val = window.localStorage.getItem(Storage.PREFIX + key);
            try {
                return JSON.parse(val);
            } catch (e) {
                return val;
            }
        }
    }, {
        key: 'remove',
        value: function remove(key) {
            if (window.localStorage[Storage.PREFIX + key]) {
                window.localStorage.removeItem(Storage.PREFIX + key);
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            window.localStorage.clear();
        }
    }]);

    return Storage;
}();

Storage.PREFIX = '$$brick!storage-';

exports.Storage = Storage;

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AlterManager = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

var _utils = require('./utils');

var _expressionModifier = require('./expressionModifier');

var _localHooks = require('../../utils/localHooks');

var _localHooks2 = _interopRequireDefault(_localHooks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var mixin = Handsontable.helper.mixin;

var AlterManager = function () {
    function AlterManager(sheet) {
        _classCallCheck(this, AlterManager);

        this.sheet = sheet;

        this.dataProvider = sheet.dataProvider;

        this.matrix = sheet.matrix;
    }

    _createClass(AlterManager, [{
        key: 'insertRow',
        value: function insertRow(row, amount, modifyFormula) {
            this._alter('insert', 'row', row, amount, modifyFormula);
        }
    }, {
        key: 'removeRow',
        value: function removeRow(row, amount, modifyFormula) {
            this._alter('remove', 'row', row, -amount, modifyFormula);
        }
    }, {
        key: 'insertColumn',
        value: function insertColumn(column, amount, modifyFormula) {
            this._alter('insert', 'column', column, amount, modifyFormula);
        }
    }, {
        key: 'removeColumn',
        value: function removeColumn(column, amount, modifyFormula) {
            this._alter('remove', 'column', column, -amount, modifyFormula);
        }
    }, {
        key: '_alter',
        value: function _alter(action, axis, start, amount) {
            var _this = this;

            var modifyFormula = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

            var startCoord = function startCoord(cell) {
                return {
                    row: axis === 'row' ? start : cell.row,
                    column: axis === 'column' ? start : cell.column
                };
            };
            var translateCellRefs = function translateCellRefs(row, column) {
                arrayEach(_this.matrix.cellReferences, function (cell) {
                    if (cell[axis] >= start) {
                        cell.translateTo(row, column);
                    }
                });
            };

            var translate = [];
            var indexOffset = Math.abs(amount) - 1;

            if (axis === 'row') {
                translate.push(amount, 0);
            } else if (axis === 'column') {
                translate.push(0, amount);
            }

            if (action === 'remove') {
                (function () {
                    var removedCellRef = _this.matrix.removeCellRefsAtRange(_defineProperty({}, axis, start), _defineProperty({}, axis, start + indexOffset));
                    var toRemove = [];

                    arrayEach(_this.matrix.data, function (cell) {
                        arrayEach(removedCellRef, function (cellRef) {
                            if (!cell.hasPrecedent(cellRef)) {
                                return;
                            }

                            cell.removePrecedent(cellRef);
                            cell.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);

                            arrayEach(_this.sheet.getCellDependencies(cell.row, cell.column), function (cellValue) {
                                cellValue.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
                            });
                        });

                        if (cell[axis] >= start && cell[axis] <= start + indexOffset) {
                            toRemove.push(cell);
                        }
                    });

                    _this.matrix.remove(toRemove);
                })();
            }

            translateCellRefs.apply(undefined, translate);

            arrayEach(this.matrix.data, function (cell) {
                var origRow = cell.row;
                var origColumn = cell.column;

                if (cell[axis] >= start) {
                    cell.translateTo.apply(cell, translate);
                    cell.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
                }

                if (modifyFormula) {
                    var row = cell.row;
                    var column = cell.column;
                    var value = _this.dataProvider.getSourceDataAtCell(row, column);

                    if ((0, _utils.isFormulaExpression)(value)) {
                        var expModifier = new _expressionModifier.ExpressionModifier(value);

                        expModifier.translate(startCoord({ row: origRow, column: origColumn }), _defineProperty({}, axis, amount));

                        _this.dataProvider.updateSourceData(row, column, expModifier.toString());
                    }
                }
            });
            this.runLocalHooks('afterAlter', action, axis, start, amount);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.sheet = null;
            this.dataProvider = null;
            this.matrix = null;
        }
    }]);

    return AlterManager;
}();

mixin(AlterManager, _localHooks2.default);

exports.AlterManager = AlterManager;

},{"../../utils/localHooks":63,"./CellValue":29,"./expressionModifier":35,"./utils":55}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./parser/utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var isObject = Handsontable.helper.isObject;

var BaseCell = function () {
    function BaseCell(row, column) {
        _classCallCheck(this, BaseCell);

        var rowObject = isObject(row);
        var columnObject = isObject(column);

        this._row = rowObject ? row.index : row;
        this.rowAbsolute = rowObject ? row.isAbsolute : false;
        this._column = columnObject ? column.index : column;
        this.columnAbsolute = columnObject ? column.isAbsolute : false;
        this.rowOffset = 0;
        this.columnOffset = 0;

        Object.defineProperty(this, 'row', {
            get: function get() {
                return this.rowOffset + this._row;
            },
            set: function set(row) {
                this._row = row;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(this, 'column', {
            get: function get() {
                return this.columnOffset + this._column;
            },
            set: function set(column) {
                this._column = column;
            },
            enumerable: true,
            configurable: true
        });
    }

    _createClass(BaseCell, [{
        key: 'translateTo',
        value: function translateTo(rowOffset, columnOffset) {
            this.row = this.row + rowOffset;
            this.column = this.column + columnOffset;
        }
    }, {
        key: 'isEqual',
        value: function isEqual(cell) {
            return cell.row === this.row && cell.column === this.column;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return (0, _utils.toLabel)({ index: this.row, isAbsolute: this.rowAbsolute }, { index: this.column, isAbsolute: this.columnAbsolute });
        }
    }]);

    return BaseCell;
}();

exports.default = BaseCell;

},{"./parser/utils":54}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CellReference = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseCell2 = require('./BaseCell');

var _BaseCell3 = _interopRequireDefault(_BaseCell2);

var _utils = require('./parser/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CellReference = function (_BaseCell) {
    _inherits(CellReference, _BaseCell);

    function CellReference(row, column) {
        _classCallCheck(this, CellReference);

        return _possibleConstructorReturn(this, (CellReference.__proto__ || Object.getPrototypeOf(CellReference)).call(this, row, column));
    }

    _createClass(CellReference, [{
        key: 'toString',
        value: function toString() {
            return (0, _utils.toLabel)({ index: this.row, isAbsolute: false }, { index: this.column, isAbsolute: false });
        }
    }]);

    return CellReference;
}(_BaseCell3.default);

exports.CellReference = CellReference;

},{"./BaseCell":27,"./parser/utils":54}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CellValue = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseCell2 = require('./BaseCell');

var _BaseCell3 = _interopRequireDefault(_BaseCell2);

var _error = require('./parser/error');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var STATE_OUT_OFF_DATE = 1;
var STATE_COMPUTING = 2;
var STATE_UP_TO_DATE = 3;
var states = [STATE_OUT_OFF_DATE, STATE_COMPUTING, STATE_UP_TO_DATE];

var arrayFilter = Handsontable.helper.arrayFilter;

var CellValue = function (_BaseCell) {
    _inherits(CellValue, _BaseCell);

    _createClass(CellValue, null, [{
        key: 'STATE_OUT_OFF_DATE',
        get: function get() {
            return 1;
        }
    }, {
        key: 'STATE_COMPUTING',
        get: function get() {
            return 2;
        }
    }, {
        key: 'STATE_UP_TO_DATE',
        get: function get() {
            return 3;
        }
    }]);

    function CellValue(row, column) {
        _classCallCheck(this, CellValue);

        var _this = _possibleConstructorReturn(this, (CellValue.__proto__ || Object.getPrototypeOf(CellValue)).call(this, row, column));

        _this.precedents = [];
        _this.value = null;
        _this.error = null;
        _this.state = CellValue.STATE_UP_TO_DATE;
        return _this;
    }

    _createClass(CellValue, [{
        key: 'setValue',
        value: function setValue(value) {
            this.value = value;
        }
    }, {
        key: 'getValue',
        value: function getValue() {
            return this.value;
        }
    }, {
        key: 'setError',
        value: function setError(error) {
            this.error = error;
        }
    }, {
        key: 'getError',
        value: function getError() {
            return this.error;
        }
    }, {
        key: 'hasError',
        value: function hasError() {
            return this.error !== null;
        }
    }, {
        key: 'setState',
        value: function setState(state) {
            if (states.indexOf(state) === -1) {
                throw '\u672A\u77E5\u72B6\u6001: ' + state;
            }
            this.state = state;
        }
    }, {
        key: 'isState',
        value: function isState(state) {
            return this.state === state;
        }
    }, {
        key: 'addPrecedent',
        value: function addPrecedent(cellReference) {
            if (this.isEqual(cellReference)) {
                throw Error(_error.ERROR_REF);
            }
            if (!this.hasPrecedent(cellReference)) {
                this.precedents.push(cellReference);
            }
        }
    }, {
        key: 'removePrecedent',
        value: function removePrecedent(cellReference) {
            if (this.isEqual(cellReference)) {
                throw Error(_error.ERROR_REF);
            }
            this.precedents = arrayFilter(this.precedents, function (cell) {
                return !cell.isEqual(cellReference);
            });
        }
    }, {
        key: 'getPrecedents',
        value: function getPrecedents() {
            return this.precedents;
        }
    }, {
        key: 'hasPrecedents',
        value: function hasPrecedents() {
            return this.precedents.length > 0;
        }
    }, {
        key: 'hasPrecedent',
        value: function hasPrecedent(cellReference) {
            return arrayFilter(this.precedents, function (cell) {
                return cell.isEqual(cellReference);
            }).length ? true : false;
        }
    }]);

    return CellValue;
}(_BaseCell3.default);

exports.CellValue = CellValue;

},{"./BaseCell":27,"./parser/error":36}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataProvider = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var rangeEach = Handsontable.helper.rangeEach;

var DataProvider = function () {
    function DataProvider(hot) {
        _classCallCheck(this, DataProvider);

        this.hot = hot;
        this.changes = {};
    }

    _createClass(DataProvider, [{
        key: 'collectChanges',
        value: function collectChanges(row, column, value) {
            if (!(0, _utils.isFormulaExpression)(value)) {
                this.changes[DataProvider._coordId(row, column)] = value;
            }
        }
    }, {
        key: 'clearChanges',
        value: function clearChanges() {
            this.changes = {};
        }
    }, {
        key: 'isInDataRange',
        value: function isInDataRange(row, column) {
            return row >= 0 && row < this.hot.countRows() && column >= 0 && column < this.hot.countCols();
        }
    }, {
        key: 'getDataAtCell',
        value: function getDataAtCell(row, column) {
            var id = DataProvider._coordId(row, column);
            var result = void 0;

            if (this.changes.hasOwnProperty(id)) {
                result = this.changes[id];
            } else {
                result = this.hot.getDataAtCell(row, column);
            }
            return result;
        }
    }, {
        key: 'getDataAtCellInSheet',
        value: function getDataAtCellInSheet(sheetName, row, column) {
            var sheet = this.workbook.getSheet(sheetName);
            var formulas = sheet.handsontable.getPlugin('XFormulas');
            return formulas.sheet.dataProvider.getDataAtCell(row, column);
        }
    }, {
        key: 'getDataByRange',
        value: function getDataByRange(row1, column1, row2, column2) {
            var _this = this;

            var result = this.hot.getData(row1, column1, row2, column2);

            arrayEach(result, function (rowData, rowIndex) {
                arrayEach(rowData, function (value, columnIndex) {
                    var id = DataProvider._coordId(rowIndex + row1, columnIndex + column1);

                    if (_this.changes.hasOwnProperty(id)) {
                        result[rowIndex][columnIndex] = _this.changes[id];
                    }
                });
            });

            return result;
        }
    }, {
        key: 'getSourceDataAtCell',
        value: function getSourceDataAtCell(row, column) {
            return this.hot.getSourceDataAtCell(row, column);
        }
    }, {
        key: 'getSourceDataByRange',
        value: function getSourceDataByRange(row1, column1, row2, column2) {
            return this.hot.getSourceDataArray(row1, column1, row2, column2);
        }
    }, {
        key: 'updateSourceData',
        value: function updateSourceData(row, column, value) {
            this.hot.getSourceData()[row][this.hot.colToProp(column)] = value;
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.hot = null;
            this.changes = null;
        }
    }], [{
        key: '_coordId',
        value: function _coordId(row, column) {
            return row + ':' + column;
        }
    }]);

    return DataProvider;
}();

exports.DataProvider = DataProvider;

},{"./utils":55}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Matrix = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require("./CellValue");

var _error = require("./parser/error");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var arrayFilter = Handsontable.helper.arrayFilter;
var arrayReduce = Handsontable.helper.arrayReduce;

var Matrix = function () {
    function Matrix() {
        _classCallCheck(this, Matrix);

        this.data = [];
        this.cellReferences = [];
    }

    _createClass(Matrix, [{
        key: "getCellAt",
        value: function getCellAt(row, column) {
            var result = null;

            arrayEach(this.data, function (cell) {
                if (cell.row === row && cell.column === column) {
                    result = cell;

                    return false;
                }
            });

            return result;
        }
    }, {
        key: "getOutOfDateCells",
        value: function getOutOfDateCells() {
            return arrayFilter(this.data, function (cell) {
                return cell.isState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
            });
        }
    }, {
        key: "add",
        value: function add(cellValue) {
            if (!arrayFilter(this.data, function (cell) {
                return cell.isEqual(cellValue);
            }).length) {
                this.data.push(cellValue);
            }
        }
    }, {
        key: "remove",
        value: function remove(cellValue) {
            var isArray = Array.isArray(cellValue);
            var isEqual = function isEqual(cell, cellValue) {
                var result = false;

                if (isArray) {
                    arrayEach(cellValue, function (value) {
                        if (cell.isEqual(value)) {
                            result = true;

                            return false;
                        }
                    });
                } else {
                    result = cell.isEqual(cellValue);
                }

                return result;
            };
            this.data = arrayFilter(this.data, function (cell) {
                return !isEqual(cell, cellValue);
            });
        }
    }, {
        key: "getDependencies",
        value: function getDependencies(cellValue) {
            var _this = this;

            var getDependencies = function getDependencies(cell) {
                return arrayReduce(_this.data, function (acc, cellValue) {
                    if (cellValue.hasPrecedent(cell) && acc.indexOf(cellValue) === -1) {
                        acc.push(cellValue);
                    }
                    return acc;
                }, []);
            };

            var getTotalDependencies = function getTotalDependencies(cell) {
                var deps = getDependencies(cell);

                if (deps.length) {
                    arrayEach(deps, function (cellValue) {
                        if (cellValue.hasPrecedents()) {
                            deps = deps.concat(getTotalDependencies(cellValue));
                        }
                    });
                }
                return deps;
            };

            try {
                return getTotalDependencies(cellValue);
            } catch (e) {
                // TODO 增加该代码是解决以下问题的权宜之策：
                // https://github.com/handsontable/handsontable/issues/4357
                var errorValue = new _CellValue.CellValue(cellValue.row, cellValue.column);
                errorValue.setError(_error.ERROR_REF);
                errorValue.setState(_CellValue.CellValue.STATE_UP_TO_DATE);
                return [errorValue];
            }
        }
    }, {
        key: "registerCellRef",
        value: function registerCellRef(cellReference) {
            if (!arrayFilter(this.cellReferences, function (cell) {
                return cell.isEqual(cellReference);
            }).length) {
                this.cellReferences.push(cellReference);
            }
        }
    }, {
        key: "removeCellRefsAtRange",
        value: function removeCellRefsAtRange(_ref, _ref2) {
            var startRow = _ref.row,
                startColumn = _ref.column;
            var endRow = _ref2.row,
                endColumn = _ref2.column;

            var removed = [];

            var rowMatch = function rowMatch(cell) {
                return startRow === void 0 ? true : cell.row >= startRow && cell.row <= endRow;
            };
            var colMatch = function colMatch(cell) {
                return startColumn === void 0 ? true : cell.column >= startColumn && cell.column <= endColumn;
            };

            this.cellReferences = arrayFilter(this.cellReferences, function (cell) {
                if (rowMatch(cell) && colMatch(cell)) {
                    removed.push(cell);

                    return false;
                }

                return true;
            });

            return removed;
        }
    }, {
        key: "reset",
        value: function reset() {
            this.data.length = 0;
            this.cellReferences.length = 0;
        }
    }]);

    return Matrix;
}();

exports.Matrix = Matrix;

},{"./CellValue":29,"./parser/error":36}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Sheet = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

var _CellReference = require('./CellReference');

var _utils = require('./utils');

var _Matrix = require('./Matrix');

var _AlterManager = require('./AlterManager');

var _parser = require('./parser/parser');

var _error = require('./parser/error');

var _localHooks = require('../../utils/localHooks');

var _localHooks2 = _interopRequireDefault(_localHooks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var STATE_UP_TO_DATE = 1;
var STATE_NEED_REBUILD = 2;
var STATE_NEED_FULL_REBUILD = 3;

var arrayEach = Handsontable.helper.arrayEach;
var arrayMap = Handsontable.helper.arrayMap;
var rangeEach = Handsontable.helper.rangeEach;
var objectEach = Handsontable.helper.objectEach;
var mixin = Handsontable.helper.mixin;

var Sheet = function () {
    function Sheet(dataProvider) {
        var _this = this;

        _classCallCheck(this, Sheet);

        this.dataProvider = dataProvider;
        this.parser = new _parser.Parser();
        this.matrix = new _Matrix.Matrix();
        this.alterManager = new _AlterManager.AlterManager(this);

        this._processingCell = null;
        this._state = STATE_NEED_FULL_REBUILD;

        this.parser.on('callCellValue', function () {
            return _this._onCallCellValue.apply(_this, arguments);
        });
        this.parser.on('callRangeValue', function () {
            return _this._onCallRangeValue.apply(_this, arguments);
        });
        this.parser.on('callCellValueInSheet', function () {
            return _this._onCallCellValueInSheet.apply(_this, arguments);
        });
        this.parser.on('callRangeValueInSheet', function () {
            return _this._onCallRangeValueInSheet.apply(_this, arguments);
        });
        this.alterManager.addLocalHook('afterAlter', function () {
            return _this._onAfterAlter.apply(_this, arguments);
        });
    }

    _createClass(Sheet, [{
        key: 'recalculate',
        value: function recalculate() {
            switch (this._state) {
                case STATE_NEED_FULL_REBUILD:
                    this.recalculateFull();
                    break;
                case STATE_NEED_REBUILD:
                    this.recalculateOptimized();
                    break;
            }
        }
    }, {
        key: 'recalculateOptimized',
        value: function recalculateOptimized() {
            var _this2 = this;

            var cells = this.matrix.getOutOfDateCells();

            arrayEach(cells, function (cellValue) {
                var value = _this2.dataProvider.getSourceDataAtCell(cellValue.row, cellValue.column);

                if ((0, _utils.isFormulaExpression)(value)) {
                    _this2.parseExpression(cellValue, value.substr(1));
                }
            });

            this._state = STATE_UP_TO_DATE;
            this.runLocalHooks('afterRecalculate', cells, 'optimized');
        }
    }, {
        key: 'recalculateFull',
        value: function recalculateFull() {
            var _this3 = this;

            var cells = this.dataProvider.getSourceDataByRange();
            this.matrix.reset();

            arrayEach(cells, function (rowData, row) {
                arrayEach(rowData, function (value, column) {
                    if ((0, _utils.isFormulaExpression)(value)) {
                        _this3.parseExpression(new _CellValue.CellValue(row, column), value.substr(1));
                    }
                });
            });

            this._state = STATE_UP_TO_DATE;
            this.runLocalHooks('afterRecalculate', cells, 'full');
        }
    }, {
        key: 'setVariable',
        value: function setVariable(name, value) {
            this.parser.setVariable(name, value);
        }
    }, {
        key: 'getVariable',
        value: function getVariable(name) {
            return this.parser.getVariable(name);
        }
    }, {
        key: 'applyChanges',
        value: function applyChanges(row, column, newValue) {
            // TODO: Move this to recalculate()
            this.matrix.remove({ row: row, column: column });

            // TODO: Move this to recalculate()
            if ((0, _utils.isFormulaExpression)(newValue)) {
                this.parseExpression(new _CellValue.CellValue(row, column), newValue.substr(1));
            }

            var deps = this.getCellDependencies(row, column);

            arrayEach(deps, function (cellValue) {
                cellValue.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
            });

            this._state = STATE_NEED_REBUILD;
        }
    }, {
        key: 'parseExpression',
        value: function parseExpression(cellValue, formula) {
            cellValue.setState(_CellValue.CellValue.STATE_COMPUTING);
            this._processingCell = cellValue;

            // TODO  wrapper formula
            // var sheetNames = this.dataProvider.workbook.getSheetNames();

            var _parser$parse = this.parser.parse((0, _utils.toUpperCaseFormula)(formula)),
                error = _parser$parse.error,
                result = _parser$parse.result;

            cellValue.setValue(result);
            cellValue.setError(error);
            cellValue.setState(_CellValue.CellValue.STATE_UP_TO_DATE);

            this.matrix.add(cellValue);
            this._processingCell = null;
        }
    }, {
        key: 'getCellAt',
        value: function getCellAt(row, column) {
            return this.matrix.getCellAt(row, column);
        }
    }, {
        key: 'getCellDependencies',
        value: function getCellDependencies(row, column) {
            return this.matrix.getDependencies({ row: row, column: column });
        }
    }, {
        key: '_onCallCellValue',
        value: function _onCallCellValue(_ref, done) {
            var row = _ref.row,
                column = _ref.column;

            var cell = new _CellReference.CellReference(row, column);

            if (!this.dataProvider.isInDataRange(cell.row, cell.column)) {
                throw Error(_error.ERROR_REF);
            }

            this.matrix.registerCellRef(cell);
            this._processingCell.addPrecedent(cell);

            done(this.dataProvider.getDataAtCell(cell.row, cell.column));
        }
    }, {
        key: '_onCallCellValueInSheet',
        value: function _onCallCellValueInSheet(_ref2, done) {
            var sheetName = _ref2.sheetName,
                row = _ref2.row,
                column = _ref2.column;

            var cell = new _CellReference.CellReference(row, column);

            // TODO 更改数据时，公式引用的数据级联更新

            done(this.dataProvider.getDataAtCellInSheet(sheetName, cell.row, cell.column));
        }
    }, {
        key: '_onCallRangeValue',
        value: function _onCallRangeValue(_ref3, _ref4, done) {
            var startRow = _ref3.row,
                startColumn = _ref3.column;

            var _this4 = this;

            var endRow = _ref4.row,
                endColumn = _ref4.column;

            rangeEach(startRow.index, endRow.index, function (row) {
                rangeEach(startColumn.index, endColumn.index, function (column) {
                    var cell = new _CellReference.CellReference(row, column);

                    _this4.matrix.registerCellRef(cell);
                    _this4._processingCell.addPrecedent(cell);
                });
            });
            done(this.dataProvider.getDataByRange(startRow.index, startColumn.index, endRow.index, endColumn.index));
        }

        // TODO 调用范围公式

    }, {
        key: '_onCallRangeValueInSheet',
        value: function _onCallRangeValueInSheet(sheetName, _ref5, _ref6, done) {
            var startRow = _ref5.row,
                startColumn = _ref5.column;
            var endRow = _ref6.row,
                endColumn = _ref6.column;


            done('_onCallRangeValueInSheet');
        }
    }, {
        key: '_onAfterAlter',
        value: function _onAfterAlter() {
            this.recalculateOptimized();
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.dataProvider.destroy();
            this.dataProvider = null;
            this.alterManager.destroy();
            this.alterManager = null;
            this.parser = null;
            this.matrix.reset();
            this.matrix = null;
        }
    }]);

    return Sheet;
}();

mixin(Sheet, _localHooks2.default);

exports.Sheet = Sheet;

},{"../../utils/localHooks":63,"./AlterManager":26,"./CellReference":28,"./CellValue":29,"./Matrix":31,"./parser/error":36,"./parser/parser":52,"./utils":55}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UndoRedoSnapshot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

var _dataStructure = require('../../utils/dataStructure');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var rangeEach = Handsontable.helper.rangeEach;

var UndoRedoSnapshot = function () {
    function UndoRedoSnapshot(sheet) {
        _classCallCheck(this, UndoRedoSnapshot);

        this.sheet = sheet;
        this.stack = new _dataStructure.Stack();
    }

    _createClass(UndoRedoSnapshot, [{
        key: 'save',
        value: function save(axis, index, amount) {
            var _sheet = this.sheet,
                matrix = _sheet.matrix,
                dataProvider = _sheet.dataProvider;

            var changes = [];

            arrayEach(matrix.data, function (cellValue) {
                var row = cellValue.row,
                    column = cellValue.column;


                if (cellValue[axis] < index || cellValue[axis] > index + (amount - 1)) {
                    var value = dataProvider.getSourceDataAtCell(row, column);

                    changes.push({ row: row, column: column, value: value });
                }
            });

            this.stack.push({ axis: axis, index: index, amount: amount, changes: changes });
        }
    }, {
        key: 'restore',
        value: function restore() {
            var _sheet2 = this.sheet,
                matrix = _sheet2.matrix,
                dataProvider = _sheet2.dataProvider;

            var _stack$pop = this.stack.pop(),
                axis = _stack$pop.axis,
                index = _stack$pop.index,
                amount = _stack$pop.amount,
                changes = _stack$pop.changes;

            if (changes) {
                arrayEach(changes, function (change) {
                    if (change[axis] > index + (amount - 1)) {
                        change[axis] -= amount;
                    }
                    var row = change.row,
                        column = change.column,
                        value = change.value;

                    var rawValue = dataProvider.getSourceDataAtCell(row, column);

                    if (rawValue !== value) {
                        dataProvider.updateSourceData(row, column, value);
                        matrix.getCellAt(row, column).setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
                    }
                });
            }
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.sheet = null;
            this.stack = null;
        }
    }]);

    return UndoRedoSnapshot;
}();

exports.UndoRedoSnapshot = UndoRedoSnapshot;

},{"../../utils/dataStructure":60,"./CellValue":29}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XFormulas = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 扩展公式：支持跨工作表的公式。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 示例：
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * + worksheet2中某单元格值为 `=worksheet1!A2+B2`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * + 工作表3中某单元格值为 `=工作表1!A1+工作表2B1`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * + sheet5中某单元格值为`=SUM(sheet3!B1:B5, sheet4!B6)`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * TODO 目前仅支持“相对引用”的坐标形式，但没有公式填充的效果；
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 目前不支持“绝对引用”和“混合引用”方式。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 此插件需要绕开 hansontable 一个插件对应一个实例的设计思路，而同时管理多个实例。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 实例的管理工作交给 Workbook 来做，因此，此插件不可作为独立的 hansontable 插件
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 使用，只能依托于该电子表格设计器。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @plugin External plugin XFormulas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @param hotInstance
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @constructor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

// TODO 禁止公式循环引用 A1=B1, B1=A1

var _utils = require('./utils');

var _Sheet = require('./Sheet');

var _DataProvider = require('./DataProvider');

var _UndoRedoSnapshot = require('./UndoRedoSnapshot');

var arrayEach = Handsontable.helper.arrayEach;
var isObject = Handsontable.helper.isObject;
var objectEach = Handsontable.helper.objectEach;

function XFormulas(hotInstance) {
    Handsontable.plugins.BasePlugin.call(this, hotInstance);
    this._superClass = Handsontable.plugins.BasePlugin;

    this.eventManager = new Handsontable.EventManager();
    this.dataProvider = new _DataProvider.DataProvider(this.hot);
    this.sheet = new _Sheet.Sheet(this.dataProvider);
    this.undoRedoSnapshot = new _UndoRedoSnapshot.UndoRedoSnapshot(this.sheet);

    this._skipRendering = false;
}

XFormulas.prototype = Object.create(Handsontable.plugins.BasePlugin.prototype, {
    constructor: {
        writable: true,
        configurable: true,
        value: XFormulas
    }
});

XFormulas.prototype.isEnabled = function () {
    return !!this.hot.getSettings().xFormulas;
};

/**
 * 插件初始化过程。
 * PS: enablePlugin 方法会在 beforeInit hook 中触发，
 *     仅当 isEnabled 方法返回 true 时执行。
 */
XFormulas.prototype.enablePlugin = function () {
    var _this = this;

    if (this.enabled) {
        return;
    }

    var settings = this.hot.getSettings();
    if (!settings._isHotTableAdaptor) {
        throw 'XFormulas 插件启用失败';
    }

    var formulasSettings = settings.formulas;
    if (isObject(formulasSettings)) {
        if (isObject(formulasSettings.variables)) {
            objectEach(formulasSettings.variables, function (value, name) {
                return _this.setVariable(name, value);
            });
        }
    }

    // TODO move to DataProvider
    var worksheet = this.dataProvider.worksheet = this.hot.getSettings()._sheet;
    this.dataProvider.workbook = worksheet.workbook;

    this.addHook('afterCreateCol', function () {
        return _this.onAfterCreateCol.apply(_this, arguments);
    });
    this.addHook('afterCreateRow', function () {
        return _this.onAfterCreateRow.apply(_this, arguments);
    });
    this.addHook('afterLoadData', function () {
        return _this.onAfterLoadData();
    });
    this.addHook('afterRemoveCol', function () {
        return _this.onAfterRemoveCol.apply(_this, arguments);
    });
    this.addHook('afterRemoveRow', function () {
        return _this.onAfterRemoveRow.apply(_this, arguments);
    });
    this.addHook('afterSetDataAtCell', function () {
        return _this.onAfterSetDataAtCell.apply(_this, arguments);
    });
    this.addHook('afterSetDataAtRowProp', function () {
        return _this.onAfterSetDataAtCell.apply(_this, arguments);
    });
    //this.addHook('beforeKeyDown', (...args) => this.onBeforeKeyDown(...args));
    this.addHook('beforeCreateCol', function () {
        return _this.onBeforeCreateCol.apply(_this, arguments);
    });
    this.addHook('beforeCreateRow', function () {
        return _this.onBeforeCreateRow.apply(_this, arguments);
    });
    this.addHook('beforeRemoveCol', function () {
        return _this.onBeforeRemoveCol.apply(_this, arguments);
    });
    this.addHook('beforeRemoveRow', function () {
        return _this.onBeforeRemoveRow.apply(_this, arguments);
    });
    this.addHook('beforeValidate', function () {
        return _this.onBeforeValidate.apply(_this, arguments);
    });
    this.addHook('beforeValueRender', function () {
        return _this.onBeforeValueRender.apply(_this, arguments);
    });
    this.addHook('modifyData', function () {
        return _this.onModifyData.apply(_this, arguments);
    });

    this.sheet.addLocalHook('afterRecalculate', function () {
        return _this.onSheetAfterRecalculate.apply(_this, arguments);
    });

    this._superClass.prototype.enablePlugin.call(this);
};

/**
 * 禁用插件。
 * PS: 注意将所有属性重置为默认值
 */
XFormulas.prototype.disablePlugin = function () {
    this._superClass.prototype.disablePlugin.call(this);
};

/**
 * 重置 Handsontable 的 settings 时，用来重置 XFormulas 插件的属性。
 * PS: 在 afterUpdateSettings hook 中调用。
 */
XFormulas.prototype.updatePlugin = function () {
    this.disablePlugin();
    this.enablePlugin();
    this._superClass.prototype.updatePlugin.call(this);
};

/**
 * 销毁插件
 */
XFormulas.prototype.destroy = function () {
    this.dataProvider.destroy();
    this.dataProvider = null;
    this.sheet.destroy();
    this.sheet = null;
    this._superClass.prototype.destroy.call(this);
};

// ---------------------------------------[start] Hooks

// TODO 工作表改名时，其它工作表关联到它的公式值要改
XFormulas.prototype.onSheetRename = function (sheet, name1, name2) {};

XFormulas.prototype.onSheetAfterRecalculate = function (cells) {
    if (this._skipRendering) {
        this._skipRendering = false;
        return;
    }
    var hot = this.hot;

    arrayEach(cells, function (_ref) {
        var row = _ref.row,
            column = _ref.column;

        hot.validateCell(hot.getDataAtCell(row, column), hot.getCellMeta(row, column), function () {});
    });
    hot.render();
};

/**
 * TODO
 * Caution - 调用 event.stopImmediatePropagation() 可以阻止默认行为。
 * @param event
 */
XFormulas.prototype.onBeforeKeyDown = function (event) {};

XFormulas.prototype.onModifyData = function (row, column, valueHolder, ioMode) {
    if (ioMode === 'get' && this.hasComputedCellValue(row, column)) {
        valueHolder.value = this.getCellValue(row, column);
    } else if (ioMode === 'set' && (0, _utils.isFormulaExpression)(valueHolder.value)) {
        valueHolder.value = (0, _utils.toUpperCaseFormula)(valueHolder.value);
    }
};

XFormulas.prototype.onBeforeValueRender = function (value) {
    if ((0, _utils.isFormulaExpressionEscaped)(value)) {
        value = (0, _utils.unescapeFormulaExpression)(value);
    }
    return value;
};

XFormulas.prototype.onBeforeValidate = function (value, row, prop) {
    var column = this.hot.propToCol(prop);

    if (this.hasComputedCellValue(row, column)) {
        value = this.getCellValue(row, column);
    }

    return value;
};

XFormulas.prototype.onAfterSetDataAtCell = function (changes, source) {
    var _this2 = this;

    if (source === 'loadData') {
        return;
    }

    this.dataProvider.clearChanges();
    arrayEach(changes, function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 4),
            row = _ref3[0],
            column = _ref3[1],
            oldValue = _ref3[2],
            newValue = _ref3[3];

        column = _this2.hot.propToCol(column);
        if ((0, _utils.isFormulaExpression)(newValue)) {
            newValue = (0, _utils.toUpperCaseFormula)(newValue);
        }
        _this2.dataProvider.collectChanges(row, column, newValue);
        if (oldValue !== newValue) {
            _this2.sheet.applyChanges(row, column, newValue);
        }
    });
    this.recalculate();
};

XFormulas.prototype.onBeforeCreateRow = function (row, amount, source) {
    if (source === 'UndoRedo.undo') {
        this.undoRedoSnapshot.restore();
    }
};

XFormulas.prototype.onAfterCreateRow = function (row, amount, source) {
    this.sheet.alterManager.insertRow(row, amount, source !== 'UndoRedo.undo');
};

XFormulas.prototype.onBeforeRemoveRow = function (row, amount) {
    // TODO Storage.save('row', row, amount);
};

XFormulas.prototype.onAfterRemoveRow = function (row, amount) {
    this.sheet.alterManager.removeRow(row, amount);
};

XFormulas.prototype.onBeforeCreateCol = function (column, amount, source) {
    if (source === 'UndoRedo.undo') {
        this.undoRedoSnapshot.restore();
    }
};

XFormulas.prototype.onAfterCreateCol = function (column, amount, source) {
    this.sheet.alterManager.insertColumn(column, amount, source !== 'UndoRedo.undo');
};

XFormulas.prototype.onBeforeRemoveCol = function (column, amount) {
    // TODO Storage.save('column', column, amount);
};

XFormulas.prototype.onAfterRemoveCol = function (column, amount) {
    this.sheet.alterManager.removeColumn(column, amount);
};

XFormulas.prototype.onAfterLoadData = function () {
    this._skipRendering = true;
    this.recalculateFull();
};

// ---------------------------------------[end] Hooks

XFormulas.prototype.getCellValue = function (row, column) {
    var cell = this.sheet.getCellAt(row, column);
    return cell ? cell.getError() || cell.getValue() : void 0;
};

XFormulas.prototype.hasComputedCellValue = function (row, column) {
    return !!this.sheet.getCellAt(row, column);
};

XFormulas.prototype.recalculate = function () {
    this.sheet.recalculate();
};

XFormulas.prototype.recalculateFull = function () {
    this.sheet.recalculateFull();
};

XFormulas.prototype.recalculateOptimized = function () {
    this.sheet.recalculateOptimized();
};

XFormulas.prototype.setVariable = function (name, value) {
    this.sheet.setVariable(name, value);
};

XFormulas.prototype.getVariable = function (name) {
    return this.sheet.getVariable(name);
};

Handsontable.plugins.registerPlugin('xFormulas', XFormulas);

exports.XFormulas = XFormulas;

},{"./DataProvider":30,"./Sheet":32,"./UndoRedoSnapshot":33,"./utils":55}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExpressionModifier = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

var _utils2 = require('./parser/utils');

var _error = require('./parser/error');

var _error2 = _interopRequireDefault(_error);

var _localHooks = require('../../utils/localHooks');

var _localHooks2 = _interopRequireDefault(_localHooks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var arrayFilter = Handsontable.helper.arrayFilter;
var mixin = Handsontable.helper.mixin;

var BARE_CELL_STRICT_REGEX = /^\$?[A-Z]+\$?\d+$/;
var BARE_CELL_REGEX = /\$?[A-Z]+\$?\d+/;
var CELL_REGEX = /(?:[^0-9A-Z$: ]|^)\s*(\$?[A-Z]+\$?\d+)\s*(?![0-9A-Z_: ])/g;
var RANGE_REGEX = /\$?[A-Z]+\$?\d+\s*:\s*\$?[A-Z]+\$?\d+/g;
var CELL_AND_RANGE_REGEX = /((?:[^0-9A-Z$: ]|^)\s*(\$?[A-Z]+\$?\d+)\s*(?![0-9A-Z_: ]))|(\$?[A-Z]+\$?\d+\s*:\s*\$?[A-Z]+\$?\d+)/g;

var ExpressionModifier = function () {
    function ExpressionModifier(expression) {
        _classCallCheck(this, ExpressionModifier);

        /**
         * 待修改的表达式
         * @type {String}
         */
        this.expression = '';

        this.cells = [];

        if (typeof expression === 'string') {
            this.setExpression(expression);
        }
    }

    _createClass(ExpressionModifier, [{
        key: 'setExpression',
        value: function setExpression(expression) {
            this.cells.length = 0;
            this.expression = (0, _utils.toUpperCaseFormula)(expression);

            this._extractCells();
            this._extractCellsRange();

            return this;
        }
    }, {
        key: 'translate',
        value: function translate(_ref, _ref2) {
            var baseRow = _ref.row,
                baseColumn = _ref.column;
            var deltaRow = _ref2.row,
                deltaColumn = _ref2.column;

            arrayEach(this.cells, function (cell) {
                if (deltaRow != null) {
                    ExpressionModifier._translateCell(cell, 'row', baseRow, deltaRow);
                }
                if (deltaColumn != null) {
                    ExpressionModifier._translateCell(cell, 'column', baseColumn, deltaColumn);
                }
            });

            return this;
        }
    }, {
        key: 'toString',
        value: function toString() {
            var _this = this;

            var expression = this.expression.replace(CELL_AND_RANGE_REGEX, function (match, p1, p2) {
                var isSingleCell = match.indexOf(':') === -1;
                var result = match;
                var cellLabel = match;
                var translatedCellLabel = null;

                if (isSingleCell) {
                    cellLabel = BARE_CELL_STRICT_REGEX.test(p1) ? p1 : p2;
                }
                var cell = _this._searchCell(cellLabel);

                if (cell) {
                    translatedCellLabel = cell.refError ? (0, _error2.default)(_error.ERROR_REF) : cell.toLabel();

                    if (isSingleCell) {
                        result = match.replace(cellLabel, translatedCellLabel);
                    } else {
                        result = translatedCellLabel;
                    }
                }

                return result;
            });

            if (!expression.startsWith('=')) {
                expression = '=' + expression;
            }

            return expression;
        }
    }, {
        key: '_extractCells',
        value: function _extractCells() {
            var _this2 = this;

            var matches = this.expression.match(CELL_REGEX);

            if (!matches) {
                return;
            }
            arrayEach(matches, function (coord) {
                coord = coord.match(BARE_CELL_REGEX);

                if (!coord) {
                    return;
                }

                var _extractLabel = (0, _utils2.extractLabel)(coord[0]),
                    _extractLabel2 = _slicedToArray(_extractLabel, 2),
                    row = _extractLabel2[0],
                    column = _extractLabel2[1];

                _this2.cells.push(_this2._createCell({ row: row, column: column }, { row: row, column: column }, coord[0]));
            });
        }
    }, {
        key: '_extractCellsRange',
        value: function _extractCellsRange() {
            var _this3 = this;

            var matches = this.expression.match(RANGE_REGEX);

            if (!matches) {
                return;
            }
            arrayEach(matches, function (match) {
                var _match$split = match.split(':'),
                    _match$split2 = _slicedToArray(_match$split, 2),
                    start = _match$split2[0],
                    end = _match$split2[1];

                var _extractLabel3 = (0, _utils2.extractLabel)(start),
                    _extractLabel4 = _slicedToArray(_extractLabel3, 2),
                    startRow = _extractLabel4[0],
                    startColumn = _extractLabel4[1];

                var _extractLabel5 = (0, _utils2.extractLabel)(end),
                    _extractLabel6 = _slicedToArray(_extractLabel5, 2),
                    endRow = _extractLabel6[0],
                    endColumn = _extractLabel6[1];

                var startCell = {
                    row: startRow,
                    column: startColumn
                };
                var endCell = {
                    row: endRow,
                    column: endColumn
                };

                _this3.cells.push(_this3._createCell(startCell, endCell, match));
            });
        }
    }, {
        key: '_searchCell',
        value: function _searchCell(label) {
            var _arrayFilter = arrayFilter(this.cells, function (cell) {
                return cell.origLabel === label;
            }),
                _arrayFilter2 = _slicedToArray(_arrayFilter, 1),
                cell = _arrayFilter2[0];

            return cell || null;
        }
    }, {
        key: '_createCell',
        value: function _createCell(start, end, label) {
            return {
                start: start,
                end: end,
                origLabel: label,
                type: label.indexOf(':') === -1 ? 'cell' : 'range',
                refError: false,
                toLabel: function toLabel() {
                    var label = (0, _utils2.toLabel)(this.start.row, this.start.column);

                    if (this.type === 'range') {
                        label += ':' + (0, _utils2.toLabel)(this.end.row, this.end.column);
                    }

                    return label;
                }
            };
        }
    }], [{
        key: '_translateCell',
        value: function _translateCell(cell, property) {
            var baseIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var delta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var type = cell.type,
                start = cell.start,
                end = cell.end;

            var startIndex = start[property].index;
            var endIndex = end[property].index;
            var deltaStart = delta;
            var deltaEnd = delta;
            var refError = false;
            var indexOffset = Math.abs(delta) - 1;

            // 增加
            if (delta > 0) {
                if (baseIndex > startIndex) {
                    deltaStart = 0;
                }
                if (baseIndex > endIndex) {
                    deltaEnd = 0;
                }
            } else {
                // 删除
                if (startIndex >= baseIndex && endIndex <= baseIndex + indexOffset) {
                    refError = true;
                }
                if (!refError && type === 'cell') {
                    if (baseIndex >= startIndex) {
                        deltaStart = 0;
                        deltaEnd = 0;
                    }
                }
                if (!refError && type === 'range') {
                    if (baseIndex >= startIndex) {
                        deltaStart = 0;
                    }
                    if (baseIndex > endIndex) {
                        deltaEnd = 0;
                    } else if (endIndex <= baseIndex + indexOffset) {
                        deltaEnd -= Math.min(endIndex - (baseIndex + indexOffset), 0);
                    }
                }
            }

            if (deltaStart && !refError) {
                start[property].index = Math.max(startIndex + deltaStart, 0);
            }
            if (deltaEnd && !refError) {
                end[property].index = Math.max(endIndex + deltaEnd, 0);
            }
            if (refError) {
                cell.refError = true;
            }
        }
    }]);

    return ExpressionModifier;
}();

mixin(ExpressionModifier, _localHooks2.default);

exports.ExpressionModifier = ExpressionModifier;

},{"../../utils/localHooks":63,"./parser/error":36,"./parser/utils":54,"./utils":55}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _errors;

exports.default = error;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ERROR = exports.ERROR = 'ERROR';
var ERROR_DIV_ZERO = exports.ERROR_DIV_ZERO = 'DIV/0';
var ERROR_NAME = exports.ERROR_NAME = 'NAME';
var ERROR_NEED_UPDATE = exports.ERROR_NEED_UPDATE = 'NEED_UPDATE';
var ERROR_NOT_AVAILABLE = exports.ERROR_NOT_AVAILABLE = 'N/A';
var ERROR_NULL = exports.ERROR_NULL = 'NULL';
var ERROR_NUM = exports.ERROR_NUM = 'NUM';
var ERROR_REF = exports.ERROR_REF = 'REF';
var ERROR_VALUE = exports.ERROR_VALUE = 'VALUE';

var errors = (_errors = {}, _defineProperty(_errors, ERROR, '#ERROR!'), _defineProperty(_errors, ERROR_DIV_ZERO, '#DIV/0!'), _defineProperty(_errors, ERROR_NAME, '#NAME?'), _defineProperty(_errors, ERROR_NEED_UPDATE, '#NEED_UPDATE!'), _defineProperty(_errors, ERROR_NOT_AVAILABLE, '#N/A'), _defineProperty(_errors, ERROR_NULL, '#NULL!'), _defineProperty(_errors, ERROR_NUM, '#NUM!'), _defineProperty(_errors, ERROR_REF, '#REF!'), _defineProperty(_errors, ERROR_VALUE, '#VALUE!'), _errors);

function error(type) {
  var error = void 0;
  type = (type + '').replace(/#|!|\?/g, '');

  if (errors[type]) {
    error = errors[type];
  }
  return error ? error : null;
}

},{}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var grammar = function () {
    var o = function o(k, v, _o, l) {
        for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}return _o;
    },
        $V0 = [1, 5],
        $V1 = [1, 8],
        $V2 = [1, 6],
        $V3 = [1, 7],
        $V4 = [1, 9],
        $V5 = [1, 15],
        $V6 = [1, 16],
        $V7 = [1, 17],
        $V8 = [1, 18],
        $V9 = [1, 13],
        $Va = [1, 14],
        $Vb = [1, 19],
        $Vc = [1, 21],
        $Vd = [1, 22],
        $Ve = [1, 23],
        $Vf = [1, 24],
        $Vg = [1, 25],
        $Vh = [1, 26],
        $Vi = [1, 27],
        $Vj = [1, 28],
        $Vk = [1, 29],
        $Vl = [1, 30],
        $Vm = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33],
        $Vn = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33, 35],
        $Vo = [1, 39],
        $Vp = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33, 37],
        $Vq = [5, 10, 11, 13, 14, 15, 16, 17, 32, 33],
        $Vr = [5, 10, 13, 14, 15, 16, 32, 33],
        $Vs = [5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 32, 33],
        $Vt = [13, 32, 33],
        $Vu = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33, 34, 38];
    var parser = { trace: function trace() {},
        yy: {},
        symbols_: { "error": 2, "expressions": 3, "expression": 4, "EOF": 5, "variableSequence": 6, "number": 7, "STRING": 8, "&": 9, "=": 10, "+": 11, "(": 12, ")": 13, "<": 14, ">": 15, "NOT": 16, "-": 17, "*": 18, "/": 19, "^": 20, "FUNCTION": 21, "expseq": 22, "sheet": 23, "cell": 24, "SHEET_NAME": 25, "!": 26, "ABSOLUTE_CELL": 27, "RELATIVE_CELL": 28, "MIXED_CELL": 29, ":": 30, "ARRAY": 31, ";": 32, ",": 33, "VARIABLE": 34, "DECIMAL": 35, "NUMBER": 36, "%": 37, "#": 38, "$accept": 0, "$end": 1 },
        terminals_: { 5: "EOF", 8: "STRING", 9: "&", 10: "=", 11: "+", 12: "(", 13: ")", 14: "<", 15: ">", 16: "NOT", 17: "-", 18: "*", 19: "/", 20: "^", 21: "FUNCTION", 25: "SHEET_NAME", 26: "!", 27: "ABSOLUTE_CELL", 28: "RELATIVE_CELL", 29: "MIXED_CELL", 30: ":", 31: "ARRAY", 32: ";", 33: ",", 34: "VARIABLE", 35: "DECIMAL", 36: "NUMBER", 37: "%", 38: "#" },
        productions_: [0, [3, 2], [4, 1], [4, 1], [4, 1], [4, 3], [4, 3], [4, 3], [4, 3], [4, 4], [4, 4], [4, 4], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 2], [4, 2], [4, 3], [4, 4], [4, 1], [4, 1], [4, 1], [4, 2], [23, 3], [23, 3], [23, 3], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [24, 1], [24, 1], [24, 1], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [22, 1], [22, 1], [22, 3], [22, 3], [6, 1], [6, 3], [7, 1], [7, 3], [7, 2], [2, 3], [2, 4]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
            /* this == yyval */

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1:

                    return $$[$0 - 1];

                    break;
                case 2:

                    this.$ = yy.callVariable($$[$0][0]);

                    break;
                case 3:

                    this.$ = yy.toNumber($$[$0]);

                    break;
                case 4:

                    this.$ = yy.trimEdges($$[$0]);

                    break;
                case 5:

                    this.$ = yy.evaluateByOperator('&', [$$[$0 - 2], $$[$0]]);

                    break;
                case 6:

                    this.$ = yy.evaluateByOperator('=', [$$[$0 - 2], $$[$0]]);

                    break;
                case 7:

                    this.$ = yy.evaluateByOperator('+', [$$[$0 - 2], $$[$0]]);

                    break;
                case 8:

                    this.$ = yy.toNumber($$[$0 - 1]);

                    break;
                case 9:

                    this.$ = yy.evaluateByOperator('<=', [$$[$0 - 3], $$[$0]]);

                    break;
                case 10:

                    this.$ = yy.evaluateByOperator('>=', [$$[$0 - 3], $$[$0]]);

                    break;
                case 11:

                    this.$ = yy.evaluateByOperator('<>', [$$[$0 - 3], $$[$0]]);

                    break;
                case 12:

                    this.$ = yy.evaluateByOperator('NOT', [$$[$0 - 2], $$[$0]]);

                    break;
                case 13:

                    this.$ = yy.evaluateByOperator('>', [$$[$0 - 2], $$[$0]]);

                    break;
                case 14:

                    this.$ = yy.evaluateByOperator('<', [$$[$0 - 2], $$[$0]]);

                    break;
                case 15:

                    this.$ = yy.evaluateByOperator('-', [$$[$0 - 2], $$[$0]]);

                    break;
                case 16:

                    this.$ = yy.evaluateByOperator('*', [$$[$0 - 2], $$[$0]]);

                    break;
                case 17:

                    this.$ = yy.evaluateByOperator('/', [$$[$0 - 2], $$[$0]]);

                    break;
                case 18:

                    this.$ = yy.evaluateByOperator('^', [$$[$0 - 2], $$[$0]]);

                    break;
                case 19:

                    var n1 = yy.invertNumber($$[$0]);
                    this.$ = n1;
                    if (isNaN(this.$)) {
                        this.$ = 0;
                    }

                    break;
                case 20:

                    var n1 = yy.toNumber($$[$0]);
                    this.$ = n1;
                    if (isNaN(this.$)) {
                        this.$ = 0;
                    }

                    break;
                case 21:

                    this.$ = yy.callFunction($$[$0 - 2]);

                    break;
                case 22:

                    this.$ = yy.callFunction($$[$0 - 3], $$[$0 - 1]);

                    break;
                case 27:case 28:case 29:

                    this.$ = yy.cellValueInSheet($$[$0 - 2], $$[$0]);

                    break;
                case 30:case 31:case 32:case 33:case 34:case 35:case 36:case 37:case 38:

                    this.$ = yy.rangeValueInSheet($$[$0 - 4], $$[$0 - 2], $$[$0]);

                    break;
                case 39:case 40:case 41:

                    this.$ = yy.cellValue($$[$0]);

                    break;
                case 42:case 43:case 44:case 45:case 46:case 47:case 48:case 49:case 50:

                    this.$ = yy.rangeValue($$[$0 - 2], $$[$0]);

                    break;
                case 51:case 55:

                    this.$ = [$$[$0]];

                    break;
                case 52:

                    var result = [];
                    var arr = eval("[" + yytext + "]");

                    arr.forEach(function (item) {
                        result.push(item);
                    });

                    this.$ = result;

                    break;
                case 53:case 54:

                    $$[$0 - 2].push($$[$0]);
                    this.$ = $$[$0 - 2];

                    break;
                case 56:

                    this.$ = Array.isArray($$[$0 - 2]) ? $$[$0 - 2] : [$$[$0 - 2]];
                    this.$.push($$[$0]);

                    break;
                case 57:

                    this.$ = $$[$0];

                    break;
                case 58:

                    this.$ = ($$[$0 - 2] + '.' + $$[$0]) * 1;

                    break;
                case 59:

                    this.$ = $$[$0 - 1] * 0.01;

                    break;
                case 60:case 61:

                    this.$ = yy.throwError($$[$0 - 2] + $$[$0 - 1] + $$[$0]);

                    break;
            }
        },
        table: [{ 2: 12, 3: 1, 4: 2, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 1: [3] }, { 5: [1, 20], 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }, o($Vm, [2, 2], { 35: [1, 31] }), o($Vm, [2, 3], { 37: [1, 32] }), o($Vm, [2, 4]), { 2: 12, 4: 33, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 34, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 35, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 12: [1, 36] }, o($Vm, [2, 23]), o($Vm, [2, 24]), o($Vm, [2, 25], { 2: 37, 34: [1, 38], 38: $Vb }), o($Vn, [2, 55], { 38: $Vo }), o($Vp, [2, 57], { 35: [1, 40] }), { 26: [1, 41] }, o($Vm, [2, 39], { 30: [1, 42] }), o($Vm, [2, 40], { 30: [1, 43] }), o($Vm, [2, 41], { 30: [1, 44] }), { 34: [1, 45] }, { 1: [2, 1] }, { 2: 12, 4: 46, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 47, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 48, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 51, 6: 3, 7: 4, 8: $V0, 10: [1, 49], 11: $V1, 12: $V2, 15: [1, 50], 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 53, 6: 3, 7: 4, 8: $V0, 10: [1, 52], 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 54, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 55, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 56, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 57, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 58, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 34: [1, 59] }, o($Vp, [2, 59]), { 9: $Vc, 10: $Vd, 11: $Ve, 13: [1, 60], 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }, o($Vq, [2, 19], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vq, [2, 20], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), { 2: 12, 4: 63, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 13: [1, 61], 17: $V3, 21: $V4, 22: 62, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 31: [1, 64], 34: $V9, 36: $Va, 38: $Vb }, o($Vm, [2, 26]), { 38: $Vo }, { 34: [1, 65] }, { 36: [1, 66] }, { 27: [1, 67], 28: [1, 68], 29: [1, 69] }, { 27: [1, 70], 28: [1, 71], 29: [1, 72] }, { 27: [1, 73], 28: [1, 74], 29: [1, 75] }, { 27: [1, 76], 28: [1, 77], 29: [1, 78] }, { 26: [1, 79] }, o($Vm, [2, 5]), o([5, 10, 13, 32, 33], [2, 6], { 9: $Vc, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vq, [2, 7], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), { 2: 12, 4: 80, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 81, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, o($Vr, [2, 14], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), { 2: 12, 4: 82, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, o($Vr, [2, 13], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o([5, 10, 13, 16, 32, 33], [2, 12], { 9: $Vc, 11: $Ve, 14: $Vf, 15: $Vg, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vq, [2, 15], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vs, [2, 16], { 9: $Vc, 20: $Vl }), o($Vs, [2, 17], { 9: $Vc, 20: $Vl }), o([5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33], [2, 18], { 9: $Vc }), o($Vn, [2, 56]), o($Vm, [2, 8]), o($Vm, [2, 21]), { 13: [1, 83], 32: [1, 84], 33: [1, 85] }, o($Vt, [2, 51], { 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vt, [2, 52]), { 26: [1, 86] }, o($Vp, [2, 58]), o($Vm, [2, 27], { 30: [1, 87] }), o($Vm, [2, 28], { 30: [1, 88] }), o($Vm, [2, 29], { 30: [1, 89] }), o($Vm, [2, 42]), o($Vm, [2, 43]), o($Vm, [2, 44]), o($Vm, [2, 45]), o($Vm, [2, 46]), o($Vm, [2, 47]), o($Vm, [2, 48]), o($Vm, [2, 49]), o($Vm, [2, 50]), o($Vu, [2, 60]), o($Vr, [2, 9], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vr, [2, 11], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vr, [2, 10], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vm, [2, 22]), { 2: 12, 4: 90, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 91, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, o($Vu, [2, 61]), { 27: [1, 92], 28: [1, 93], 29: [1, 94] }, { 27: [1, 95], 28: [1, 96], 29: [1, 97] }, { 27: [1, 98], 28: [1, 99], 29: [1, 100] }, o($Vt, [2, 53], { 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vt, [2, 54], { 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vm, [2, 30]), o($Vm, [2, 31]), o($Vm, [2, 32]), o($Vm, [2, 33]), o($Vm, [2, 34]), o($Vm, [2, 35]), o($Vm, [2, 36]), o($Vm, [2, 37]), o($Vm, [2, 38])],
        defaultActions: { 20: [2, 1] },
        parseError: function parseError(str, hash) {
            if (hash.recoverable) {
                this.trace(str);
            } else {
                var _parseError = function _parseError(msg, hash) {
                    this.message = msg;
                    this.hash = hash;
                };

                _parseError.prototype = Error;

                throw new _parseError(str, hash);
            }
        },
        parse: function parse(input) {
            var self = this,
                stack = [0],
                tstack = [],
                // token stack
            vstack = [null],
                // semantic value stack
            lstack = [],
                // location stack
            table = this.table,
                yytext = '',
                yylineno = 0,
                yyleng = 0,
                recovering = 0,
                TERROR = 2,
                EOF = 1;

            var args = lstack.slice.call(arguments, 1);

            //this.reductionCount = this.shiftCount = 0;

            var lexer = Object.create(this.lexer);
            var sharedState = { yy: {} };
            // copy state
            for (var k in this.yy) {
                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                    sharedState.yy[k] = this.yy[k];
                }
            }

            lexer.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer;
            sharedState.yy.parser = this;
            if (typeof lexer.yylloc == 'undefined') {
                lexer.yylloc = {};
            }
            var yyloc = lexer.yylloc;
            lstack.push(yyloc);

            var ranges = lexer.options && lexer.options.ranges;

            if (typeof sharedState.yy.parseError === 'function') {
                this.parseError = sharedState.yy.parseError;
            } else {
                this.parseError = Object.getPrototypeOf(this).parseError;
            }

            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }

            _token_stack: var lex = function lex() {
                var token;
                token = lexer.lex() || EOF;
                // if token isn't its numeric value, convert
                if (typeof token !== 'number') {
                    token = self.symbols_[token] || token;
                }
                return token;
            };

            var symbol,
                preErrorSymbol,
                state,
                action,
                a,
                r,
                yyval = {},
                p,
                len,
                newState,
                expected;
            while (true) {
                // retreive state number from top of stack
                state = stack[stack.length - 1];

                // use default actions if available
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == 'undefined') {
                        symbol = lex();
                    }
                    // read action for current state and first input
                    action = table[state] && table[state][symbol];
                }

                _handle_error:
                // handle parse error
                if (typeof action === 'undefined' || !action.length || !action[0]) {

                    // Return the rule stack depth where the nearest error rule can be found.
                    // Return FALSE when no error recovery rule was found.
                    var locateNearestErrorRecoveryRule = function locateNearestErrorRecoveryRule(state) {
                        var stack_probe = stack.length - 1;
                        var depth = 0;

                        // try to recover from error
                        for (;;) {
                            // check for error recovery rule in this state
                            if (TERROR.toString() in table[state]) {
                                return depth;
                            }
                            if (state === 0 || stack_probe < 2) {
                                return false; // No suitable error recovery rule available.
                            }
                            stack_probe -= 2; // popStack(1): [symbol, action]
                            state = stack[stack_probe];
                            ++depth;
                        }
                    };

                    var error_rule_depth;
                    var errStr = '';

                    if (!recovering) {
                        // first see if there's any chance at hitting an error recovery rule:
                        error_rule_depth = locateNearestErrorRecoveryRule(state);

                        // Report error
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push("'" + this.terminals_[p] + "'");
                            }
                        }
                        if (lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ":\n" + lexer.showPosition() + "\nExpecting " + expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                        }
                        this.parseError(errStr, {
                            text: lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: lexer.yylineno,
                            loc: yyloc,
                            expected: expected,
                            recoverable: error_rule_depth !== false
                        });
                    } else if (preErrorSymbol !== EOF) {
                        error_rule_depth = locateNearestErrorRecoveryRule(state);
                    }

                    // just recovered from another error
                    if (recovering == 3) {
                        if (symbol === EOF || preErrorSymbol === EOF) {
                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
                        }

                        // discard current lookahead and grab another
                        yyleng = lexer.yyleng;
                        yytext = lexer.yytext;
                        yylineno = lexer.yylineno;
                        yyloc = lexer.yylloc;
                        symbol = lex();
                    }

                    // try to recover from error
                    if (error_rule_depth === false) {
                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
                    }
                    popStack(error_rule_depth);

                    preErrorSymbol = symbol == TERROR ? null : symbol; // save the lookahead token
                    symbol = TERROR; // insert generic error symbol as new lookahead
                    state = stack[stack.length - 1];
                    action = table[state] && table[state][TERROR];
                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
                }

                // this shouldn't happen, unless resolve defaults are off
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                }

                switch (action[0]) {
                    case 1:
                        // shift
                        //this.shiftCount++;

                        stack.push(symbol);
                        vstack.push(lexer.yytext);
                        lstack.push(lexer.yylloc);
                        stack.push(action[1]); // push state
                        symbol = null;
                        if (!preErrorSymbol) {
                            // normal execution/no error
                            yyleng = lexer.yyleng;
                            yytext = lexer.yytext;
                            yylineno = lexer.yylineno;
                            yyloc = lexer.yylloc;
                            if (recovering > 0) {
                                recovering--;
                            }
                        } else {
                            // error just occurred, resume old lookahead f/ before error
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;

                    case 2:
                        // reduce
                        //this.reductionCount++;

                        len = this.productions_[action[1]][1];

                        // perform semantic action
                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
                        // default location, uses first token for firsts, last for lasts
                        yyval._$ = {
                            first_line: lstack[lstack.length - (len || 1)].first_line,
                            last_line: lstack[lstack.length - 1].last_line,
                            first_column: lstack[lstack.length - (len || 1)].first_column,
                            last_column: lstack[lstack.length - 1].last_column
                        };
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                        }
                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

                        if (typeof r !== 'undefined') {
                            return r;
                        }

                        // pop off stack
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }

                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        // goto new state = table[STATE][NONTERMINAL]
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;

                    case 3:
                        // accept
                        return true;
                }
            }

            return true;
        } };

    /* generated by jison-lex 0.3.4 */
    var lexer = function () {
        var lexer = {

            EOF: 1,

            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },

            // resets the lexer, sets new input
            setInput: function setInput(input, yy) {
                this.yy = yy || this.yy || {};
                this._input = input;
                this._more = this._backtrack = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                };
                if (this.options.ranges) {
                    this.yylloc.range = [0, 0];
                }
                this.offset = 0;
                return this;
            },

            // consumes and returns one char from the input
            input: function input() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) {
                    this.yylloc.range[1]++;
                }

                this._input = this._input.slice(1);
                return ch;
            },

            // unshifts one char (or a string) into the input
            unput: function unput(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);

                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);

                if (lines.length - 1) {
                    this.yylineno -= lines.length - 1;
                }
                var r = this.yylloc.range;

                this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };

                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                this.yyleng = this.yytext.length;
                return this;
            },

            // When called from action, caches matched text and appends it on next action
            more: function more() {
                this._more = true;
                return this;
            },

            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function reject() {
                if (this.options.backtrack_lexer) {
                    this._backtrack = true;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
                return this;
            },

            // retain first n characters of the match
            less: function less(n) {
                this.unput(this.match.slice(n));
            },

            // displays already matched input, i.e. for error messages
            pastInput: function pastInput() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
            },

            // displays upcoming input, i.e. for error messages
            upcomingInput: function upcomingInput() {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },

            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function showPosition() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },

            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function test_match(match, indexed_rule) {
                var token, lines, backup;

                if (this.options.backtrack_lexer) {
                    // save context
                    backup = {
                        yylineno: this.yylineno,
                        yylloc: {
                            first_line: this.yylloc.first_line,
                            last_line: this.last_line,
                            first_column: this.yylloc.first_column,
                            last_column: this.yylloc.last_column
                        },
                        yytext: this.yytext,
                        match: this.match,
                        matches: this.matches,
                        matched: this.matched,
                        yyleng: this.yyleng,
                        offset: this.offset,
                        _more: this._more,
                        _input: this._input,
                        yy: this.yy,
                        conditionStack: this.conditionStack.slice(0),
                        done: this.done
                    };
                    if (this.options.ranges) {
                        backup.yylloc.range = this.yylloc.range.slice(0);
                    }
                }

                lines = match[0].match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno += lines.length;
                }
                this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                };
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._backtrack = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input) {
                    this.done = false;
                }
                if (token) {
                    return token;
                } else if (this._backtrack) {
                    // recover context
                    for (var k in backup) {
                        this[k] = backup[k];
                    }
                    return false; // rule action called reject() implying the next rule should be tested instead.
                }
                return false;
            },

            // return next match in input
            next: function next() {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) {
                    this.done = true;
                }

                var token, match, tempMatch, index;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (this.options.backtrack_lexer) {
                            token = this.test_match(tempMatch, rules[i]);
                            if (token !== false) {
                                return token;
                            } else if (this._backtrack) {
                                match = false;
                                continue; // rule action called reject() implying a rule MISmatch.
                            } else {
                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                return false;
                            }
                        } else if (!this.options.flex) {
                            break;
                        }
                    }
                }
                if (match) {
                    token = this.test_match(match, rules[index]);
                    if (token !== false) {
                        return token;
                    }
                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                    return false;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
            },

            // return next match that has a token
            lex: function lex() {
                var r = this.next();
                if (r) {
                    return r;
                } else {
                    return this.lex();
                }
            },

            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },

            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
                var n = this.conditionStack.length - 1;
                if (n > 0) {
                    return this.conditionStack.pop();
                } else {
                    return this.conditionStack[0];
                }
            },

            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                } else {
                    return this.conditions["INITIAL"].rules;
                }
            },

            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
                n = this.conditionStack.length - 1 - Math.abs(n || 0);
                if (n >= 0) {
                    return this.conditionStack[n];
                } else {
                    return "INITIAL";
                }
            },

            // alias for begin(condition)
            pushState: function pushState(condition) {
                this.begin(condition);
            },

            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
                return this.conditionStack.length;
            },
            options: {},
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                var YYSTATE = YY_START;
                switch ($avoiding_name_collisions) {
                    case 0:
                        /* 跳过空白符 */
                        break;
                    case 1:
                        return 25;
                        break;
                    case 2:
                        return 8;
                        break;
                    case 3:
                        return 8;
                        break;
                    case 4:
                        return 21;
                        break;
                    case 5:
                        return 25;
                        break;
                    case 6:
                        return 27;
                        break;
                    case 7:
                        return 29;
                        break;
                    case 8:
                        return 29;
                        break;
                    case 9:
                        return 28;
                        break;
                    case 10:
                        return 21;
                        break;
                    case 11:
                        return 34;
                        break;
                    case 12:
                        return 34;
                        break;
                    case 13:
                        return 36;
                        break;
                    case 14:
                        return 31;
                        break;
                    case 15:
                        break;
                    case 16:
                        return 9;
                        break;
                    case 17:
                        return ' ';
                        break;
                    case 18:
                        return 35;
                        break;
                    case 19:
                        return 30;
                        break;
                    case 20:
                        return 32;
                        break;
                    case 21:
                        return 33;
                        break;
                    case 22:
                        return 18;
                        break;
                    case 23:
                        return 19;
                        break;
                    case 24:
                        return 17;
                        break;
                    case 25:
                        return 11;
                        break;
                    case 26:
                        return 20;
                        break;
                    case 27:
                        return 12;
                        break;
                    case 28:
                        return 13;
                        break;
                    case 29:
                        return 15;
                        break;
                    case 30:
                        return 14;
                        break;
                    case 31:
                        return 16;
                        break;
                    case 32:
                        return '"';
                        break;
                    case 33:
                        return "'";
                        break;
                    case 34:
                        return "!";
                        break;
                    case 35:
                        return 10;
                        break;
                    case 36:
                        return 37;
                        break;
                    case 37:
                        return 38;
                        break;
                    case 38:
                        return 5;
                        break;
                }
            },
            rules: [/^(?:\s+)/, /^(?:'([^\\/\?\*\[\]\!'"]+)'(?=[!]))/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9\.]+(?=[(]))/, /^(?:[^\\/\?\*\[\]'"\!,\)]+(?=[!]))/, /^(?:\$[A-Za-z]+\$[0-9]+)/, /^(?:\$[A-Za-z]+[0-9]+)/, /^(?:[A-Za-z]+\$[0-9]+)/, /^(?:[A-Za-z]+[0-9]+)/, /^(?:[A-Za-z\.]+(?=[(]))/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9]+)/, /^(?:[A-Za-z_]+)/, /^(?:[0-9]+)/, /^(?:\[(.*)?\])/, /^(?:\$)/, /^(?:&)/, /^(?: )/, /^(?:[.])/, /^(?::)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\/)/, /^(?:-)/, /^(?:\+)/, /^(?:\^)/, /^(?:\()/, /^(?:\))/, /^(?:>)/, /^(?:<)/, /^(?:NOT\b)/, /^(?:")/, /^(?:')/, /^(?:!)/, /^(?:=)/, /^(?:%)/, /^(?:[#])/, /^(?:$)/],
            conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38], "inclusive": true } }
        };
        return lexer;
    }();
    parser.lexer = lexer;
    function Parser() {
        this.yy = {};
    }
    Parser.prototype = parser;parser.Parser = Parser;
    return new Parser();
}();

var Parser = exports.Parser = grammar.Parser;

},{}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '+';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc + (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (Number.isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '&';

function func() {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return params.reduce(function (acc, value) {
    return acc + value.toString();
  }, '');
};

func.SYMBOL = SYMBOL;

},{}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '/';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc / (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (result === Infinity) {
    throw Error(_error.ERROR_DIV_ZERO);
  }
  if (Number.isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '=';

function func(exp1, exp2) {
  return exp1 === exp2;
};

func.SYMBOL = SYMBOL;

},{}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _supportedFormulas = require('./../supported-formulas');

var _supportedFormulas2 = _interopRequireDefault(_supportedFormulas);

var _error = require('./../error');

var _formulajs = require('formulajs');

var formulajs = _interopRequireWildcard(_formulajs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SYMBOL = exports.SYMBOL = _supportedFormulas2.default; /**
                                                            * Excel 公式中的函数，由 formulajs 实现。
                                                            *
                                                            */

function func(symbol) {
    return function () {
        symbol = symbol.toUpperCase();

        var symbolParts = symbol.split('.');
        var foundFormula = false;
        var result = void 0;

        if (symbolParts.length === 1) {
            if (formulajs[symbolParts[0]]) {
                foundFormula = true;
                result = formulajs[symbolParts[0]].apply(formulajs, arguments);
            }
        } else {
            var length = symbolParts.length;
            var index = 0;
            var nestedFormula = formulajs;

            while (index < length) {
                nestedFormula = nestedFormula[symbolParts[index]];
                index++;

                if (!nestedFormula) {
                    nestedFormula = null;
                    break;
                }
            }
            if (nestedFormula) {
                foundFormula = true;
                result = nestedFormula.apply(undefined, arguments);
            }
        }

        if (!foundFormula) {
            throw Error(_error.ERROR_NAME);
        }

        return result;
    };
};

func.isFactory = true;
func.SYMBOL = SYMBOL;

},{"./../error":36,"./../supported-formulas":53,"formulajs":1}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '>=';

function func(exp1, exp2) {
  return exp1 >= exp2;
};

func.SYMBOL = SYMBOL;

},{}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '>';

function func(exp1, exp2) {
  return exp1 > exp2;
};

func.SYMBOL = SYMBOL;

},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '<=';

function func(exp1, exp2) {
  return exp1 <= exp2;
};

func.SYMBOL = SYMBOL;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '<';

function func(exp1, exp2) {
  return exp1 < exp2;
};

func.SYMBOL = SYMBOL;

},{}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '-';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc - (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '*';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc * (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '<>';

function func(exp1, exp2) {
  return exp1 !== exp2;
};

func.SYMBOL = SYMBOL;

},{}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '^';

function func(exp1, exp2) {
  var result = Math.pow((0, _utils.toNumber)(exp1), (0, _utils.toNumber)(exp2));

  if (Number.isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = evaluateByOperator;
exports.registerOperation = registerOperation;

var _add = require('./operator/add');

var _add2 = _interopRequireDefault(_add);

var _ampersand = require('./operator/ampersand');

var _ampersand2 = _interopRequireDefault(_ampersand);

var _divide = require('./operator/divide');

var _divide2 = _interopRequireDefault(_divide);

var _equal = require('./operator/equal');

var _equal2 = _interopRequireDefault(_equal);

var _formulaFunction = require('./operator/formula-function');

var _formulaFunction2 = _interopRequireDefault(_formulaFunction);

var _greaterThan = require('./operator/greater-than');

var _greaterThan2 = _interopRequireDefault(_greaterThan);

var _greaterThanOrEqual = require('./operator/greater-than-or-equal');

var _greaterThanOrEqual2 = _interopRequireDefault(_greaterThanOrEqual);

var _lessThan = require('./operator/less-than');

var _lessThan2 = _interopRequireDefault(_lessThan);

var _lessThanOrEqual = require('./operator/less-than-or-equal');

var _lessThanOrEqual2 = _interopRequireDefault(_lessThanOrEqual);

var _minus = require('./operator/minus');

var _minus2 = _interopRequireDefault(_minus);

var _multiply = require('./operator/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _notEqual = require('./operator/not-equal');

var _notEqual2 = _interopRequireDefault(_notEqual);

var _power = require('./operator/power');

var _power2 = _interopRequireDefault(_power);

var _error = require('./error');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
// import {default as crossSheet} from './operator/cross-sheet';


var availableOperators = Object.create(null);

registerOperation(_add2.default.SYMBOL, _add2.default);
registerOperation(_ampersand2.default.SYMBOL, _ampersand2.default);
// registerOperation(crossSheet.SYMBOL, crossSheet);
registerOperation(_divide2.default.SYMBOL, _divide2.default);
registerOperation(_equal2.default.SYMBOL, _equal2.default);
registerOperation(_power2.default.SYMBOL, _power2.default);
registerOperation(_formulaFunction2.default.SYMBOL, _formulaFunction2.default);
registerOperation(_greaterThan2.default.SYMBOL, _greaterThan2.default);
registerOperation(_greaterThanOrEqual2.default.SYMBOL, _greaterThanOrEqual2.default);
registerOperation(_lessThan2.default.SYMBOL, _lessThan2.default);
registerOperation(_lessThanOrEqual2.default.SYMBOL, _lessThanOrEqual2.default);
registerOperation(_multiply2.default.SYMBOL, _multiply2.default);
registerOperation(_notEqual2.default.SYMBOL, _notEqual2.default);
registerOperation(_minus2.default.SYMBOL, _minus2.default);

function evaluateByOperator(operator) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    operator = operator.toUpperCase();

    if (!availableOperators[operator]) {
        throw Error(_error.ERROR_NAME);
    }
    return availableOperators[operator].apply(availableOperators, _toConsumableArray(params));
}

/**
 * 注册
 * @param symbol
 * @param func
 */
function registerOperation(symbol, func) {
    if (!Array.isArray(symbol)) {
        symbol = [symbol.toUpperCase()];
    }
    symbol.forEach(function (s) {
        if (func.isFactory) {
            availableOperators[s] = func(s);
        } else {
            availableOperators[s] = func;
        }
    });
}

},{"./error":36,"./operator/add":38,"./operator/ampersand":39,"./operator/divide":40,"./operator/equal":41,"./operator/formula-function":42,"./operator/greater-than":44,"./operator/greater-than-or-equal":43,"./operator/less-than":46,"./operator/less-than-or-equal":45,"./operator/minus":47,"./operator/multiply":48,"./operator/not-equal":49,"./operator/power":50}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Parser = exports.SUPPORTED_FORMULAS = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _supportedFormulas = require('./supported-formulas');

Object.defineProperty(exports, 'SUPPORTED_FORMULAS', {
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_supportedFormulas).default;
    }
});

var _Emitter2 = require('../../../utils/Emitter');

var _Emitter3 = _interopRequireDefault(_Emitter2);

var _operators = require('./operators');

var _operators2 = _interopRequireDefault(_operators);

var _grammar = require('./grammar');

var _utils = require('./utils');

var _error = require('./error');

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 公式解析器。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 底层的语法解析器使用 jison 生成，参见 http://zaa.ch/jison/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 注意: jison 生成的代码使用 AMD 方式导出变量，重新生成后记得改成 ES6 的方式:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *      `export var Parser = grammar.Parser;`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @class Parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fires Parser#callVariable
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fires Parser#callCellValue
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fires Parser#callRangeValue
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var Parser = function (_Emitter) {
    _inherits(Parser, _Emitter);

    function Parser() {
        _classCallCheck(this, Parser);

        var _this = _possibleConstructorReturn(this, (Parser.__proto__ || Object.getPrototypeOf(Parser)).call(this));

        _this.parser = new _grammar.Parser();
        _this.parser.yy = {
            toNumber: _utils.toNumber,
            trimEdges: _utils.trimEdges,
            invertNumber: _utils.invertNumber,
            throwError: function throwError(errorName) {
                return Parser._throwError(errorName);
            },
            callVariable: function callVariable(variable) {
                return _this._callVariable(variable);
            },
            evaluateByOperator: _operators2.default,
            callFunction: _operators2.default,
            cellValue: function cellValue(value) {
                return _this._callCellValue(value);
            },
            rangeValue: function rangeValue(start, end) {
                return _this._callRangeValue(start, end);
            },
            cellValueInSheet: function cellValueInSheet(sheetName, value) {
                return _this._callCellValueInSheet(sheetName, value);
            },
            rangeValueInSheet: function rangeValueInSheet(sheetName, start, end) {
                return _this._callRangeValueInSheet(sheetName, start, end);
            },
            parseError: function parseError() {
                return Parser._parseError.apply(Parser, arguments);
            }
        };
        _this.variables = Object.create(null);

        _this.setVariable('TRUE', true).setVariable('FALSE', false).setVariable('NULL', null);
        return _this;
    }

    /**
     * 解析表达式
     * @param expression
     * @returns {{error: *, result: *}}
     */


    _createClass(Parser, [{
        key: 'parse',
        value: function parse(expression) {
            var result = null;
            var error = null;

            try {
                result = this.parser.parse(expression);
            } catch (ex) {
                var message = (0, _error2.default)(ex.message);
                if (message) {
                    error = message;
                } else {
                    error = (0, _error2.default)(_error.ERROR);
                }
            }

            if (result instanceof Error) {
                error = (0, _error2.default)(result.message) || (0, _error2.default)(_error.ERROR);
                result = null;
            }

            return {
                error: error,
                result: result
            };
        }

        /**
         * 设置变量
         * @param name
         * @param value
         * @returns {Parser}
         */

    }, {
        key: 'setVariable',
        value: function setVariable(name, value) {
            this.variables[name] = value;
            return this;
        }
    }, {
        key: 'getVariable',
        value: function getVariable(name) {
            return this.variables[name];
        }

        /**
         * 调用变量值
         * @param name
         * @returns {*}
         * @private
         */

    }, {
        key: '_callVariable',
        value: function _callVariable(name) {
            var value = this.getVariable(name);

            this.emit('callVariable', name, function (newValue) {
                if (newValue !== void 0) {
                    value = newValue;
                }
            });

            if (value === void 0) {
                throw Error(_error.ERROR_NAME);
            }

            return value;
        }

        /**
         * 调用单元格的值
         * @param {string} label - 例如 `B3`, `B$3`, `B$3`, `$B$3`
         * @returns {*}
         * @private
         */

    }, {
        key: '_callCellValue',
        value: function _callCellValue(label) {
            var _extractLabel = (0, _utils.extractLabel)(label),
                _extractLabel2 = _slicedToArray(_extractLabel, 2),
                row = _extractLabel2[0],
                column = _extractLabel2[1];

            var value = void 0;

            this.emit('callCellValue', { label: label, row: row, column: column }, function (_value) {
                value = _value;
            });

            return value;
        }

        /**
         * 调用指定 sheet 中单元格的值
         * @param sheetName
         * @param label
         * @returns {*}
         * @private
         */

    }, {
        key: '_callCellValueInSheet',
        value: function _callCellValueInSheet(sheetName, label) {
            var _extractLabel3 = (0, _utils.extractLabel)(label),
                _extractLabel4 = _slicedToArray(_extractLabel3, 2),
                row = _extractLabel4[0],
                column = _extractLabel4[1];

            var value = void 0;

            this.emit('callCellValueInSheet', { sheetName: sheetName, label: label, row: row, column: column }, function (_value) {
                value = _value;
            });
            return value;
        }
    }, {
        key: '_callRangeValue',


        /**
         * 调用某范围的单元格值，如 `B3:A1`
         * @param {string} startLabel - 起始标签，如 `B3`
         * @param {string} endLabel - 结束标签，如 `A1`
         * @returns {Array}
         * @private
         */
        value: function _callRangeValue(startLabel, endLabel) {
            var _Parser$_explainCell = Parser._explainCell(startLabel, endLabel),
                startCell = _Parser$_explainCell.startCell,
                endCell = _Parser$_explainCell.endCell;

            var value = [];
            this.emit('callRangeValue', startCell, endCell, function () {
                var _value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

                value = _value;
            });
            return value;
        }

        /**
         * 调用指定 sheet 中某范围的单元格值，如 `工作表1!B3:A1`
         * @param sheetName
         * @param startLabel
         * @param endLabel
         * @returns {Array}
         * @private
         */

    }, {
        key: '_callRangeValueInSheet',
        value: function _callRangeValueInSheet(sheetName, startLabel, endLabel) {
            var _Parser$_explainCell2 = Parser._explainCell(startLabel, endLabel),
                startCell = _Parser$_explainCell2.startCell,
                endCell = _Parser$_explainCell2.endCell;

            var value = [];
            this.emit('callRangeValueInSheet', sheetName, startCell, endCell, function () {
                var _value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

                value = _value;
            });
            return value;
        }

        /**
         *
         * @param errorName
         * @returns {*}
         * @private
         */

    }], [{
        key: '_explainCell',
        value: function _explainCell(startLabel, endLabel) {
            var _extractLabel5 = (0, _utils.extractLabel)(startLabel),
                _extractLabel6 = _slicedToArray(_extractLabel5, 2),
                startRow = _extractLabel6[0],
                startColumn = _extractLabel6[1];

            var _extractLabel7 = (0, _utils.extractLabel)(endLabel),
                _extractLabel8 = _slicedToArray(_extractLabel7, 2),
                endRow = _extractLabel8[0],
                endColumn = _extractLabel8[1];

            var startCell = {};
            var endCell = {};

            if (startRow.index <= endRow.index) {
                startCell.row = startRow;
                endCell.row = endRow;
            } else {
                startCell.row = endRow;
                endCell.row = startRow;
            }

            if (startColumn.index <= endColumn.index) {
                startCell.column = startColumn;
                endCell.column = endColumn;
            } else {
                startCell.column = endColumn;
                endCell.column = startColumn;
            }

            startCell.label = (0, _utils.toLabel)(startCell.row, startCell.column);
            endCell.label = (0, _utils.toLabel)(endCell.row, endCell.column);
            return { startCell: startCell, endCell: endCell };
        }
    }, {
        key: '_throwError',
        value: function _throwError(errorName) {
            var parsedError = (0, _error2.default)(errorName);
            if (parsedError) {
                throw Error(parsedError);
            }
            return errorName;
        }

        // TODO 解析失败时，给用户提供合适的错误信息。

    }, {
        key: '_parseError',
        value: function _parseError() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            console.log(args);
        }
    }]);

    return Parser;
}(_Emitter3.default);

exports.Parser = Parser;

},{"../../../utils/Emitter":58,"./error":36,"./grammar":37,"./operators":51,"./supported-formulas":53,"./utils":54}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SUPPORTED_FORMULAS = ['ABS', 'ACCRINT', 'ACOS', 'ACOSH', 'ACOT', 'ACOTH', 'ADD', 'AGGREGATE', 'AND', 'ARABIC', 'ARGS2ARRAY', 'ASIN', 'ASINH', 'ATAN', 'ATAN2', 'ATANH', 'AVEDEV', 'AVERAGE', 'AVERAGEA', 'AVERAGEIF', 'AVERAGEIFS', 'BASE', 'BESSELI', 'BESSELJ', 'BESSELK', 'BESSELY', 'BETA.DIST', 'BETA.INV', 'BETADIST', 'BETAINV', 'BIN2DEC', 'BIN2HEX', 'BIN2OCT', 'BINOM.DIST', 'BINOM.DIST.RANGE', 'BINOM.INV', 'BINOMDIST', 'BITAND', 'BITLSHIFT', 'BITOR', 'BITRSHIFT', 'BITXOR', 'CEILING', 'CEILINGMATH', 'CEILINGPRECISE', 'CHAR', 'CHISQ.DIST', 'CHISQ.DIST.RT', 'CHISQ.INV', 'CHISQ.INV.RT', 'CHOOSE', 'CHOOSE', 'CLEAN', 'CODE', 'COLUMN', 'COLUMNS', 'COMBIN', 'COMBINA', 'COMPLEX', 'CONCATENATE', 'CONFIDENCE', 'CONFIDENCE.NORM', 'CONFIDENCE.T', 'CONVERT', 'CORREL', 'COS', 'COSH', 'COT', 'COTH', 'COUNT', 'COUNTA', 'COUNTBLANK', 'COUNTIF', 'COUNTIFS', 'COUNTIN', 'COUNTUNIQUE', 'COVARIANCE.P', 'COVARIANCE.S', 'CSC', 'CSCH', 'CUMIPMT', 'CUMPRINC', 'DATE', 'DATEVALUE', 'DAY', 'DAYS', 'DAYS360', 'DB', 'DDB', 'DEC2BIN', 'DEC2HEX', 'DEC2OCT', 'DECIMAL', 'DEGREES', 'DELTA', 'DEVSQ', 'DIVIDE', 'DOLLAR', 'DOLLARDE', 'DOLLARFR', 'E', 'EDATE', 'EFFECT', 'EOMONTH', 'EQ', 'ERF', 'ERFC', 'EVEN', 'EXACT', 'EXPON.DIST', 'EXPONDIST', 'F.DIST', 'F.DIST.RT', 'F.INV', 'F.INV.RT', 'FACT', 'FACTDOUBLE', 'FALSE', 'FDIST', 'FDISTRT', 'FIND', 'FINV', 'FINVRT', 'FISHER', 'FISHERINV', 'FIXED', 'FLATTEN', 'FLOOR', 'FORECAST', 'FREQUENCY', 'FV', 'FVSCHEDULE', 'GAMMA', 'GAMMA.DIST', 'GAMMA.INV', 'GAMMADIST', 'GAMMAINV', 'GAMMALN', 'GAMMALN.PRECISE', 'GAUSS', 'GCD', 'GEOMEAN', 'GESTEP', 'GROWTH', 'GTE', 'HARMEAN', 'HEX2BIN', 'HEX2DEC', 'HEX2OCT', 'HOUR', 'HTML2TEXT', 'HYPGEOM.DIST', 'HYPGEOMDIST', 'IF', 'IMABS', 'IMAGINARY', 'IMARGUMENT', 'IMCONJUGATE', 'IMCOS', 'IMCOSH', 'IMCOT', 'IMCSC', 'IMCSCH', 'IMDIV', 'IMEXP', 'IMLN', 'IMLOG10', 'IMLOG2', 'IMPOWER', 'IMPRODUCT', 'IMREAL', 'IMSEC', 'IMSECH', 'IMSIN', 'IMSINH', 'IMSQRT', 'IMSUB', 'IMSUM', 'IMTAN', 'INT', 'INTERCEPT', 'INTERVAL', 'IPMT', 'IRR', 'ISBINARY', 'ISBLANK', 'ISEVEN', 'ISLOGICAL', 'ISNONTEXT', 'ISNUMBER', 'ISODD', 'ISODD', 'ISOWEEKNUM', 'ISPMT', 'ISTEXT', 'JOIN', 'KURT', 'LARGE', 'LCM', 'LEFT', 'LEN', 'LINEST', 'LN', 'LOG', 'LOG10', 'LOGEST', 'LOGNORM.DIST', 'LOGNORM.INV', 'LOGNORMDIST', 'LOGNORMINV', 'LOWER', 'LT', 'LTE', 'MATCH', 'MAX', 'MAXA', 'MEDIAN', 'MID', 'MIN', 'MINA', 'MINUS', 'MINUTE', 'MIRR', 'MOD', 'MODE.MULT', 'MODE.SNGL', 'MODEMULT', 'MODESNGL', 'MONTH', 'MROUND', 'MULTINOMIAL', 'MULTIPLY', 'NE', 'NEGBINOM.DIST', 'NEGBINOMDIST', 'NETWORKDAYS', 'NOMINAL', 'NORM.DIST', 'NORM.INV', 'NORM.S.DIST', 'NORM.S.INV', 'NORMDIST', 'NORMINV', 'NORMSDIST', 'NORMSINV', 'NOT', 'NOW', 'NPER', 'NPV', 'NUMBERS', 'NUMERAL', 'OCT2BIN', 'OCT2DEC', 'OCT2HEX', 'ODD', 'OR', 'PDURATION', 'PEARSON', 'PERCENTILEEXC', 'PERCENTILEINC', 'PERCENTRANKEXC', 'PERCENTRANKINC', 'PERMUT', 'PERMUTATIONA', 'PHI', 'PI', 'PMT', 'POISSON.DIST', 'POISSONDIST', 'POW', 'POWER', 'PPMT', 'PROB', 'PRODUCT', 'PROPER', 'PV', 'QUARTILE.EXC', 'QUARTILE.INC', 'QUARTILEEXC', 'QUARTILEINC', 'QUOTIENT', 'RADIANS', 'RAND', 'RANDBETWEEN', 'RANK.AVG', 'RANK.EQ', 'RANKAVG', 'RANKEQ', 'RATE', 'REFERENCE', 'REGEXEXTRACT', 'REGEXMATCH', 'REGEXREPLACE', 'REPLACE', 'REPT', 'RIGHT', 'ROMAN', 'ROUND', 'ROUNDDOWN', 'ROUNDUP', 'ROW', 'ROWS', 'RRI', 'RSQ', 'SEARCH', 'SEC', 'SECH', 'SECOND', 'SERIESSUM', 'SIGN', 'SIN', 'SINH', 'SKEW', 'SKEW.P', 'SKEWP', 'SLN', 'SLOPE', 'SMALL', 'SPLIT', 'SPLIT', 'SQRT', 'SQRTPI', 'STANDARDIZE', 'STDEV.P', 'STDEV.S', 'STDEVA', 'STDEVP', 'STDEVPA', 'STDEVS', 'STEYX', 'SUBSTITUTE', 'SUBTOTAL', 'SUM', 'SUMIF', 'SUMIFS', 'SUMPRODUCT', 'SUMSQ', 'SUMX2MY2', 'SUMX2PY2', 'SUMXMY2', 'SWITCH', 'SYD', 'T', 'T.DIST', 'T.DIST.2T', 'T.DIST.RT', 'T.INV', 'T.INV.2T', 'TAN', 'TANH', 'TBILLEQ', 'TBILLPRICE', 'TBILLYIELD', 'TDIST', 'TDIST2T', 'TDISTRT', 'TEXT', 'TIME', 'TIMEVALUE', 'TINV', 'TINV2T', 'TODAY', 'TRANSPOSE', 'TREND', 'TRIM', 'TRIMMEAN', 'TRUE', 'TRUNC', 'UNICHAR', 'UNICODE', 'UNIQUE', 'UPPER', 'VALUE', 'VAR.P', 'VAR.S', 'VARA', 'VARP', 'VARPA', 'VARS', 'WEEKDAY', 'WEEKNUM', 'WEIBULL.DIST', 'WEIBULLDIST', 'WORKDAY', 'XIRR', 'XNPV', 'XOR', 'YEAR', 'YEARFRAC'];

exports.default = SUPPORTED_FORMULAS;

},{}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.extractLabel = extractLabel;
exports.toLabel = toLabel;
exports.columnLabelToIndex = columnLabelToIndex;
exports.columnIndexToLabel = columnIndexToLabel;
exports.rowLabelToIndex = rowLabelToIndex;
exports.rowIndexToLabel = rowIndexToLabel;
exports.toNumber = toNumber;
exports.invertNumber = invertNumber;
exports.trimEdges = trimEdges;
/* ****************************************** *\
 *                  单元格相关
 * ****************************************** */

var LABEL_EXTRACT_REGEXP = /^([$])?([A-Za-z]+)([$])?([0-9]+)$/;

function extractLabel(label) {
    if (!LABEL_EXTRACT_REGEXP.test(label)) {
        return [];
    }

    var _label$match = label.match(LABEL_EXTRACT_REGEXP),
        _label$match2 = _slicedToArray(_label$match, 5),
        columnAbs = _label$match2[1],
        column = _label$match2[2],
        rowAbs = _label$match2[3],
        row = _label$match2[4];

    return [{
        index: rowLabelToIndex(row),
        label: row,
        isAbsolute: rowAbs === '$'
    }, {
        index: columnLabelToIndex(column),
        label: column,
        isAbsolute: columnAbs === '$'
    }];
}

function toLabel(row, column) {
    var rowLabel = (row.isAbsolute ? '$' : '') + rowIndexToLabel(row.index);
    var columnLabel = (column.isAbsolute ? '$' : '') + columnIndexToLabel(column.index);
    return columnLabel + rowLabel;
}

var COLUMN_LABEL_BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
var COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;

function columnLabelToIndex(label) {
    var result = 0;

    if (label) {
        for (var i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {
            result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j) * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);
        }
    }
    --result;

    return result;
}

function columnIndexToLabel(column) {
    var result = '';

    while (column >= 0) {
        result = String.fromCharCode(column % COLUMN_LABEL_BASE_LENGTH + 97) + result;
        column = Math.floor(column / COLUMN_LABEL_BASE_LENGTH) - 1;
    }

    return result.toUpperCase();
}

function rowLabelToIndex(label) {
    var result = parseInt(label, 10);

    if (Number.isNaN(result)) {
        result = -1;
    } else {
        result = Math.max(result - 1, -1);
    }
    return result;
}

function rowIndexToLabel(row) {
    return row >= 0 ? '' + (row + 1) : '';
}

/* ****************************************** *\
 *                  number
 * ****************************************** */

function toNumber(number) {
    var result = void 0;
    if (typeof number === 'number') {
        result = number;
    } else if (typeof number === 'string') {
        result = number.indexOf('.') > -1 ? parseFloat(number) : parseInt(number, 10);
    }
    return result;
}

/**
 * 取负数
 * @param {Number} number
 * @returns {Number}
 */
function invertNumber(number) {
    return -1 * toNumber(number);
}

/* ****************************************** *\
 *                  string
 * ****************************************** */

function trimEdges(string) {
    var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    string = string.substring(margin, string.length - margin);
    return string;
}

},{}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFormulaExpression = isFormulaExpression;
exports.isFormulaExpressionEscaped = isFormulaExpressionEscaped;
exports.unescapeFormulaExpression = unescapeFormulaExpression;
exports.toUpperCaseFormula = toUpperCaseFormula;

/**
 * Check if provided expression is valid formula expression.
 *
 * @param {*} expression Expression to check.
 * @returns {Boolean}
 */
function isFormulaExpression(expression) {
    return expression && (expression + '').charAt(0) === '=' ? true : false;
}

/**
 * Check if provided formula expression is escaped.
 *
 * @param {*} expression Expression to check.
 * @returns {Boolean}
 */
function isFormulaExpressionEscaped(expression) {
    return expression && (expression + '').charAt(0) === '\'' && (expression + '').charAt(1) === '=' ? true : false;
}

/**
 * Replace escaped formula expression into valid string.
 *
 * @param {String} expression Expression to process.
 * @returns {String}
 */
function unescapeFormulaExpression(expression) {
    return isFormulaExpressionEscaped(expression) ? expression.substr(1) : expression;
}

/**
 * Upper case formula expression.
 *
 * @param {String} expression Formula expression.
 * @returns {String}
 */
function toUpperCaseFormula(expression) {
    var PATTERN = /(\\"|"(?:\\"|[^"])*"|(\+))|(\\'|'(?:\\'|[^'])*'|(\+))/g;
    var strings = expression.match(PATTERN) || [];
    var index = -1;

    return expression.toUpperCase().replace(PATTERN, function () {
        ++index;

        return strings[index];
    });
}

},{}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = polyfill;
/**
 *
 * @param _g 全局变量（即浏览器环境下的 window 对象）
 */
function polyfill(_g) {

    // --------------------------------------------- es6 polyfill

    // Number.isNaN()
    if (!_g.Number.isNaN) {
        _g.Number.isNaN = function (x) {
            return x !== x;
        };
    }

    // String.contains()
    if (typeof _g.String.prototype.contains === 'undefined') {
        _g.String.prototype.contains = function (str) {
            return !!~this.indexOf(str);
        };
    }

    // String.startsWith()
    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function (searchString, position) {
            position = position || 0;
            return this.substr(position, searchString.length) === searchString;
        };
    }

    // --------------------------------------------- IE polyfill

    // HTMLElement.classList
    if (!('classList' in document.documentElement)) {
        Object.defineProperty(HTMLElement.prototype, 'classList', {
            get: function get() {
                var self = this;

                function update(fn) {
                    return function (value) {
                        var classes = self.className.split(/\s+/g);
                        var index = classes.indexOf(value);

                        fn(classes, index, value);
                        self.className = classes.join(' ');
                    };
                }

                return {
                    add: update(function (classes, index, value) {
                        if (!~index) {
                            classes.push(value);
                        }
                    }),

                    remove: update(function (classes, index) {
                        if (~index) {
                            classes.splice(index, 1);
                        }
                    }),

                    toggle: update(function (classes, index, value) {
                        if (~index) {
                            classes.splice(index, 1);
                        } else {
                            classes.push(value);
                        }
                    }),

                    contains: function contains(value) {
                        return !!~self.className.split(/\s+/g).indexOf(value);
                    },

                    item: function item(i) {
                        return self.className.split(/\s+/g)[i] || null;
                    }
                };
            }
        });
    }
}

},{}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * 全局配置。
 */
var globalSettings = {
    idPrefix: 'brick-ssd-',
    idSuffix4Workbook: '-workbook',

    sheet: {

        /**
         * 自动生成工作表名称时的前缀(工作表1, 工作表2...)
         */
        autoPrefix: '工作表',

        /**
         * sheet 名称中的非法字符。微软没有相关文档，以下是 Apache POI 的说明：
         *
         * Note that sheet name in Excel must not exceed 31 characters
         * and must not contain any of the any of the following characters:
         *    - 0x0000
         *    - 0x0003
         *    - colon (:)
         *    - backslash (\)
         *    - asterisk (*)
         *    - question mark (?)
         *    - forward slash (/)
         *    - opening square bracket ([)
         *    - closing square bracket (])
         *
         */
        sheetName: /[\\/\?\*:\[\]'"]/,

        animated: false
    }

};

/**
 * 默认配置
 */
var defaultSettings = {

    workbook: {
        activeSheet: '工作表1',
        sheets: [{
            name: '工作表1'
        }]
    },

    persistent: true

};

exports.globalSettings = globalSettings;
exports.defaultSettings = defaultSettings;

},{}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * 事件发射器
 *
 * PS: nodejs 的系统类库 Emitter 过大，不适合在浏览器环境使用。故引入一个简易实现。
 * @constructor
 */
function Emitter() {
    // 保持此函数为空，以便于继承
}

Emitter.prototype = {

    /**
     * 订阅事件
     * @param {string} name - 事件名
     * @param {function} callback - 事件回调函数
     * @param [ctx] - 设置调用 callback 时的上下文
     * @returns {Emitter}
     */
    on: function on(name, callback, ctx) {
        var e = this.e || (this.e = {});

        (e[name] || (e[name] = [])).push({
            fn: callback,
            ctx: ctx
        });

        return this;
    },

    /**
     * 订阅一次性事件
     * @param {string} name - 事件名
     * @param {function} callback - 事件回调函数
     * @param ctx - 设置调用 callback 时的上下文
     * @returns {*|Emitter}
     */
    once: function once(name, callback, ctx) {
        var self = this;

        function listener() {
            self.off(name, listener);
            callback.apply(ctx, arguments);
        }

        listener._ = callback;
        return this.on(name, listener, ctx);
    },

    /**
     * 发射指定事件
     * @param {string} name - 事件名
     * @returns {Emitter}
     */
    emit: function emit(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;

        for (i; i < len; i++) {
            evtArr[i].fn.apply(evtArr[i].ctx, data);
        }

        return this;
    },

    /**
     * 注销事件
     * @param {string} name - 事件名
     * @param {function} [callback] - 绑定事件时的回调函数，如果不指定则注销所有 `name` 事件
     * @returns {Emitter}
     */
    off: function off(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];

        if (evts && callback) {
            for (var i = 0, len = evts.length; i < len; i++) {
                if (evts[i].fn !== callback && evts[i].fn._ !== callback) {
                    liveEvents.push(evts[i]);
                }
            }
        }

        // 防止内存溢出
        liveEvents.length ? e[name] = liveEvents : delete e[name];

        return this;
    },

    /**
     * 获取全局唯一事件发射器
     */
    getGlobalEmitter: function () {
        var instance = new Emitter();
        return function () {
            return instance;
        };
    }()
};

exports.default = Emitter;

/**
 * 全局唯一事件发射器
 */

var GlobalEmitter = exports.GlobalEmitter = Emitter.prototype.getGlobalEmitter();

},{}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extend = extend;
exports.objectEach = objectEach;
exports.emptyFunction = emptyFunction;
exports.upperCase = upperCase;
exports.upperCaseFirst = upperCaseFirst;
exports.randomString = randomString;
exports.isEmptyValue = isEmptyValue;


// ------------------------------------- object

function extend(target, extension) {
    objectEach(extension, function (value, key) {
        target[key] = value;
    });
    return target;
}

function objectEach(object, iteratee) {
    for (var key in object) {
        if (!object.hasOwnProperty || object.hasOwnProperty && object.hasOwnProperty(key)) {
            if (iteratee(object[key], key, object) === false) {
                break;
            }
        }
    }
    return object;
}

// ------------------------------------- function

var _emptyFn = function _emptyFn() {};

/**
 * 获取空函数。
 * @param newOne 默认 `false`，当为 `true` 时将返回一个新的空函数。
 * @returns {Function}
 */
function emptyFunction() {
    var newOne = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (newOne) {
        return function () {};
    }
    return _emptyFn;
}

// ------------------------------------- string


function upperCase(str) {
    return str.toUpperCase();
}

function upperCaseFirst(str) {
    return str.replace(/^\S/g, function (f) {
        return upperCase(f);
    });
}

/**
 * 生成一个长度为 16 的随机字符串
 * @returns {*}
 */
function randomString() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    return s4() + s4() + s4() + s4();
}

// ------------------------------------- mixed

/**
 * 判断是否为`空`值。
 * PS：此方法的判断逻辑作为单元格是否为空的依据。
 * @param value
 * @returns {boolean}
 */
function isEmptyValue(value) {
    return value === '' || value === null || typeof value === 'undefined';
}

// ------------------------------------- coordinate


var c_isEqual = function c_isEqual(r1, r2) {
    return r1[0] === r2[0] && r1[1] === r2[1] && r1[2] === r2[2] && r1[3] === r2[3];
};

var c_intersection = function c_intersection(r1, r2) {
    var x1 = Math.max(r1[0], r2[0]);
    var y1 = Math.max(r1[1], r2[1]);
    var x2 = Math.min(r1[2], r2[2]);
    var y2 = Math.min(r1[3], r2[3]);

    if (x1 <= x2 && y1 <= y2) {
        return [x1, y1, x2, y2];
    }
    return false;
};

var c_set = function c_set(t) {
    return function (r1, r2) {
        var ins = c_intersection(r1, r2);
        if (ins) {
            return c_isEqual(ins, t === 'sub' ? r1 : r2);
        }
        return false;
    };
};

var Coordinate = exports.Coordinate = {

    /**
     * 判断坐标范围 r1 是否与 r2 相等。
     * @param {Array} r1
     * @param {int} r1[0] - 坐标范围 r1 的起始行坐标
     * @param {int} r1[1] - 坐标范围 r1 的起始列坐标
     * @param {int} r1[2] - 坐标范围 r1 的终止行坐标
     * @param {int} r1[3] - 坐标范围 r1 的终止列坐标
     * @param {Array} r2
     * @param {int} r2[0] - 坐标范围 r2 的起始行坐标
     * @param {int} r2[1] - 坐标范围 r2 的起始列坐标
     * @param {int} r2[2] - 坐标范围 r2 的终止行坐标
     * @param {int} r2[3] - 坐标范围 r2 的终止列坐标
     * @returns {boolean}
     */
    isEqual: c_isEqual,

    /**
     * 判断坐标范围 r1 是否与 r2 存在交集。
     * @returns {boolean}
     */
    intersection: c_intersection,

    /**
     * 判断坐标范围 r1 是否是 r2 的子集。
     * @returns {boolean}
     */
    isSubset: c_set('sub'),

    /**
     * 判断坐标范围 r1 是否是 r2 的超集。
     * @returns {boolean}
     */
    isSuperset: c_set('sup')
};

// -------------------------------------

},{}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Stack = exports.CaseInsensitiveMap = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _common = require('./common.js');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 大小写不敏感的 Map
 */
var CaseInsensitiveMap = function () {
    function CaseInsensitiveMap(iterable) {
        _classCallCheck(this, CaseInsensitiveMap);

        this._map = new Map(iterable);
        this._keys = {};
    }

    _createClass(CaseInsensitiveMap, [{
        key: 'get',
        value: function get(key) {
            var acKey = this._keys[(0, _common.upperCase)(key)];
            return this._map.get(acKey);
        }
    }, {
        key: 'set',
        value: function set(key, value) {
            this._keys[(0, _common.upperCase)(key)] = key;
            return this._map.set(key, value);
        }
    }, {
        key: 'has',
        value: function has(key) {
            return this._keys[(0, _common.upperCase)(key)];
        }
    }, {
        key: 'hasExact',
        value: function hasExact(key) {
            return this._map.has(key);
        }
    }, {
        key: 'clear',
        value: function clear() {
            this._keys = {};
            return this._map.clear();
        }
    }, {
        key: 'delete',
        value: function _delete(key) {
            var acKey = this._keys[(0, _common.upperCase)(key)];
            delete this._keys[(0, _common.upperCase)(key)];
            return this._map.delete(acKey);
        }
    }, {
        key: 'entries',
        value: function entries() {
            return this._map.entries();
        }
    }, {
        key: 'forEach',
        value: function forEach(callbackfn, thisArg) {
            return this._map.forEach(callbackfn, thisArg);
        }

        /**
         *
         * @returns {Iterator.<string>}
         */

    }, {
        key: 'keys',
        value: function keys() {
            return this._map.keys();
        }
    }, {
        key: 'values',
        value: function values() {
            return this._map.values();
        }
    }, {
        key: 'toMap',
        value: function toMap() {
            return this._map;
        }
    }, {
        key: 'size',
        value: function size() {
            return this._map.size;
        }
    }]);

    return CaseInsensitiveMap;
}();

/**
 * Stack
 */


var Stack = function () {
    function Stack() {
        var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        _classCallCheck(this, Stack);

        this.items = initial;
    }

    _createClass(Stack, [{
        key: 'push',
        value: function push() {
            var _items;

            (_items = this.items).push.apply(_items, arguments);
        }
    }, {
        key: 'pop',
        value: function pop() {
            return this.items.pop();
        }
    }, {
        key: 'peek',
        value: function peek() {
            return this.isEmpty() ? void 0 : this.items[this.items.length - 1];
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return !this.size();
        }
    }, {
        key: 'size',
        value: function size() {
            return this.items.length;
        }
    }]);

    return Stack;
}();

exports.CaseInsensitiveMap = CaseInsensitiveMap;
exports.Stack = Stack;

},{"./common.js":59}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.innerHTML = innerHTML;
exports.insertAfter = insertAfter;
exports.closest = closest;
exports.empty = empty;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
var textContextSupport = document.createTextNode('test').textContent ? true : false;

var REG_HTML_CHARACTERS = /(<(.*)>|&(.*);)/;

/**
 * 能同时兼容文本节点的 innerHTML 方法。
 *
 * @returns {void}
 */
function innerHTML(element, content) {
    if (REG_HTML_CHARACTERS.test(content)) {
        element.innerHTML = content;
    } else {
        var child = element.firstChild;
        if (child && child.nodeType === 3 && child.nextSibling === null) {
            if (textContextSupport) {
                child.textContent = content;
            } else {
                child.data = content;
            }
        } else {
            empty(element);
            element.appendChild(document.createTextNode(content));
        }
    }
}

/**
 * 在指定节点后插入节点
 * @param element
 * @param content
 */
function insertAfter(element, content) {
    if (REG_HTML_CHARACTERS.test(content)) {
        element.insertAdjacentHTML('afterend', content);
    } else {
        if (content.nodeType === 1) {
            if (element.nextSibling) {
                element.parentNode.insertBefore(content, element.nextSibling);
            } else {
                element.parentNode.appendChild(content);
            }
        } else {
            // TODO
        }
    }
}

function closest(element, selector) {
    var ret;
    do {
        element = element.parentNode;
        if (!element || !element.ownerDocument || (ret = element.querySelector(selector))) {
            break;
        }
    } while (element);

    return ret;
}

/**
 * 清空指定元素的所有子节点。
 *
 * @param element
 * @returns {void}
 */
function empty(element) {
    var child;
    while (child = element.lastChild) {
        // jshint ignore:line
        try {
            element.removeChild(child);
        } catch (e) {
            // TODO 暂时这样处理 https://bugzilla.mozilla.org/show_bug.cgi?id=559561
        }
    }
}

/**
 * 返回指定元素的外高度（包括 padding、border 及可选的 margin 值）。
 *
 * @param el
 * @param {Boolean} withMargin - 高度中是否包括 margin 值
 * @returns {number}
 */
function outerHeight(el) {
    var withMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var height = el.offsetHeight;
    var style;

    if (withMargin === false) {
        return height;
    }
    style = getComputedStyle(el);
    height += parseInt(style.marginTop) + parseInt(style.marginBottom);
    return height;
}

/**
 * 返回指定元素的外宽度（包括 padding、border 及可选的 margin 值）。
 *
 * @param el
 * @param {Boolean} withMargin - 宽度中是否包括 margin 值
 * @returns {number}
 */
function outerWidth(el) {
    var withMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var width = el.offsetWidth;
    var style;

    if (withMargin === false) {
        return width;
    }
    style = getComputedStyle(el);
    width += parseInt(style.marginLeft) + parseInt(style.marginRight);
    return width;
}

},{}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stopImmediatePropagation = stopImmediatePropagation;
exports.stopPropagation = stopPropagation;
/**
 * 阻止其它监听被调用。
 * @param {Event} event
 */
function stopImmediatePropagation(event) {
    event.isImmediatePropagationEnabled = false;
    event.cancelBubble = true;
}

/**
 * 阻止事件冒泡。
 * @param {Event} event
 */
function stopPropagation(event) {
    if (typeof event.stopPropagation === 'function') {
        event.stopPropagation();
    } else {
        event.cancelBubble = true;
    }
}

},{}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var arrayEach = Handsontable.helper.arrayEach;
var defineGetter = Handsontable.helper.defineGetter;

var MIXIN_NAME = 'localHooks';

/**
 * 用来做对象掺和的 hooks.
 *
 * @type {Object}
 */
var localHooks = {

    _localHooks: Object.create(null),

    /**
     * 增加 hook
     *
     * @param {string} key - hook 名
     * @param {Function} callback - 回调
     */
    addLocalHook: function addLocalHook(key, callback) {
        if (!this._localHooks[key]) {
            this._localHooks[key] = [];
        }
        this._localHooks[key].push(callback);
    },

    /**
     * 执行 hooks
     *
     * @param {String} key - hook 名
     * @param {*} params
     */
    runLocalHooks: function runLocalHooks(key) {
        var _this = this;

        for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
        }

        if (this._localHooks[key]) {
            arrayEach(this._localHooks[key], function (callback) {
                return callback.apply(_this, params);
            });
        }
    },

    /**
     * 清空 hooks
     */
    clearLocalHooks: function clearLocalHooks() {
        this._localHooks = {};
    }
};

defineGetter(localHooks, 'MIXIN_NAME', MIXIN_NAME, {
    writable: false,
    enumerable: false
});

exports.default = localHooks;

},{}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL2Rpc3QvZm9ybXVsYS5qcyIsIm5vZGVfbW9kdWxlcy9mb3JtdWxhanMvbm9kZV9tb2R1bGVzL2pTdGF0L2Rpc3QvanN0YXQuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL25vZGVfbW9kdWxlcy9udW1lcmFsL251bWVyYWwuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL25vZGVfbW9kdWxlcy9udW1lcmljL251bWVyaWMtMS4yLjYuanMiLCJzcmMvU3ByZWFkU2hlZXRFcnJvci5qcyIsInNyYy9icm93c2VyLmpzIiwic3JjL2NvcmUuanMiLCJzcmMvZGVzaWduZXIvQ29uZmlnVHJhbnNsYXRvci5qcyIsInNyYy9kZXNpZ25lci9GcmFtZS5qcyIsInNyYy9kZXNpZ25lci9Ib3RUYWJsZUFkYXB0b3IuanMiLCJzcmMvZGVzaWduZXIvU2hlZXQuanMiLCJzcmMvZGVzaWduZXIvU2hlZXRFcnJvci5qcyIsInNyYy9kZXNpZ25lci9Xb3JrYm9vay5qcyIsInNyYy9kZXNpZ25lci9leHQvU2hlZXRfZXhjaGFuZ2UuanMiLCJzcmMvZGVzaWduZXIvZXh0L1NoZWV0X2hlbHBlci5qcyIsInNyYy9kZXNpZ25lci9mcmFtZS9Db250ZXh0TWVudS5qcyIsInNyYy9kZXNpZ25lci9mcmFtZS9Db250ZXh0TWVudV9hbGlnbm1lbnQuanMiLCJzcmMvZGVzaWduZXIvZnJhbWUvQ29udGV4dE1lbnVfbWVyZ2VDZWxscy5qcyIsInNyYy9kZXNpZ25lci9mcmFtZS9Db250ZXh0TWVudV9yb3dPckNvbHVtblJlc2l6ZS5qcyIsInNyYy9kZXNpZ25lci92aWV3cy9UYWJzLmpzIiwic3JjL2kxOG4uanMiLCJzcmMvcGx1Z2lucy9QbHVnaW4uanMiLCJzcmMvcGx1Z2lucy9QbHVnaW5FcnJvci5qcyIsInNyYy9wbHVnaW5zL3BlcnNpc3RlbnQvUGVyc2lzdGVudC5qcyIsInNyYy9wbHVnaW5zL3BlcnNpc3RlbnQvU3RvcmFnZS5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9BbHRlck1hbmFnZXIuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvQmFzZUNlbGwuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvQ2VsbFJlZmVyZW5jZS5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9DZWxsVmFsdWUuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvRGF0YVByb3ZpZGVyLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL01hdHJpeC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9TaGVldC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9VbmRvUmVkb1NuYXBzaG90LmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL1hGb3JtdWxhcy5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9leHByZXNzaW9uTW9kaWZpZXIuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL2Vycm9yLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9ncmFtbWFyLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9hZGQuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL2FtcGVyc2FuZC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvZGl2aWRlLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9lcXVhbC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvZm9ybXVsYS1mdW5jdGlvbi5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvZ3JlYXRlci10aGFuLW9yLWVxdWFsLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9ncmVhdGVyLXRoYW4uanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL2xlc3MtdGhhbi1vci1lcXVhbC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvbGVzcy10aGFuLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9taW51cy5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvbXVsdGlwbHkuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL25vdC1lcXVhbC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvcG93ZXIuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9ycy5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvcGFyc2VyLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9zdXBwb3J0ZWQtZm9ybXVsYXMuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL3V0aWxzLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3V0aWxzLmpzIiwic3JjL3BvbHlmaWxsLmpzIiwic3JjL3NldHRpbmdzLmpzIiwic3JjL3V0aWxzL0VtaXR0ZXIuanMiLCJzcmMvdXRpbHMvY29tbW9uLmpzIiwic3JjL3V0aWxzL2RhdGFTdHJ1Y3R1cmUuanMiLCJzcmMvdXRpbHMvZG9tSGVscGVyLmpzIiwic3JjL3V0aWxzL2V2ZW50SGVscGVyLmpzIiwic3JjL3V0aWxzL2xvY2FsSG9va3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3gwSUEsU0FBUyxnQkFBVCxHQUE0QjtBQUN4QixTQUFLLElBQUwsR0FBWSxrQkFBWjtBQUNBLFNBQUssT0FBTCxHQUFlLE9BQWY7QUFDSDs7QUFFRCxpQkFBaUIsU0FBakIsR0FBNkIsSUFBSSxLQUFKLEVBQTdCO0FBQ0EsaUJBQWlCLFNBQWpCLENBQTJCLFdBQTNCLEdBQXlDLGdCQUF6QztBQUNBLGlCQUFpQixTQUFqQixDQUEyQixRQUEzQixHQUFzQyxZQUFZO0FBQzlDLFdBQU8sS0FBSyxJQUFMLEdBQVksTUFBWixHQUFxQixLQUFLLE9BQWpDO0FBQ0gsQ0FGRDs7UUFJUSxnQixHQUFBLGdCOzs7OztBQ1hSOztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFHQSxlQUFZLGNBQVo7QUFOQTs7QUFPQSxlQUFZLGVBQVo7QUFDQSxlQUFZLE9BQVosR0FBc0IsZUFBdEI7O0FBRUEsZUFBWSxPQUFaLEdBQXNCO0FBQ2xCLDBCQURrQjtBQUVsQjtBQUZrQixDQUF0Qjs7QUFLQTtBQUNBLDRCQUFlLFlBQWY7O0FBR0E7QUFDQSxPQUFPLGdCQUFQO0FBQ0EsT0FBTyxXQUFQLEdBQXFCLEVBQXJCO0FBQ0Esd0JBQVMsTUFBVDs7QUFFQTs7Ozs7Ozs7Ozs7QUMzQkE7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQSxJQUFJLFVBQVUsQ0FBZDs7SUFFTSxXOzs7QUFFRjs7Ozs7Ozs7OztBQVVBLHlCQUFZLFdBQVosRUFBeUIsWUFBekIsRUFBNEQ7QUFBQSxZQUFyQixXQUFxQix1RUFBUCxLQUFPOztBQUFBOztBQUFBOztBQUd4RCxjQUFLLFdBQUwsR0FBbUIsV0FBbkI7QUFDQSxjQUFLLGVBQUwsQ0FBcUIsWUFBckI7O0FBRUEsY0FBSyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsNEJBQU8sTUFBSyxRQUFaLEVBQXNCLFlBQVksZUFBbEM7QUFDQSw0QkFBTyxNQUFLLFFBQVosRUFBc0IsTUFBSyxZQUEzQjs7QUFFQSxjQUFLLEVBQUwsR0FBVSxNQUFLLFFBQUwsQ0FBYyxFQUFkLElBQW9CLE1BQUssS0FBTCxFQUE5QjtBQUNBLGNBQUssV0FBTCxHQUFtQixXQUFuQjs7QUFFQSxjQUFLLFdBQUw7QUFDQSxjQUFLLEtBQUwsR0FBYSwyQkFBZ0IsTUFBSyxRQUFMLENBQWMsS0FBOUIsQ0FBYjtBQUNBLGNBQUssUUFBTCxHQUFnQiw4QkFBbUIsTUFBSyxRQUFMLENBQWMsUUFBakMsQ0FBaEI7QUFDQSxjQUFLLGFBQUw7QUFoQndEO0FBaUIzRDs7OztnQ0FFTztBQUNKO0FBQ0EsbUJBQU8sS0FBSyxFQUFMLElBQVcsWUFBWSxjQUFaLENBQTJCLFFBQTNCLEdBQXVDLFNBQXZDLEdBQW9ELEdBQXBELEdBQTBELDJCQUE1RTtBQUNIOzs7eUNBRWdCO0FBQ2IsbUJBQU8sS0FBSyxXQUFaO0FBQ0g7Ozt5Q0FFZ0I7QUFDYixtQkFBTyxLQUFLLFdBQVo7QUFDSDs7QUFFRDs7Ozs7Ozs7d0NBS2dCLEMsRUFBRztBQUNmLGdCQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQix1QkFBTyxLQUFLLFlBQVo7QUFDSDtBQUNELGdCQUFJLEtBQUssT0FBTyxDQUFQLEtBQWEsUUFBdEIsRUFBZ0M7QUFDNUIscUJBQUssWUFBTCxHQUFvQixLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQXBCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gscUJBQUssWUFBTCxHQUFvQixDQUFwQjtBQUNIO0FBQ0QsbUJBQU8sS0FBSyxZQUFaO0FBQ0g7O0FBRUQ7Ozs7Ozs7c0NBSWM7QUFDVixtQkFBTyxLQUFLLFFBQVo7QUFDSDs7QUFFRDs7Ozs7Ozs7MENBS2dDO0FBQUEsZ0JBQWhCLE1BQWdCLHVFQUFQLEtBQU87O0FBQzVCLGdCQUFJLElBQUksS0FBSyxRQUFMLENBQWMsWUFBZCxFQUFSO0FBQ0EsZ0JBQUksSUFBSSxLQUFLLEtBQUwsQ0FBVyxZQUFYLEVBQVIsQ0FGNEIsQ0FFTztBQUNuQyxnQkFBSSxJQUFJO0FBQ0osMEJBQVUsQ0FETjtBQUVKLHVCQUFPLENBRkg7QUFHSixvQkFBSSxLQUFLLEtBQUw7QUFIQSxhQUFSO0FBS0EsbUJBQU8sU0FBUyxDQUFULEdBQWEsS0FBSyxTQUFMLENBQWUsQ0FBZixDQUFwQjtBQUNIOztBQUVEOzs7Ozs7OzhDQUlzQjtBQUNsQixtQkFBTyxLQUFLLFFBQVo7QUFDSDs7QUFFRDs7Ozs7OzsyQ0FJbUI7QUFDZixtQkFBTyxLQUFLLEtBQVo7QUFDSDs7O3NDQUdhO0FBQUE7O0FBQ1YsaUJBQUssT0FBTCxHQUFlLElBQUksR0FBSixFQUFmO0FBQ0EseUNBQWdCLE9BQWhCLENBQXdCLGFBQUs7QUFDekIsb0JBQUksSUFBSSxJQUFJLENBQUosUUFBUjtBQUNBLDRDQUFlLENBQWY7QUFDQSx1QkFBSyxPQUFMLENBQWEsR0FBYixDQUFpQixFQUFFLFFBQW5CLEVBQTZCLENBQTdCO0FBQ0gsYUFKRDtBQUtIOzs7d0NBRWU7QUFDWixpQkFBSyxPQUFMLENBQWEsT0FBYixDQUFxQixhQUFLO0FBQ3RCLG9CQUFJLEVBQUUsUUFBRixFQUFKLEVBQWtCO0FBQ2Qsc0JBQUUsTUFBRjtBQUNIO0FBQ0osYUFKRDtBQUtIOzs7Ozs7a0JBR1UsVzs7Ozs7Ozs7Ozs7OztBQ2hJZjs7Ozs7O0lBTU0sZ0I7O0FBRUY7Ozs7OztBQU1BLDhCQUFZLE1BQVosRUFBb0IsS0FBcEIsRUFBMkI7QUFBQTs7QUFDdkIsYUFBSyxhQUFMLEdBQXFCLE1BQXJCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGFBQUssV0FBTCxHQUFtQixNQUFNLFFBQU4sQ0FBZSxXQUFsQztBQUNIOztBQUdEOzs7Ozs7Ozs7Ozs7b0NBUVk7QUFDUixnQkFBSSxXQUFXLEVBQWY7QUFDQSxnQkFBSSxRQUFRLE9BQU8sY0FBUCxDQUFzQixJQUF0QixDQUFaO0FBQ0EsZ0JBQUksV0FBVyxPQUFPLG1CQUFQLENBQTJCLEtBQTNCLENBQWY7O0FBRUEsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLE1BQTdCLEVBQXFDLEVBQUUsQ0FBdkMsRUFBMEM7QUFDdEMsb0JBQUksU0FBUyxDQUFULEVBQVksVUFBWixDQUF1QixRQUF2QixDQUFKLEVBQXNDO0FBQ2xDLHlCQUFLLFNBQVMsQ0FBVCxDQUFMLEVBQWtCLElBQWxCLENBQXVCLElBQXZCLEVBQTZCLFFBQTdCO0FBQ0g7QUFDSjtBQUNELG1CQUFPLFFBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7eUNBS2lCO0FBQ2IsZ0JBQUksUUFBUSxPQUFPLGNBQVAsQ0FBc0IsSUFBdEIsQ0FBWjtBQUNBLGdCQUFJLFdBQVcsT0FBTyxtQkFBUCxDQUEyQixLQUEzQixDQUFmOztBQUVBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxFQUFFLENBQXZDLEVBQTBDO0FBQ3RDLG9CQUFJLFNBQVMsQ0FBVCxFQUFZLFVBQVosQ0FBdUIsT0FBdkIsQ0FBSixFQUFxQztBQUNqQyx5QkFBSyxTQUFTLENBQVQsQ0FBTCxFQUFrQixJQUFsQixDQUF1QixJQUF2QjtBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7OzttQ0FFVyxRLEVBQVU7QUFDakIsZ0JBQUksSUFBSSxLQUFLLGFBQUwsQ0FBbUIsU0FBM0I7QUFDQSxnQkFBSSxDQUFKLEVBQU87QUFDSCx5QkFBUyxJQUFULEdBQWdCLEVBQWhCO0FBQ0EscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFFLE1BQXRCLEVBQThCLEVBQUUsQ0FBaEMsRUFBbUM7QUFDL0Isd0JBQUksTUFBTSxFQUFFLENBQUYsQ0FBVjtBQUNBLHlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBSSxNQUF4QixFQUFnQyxFQUFFLENBQWxDLEVBQXFDO0FBQ2pDLDRCQUFJLFdBQVcsSUFBSSxDQUFKLENBQWY7QUFDQSw0QkFBSSxRQUFKLEVBQWM7QUFDVixnQ0FBSSxPQUFPLEVBQVg7QUFDQSxpQ0FBSyxHQUFMLEdBQVcsU0FBUyxHQUFwQjtBQUNBLGlDQUFLLEdBQUwsR0FBVyxTQUFTLEdBQXBCOztBQUVBO0FBQ0EsZ0NBQUksU0FBUyxRQUFiLEVBQXVCO0FBQ25CLHFDQUFLLElBQUksRUFBVCxJQUFlLFNBQVMsUUFBeEIsRUFBa0M7QUFDOUIsd0NBQUksU0FBUyxRQUFULENBQWtCLGNBQWxCLENBQWlDLEVBQWpDLENBQUosRUFBMEM7QUFDdEMsNkNBQUssRUFBTCxJQUFXLFNBQVMsUUFBVCxDQUFrQixFQUFsQixDQUFYO0FBQ0g7QUFDSjtBQUNELHFDQUFLLElBQUwsR0FBWSxTQUFTLFFBQVQsQ0FBa0IsUUFBOUI7QUFDQSx1Q0FBTyxLQUFLLFFBQVo7QUFDSDs7QUFFRDtBQUNBLGdDQUFJLFNBQVMsTUFBYixFQUFxQjtBQUNqQixvQ0FBSSxTQUFTLE1BQVQsQ0FBZ0IsVUFBcEIsRUFBZ0M7QUFDNUIsd0NBQUksSUFBSSxTQUFTLE1BQVQsQ0FBZ0IsVUFBaEIsQ0FBMkIsSUFBM0IsQ0FBZ0MsS0FBaEMsQ0FBUjtBQUNBLHlDQUFLLFNBQUwsR0FBaUIsS0FBSyxTQUFMLEdBQWtCLEtBQUssU0FBTCxJQUFrQixRQUFRLENBQTVDLEdBQWlELE9BQU8sQ0FBekU7QUFDSDtBQUNELG9DQUFJLFNBQVMsTUFBVCxDQUFnQixVQUFwQixFQUFnQztBQUM1Qix5Q0FBSyxpQkFBTCxHQUF5QixTQUFTLE1BQVQsQ0FBZ0IsVUFBekM7QUFDSDtBQUNELG9DQUFJLFNBQVMsTUFBVCxDQUFnQixRQUFwQixFQUE4QjtBQUMxQix5Q0FBSyxlQUFMLEdBQXVCLFNBQVMsTUFBVCxDQUFnQixRQUF2QztBQUNIO0FBQ0Qsb0NBQUksU0FBUyxNQUFULENBQWdCLEtBQXBCLEVBQTJCO0FBQ3ZCLHlDQUFLLFlBQUwsR0FBb0IsU0FBUyxNQUFULENBQWdCLEtBQXBDO0FBQ0g7QUFDRCxvQ0FBSSxTQUFTLE1BQVQsQ0FBZ0IsZUFBcEIsRUFBcUM7QUFDakMseUNBQUssc0JBQUwsR0FBOEIsU0FBUyxNQUFULENBQWdCLGVBQTlDO0FBQ0g7QUFDRCxvQ0FBSSxTQUFTLE1BQVQsQ0FBZ0IsU0FBcEIsRUFBK0I7QUFDM0IseUNBQUssU0FBTCxHQUFpQixLQUFLLFNBQUwsR0FDVixLQUFLLFNBQUwsSUFBa0IsZUFBZSxTQUFTLE1BQVQsQ0FBZ0IsU0FEdkMsR0FFWCxjQUFjLFNBQVMsTUFBVCxDQUFnQixTQUZwQztBQUdIO0FBQ0Qsb0NBQUksU0FBUyxNQUFULENBQWdCLFVBQXBCLEVBQWdDO0FBQzVCLHlDQUFLLFNBQUwsR0FBaUIsS0FBSyxTQUFMLEdBQ1YsS0FBSyxTQUFMLElBQWtCLGdCQURSLEdBRVgsZUFGTjtBQUdIO0FBQ0Qsb0NBQUksU0FBUyxNQUFULENBQWdCLGNBQXBCLEVBQW9DO0FBQ2hDLHlDQUFLLFNBQUwsR0FBaUIsS0FBSyxTQUFMLEdBQ1YsS0FBSyxTQUFMLElBQWtCLHFCQURSLEdBRVgsb0JBRk47QUFHSDtBQUNKO0FBQ0QscUNBQVMsSUFBVCxDQUFjLElBQWQsQ0FBbUIsSUFBbkI7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKOzs7bUNBRVUsUSxFQUFVO0FBQ2pCLGdCQUFJLElBQUksS0FBSyxhQUFMLENBQW1CLElBQTNCO0FBQ0EsZ0JBQUksQ0FBSixFQUFPO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQUksQ0FBQyxLQUFLLFdBQUwsQ0FBaUIsV0FBdEIsRUFBbUM7QUFDL0IsNkJBQVMsT0FBVCxHQUFtQixLQUFLLEtBQUwsQ0FBVyxRQUE5QjtBQUNBLDZCQUFTLE9BQVQsR0FBbUIsS0FBSyxLQUFMLENBQVcsUUFBOUI7QUFDSDtBQUNELHlCQUFTLElBQVQsR0FBZ0IsQ0FBaEI7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O3NDQUNjLFEsRUFBVSxDQUt2QjtBQUpHO0FBQ0E7QUFDQTtBQUNBOzs7QUFHSjs7Ozt5Q0FDaUIsUSxFQUFVO0FBQ3ZCLGdCQUFJLElBQUksS0FBSyxhQUFMLENBQW1CLFVBQTNCO0FBQ0EsZ0JBQUksQ0FBSixFQUFPO0FBQ0gseUJBQVMsVUFBVCxHQUFzQixDQUF0QjtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUE7Ozs7eUNBQ2lCO0FBQ2IsZ0JBQUksSUFBSSxLQUFLLGFBQUwsQ0FBbUIsU0FBM0I7QUFDQSxnQkFBSSxDQUFKLEVBQU87QUFDSCxxQkFBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixFQUFFLEdBQXBCLEVBQXlCLEVBQUUsR0FBM0IsRUFBZ0MsRUFBRSxNQUFsQyxFQUEwQyxFQUFFLE1BQTVDO0FBQ0gsYUFGRCxNQUVPO0FBQ0gscUJBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBckI7QUFDSDtBQUNKOztBQUVEOzs7O3lDQUNpQjtBQUNiLGdCQUFNLElBQUksS0FBSyxhQUFMLENBQW1CLFNBQTdCO0FBQ0EsZ0JBQU0sTUFBTSxLQUFLLEtBQUwsQ0FBVyxZQUFYLENBQXdCLFNBQXhCLENBQWtDLG9CQUFsQyxDQUFaO0FBQ0EsZ0JBQUksVUFBSjtBQUFBLGdCQUFPLFlBQVA7O0FBRUEsZ0JBQUksS0FBSyxFQUFFLE1BQVgsRUFBbUI7QUFDZixxQkFBSyxJQUFJLENBQUosRUFBTyxNQUFNLEVBQUUsTUFBcEIsRUFBNEIsSUFBSSxHQUFoQyxFQUFxQyxFQUFFLENBQXZDLEVBQTBDO0FBQ3RDLHdCQUFJLGFBQUosQ0FBa0IsQ0FBbEIsRUFBcUIsRUFBRSxDQUFGLENBQXJCO0FBQ0g7QUFDSjtBQUNKOztBQUVEOzs7OzBDQUNrQjtBQUNkLGdCQUFNLElBQUksS0FBSyxhQUFMLENBQW1CLFVBQTdCO0FBQ0EsZ0JBQU0sTUFBTSxLQUFLLEtBQUwsQ0FBVyxZQUFYLENBQXdCLFNBQXhCLENBQWtDLGlCQUFsQyxDQUFaO0FBQ0EsZ0JBQUksVUFBSjtBQUFBLGdCQUFPLFlBQVA7O0FBRUEsZ0JBQUksS0FBSyxFQUFFLE1BQVgsRUFBbUI7QUFDZixxQkFBSyxJQUFJLENBQUosRUFBTyxNQUFNLEVBQUUsTUFBcEIsRUFBNEIsSUFBSSxHQUFoQyxFQUFxQyxFQUFFLENBQXZDLEVBQTBDO0FBQ3RDLHdCQUFJLGFBQUosQ0FBa0IsQ0FBbEIsRUFBcUIsRUFBRSxDQUFGLENBQXJCO0FBQ0g7QUFDSjtBQUNKOzs7Ozs7a0JBSVUsZ0I7Ozs7Ozs7Ozs7O0FDcE9mOzs7Ozs7OztBQUVBOzs7O0lBSU0sSztBQUVGLGlCQUFZLFFBQVosRUFBc0IsTUFBdEIsRUFBOEI7QUFBQTs7QUFDMUIsU0FBSyxXQUFMLEdBQW1CLFFBQW5CO0FBQ0E7Ozs7QUFJQSxTQUFLLFdBQUwsR0FBbUIsMEJBQWdCLFFBQWhCLENBQW5CO0FBQ0g7Ozs7bUNBRWMsQ0FFZDs7Ozs7O2tCQUlVLEs7Ozs7Ozs7Ozs7Ozs7QUNwQmY7O0FBQ0E7Ozs7Ozs7Ozs7K2VBSkE7Ozs7O0lBTU0sZTs7O0FBRUY7Ozs7Ozs7QUFPQSw2QkFBWSxXQUFaLEVBQXlCLE1BQXpCLEVBQWlDLFNBQWpDLEVBQTRDLEtBQTVDLEVBQW1EO0FBQUE7O0FBQy9DLFlBQUksY0FBYyxFQUFsQjtBQUNBLFlBQUksYUFBYSwrQkFBcUIsTUFBckIsRUFBNkIsS0FBN0IsQ0FBakI7QUFDQSxZQUFJLFdBQVcsV0FBVyxTQUFYLEVBQWY7QUFDQSxZQUFJLEtBQUssTUFBTSxRQUFOLENBQWUsV0FBeEI7O0FBRUEsWUFBSSxRQUFRLEdBQUcsZ0JBQUgsRUFBWjtBQUNBLFlBQUksY0FBYyxHQUFHLGNBQUgsRUFBbEI7QUFDQSxZQUFJLFlBQVksTUFBTSxXQUFOLENBQWtCLFNBQWxDO0FBQ0EsWUFBSSxjQUFjLEVBQWxCOztBQUVBLG9CQUFZLEtBQVosR0FBb0IsTUFBTSxXQUFOLENBQWtCLHFCQUFsQixFQUFwQjtBQUNBLG9CQUFZLFFBQVosR0FBd0IsVUFBVSxLQUFWLEVBQWlCO0FBQ3JDLG1CQUFPLFVBQVUsR0FBVixFQUFlLE9BQWYsRUFBd0I7QUFDM0Isb0JBQUksVUFBVSxHQUFWLENBQWMsR0FBZCxDQUFKLEVBQXdCO0FBQ3BCLHdCQUFJLE9BQU8sVUFBVSxHQUFWLENBQWMsR0FBZCxDQUFYO0FBQ0Esd0JBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2QsNkJBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsRUFBd0IsS0FBeEIsRUFBK0IsUUFBUSxLQUF2QyxFQUE4QyxRQUFRLEdBQXRELEVBQTJELE9BQTNEO0FBQ0g7QUFDSjtBQUNKLGFBUEQ7QUFRSCxTQVR1QixDQVN0QixLQVRzQixDQUF4Qjs7QUFXQSxTQUFDLFdBQUQsS0FBaUIsZ0JBQWdCLFdBQWhCLENBQTRCLFdBQTVCLEdBQTBDLFdBQTNEO0FBQ0Esd0JBQWdCLGdCQUFnQixXQUFoQixDQUE0QixjQUE1QixJQUE4QyxjQUE5RDs7QUFFQSw0QkFBTyxXQUFQLEVBQW9CLGdCQUFnQixXQUFwQztBQUNBLDRCQUFPLFdBQVAsRUFBb0IsUUFBcEI7QUFDQSw0QkFBTyxXQUFQLEVBQW9CLFNBQXBCOztBQUVBLFlBQUksV0FBSixFQUFpQjtBQUNiLHdCQUFZLFVBQVosR0FBeUIsS0FBekI7QUFDQSx3QkFBWSxVQUFaLEdBQXlCLEtBQXpCO0FBQ0g7O0FBakM4QyxzSUFtQ3pDLFdBbkN5QyxFQW1DNUIsV0FuQzRCOztBQXFDL0MsY0FBSyxXQUFMLEdBQW1CLFVBQW5COztBQUVBO0FBQ0E7QUFDQSxxQkFBYSxLQUFiLENBQW1CLEdBQW5CLENBQXVCLGdCQUF2QixFQUF5QyxVQUFVLEVBQVYsRUFBYyxHQUFkLEVBQW1CLEdBQW5CLEVBQXdCLElBQXhCLEVBQThCLEtBQTlCLEVBQXFDLGNBQXJDLEVBQXFEO0FBQzFGLGVBQUcsS0FBSCxDQUFTLEtBQVQsR0FBaUIsZUFBZSxZQUFmLElBQStCLEVBQWhEO0FBQ0EsZUFBRyxLQUFILENBQVMsVUFBVCxHQUFzQixlQUFlLGlCQUFmLElBQW9DLEVBQTFEO0FBQ0EsZUFBRyxLQUFILENBQVMsUUFBVCxHQUFvQixlQUFlLGVBQWYsSUFBa0MsRUFBdEQ7QUFDQSwyQkFBZSxlQUFmLEtBQW1DLEdBQUcsS0FBSCxDQUFTLFVBQVQsR0FBc0IsZUFBZSxlQUF4RTtBQUNBLGVBQUcsS0FBSCxDQUFTLGVBQVQsR0FBMkIsZUFBZSxzQkFBZixJQUF5QyxFQUFwRTtBQUNILFNBTkQ7O0FBUUE7Ozs7QUFJQSxTQUFDLG1CQUFELEVBQXNCLE9BQXRCLENBQThCLGdCQUFRO0FBQ2xDO0FBQ0EseUJBQWEsS0FBYixDQUFtQixHQUFuQixDQUF1QixJQUF2QixFQUE2QixZQUFZO0FBQ3JDLG9CQUFJLE9BQU8sRUFBWDtBQUNBLHFCQUFLLElBQUwsQ0FBVSxJQUFWO0FBQ0EscUJBQUssSUFBTCxDQUFVLEtBQVY7QUFDQSxxQkFBSyxJQUFMLENBQVUsS0FBVixDQUFnQixJQUFoQixFQUFzQixHQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsU0FBZCxDQUF0QjtBQUNBLG9CQUFJLE1BQU0sTUFBTSxRQUFOLENBQWUsV0FBekI7QUFDQSxvQkFBSSxJQUFKLENBQVMsS0FBVCxDQUFlLEdBQWYsRUFBb0IsSUFBcEI7QUFDSCxhQVBEO0FBUUgsU0FWRDtBQXJEK0M7QUFnRWxEOzs7O2tDQUVTO0FBQ047QUFDQSxtQkFBTyxLQUFLLFdBQVo7QUFDSDs7OztFQTlFeUIsWTs7QUFtRjlCOzs7Ozs7QUFJQSxnQkFBZ0IsV0FBaEIsR0FBOEI7QUFDMUIsMkJBQXVCLEtBREc7QUFFMUIsaUJBQWEsS0FGYTs7QUFJMUIsZ0JBQVksSUFKYztBQUsxQixnQkFBWSxJQUxjOztBQU8xQix3QkFBb0IsSUFQTTtBQVExQixxQkFBaUIsSUFSUzs7QUFVMUIsb0JBQWdCLHdCQVZVOztBQVkxQixtQkFBZSxJQVpXOztBQWMxQixlQUFXO0FBZGUsQ0FBOUI7O2tCQWlCZSxlOzs7Ozs7Ozs7OztBQzlHZjs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7QUFHQSxJQUFNLFlBQVksR0FBbEIsQyxDQUF1QjtBQUN2QixJQUFNLFlBQVksRUFBbEIsQyxDQUF1Qjs7QUFFdkI7Ozs7Ozs7SUFNTSxLOzs7QUFFRjs7Ozs7Ozs7QUFRQSxtQkFBWSxRQUFaLEVBQXNCLE1BQXRCLEVBQThCO0FBQUE7O0FBRTFCOzs7O0FBRjBCOztBQU0xQixjQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxjQUFLLE1BQUwsR0FBYyxTQUFTLE1BQXZCO0FBQ0EsY0FBSyxRQUFMLEdBQWdCLE1BQWhCO0FBQ0EsY0FBSyxTQUFMLEdBQWlCLE9BQU8sSUFBeEI7O0FBRUEsY0FBSyxRQUFMLEdBQWdCLFNBQWhCO0FBQ0EsY0FBSyxRQUFMLEdBQWdCLFNBQWhCOztBQUVBLGNBQUssRUFBTCxHQUFVLEVBQVYsQ0FkMEIsQ0FjWjs7QUFFZCxjQUFLLE9BQUw7QUFoQjBCO0FBaUI3Qjs7QUFFRDs7Ozs7OztrQ0FHVTtBQUNOLGlCQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLEtBQUssU0FBM0I7O0FBRE0sd0NBRTJCLEtBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsR0FBdkIsQ0FBMkIsS0FBSyxTQUFoQyxDQUYzQjtBQUFBLGdCQUVELFNBRkMseUJBRUQsU0FGQztBQUFBLGdCQUVVLEtBRlYseUJBRVUsS0FGVjtBQUFBLGdCQUVpQixNQUZqQix5QkFFaUIsTUFGakI7O0FBSU47Ozs7QUFJQSxpQkFBSyxZQUFMLEdBQW9CLDhCQUFpQixTQUFqQixFQUE0QixLQUFLLFFBQWpDLEVBQTJDO0FBQzNELHVCQUFPLEtBRG9EO0FBRTNELHdCQUFRLE1BRm1EO0FBRzNELDBCQUFVLEtBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsY0FBMUIsRUFIaUQ7QUFJM0QsMkJBQVcsS0FBSyxRQUoyQztBQUszRCwyQkFBVyxLQUFLLFFBTDJDO0FBTTNELG9DQUFvQixJQU51QztBQU8zRCx3QkFBUTtBQVBtRCxhQUEzQyxFQVFqQixJQVJpQixDQUFwQjtBQVNBLGlCQUFLLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBOEIsY0FBOUI7QUFDQSxpQkFBSyxLQUFMO0FBQ0EsaUJBQUssTUFBTCxDQUFZLFdBQVosQ0FBd0IsS0FBSyxPQUFMLEVBQXhCO0FBQ0g7O0FBRUQ7Ozs7Ozs7a0NBSVU7QUFDTixtQkFBTyxLQUFLLFNBQVo7QUFDSDs7QUFFRDs7Ozs7O2lDQUdTO0FBQ0wsaUJBQUssUUFBTCxDQUFjLFdBQWQsR0FBNEIsS0FBSyxPQUFMLEVBQTVCO0FBQ0EsaUJBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsS0FBSyxPQUFMLEVBQXRCO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixNQUFsQjtBQUNIOztBQUVEOzs7Ozs7O21DQUlXO0FBQ1AsbUJBQU8sS0FBSyxRQUFMLENBQWMsV0FBZCxLQUE4QixLQUFLLE9BQUwsRUFBckM7QUFDSDs7QUFFRDs7Ozs7O2dDQUdRO0FBQ0osaUJBQUssUUFBTCxDQUFjLFVBQWQsQ0FBeUIsS0FBSyxPQUFMLEVBQXpCO0FBQ0g7O0FBRUQ7Ozs7OztrQ0FHVTtBQUNOLGlCQUFLLFlBQUwsQ0FBa0IsT0FBbEI7QUFDQSxpQkFBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixNQUFyQixDQUE0QixLQUFLLE9BQUwsRUFBNUI7QUFDQSxtQkFBTyxLQUFLLFFBQVo7QUFDQSxtQkFBTyxLQUFLLE1BQVo7QUFDSDs7QUFFRDs7Ozs7OzsrQkFJTyxJLEVBQU07QUFDVCxpQkFBSyxRQUFMLENBQWMsV0FBZCxDQUEwQixLQUFLLE9BQUwsRUFBMUIsRUFBMEMsSUFBMUM7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7K0JBUU8sTyxFQUFTLE8sRUFBUyxLLEVBQU8sSyxFQUFPO0FBQ25DLG9CQUFRLFNBQVMsT0FBakI7QUFDQSxvQkFBUSxTQUFTLE9BQWpCO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixVQUFsQixDQUE2QixPQUE3QixFQUFzQyxPQUF0QyxFQUErQyxLQUEvQyxFQUFzRCxLQUF0RCxFQUE2RCxLQUE3RDtBQUNIOztBQUVEOzs7Ozs7O3VDQUllO0FBQ1gsZ0JBQUksWUFBWSxLQUFLLFlBQUwsQ0FBa0IsV0FBbEIsRUFBaEI7QUFDQSxtQkFBTztBQUNILHFCQUFLLFVBQVUsQ0FBVixDQURGO0FBRUgscUJBQUssVUFBVSxDQUFWLENBRkY7QUFHSCx3QkFBUSxVQUFVLENBQVYsQ0FITDtBQUlILHdCQUFRLFVBQVUsQ0FBVjtBQUpMLGFBQVA7QUFNSDs7QUFFRDs7Ozs7Ozs7QUFRQTs7OzttQ0FDVyxHLEVBQUssRyxFQUFLLE8sRUFBUyxPLEVBQVM7QUFDbkMsZ0JBQUksSUFBSSxDQUFSO0FBQ0EsZ0JBQUksUUFBUSxFQUFaO0FBQ0EsZ0JBQUksYUFBYSxLQUFLLFlBQUwsQ0FBa0IsV0FBbEIsR0FBZ0MsVUFBakQ7O0FBRUEsZ0JBQUksS0FBSyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsTUFBTSxPQUFOLEdBQWdCLENBQTNCLEVBQThCLE1BQU0sT0FBTixHQUFnQixDQUE5QyxDQUFUOztBQUVBLGlCQUFLLElBQUksSUFBSSxXQUFXLE1BQXhCLEVBQWdDLENBQWhDLEVBQW1DLEVBQUUsQ0FBckMsRUFBd0M7QUFDcEMsb0JBQUksSUFBSSxXQUFXLElBQUksQ0FBZixDQUFSO0FBQ0Esb0JBQUksS0FBSyxDQUFDLEVBQUUsR0FBSCxFQUFRLEVBQUUsR0FBVixFQUFlLEVBQUUsR0FBRixHQUFRLEVBQUUsT0FBVixHQUFvQixDQUFuQyxFQUFzQyxFQUFFLEdBQUYsR0FBUSxFQUFFLE9BQVYsR0FBb0IsQ0FBMUQsQ0FBVDs7QUFFQTtBQUNBLG9CQUFJLG1CQUFXLE9BQVgsQ0FBbUIsRUFBbkIsRUFBdUIsRUFBdkIsQ0FBSixFQUFnQztBQUM1Qix3QkFBSSxDQUFKO0FBQ0E7QUFDSDtBQUNEO0FBQ0Esb0JBQUksbUJBQVcsUUFBWCxDQUFvQixFQUFwQixFQUF3QixFQUF4QixDQUFKLEVBQWlDO0FBQzdCLHdCQUFJLENBQUo7QUFDQTtBQUNIO0FBQ0Q7QUFDQSxvQkFBSSxtQkFBVyxVQUFYLENBQXNCLEVBQXRCLEVBQTBCLEVBQTFCLENBQUosRUFBbUM7QUFDL0IsMEJBQU0sSUFBTixDQUFXLElBQUksQ0FBZjtBQUNBLHdCQUFJLENBQUo7QUFDQTtBQUNIO0FBQ0Q7QUFDQSxvQkFBSSxtQkFBVyxZQUFYLENBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLENBQUosRUFBcUM7QUFDakMsd0JBQUksQ0FBSjtBQUNIO0FBQ0o7O0FBRUQsZ0JBQUksTUFBTSxDQUFOLElBQVcsTUFBTSxDQUFyQixFQUF3QjtBQUNwQixvQkFBSSxNQUFNLENBQVYsRUFBYTtBQUFFO0FBQ1gseUJBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxNQUFNLE1BQTFCLEVBQWtDLEVBQUUsRUFBcEMsRUFBdUM7QUFDbkMsbUNBQVcsTUFBWCxDQUFrQixNQUFNLEVBQU4sQ0FBbEIsRUFBNEIsQ0FBNUI7QUFDSDtBQUNKO0FBQ0QsNkJBQWEsY0FBYyxFQUEzQjtBQUNBLDJCQUFXLElBQVgsQ0FBZ0I7QUFDWix5QkFBSyxHQURPO0FBRVoseUJBQUssR0FGTztBQUdaLDZCQUFTLE9BSEc7QUFJWiw2QkFBUztBQUpHLGlCQUFoQjtBQU1BLHFCQUFLLFlBQUwsQ0FBa0IsY0FBbEIsQ0FBaUM7QUFDN0IsZ0NBQVk7QUFEaUIsaUJBQWpDO0FBR0gsYUFoQkQsTUFnQk8sSUFBSSxNQUFNLENBQU4sSUFBVyxNQUFNLENBQXJCLEVBQXdCO0FBQzNCLHNCQUFNLCtGQUErQixHQUEvQixVQUF1QyxHQUF2QyxVQUErQyxPQUEvQyxVQUEyRCxPQUEzRCxPQUFOO0FBQ0g7QUFDSjs7QUFHRDs7Ozs7Ozs7OztxQ0FPYSxHLEVBQUssRyxFQUFLLE8sRUFBUyxPLEVBQVM7QUFDckMsZ0JBQUksU0FBUyxLQUFLLFlBQUwsQ0FBa0IsV0FBbEIsR0FBZ0MsVUFBN0M7QUFDQSxnQkFBSSxhQUFhLEVBQWpCO0FBQ0EsZ0JBQUksVUFBVSxPQUFPLE1BQXJCLEVBQTZCO0FBQ3pCLHFCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxFQUFFLENBQXJDLEVBQXdDO0FBQ3BDLHdCQUFJLG1CQUFXLFFBQVgsQ0FBb0IsQ0FDaEIsT0FBTyxDQUFQLEVBQVUsR0FETSxFQUVoQixPQUFPLENBQVAsRUFBVSxHQUZNLEVBR2hCLE9BQU8sQ0FBUCxFQUFVLEdBQVYsR0FBZ0IsT0FBTyxDQUFQLEVBQVUsT0FBMUIsR0FBb0MsQ0FIcEIsRUFJaEIsT0FBTyxDQUFQLEVBQVUsR0FBVixHQUFnQixPQUFPLENBQVAsRUFBVSxPQUExQixHQUFvQyxDQUpwQixDQUFwQixFQUtHLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxNQUFNLE9BQU4sR0FBZ0IsQ0FBM0IsRUFBOEIsTUFBTSxPQUFOLEdBQWdCLENBQTlDLENBTEgsQ0FBSixFQUswRDtBQUN0RDtBQUNIO0FBQ0QsK0JBQVcsSUFBWCxDQUFnQixPQUFPLENBQVAsQ0FBaEI7QUFDSDtBQUNKO0FBQ0QsaUJBQUssWUFBTCxDQUFrQixjQUFsQixDQUFpQztBQUM3Qiw0QkFBWSxXQUFXLE1BQVgsS0FBc0IsQ0FBdEIsR0FBMEIsS0FBMUIsR0FBa0M7QUFEakIsYUFBakM7QUFHSDs7O29DQUVXLFMsRUFBVyxZLEVBQTZCO0FBQUEsOENBQVosVUFBWTtBQUFaLDBCQUFZO0FBQUE7O0FBQUE7O0FBQ2hELGlCQUFLLGdCQUFMLENBQXNCLFNBQXRCLEVBQWlDLFVBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxRQUFYLEVBQXdCO0FBQ3JELHVCQUFPO0FBQ0gsK0JBQVcsQ0FBQyxPQUFLLGtCQUFMLENBQ1IsU0FBUyxTQURELEVBRVIsVUFGUSxJQUdSLEdBSFEsR0FHRixZQUhDLEVBR2EsSUFIYjtBQURSLGlCQUFQO0FBTUgsYUFQRCxFQU9HLEVBQUMsV0FBVyxZQUFaLEVBUEg7QUFRSDs7QUFFRDs7Ozs7Ozs7Ozs7O3NDQVMyRDtBQUFBLGdCQUEvQyxLQUErQyx1RUFBdkMsSUFBdUM7QUFBQSxnQkFBakMsU0FBaUMsdUVBQXJCLEtBQUssWUFBTCxFQUFxQjs7QUFDdkQsZ0JBQUksS0FBSixFQUFXO0FBQ1AscUJBQUssV0FBTCxDQUFpQixTQUFqQixFQUE0QixlQUE1QixFQUE2QyxlQUE3QztBQUNILGFBRkQsTUFFTztBQUNILHFCQUFLLFdBQUwsQ0FBaUIsU0FBakIsRUFBNEIsRUFBNUIsRUFBZ0MsZUFBaEM7QUFDSDtBQUNELGlCQUFLLFlBQUwsQ0FBa0IsTUFBbEI7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7O3dDQVM2RDtBQUFBLGdCQUEvQyxLQUErQyx1RUFBdkMsSUFBdUM7QUFBQSxnQkFBakMsU0FBaUMsdUVBQXJCLEtBQUssWUFBTCxFQUFxQjs7QUFDekQsZ0JBQUksS0FBSixFQUFXO0FBQ1AscUJBQUssV0FBTCxDQUFpQixTQUFqQixFQUE0QixpQkFBNUIsRUFBK0MsaUJBQS9DO0FBQ0gsYUFGRCxNQUVPO0FBQ0gscUJBQUssV0FBTCxDQUFpQixTQUFqQixFQUE0QixFQUE1QixFQUFnQyxpQkFBaEM7QUFDSDtBQUNELGlCQUFLLFlBQUwsQ0FBa0IsTUFBbEI7QUFDSDs7QUFHRDs7Ozs7Ozs7Ozs7OzJDQVNnRTtBQUFBLGdCQUEvQyxLQUErQyx1RUFBdkMsSUFBdUM7QUFBQSxnQkFBakMsU0FBaUMsdUVBQXJCLEtBQUssWUFBTCxFQUFxQjs7QUFDNUQsZ0JBQUksS0FBSixFQUFXO0FBQ1AscUJBQUssV0FBTCxDQUFpQixTQUFqQixFQUE0QixvQkFBNUIsRUFBa0Qsb0JBQWxEO0FBQ0gsYUFGRCxNQUVPO0FBQ0gscUJBQUssV0FBTCxDQUFpQixTQUFqQixFQUE0QixFQUE1QixFQUFnQyxvQkFBaEM7QUFDSDtBQUNELGlCQUFLLFlBQUwsQ0FBa0IsTUFBbEI7QUFDSDs7QUFFRDs7Ozs7Ozs7O3VDQU0wRDtBQUFBLGdCQUE3QyxLQUE2Qyx1RUFBckMsRUFBcUM7QUFBQSxnQkFBakMsU0FBaUMsdUVBQXJCLEtBQUssWUFBTCxFQUFxQjs7QUFDdEQsaUJBQUssZ0JBQUwsQ0FBc0IsU0FBdEIsRUFBaUMsWUFBTTtBQUNuQyx1QkFBTztBQUNILGtDQUFjO0FBRFgsaUJBQVA7QUFHSCxhQUpELEVBSUcsRUFBQyxjQUFjLEtBQWYsRUFKSDtBQUtBLGlCQUFLLFlBQUwsQ0FBa0IsTUFBbEI7QUFDSDs7QUFFRDs7Ozs7Ozs7d0NBSzJEO0FBQUEsZ0JBQTdDLEtBQTZDLHVFQUFyQyxFQUFxQztBQUFBLGdCQUFqQyxTQUFpQyx1RUFBckIsS0FBSyxZQUFMLEVBQXFCOztBQUN2RCxpQkFBSyxnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxZQUFNO0FBQ25DLHVCQUFPO0FBQ0gsdUNBQW1CO0FBRGhCLGlCQUFQO0FBR0gsYUFKRCxFQUlHLEVBQUMsbUJBQW1CLEtBQXBCLEVBSkg7QUFLQSxpQkFBSyxZQUFMLENBQWtCLE1BQWxCO0FBQ0g7O0FBRUQ7Ozs7Ozs7O29DQUtZLEssRUFBd0M7QUFBQSxnQkFBakMsU0FBaUMsdUVBQXJCLEtBQUssWUFBTCxFQUFxQjs7QUFDaEQsaUJBQUssZ0JBQUwsQ0FBc0IsU0FBdEIsRUFBaUMsWUFBTTtBQUNuQyx1QkFBTztBQUNILHFDQUFpQjtBQURkLGlCQUFQO0FBR0gsYUFKRCxFQUlHLEVBQUMsaUJBQWlCLEtBQWxCLEVBSkg7QUFLQSxpQkFBSyxZQUFMLENBQWtCLE1BQWxCO0FBQ0g7O0FBRUQ7Ozs7Ozs7OzZDQUtnRTtBQUFBLGdCQUE3QyxLQUE2Qyx1RUFBckMsRUFBcUM7QUFBQSxnQkFBakMsU0FBaUMsdUVBQXJCLEtBQUssWUFBTCxFQUFxQjs7QUFDNUQsaUJBQUssZ0JBQUwsQ0FBc0IsU0FBdEIsRUFBaUMsWUFBTTtBQUNuQyx1QkFBTztBQUNILDRDQUF3QjtBQURyQixpQkFBUDtBQUdILGFBSkQsRUFJRyxFQUFDLHdCQUF3QixLQUF6QixFQUpIO0FBS0EsaUJBQUssWUFBTCxDQUFrQixNQUFsQjtBQUNIOztBQUdEOzs7Ozs7Ozs7Ozs7a0NBU1UsSyxFQUFPLEcsRUFBSyxLLEVBQU8sTSxFQUFRLEksRUFBTTtBQUN2QyxnQkFBSSxTQUFTO0FBQ1QsdUJBQU8sS0FERTtBQUVULHFCQUFLO0FBRkksYUFBYjtBQUlBLG1CQUFPLEtBQVAsR0FBZSxTQUFTLEdBQXhCO0FBQ0EsbUJBQU8sTUFBUCxHQUFnQixVQUFVLEdBQTFCO0FBQ0EsbUJBQU8sSUFBUCxHQUFjLFFBQVEsT0FBTyxLQUE3Qjs7QUFFQSxnQkFBSSxnQkFBZ0IsS0FBSyxZQUFMLENBQWtCLFdBQWxCLEdBQWdDLGFBQXBEO0FBQ0EsZ0JBQUksa0JBQWtCLElBQXRCLEVBQTRCO0FBQ3hCLGdDQUFnQixFQUFoQjtBQUNIO0FBQ0QsMEJBQWMsSUFBZCxDQUFtQixNQUFuQjs7QUFFQTtBQUNBO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixjQUFsQixDQUFpQztBQUM3QiwrQkFBZTtBQURjLGFBQWpDO0FBR0E7QUFDSDs7QUFHRDs7Ozs7Ozs7Ozt3Q0FPMkU7QUFBQSxnQkFBN0QsSUFBNkQsdUVBQXhELE1BQXdEO0FBQUEsZ0JBQWhELFFBQWdELHVFQUFyQyxFQUFxQztBQUFBLGdCQUFqQyxTQUFpQyx1RUFBckIsS0FBSyxZQUFMLEVBQXFCOztBQUN2RSxpQkFBSyxnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxVQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsUUFBWCxFQUF3QjtBQUNyRCxvQkFBSSxRQUFRLFNBQVMsSUFBckI7O0FBRUEsb0JBQUksVUFBVSxNQUFkLEVBQXNCO0FBQ2xCLDJCQUFPLFNBQVMsVUFBaEI7QUFDQSwyQkFBTyxTQUFTLFdBQWhCO0FBQ0EsMkJBQU8sU0FBUyxhQUFoQjtBQUNILGlCQUpELE1BSU8sSUFBSSxVQUFVLFNBQWQsRUFBeUI7QUFDNUIsMkJBQU8sU0FBUyxNQUFoQjtBQUNBLDJCQUFPLFNBQVMsUUFBaEI7QUFDSDtBQUNELHlCQUFTLElBQVQsR0FBZ0IsSUFBaEI7O0FBRUE7QUFDQSx1QkFBTyxTQUFTLFFBQWhCO0FBQ0EsdUJBQU8sU0FBUyxNQUFoQjtBQUNBLHVCQUFPLFNBQVMsU0FBaEI7QUFDQSx1QkFBTyxvQkFBTyxRQUFQLEVBQWlCLFFBQWpCLENBQVA7QUFDSCxhQWxCRCxFQWtCRyxFQUFDLE1BQU0sSUFBUCxFQWxCSDtBQW1CQSxpQkFBSyxZQUFMLENBQWtCLE1BQWxCO0FBQ0g7Ozs7RUF6WmUsK0JBQVksZ0RBQVosQzs7a0JBNlpMLEs7O0FBR2Y7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7UUN4YmdCLFUsR0FBQSxVOztBQUZoQjs7QUFFTyxTQUFTLFVBQVQsQ0FBb0IsS0FBcEIsRUFBMkI7QUFDOUIsU0FBSyxJQUFMLEdBQVksWUFBWjtBQUNBLFNBQUssT0FBTCxHQUFlLEtBQWY7QUFDSDtBQUNELFdBQVcsU0FBWCxHQUF1Qix3Q0FBdkI7QUFDQSxXQUFXLFNBQVgsQ0FBcUIsV0FBckIsR0FBbUMsVUFBbkM7Ozs7Ozs7Ozs7Ozs7QUNQQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBLElBQU0sU0FBUyx5QkFBZSxLQUFmLENBQXFCLFNBQXBDOztBQUVBOzs7O0lBR00sUTs7QUFFRjs7Ozs7QUFLQSxzQkFBWSxRQUFaLEVBQXNCLE1BQXRCLEVBQThCO0FBQUE7O0FBQUE7O0FBQzFCOzs7QUFHQSxhQUFLLFdBQUwsR0FBbUIsUUFBbkI7QUFDQTs7O0FBR0EsYUFBSyxNQUFMLEdBQWMsdUNBQWQ7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsTUFBaEI7O0FBRUEsYUFBSyxhQUFMLENBQW1CLE1BQW5CO0FBQ0EsYUFBSyxNQUFMLEdBQWMsbUJBQVMsSUFBVCxDQUFkOztBQUVBLGVBQU8sTUFBUCxDQUFjLE9BQWQsQ0FBc0I7QUFBQSxtQkFBSyxNQUFLLFdBQUwsQ0FBaUIsQ0FBakIsQ0FBTDtBQUFBLFNBQXRCOztBQUVBO0FBQ0EsWUFBSSxXQUFXLEtBQUssUUFBTCxDQUFjLEtBQUssV0FBbkIsQ0FBZjtBQUNBLFlBQUksQ0FBQyxRQUFMLEVBQWU7QUFDWCxrQkFBTSxtRkFBdUMsS0FBSyxXQUE1QyxDQUFOO0FBQ0g7QUFDRCxpQkFBUyxNQUFUO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztzQ0FLYyxRLEVBQVU7QUFDcEIsZ0JBQUksT0FBTyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVg7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBUixFQUFXLE1BQU0sS0FBSyxNQUEzQixFQUFtQyxJQUFJLEdBQXZDLEVBQTRDLEVBQUUsQ0FBOUMsRUFBaUQ7QUFDN0Msb0JBQUksS0FBSyxDQUFMLE1BQVksUUFBaEIsRUFBMEI7QUFDdEI7QUFDSDtBQUNELHFCQUFLLEtBQUssQ0FBTCxDQUFMLElBQWdCLFNBQVMsS0FBSyxDQUFMLENBQVQsQ0FBaEI7QUFDSDtBQUNKOztBQUVEOzs7Ozs7O3NDQUljO0FBQ1YsbUJBQU8sS0FBSyxXQUFMLENBQWlCLFdBQWpCLEVBQVA7QUFDSDs7QUFFRDs7Ozs7OztnQ0FJUTtBQUNKLG1CQUFPLEtBQUssRUFBTCxLQUFZLEtBQUssRUFBTCxHQUFVLEtBQUssV0FBTCxDQUFpQixLQUFqQixLQUEyQix5QkFBZSxpQkFBaEUsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7OztpQ0FLUyxJLEVBQU07QUFDWCxtQkFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLElBQWhCLENBQVA7QUFDSDs7QUFFRDs7Ozs7OztvQ0FJWTtBQUNSLG1CQUFPLEtBQUssTUFBWjtBQUNIOztBQUVEOzs7Ozs7O3dDQUlnQjtBQUNaLG1CQUFPLEtBQUssTUFBTCxDQUFZLElBQVosRUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7cUNBTWEsSSxFQUFNLE8sRUFBUztBQUN4QixnQkFBSSxPQUFKLEVBQWE7QUFDVCx1QkFBTyxLQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLElBQXJCLENBQVA7QUFDSDtBQUNEO0FBQ0EsbUJBQU8sS0FBSyxNQUFMLENBQVksR0FBWixDQUFnQixJQUFoQixDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7OzZDQUtxQjtBQUNqQixnQkFBSSxDQUFDLEtBQUssZ0JBQVYsRUFBNEI7QUFDeEIscUJBQUssZ0JBQUwsR0FBd0IsQ0FBeEI7QUFDSDtBQUNELG1CQUFPLEVBQUUsS0FBSyxnQkFBZCxDQUppQixDQUllO0FBQ25DOztBQUVEOzs7Ozs7Ozs0Q0FLb0I7QUFDaEIsZ0JBQU0sU0FBUyx5QkFBZSxLQUFmLENBQXFCLFVBQXJCLEdBQWtDLEVBQWpELENBRGdCLENBQ3FDO0FBQ3JELGdCQUFJLE9BQU8sU0FBUyxLQUFLLGtCQUFMLEVBQXBCO0FBQ0EsZ0JBQUksS0FBSyxZQUFMLENBQWtCLElBQWxCLENBQUosRUFBNkI7QUFDekIsdUJBQU8sS0FBSyxpQkFBTCxFQUFQO0FBQ0g7QUFDRCxtQkFBTyxJQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7eUNBSWlCO0FBQ2IsbUJBQU8sS0FBSyxNQUFMLENBQVksR0FBWixDQUFnQixLQUFLLFdBQXJCLENBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7b0NBS1ksTSxFQUFRO0FBQ2hCLGdCQUFJLE1BQUosRUFBWTtBQUFHO0FBQ1gscUJBQUssa0JBQUwsQ0FBd0IsT0FBTyxJQUEvQjtBQUNILGFBRkQsTUFFTztBQUFFO0FBQ0wseUJBQVMsRUFBVDtBQUNBLHVCQUFPLElBQVAsR0FBYyxLQUFLLGlCQUFMLEVBQWQ7QUFDSDtBQUNELGdCQUFJLFNBQVMsb0JBQVUsSUFBVixFQUFnQixNQUFoQixDQUFiO0FBQ0EsaUJBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsT0FBTyxJQUF2QixFQUE2QixNQUE3QjtBQUNBLG1CQUFPLE1BQVA7QUFDSDs7QUFFRDs7Ozs7OztxQ0FJYSxLLEVBQU87QUFDaEIsZ0JBQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzNCLHdCQUFRLEtBQUssUUFBTCxDQUFjLEtBQWQsQ0FBUjtBQUNIO0FBQ0Qsa0JBQU0sT0FBTjtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7O29DQUNZLEssRUFBTyxLLEVBQU87QUFDdEIsZ0JBQUksUUFBUSxLQUFLLFFBQUwsQ0FBYyxLQUFkLENBQVo7QUFDQSxnQkFBSSxDQUFDLEtBQUwsRUFBWTtBQUNSLHNCQUFNLG9EQUF1QixLQUF2QiwwQkFBTjtBQUNIO0FBQ0QsZ0JBQUksVUFBVSxLQUFkLEVBQXFCO0FBQ2pCLHFCQUFLLGtCQUFMLENBQXdCLEtBQXhCLEVBQStCLHVCQUFVLEtBQVYsTUFBcUIsdUJBQVUsS0FBVixDQUFwRDtBQUNBLHNCQUFNLFNBQU4sR0FBa0IsS0FBbEI7QUFDQSxvQkFBSSxLQUFLLFdBQUwsS0FBcUIsS0FBekIsRUFBZ0M7QUFDNUIseUJBQUssV0FBTCxHQUFtQixLQUFuQjtBQUNIO0FBQ0QscUJBQUssU0FBTCxHQUFpQixNQUFqQixDQUF3QixLQUF4QjtBQUNBLHFCQUFLLFNBQUwsR0FBaUIsR0FBakIsQ0FBcUIsS0FBckIsRUFBNEIsS0FBNUI7QUFDQSxxQkFBSyxNQUFMLENBQVksU0FBWixDQUFzQixLQUF0QixFQUE2QixLQUE3QjtBQUNILGFBVEQsTUFTTztBQUNILHFCQUFLLE1BQUwsQ0FBWSxlQUFaLENBQTRCLEtBQTVCLEVBQW1DLEtBQW5DO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7O21DQUdXLEksRUFBTTtBQUNiLGdCQUFJLFFBQVEsS0FBSyxRQUFMLENBQWMsSUFBZCxDQUFaO0FBQ0EsZ0JBQUksQ0FBQyxLQUFMLEVBQVk7QUFDUixzQkFBTSxvR0FBK0IsSUFBL0IsY0FBTjtBQUNIO0FBQ0QsZ0JBQUksS0FBSyxNQUFMLENBQVksSUFBWixPQUF1QixDQUEzQixFQUE4QjtBQUMxQixzQkFBTSwwR0FBZ0MsSUFBaEMsY0FBTjtBQUNIO0FBQ0QsZ0JBQUksTUFBTSxRQUFOLEVBQUosRUFBc0I7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDbEIseUNBQWMsS0FBSyxNQUFMLENBQVksSUFBWixFQUFkLDhIQUFrQztBQUFBLDRCQUF6QixDQUF5Qjs7QUFDOUIsNEJBQUksS0FBSyxNQUFNLElBQWYsRUFBcUI7QUFDakIsaUNBQUssV0FBTCxHQUFtQixDQUFuQjtBQUNBLGlDQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLE1BQWpCO0FBQ0E7QUFDSDtBQUNKO0FBUGlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRckI7QUFDRCxpQkFBSyxNQUFMLENBQVksTUFBWixDQUFtQixJQUFuQjtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLElBQXRCO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixLQUFsQjtBQUNIOztBQUdEOzs7Ozs7aUNBR1M7QUFDTCxpQkFBSyxjQUFMLEdBQXNCLE1BQXRCO0FBQ0g7O0FBRUQ7Ozs7Ozs7b0NBSVksUyxFQUFXO0FBQ25CLGdCQUFJLFFBQVEsS0FBSyxRQUFMLENBQWMsU0FBZCxDQUFaO0FBQ0EsZ0JBQUksS0FBSixFQUFXO0FBQ1Asc0JBQU0sTUFBTjtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7OzsyQ0FNbUIsSSxFQUFNLE8sRUFBUztBQUM5QixnQkFBSSxDQUFDLElBQUwsRUFBVztBQUNQLHNCQUFNLDJCQUFlLFlBQWYsQ0FBTjtBQUNIO0FBQ0Q7QUFDQSxnQkFBSSxPQUFPLElBQVAsQ0FBWSxJQUFaLENBQUosRUFBdUI7QUFDbkIsc0JBQU0sb0RBQXVCLElBQXZCLDRDQUFOO0FBQ0g7QUFDRCxnQkFBSSxLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0IsT0FBeEIsQ0FBSixFQUFzQztBQUNsQyxzQkFBTSxvREFBdUIsSUFBdkIsMEJBQU47QUFDSDtBQUNKOzs7dUNBRWM7QUFDWCxnQkFBSSxTQUFTLEVBQWI7QUFEVztBQUFBO0FBQUE7O0FBQUE7QUFFWCxzQ0FBcUIsS0FBSyxTQUFMLEdBQWlCLEtBQWpCLEVBQXJCLG1JQUErQztBQUFBO0FBQUEsd0JBQXBDLEtBQW9DOztBQUMzQyw2QkFBUyxPQUFPLElBQVAsQ0FBWSxNQUFNLFlBQU4sRUFBWixDQUFUO0FBQ0g7QUFKVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUtYLG1CQUFPO0FBQ0gsNkJBQWEsS0FBSyxXQURmO0FBRUgsd0JBQVE7QUFGTCxhQUFQO0FBSUg7Ozs7OztrQkFJVSxROzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hSUixJQUFNLDhCQUFXLFNBQVgsUUFBVztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSwyQ0FFTDtBQUFBLG9DQUNTLEtBQUssWUFBTCxFQURUO0FBQUEsb0JBQ04sSUFETSxpQkFDTixJQURNO0FBQUEsb0JBQ0EsS0FEQSxpQkFDQSxLQURBOztBQUFBLGtDQUVhLEtBQUssVUFBTCxFQUZiO0FBQUEsb0JBRU4sT0FGTSxlQUVOLE9BRk07QUFBQSxvQkFFRyxNQUZILGVBRUcsTUFGSDs7QUFHWCxvQkFBSSxhQUFhLEtBQUssWUFBTCxDQUFrQixXQUFsQixHQUFnQyxVQUFqRDs7QUFFQSxvQkFBSSxlQUFlLEtBQW5CLEVBQTBCO0FBQ3RCLGlDQUFhLElBQWIsQ0FEc0IsQ0FDSDtBQUN0Qjs7QUFFRCx1QkFBTztBQUNILDBCQUFNLEtBQUssT0FBTCxFQURIO0FBRUgsK0JBQVcsS0FBSyxZQUFMLEVBRlI7QUFHSCwwQkFBTSxLQUFLLE1BQUwsR0FBYyxJQUFkLEdBQXFCLEdBQUcsQ0FIM0I7QUFJSCxnQ0FBWSxPQUpUO0FBS0gsK0JBQVcsTUFMUjtBQU1ILGdDQUFZLFVBTlQ7QUFPSCwrQkFBVztBQVBSLGlCQUFQO0FBU0g7QUFwQm1CO0FBQUE7QUFBQSx5Q0F1QlAsSUF2Qk8sRUF1QkQ7QUFDZixvQkFBSSxNQUFNLEVBQVY7QUFDQSxvQkFBSSxhQUFhLEtBQUssZUFBTCxDQUFxQixLQUFLLFNBQTFCLENBQWpCO0FBQ0Esb0JBQUksVUFBSixFQUFnQjtBQUNaLHdCQUFJLFVBQUosR0FBaUIsVUFBakI7QUFDSDtBQUNELHFCQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsRUFBc0IsR0FBdEI7QUFDQSxxQkFBSyxhQUFMLENBQW1CLElBQW5CLEVBQXlCLEdBQXpCO0FBQ0EsdUJBQU8sR0FBUDtBQUNIO0FBaENtQjtBQUFBO0FBQUEsMENBbUNOLElBbkNNLEVBbUNBLEdBbkNBLEVBbUNLO0FBQ3JCLG9CQUFJLEtBQUssc0JBQVQsRUFBaUM7QUFDN0Isd0JBQUksZUFBSixHQUFzQixLQUFLLHNCQUEzQjtBQUNIO0FBQ0o7QUF2Q21CO0FBQUE7QUFBQSx1Q0EwQ1QsSUExQ1MsRUEwQ0gsR0ExQ0csRUEwQ0U7QUFDbEIsb0JBQUksS0FBSyxpQkFBVCxFQUE0QjtBQUN4Qix3QkFBSSxVQUFKLEdBQWlCLEtBQUssaUJBQXRCO0FBQ0g7QUFDRCxvQkFBSSxLQUFLLGVBQVQsRUFBMEI7QUFDdEIsd0JBQUksUUFBSixHQUFlLEtBQUssZUFBcEI7QUFDSDtBQUNELG9CQUFJLEtBQUssU0FBTCxJQUFrQixLQUFLLFNBQUwsQ0FBZSxRQUFmLENBQXdCLGlCQUF4QixDQUF0QixFQUFrRTtBQUM5RCx3QkFBSSxTQUFKLEdBQWdCLFFBQWhCO0FBQ0g7QUFDRCxvQkFBSSxLQUFLLFNBQUwsSUFBa0IsS0FBSyxTQUFMLENBQWUsUUFBZixDQUF3QixlQUF4QixDQUF0QixFQUFnRTtBQUM1RCx3QkFBSSxVQUFKLEdBQWlCLE1BQWpCO0FBQ0g7QUFDRCxvQkFBSSxLQUFLLFNBQUwsSUFBa0IsS0FBSyxTQUFMLENBQWUsUUFBZixDQUF3QixvQkFBeEIsQ0FBdEIsRUFBcUU7QUFDakUsd0JBQUksY0FBSixHQUFxQixXQUFyQjtBQUNIO0FBQ0Qsb0JBQUksS0FBSyxZQUFULEVBQXVCO0FBQ25CLHdCQUFJLEtBQUosR0FBWSxLQUFLLFlBQWpCO0FBQ0g7QUFDSjtBQTdEbUI7QUFBQTtBQUFBLDRDQWdFSixTQWhFSSxFQWdFTztBQUN2QixvQkFBSSxZQUFZLEVBQWhCO0FBQ0Esb0JBQUksU0FBSixFQUFlO0FBQ1gsOEJBQVUsUUFBVixDQUFtQixRQUFuQixLQUFnQyxVQUFVLElBQVYsQ0FBZSxNQUFmLENBQWhDO0FBQ0EsOEJBQVUsUUFBVixDQUFtQixVQUFuQixLQUFrQyxVQUFVLElBQVYsQ0FBZSxRQUFmLENBQWxDO0FBQ0EsOEJBQVUsUUFBVixDQUFtQixTQUFuQixLQUFpQyxVQUFVLElBQVYsQ0FBZSxPQUFmLENBQWpDO0FBQ0EsOEJBQVUsUUFBVixDQUFtQixXQUFuQixLQUFtQyxVQUFVLElBQVYsQ0FBZSxTQUFmLENBQW5DO0FBQ0EsOEJBQVUsUUFBVixDQUFtQixPQUFuQixLQUErQixVQUFVLElBQVYsQ0FBZSxLQUFmLENBQS9CO0FBQ0EsOEJBQVUsUUFBVixDQUFtQixVQUFuQixLQUFrQyxVQUFVLElBQVYsQ0FBZSxRQUFmLENBQWxDO0FBQ0EsOEJBQVUsUUFBVixDQUFtQixVQUFuQixLQUFrQyxVQUFVLElBQVYsQ0FBZSxRQUFmLENBQWxDO0FBQ0g7QUFDRCx1QkFBTyxVQUFVLE1BQVYsR0FBbUIsU0FBbkIsR0FBK0IsS0FBdEM7QUFDSDtBQTVFbUI7QUFBQTtBQUFBLHlDQStFUDtBQUNULG9CQUFJLE1BQU0sS0FBSyxZQUFmO0FBQ0Esb0JBQUksT0FBTyxLQUFLLEdBQUwsQ0FBUyxJQUFJLFNBQUosS0FBa0IsSUFBSSxjQUFKLENBQW1CLElBQW5CLENBQTNCLEVBQXFELEVBQXJELENBQVg7QUFDQSxvQkFBSSxPQUFPLEtBQUssR0FBTCxDQUFTLElBQUksU0FBSixLQUFrQixJQUFJLGNBQUosQ0FBbUIsSUFBbkIsQ0FBM0IsRUFBcUQsRUFBckQsQ0FBWDtBQUNBLG9CQUFJLFVBQVUsRUFBZDtBQUNBLG9CQUFJLFNBQVMsRUFBYjs7QUFFQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQXBCLEVBQTBCLEVBQUUsQ0FBNUIsRUFBK0I7QUFDM0Isd0JBQUksSUFBSSxJQUFJLFlBQUosQ0FBaUIsQ0FBakIsQ0FBUjtBQUNBLHdCQUFJLE1BQU0sQ0FBTixJQUFXLENBQUMsQ0FBaEIsRUFBbUI7QUFBRTtBQUNqQiw0QkFBSSxFQUFKO0FBQ0g7QUFDRCw0QkFBUSxJQUFSLENBQWEsQ0FBYjtBQUNIO0FBQ0QscUJBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxJQUFwQixFQUEwQixFQUFFLEVBQTVCLEVBQStCO0FBQzNCLDJCQUFPLElBQVAsQ0FBWSxJQUFJLFdBQUosQ0FBZ0IsRUFBaEIsQ0FBWjtBQUNIO0FBQ0QsdUJBQU8sRUFBQyxnQkFBRCxFQUFVLGNBQVYsRUFBUDtBQUNIO0FBakdtQjtBQUFBO0FBQUEsMkNBb0dMO0FBQ1gsb0JBQUksTUFBTSxLQUFLLFlBQWY7QUFDQSxvQkFBSSxPQUFPLElBQUksU0FBSixLQUFrQixJQUFJLGNBQUosQ0FBbUIsSUFBbkIsQ0FBN0I7QUFDQSxvQkFBSSxPQUFPLElBQUksU0FBSixLQUFrQixJQUFJLGNBQUosQ0FBbUIsSUFBbkIsQ0FBN0I7QUFDQSxvQkFBSSxPQUFPLEVBQVg7QUFDQSxvQkFBSSxRQUFRLEVBQVo7O0FBRUEscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFwQixFQUEwQixFQUFFLENBQTVCLEVBQStCO0FBQzNCLHdCQUFJLFlBQVksRUFBaEI7QUFDQSx3QkFBSSxjQUFjLEVBQWxCOztBQUVBLHlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBcEIsRUFBMEIsRUFBRSxDQUE1QixFQUErQjtBQUMzQiw0QkFBSSxjQUFjLElBQUksbUJBQUosQ0FBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsQ0FBbEI7QUFDQSw0QkFBSSxRQUFRLElBQUksV0FBSixDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFaO0FBQ0EsNEJBQUksUUFBUSxJQUFJLGFBQUosQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsQ0FBWjtBQUNBLDRCQUFJLFlBQVksRUFBaEI7O0FBRUEsa0NBQVUsR0FBVixHQUFnQixDQUFoQjtBQUNBLGtDQUFVLEdBQVYsR0FBZ0IsQ0FBaEI7QUFDQSxrQ0FBVSxTQUFWLEdBQXNCLENBQUMsRUFBRSxlQUFlLENBQUMsY0FBYyxFQUFmLEVBQW1CLE1BQW5CLENBQTBCLENBQTFCLE1BQWlDLEdBQWxELENBQXZCO0FBQ0Esa0NBQVUsV0FBVixHQUF3QixXQUF4QjtBQUNBLGtDQUFVLEtBQVYsR0FBa0IsS0FBbEI7O0FBRUMsbUNBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDYjtBQUNBLGlDQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUI7QUFDYixrQ0FBRSxNQUFGLEdBQVcsQ0FBWDtBQUNBO0FBQ0g7QUFDSix5QkFOQSxFQU1DLEtBQUssWUFBTCxDQUFrQixLQUFsQixDQU5ELEVBTTJCLFNBTjNCLENBQUQ7O0FBUUEsNkJBQUssWUFBTCxDQUFrQixLQUFsQixFQUF5QixTQUF6Qjs7QUFFQSxrQ0FBVSxJQUFWLENBQWUsV0FBZjtBQUNBLG9DQUFZLElBQVosQ0FBaUIsU0FBakI7QUFDSDtBQUNELHlCQUFLLElBQUwsQ0FBVSxTQUFWO0FBQ0EsMEJBQU0sSUFBTixDQUFXLFdBQVg7QUFDSDtBQUNELHVCQUFPLEVBQUMsVUFBRCxFQUFPLFlBQVAsRUFBUDtBQUNIOztBQUVEOztBQTlJb0I7QUFBQTtBQUFBLDRDQStJSixDQUVmOztBQUVEOztBQW5Kb0I7QUFBQTtBQUFBLHlDQW9KUCxLQXBKTyxFQW9KQSxTQXBKQSxFQW9KVztBQUMzQixvQkFBSSxJQUFJLE1BQU0sSUFBZDtBQUNBLDBCQUFVLFFBQVYsR0FBcUIsRUFBckI7QUFDQSwwQkFBVSxRQUFWLENBQW1CLFFBQW5CLEdBQThCLENBQTlCOztBQUVBLG9CQUFJLE1BQU0sTUFBVixFQUFrQjtBQUNkLDhCQUFVLFFBQVYsQ0FBbUIsVUFBbkIsR0FBZ0MsTUFBTSxVQUF0QztBQUNBLDBCQUFNLFdBQU4sS0FBc0IsVUFBVSxRQUFWLENBQW1CLFdBQW5CLEdBQWlDLE1BQU0sV0FBN0Q7QUFDQSwwQkFBTSxhQUFOLEtBQXdCLFVBQVUsUUFBVixDQUFtQixhQUFuQixHQUFtQyxNQUFNLGFBQWpFO0FBQ0gsaUJBSkQsTUFJTyxJQUFJLE1BQU0sU0FBVixFQUFxQjtBQUN4Qiw4QkFBVSxRQUFWLENBQW1CLE1BQW5CLEdBQTRCLE1BQU0sTUFBbEM7QUFDQSwwQkFBTSxRQUFOLEtBQW1CLFVBQVUsUUFBVixDQUFtQixRQUFuQixHQUE4QixNQUFNLFFBQXZEO0FBQ0g7QUFDSjtBQWpLbUI7O0FBQUE7QUFBQSxNQUFxQixHQUFyQjtBQUFBLENBQWpCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBLElBQU0sb0NBQWMsU0FBZCxXQUFjLE1BQU87QUFDOUI7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7O0FBRUk7QUFGSixvQ0FHWTtBQUNKLG9CQUFJLE1BQU0sS0FBSyxZQUFmOztBQUVBO0FBQ0Esb0JBQUksT0FBSixDQUFZLGlCQUFaLEVBQStCLFVBQUMsS0FBRCxFQUFRLE1BQVIsRUFBbUI7QUFDOUMsd0JBQU0sTUFBTSxJQUFJLFNBQUosQ0FBYyxvQkFBZCxDQUFaO0FBQ0Esd0JBQUksWUFBWSxFQUFoQjtBQUNBLHdCQUFJLElBQUksUUFBUSxNQUFoQjtBQUFBLHdCQUF3QixVQUF4QjtBQUNBLHdCQUFJLE1BQU0sSUFBSSxTQUFKLEVBQVY7QUFDQSwyQkFBTyxJQUFJLEdBQVgsRUFBZ0IsRUFBRSxDQUFsQixFQUFxQjtBQUNqQixrQ0FBVSxJQUFWLENBQWUsSUFBSSxXQUFKLENBQWdCLENBQWhCLENBQWY7QUFDSDtBQUNELHlCQUFLLElBQUksQ0FBSixFQUFPLElBQUksS0FBWCxFQUFrQixNQUFNLFVBQVUsTUFBdkMsRUFBK0MsSUFBSSxHQUFuRCxFQUF3RCxFQUFFLENBQUYsRUFBSyxFQUFFLENBQS9ELEVBQWtFO0FBQzlELDRCQUFJLGFBQUosQ0FBa0IsQ0FBbEIsRUFBcUIsVUFBVSxDQUFWLENBQXJCO0FBQ0g7QUFDSixpQkFYRDtBQVlBLG9CQUFJLE9BQUosQ0FBWSxpQkFBWixFQUErQixVQUFDLEtBQUQsRUFBUSxNQUFSLEVBQW1CO0FBQzlDLHdCQUFNLE1BQU0sSUFBSSxTQUFKLENBQWMsaUJBQWQsQ0FBWjtBQUNBLHdCQUFJLGFBQWEsRUFBakI7QUFDQSx3QkFBSSxJQUFJLFFBQVEsTUFBaEI7QUFBQSx3QkFBd0IsVUFBeEI7QUFDQSx3QkFBSSxNQUFNLElBQUksU0FBSixFQUFWO0FBQ0EsMkJBQU8sSUFBSSxHQUFYLEVBQWdCLEVBQUUsQ0FBbEIsRUFBcUI7QUFDakIsbUNBQVcsSUFBWCxDQUFnQixJQUFJLFlBQUosQ0FBaUIsQ0FBakIsQ0FBaEI7QUFDSDtBQUNELHlCQUFLLElBQUksQ0FBSixFQUFPLElBQUksS0FBWCxFQUFrQixNQUFNLFdBQVcsTUFBeEMsRUFBZ0QsSUFBSSxHQUFwRCxFQUF5RCxFQUFFLENBQUYsRUFBSyxFQUFFLENBQWhFLEVBQW1FO0FBQy9ELDRCQUFJLGFBQUosQ0FBa0IsQ0FBbEIsRUFBcUIsV0FBVyxDQUFYLENBQXJCO0FBQ0g7QUFDSixpQkFYRDtBQVlIOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQXBDSjtBQUFBO0FBQUEsOENBcUNzQixDQXJDdEIsRUFxQ3lCO0FBQ2pCLGtCQUFFLEdBQUYsR0FBUSxFQUFFLE1BQVYsS0FBcUIsRUFBRSxHQUFGLEdBQVEsQ0FBQyxFQUFFLE1BQUgsRUFBVyxFQUFFLE1BQUYsR0FBVyxFQUFFLEdBQXhCLEVBQTZCLENBQTdCLENBQTdCO0FBQ0Esa0JBQUUsR0FBRixHQUFRLEVBQUUsTUFBVixLQUFxQixFQUFFLEdBQUYsR0FBUSxDQUFDLEVBQUUsTUFBSCxFQUFXLEVBQUUsTUFBRixHQUFXLEVBQUUsR0FBeEIsRUFBNkIsQ0FBN0IsQ0FBN0I7O0FBRUEsdUJBQU87QUFDSCw4QkFBVSxFQUFFLEdBRFQ7QUFFSCw0QkFBUSxFQUFFLE1BQUYsSUFBWSxFQUFFLEdBRm5CO0FBR0gsOEJBQVUsRUFBRSxHQUhUO0FBSUgsNEJBQVEsRUFBRSxNQUFGLElBQVksRUFBRTtBQUpuQixpQkFBUDtBQU1IOztBQUVEOztBQWpESjtBQUFBO0FBQUEsK0NBa0R1QixPQWxEdkIsRUFrRDhDO0FBQ3RDLG9CQUFJLENBQUMsT0FBTCxFQUFjO0FBQ1YsMkJBQU8sRUFBUDtBQUNIOztBQUhxQyxrREFBWCxTQUFXO0FBQVgsNkJBQVc7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFJdEMseUNBQWtCLFNBQWxCLDhIQUE2QjtBQUFBLDRCQUFwQixLQUFvQjs7QUFDekIsa0NBQVUsUUFBUSxLQUFSLENBQWMsS0FBZCxFQUFxQixJQUFyQixDQUEwQixFQUExQixDQUFWO0FBQ0g7QUFOcUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPdEMsdUJBQU8sUUFBUSxJQUFSLEVBQVA7QUFDSDs7QUFFRDs7QUE1REo7QUFBQTtBQUFBLDZDQTZEcUIsU0E3RHJCLEVBNkRnQyxRQTdEaEMsRUE2RDBDLE1BN0QxQyxFQTZEa0Q7QUFBQSx5Q0FDQyxLQUFLLGlCQUFMLENBQXVCLFNBQXZCLENBREQ7QUFBQSxvQkFDckMsUUFEcUMsc0JBQ3JDLFFBRHFDO0FBQUEsb0JBQzNCLE1BRDJCLHNCQUMzQixNQUQyQjtBQUFBLG9CQUNuQixRQURtQixzQkFDbkIsUUFEbUI7QUFBQSxvQkFDVCxNQURTLHNCQUNULE1BRFM7O0FBRTFDLHFCQUFLLElBQUksSUFBSSxRQUFiLEVBQXVCLEtBQUssTUFBNUIsRUFBb0MsRUFBRSxDQUF0QyxFQUF5QztBQUNyQyx5QkFBSyxJQUFJLElBQUksUUFBYixFQUF1QixLQUFLLE1BQTVCLEVBQW9DLEVBQUUsQ0FBdEMsRUFBeUM7QUFDckMsNEJBQUksV0FBVyxLQUFLLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBOEIsQ0FBOUIsRUFBaUMsQ0FBakMsQ0FBZjtBQUNBLDRCQUFJLFFBQUosRUFBYztBQUNWLGdDQUFJLFVBQVUsU0FBUyxJQUFULENBQWMsSUFBZCxFQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixRQUExQixDQUFkO0FBQ0EsdUNBQVcsS0FBSyxZQUFMLENBQWtCLGlCQUFsQixDQUFvQyxDQUFwQyxFQUF1QyxDQUF2QyxFQUEwQyxPQUExQyxDQUFYO0FBQ0gseUJBSEQsTUFHTztBQUNILHNDQUFVLEtBQUssWUFBTCxDQUFrQixpQkFBbEIsQ0FBb0MsQ0FBcEMsRUFBdUMsQ0FBdkMsRUFBMEMsTUFBMUMsQ0FBVjtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEOztBQTVFSjtBQUFBO0FBQUEseUNBNkVpQixTQTdFakIsRUE2RTRCLFFBN0U1QixFQTZFc0M7QUFBQSx5Q0FDYSxLQUFLLGlCQUFMLENBQXVCLFNBQXZCLENBRGI7QUFBQSxvQkFDekIsUUFEeUIsc0JBQ3pCLFFBRHlCO0FBQUEsb0JBQ2YsTUFEZSxzQkFDZixNQURlO0FBQUEsb0JBQ1AsUUFETyxzQkFDUCxRQURPO0FBQUEsb0JBQ0csTUFESCxzQkFDRyxNQURIOztBQUU5QixxQkFBSyxJQUFJLElBQUksUUFBYixFQUF1QixLQUFLLE1BQTVCLEVBQW9DLEVBQUUsQ0FBdEMsRUFBeUM7QUFDckMseUJBQUssSUFBSSxJQUFJLFFBQWIsRUFBdUIsS0FBSyxNQUE1QixFQUFvQyxFQUFFLENBQXRDLEVBQXlDO0FBQ3JDLDRCQUFJLFNBQVMsS0FBSyxZQUFMLENBQWtCLE9BQWxCLENBQTBCLENBQTFCLEVBQTZCLENBQTdCLEVBQWdDLElBQWhDLENBQWI7QUFDQSw0QkFBSSxNQUFKLEVBQVk7QUFDUixxQ0FBUyxJQUFULENBQWMsSUFBZCxFQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixNQUExQjtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUdEOztBQTFGSjtBQUFBO0FBQUEsNkNBMkZxQixTQTNGckIsRUEyRmdDLFFBM0ZoQyxFQTJGMEM7QUFBQSx5Q0FDUyxLQUFLLGlCQUFMLENBQXVCLFNBQXZCLENBRFQ7QUFBQSxvQkFDN0IsUUFENkIsc0JBQzdCLFFBRDZCO0FBQUEsb0JBQ25CLE1BRG1CLHNCQUNuQixNQURtQjtBQUFBLG9CQUNYLFFBRFcsc0JBQ1gsUUFEVztBQUFBLG9CQUNELE1BREMsc0JBQ0QsTUFEQzs7QUFFbEMscUJBQUssSUFBSSxJQUFJLFFBQWIsRUFBdUIsS0FBSyxNQUE1QixFQUFvQyxFQUFFLENBQXRDLEVBQXlDO0FBQ3JDLHlCQUFLLElBQUksSUFBSSxRQUFiLEVBQXVCLEtBQUssTUFBNUIsRUFBb0MsRUFBRSxDQUF0QyxFQUF5QztBQUNyQyxpQ0FBUyxJQUFULENBQWMsSUFBZCxFQUFvQixDQUFwQixFQUF1QixDQUF2QjtBQUNIO0FBQ0o7QUFDSjtBQWxHTDs7QUFBQTtBQUFBLE1BQXFCLEdBQXJCO0FBcUdILENBdEdNOzs7Ozs7Ozs7QUNBUDs7QUFDQTs7QUFDQTs7QUFFQTs7O0FBR0EsU0FBUyxXQUFULENBQXFCLFdBQXJCLEVBQWtDO0FBQzlCLFNBQUssV0FBTCxHQUFtQixXQUFuQjtBQUNBOzs7O0FBSUEsU0FBSyxTQUFMLEdBQWlCLElBQUksR0FBSixFQUFqQjtBQUNBLFNBQUssS0FBTDtBQUNIOztrQkFFYyxXOzs7QUFFZixZQUFZLFNBQVosQ0FBc0IsUUFBdEIsR0FBaUMsVUFBVSxHQUFWLEVBQWUsTUFBZixFQUF1QixPQUF2QixFQUFnQztBQUM3RCxTQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLGdCQUFRLE1BRFk7QUFFcEIsaUJBQVM7QUFGVyxLQUF4QjtBQUlILENBTEQ7O0FBT0E7OztBQUdBLFlBQVksU0FBWixDQUFzQixxQkFBdEIsR0FBOEMsWUFBWTtBQUFBOztBQUN0RCxRQUFJLENBQUMsS0FBSyxjQUFWLEVBQTBCO0FBQ3RCLGFBQUssY0FBTCxHQUFzQixFQUF0QjtBQUNBLGFBQUssU0FBTCxDQUFlLE9BQWYsQ0FBdUIsZ0JBQVcsR0FBWDtBQUFBLGdCQUFFLE1BQUYsUUFBRSxNQUFGO0FBQUEsbUJBQW1CLE1BQUssY0FBTCxDQUFvQixHQUFwQixJQUEyQixNQUE5QztBQUFBLFNBQXZCO0FBQ0g7QUFDRCxXQUFPLEtBQUssY0FBWjtBQUNILENBTkQ7O0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLFlBQVksU0FBWixDQUFzQixLQUF0QixHQUE4QixZQUFZO0FBQ3RDLFFBQU0sTUFBTSxXQUFaOztBQUdBLFNBQUssUUFBTCxDQUFjLFdBQWQsRUFBMkI7QUFDdkIsY0FBTSxRQURpQjtBQUV2QixrQkFBVSxvQkFBWTtBQUNsQjtBQUNBO0FBQ0EsbUJBQU8sS0FBUDtBQUNIO0FBTnNCLEtBQTNCOztBQVNBLFNBQUssUUFBTCxDQUFjLFdBQWQsRUFBMkI7QUFDdkIsY0FBTTtBQURpQixLQUEzQjs7QUFJQSxTQUFLLFFBQUwsQ0FBYyxVQUFkLEVBQTBCO0FBQ3RCLGNBQU07QUFEZ0IsS0FBMUI7O0FBSUEsU0FBSyxRQUFMLENBQWMsV0FBZCxFQUEyQjtBQUN2QixjQUFNO0FBRGlCLEtBQTNCOztBQUlBLFNBQUssUUFBTCxDQUFjLGdCQUFkLEVBQWdDLEdBQWhDOztBQUVBO0FBQ0EsU0FBSyxRQUFMLENBQWMsWUFBZCxFQUE0QjtBQUN4QixjQUFNLE9BRGtCO0FBRXhCLGtCQUFVLG9CQUFZO0FBQ2xCO0FBQ0EsbUJBQU8sS0FBUDtBQUNIO0FBTHVCLEtBQTVCO0FBT0EsU0FBSyxRQUFMLENBQWMsWUFBZCxFQUE0QjtBQUN4QixjQUFNO0FBRGtCLEtBQTVCOztBQUlBLFNBQUssUUFBTCxDQUFjLGdCQUFkLEVBQWdDLEdBQWhDOztBQUVBLFNBQUssUUFBTCxDQUFjLFdBQWQsRUFBMkIsMkNBQTNCO0FBQ0EsU0FBSyxRQUFMLENBQWMsWUFBZDtBQUNBLFNBQUssUUFBTCxDQUFjLFlBQWQ7O0FBRUEsU0FBSyxRQUFMLENBQWMsZ0JBQWQsRUFBZ0MsR0FBaEM7O0FBRUEsU0FBSyxRQUFMLENBQWMsZUFBZDtBQUNBLFNBQUssUUFBTCxDQUFjLHNCQUFkO0FBQ0gsQ0FqREQ7Ozs7Ozs7O1FDcERnQixhLEdBQUEsYTs7QUFIaEI7O0FBRUE7QUFDTyxTQUFTLGFBQVQsR0FBeUI7QUFDNUIsV0FBTztBQUNILGNBQU0sV0FBSyxFQURSO0FBRUgsa0JBQVUsb0JBQVk7QUFDbEIsbUJBQU8sRUFBRSxLQUFLLGdCQUFMLE1BQTJCLENBQUMsS0FBSyxTQUFMLENBQWUsY0FBZixDQUE4QixNQUE1RCxDQUFQO0FBQ0gsU0FKRTtBQUtILGlCQUFTO0FBQ0wsbUJBQU8sQ0FBQztBQUNKLHFCQUFLLGdCQUREO0FBRUosc0JBQU0sZ0JBQVk7QUFBQTs7QUFDZCx3QkFBSSxXQUFXLDBCQUEwQixLQUFLLGdCQUFMLEVBQTFCLEVBQW1ELFVBQUMsR0FBRCxFQUFNLEdBQU4sRUFBYztBQUM1RSw0QkFBSSxZQUFZLE1BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixFQUEyQixTQUEzQztBQUNBLDRCQUFJLGFBQWEsVUFBVSxPQUFWLENBQWtCLFFBQWxCLE1BQWdDLENBQUMsQ0FBbEQsRUFBcUQ7QUFDakQsbUNBQU8sSUFBUDtBQUNIO0FBQ0oscUJBTGMsQ0FBZjtBQU1BLDJCQUFPLFdBQVcsb0JBQW9CLFdBQUssRUFBekIsQ0FBWCxHQUEwQyxXQUFLLEVBQXREO0FBQ0gsaUJBVkc7QUFXSiwwQkFBVSxvQkFBWTtBQUFBOztBQUNsQix3QkFBSSxRQUFRLEtBQUssZ0JBQUwsRUFBWjtBQUNBLHdCQUFJLGNBQWMsb0JBQW9CLEtBQXBCLEVBQTJCLFVBQUMsR0FBRCxFQUFNLEdBQU47QUFBQSwrQkFBYyxPQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsRUFBMkIsU0FBekM7QUFBQSxxQkFBM0IsQ0FBbEI7QUFDQSx3QkFBSSxPQUFPLFlBQVg7QUFDQSx3QkFBSSxZQUFZLFFBQWhCO0FBQ0EseUJBQUssUUFBTCxDQUFjLHFCQUFkLEVBQXFDLFdBQXJDLEVBQWtELEtBQWxELEVBQXlELElBQXpELEVBQStELFNBQS9EO0FBQ0EsMEJBQU0sS0FBTixFQUFhLElBQWIsRUFBbUIsU0FBbkIsRUFBOEIsVUFBQyxHQUFELEVBQU0sR0FBTjtBQUFBLCtCQUFjLE9BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixDQUFkO0FBQUEscUJBQTlCO0FBQ0EseUJBQUssTUFBTDtBQUNILGlCQW5CRztBQW9CSiwwQkFBVTtBQXBCTixhQUFELEVBcUJKO0FBQ0MscUJBQUssa0JBRE47QUFFQyxzQkFBTSxnQkFBWTtBQUFBOztBQUNkLHdCQUFJLFdBQVcsMEJBQTBCLEtBQUssZ0JBQUwsRUFBMUIsRUFBbUQsVUFBQyxHQUFELEVBQU0sR0FBTixFQUFjO0FBQzVFLDRCQUFJLFlBQVksT0FBSyxXQUFMLENBQWlCLEdBQWpCLEVBQXNCLEdBQXRCLEVBQTJCLFNBQTNDO0FBQ0EsNEJBQUksYUFBYSxVQUFVLE9BQVYsQ0FBa0IsVUFBbEIsTUFBa0MsQ0FBQyxDQUFwRCxFQUF1RDtBQUNuRCxtQ0FBTyxJQUFQO0FBQ0g7QUFDSixxQkFMYyxDQUFmO0FBTUEsMkJBQU8sV0FBVyxvQkFBb0IsV0FBSyxFQUF6QixDQUFYLEdBQTBDLFdBQUssRUFBdEQ7QUFDSCxpQkFWRjtBQVdDLDBCQUFVLG9CQUFZO0FBQUE7O0FBQ2xCLHdCQUFJLFFBQVEsS0FBSyxnQkFBTCxFQUFaO0FBQ0Esd0JBQUksY0FBYyxvQkFBb0IsS0FBcEIsRUFBMkIsVUFBQyxHQUFELEVBQU0sR0FBTjtBQUFBLCtCQUFjLE9BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixFQUEyQixTQUF6QztBQUFBLHFCQUEzQixDQUFsQjtBQUNBLHdCQUFJLE9BQU8sWUFBWDtBQUNBLHdCQUFJLFlBQVksVUFBaEI7O0FBRUEseUJBQUssUUFBTCxDQUFjLHFCQUFkLEVBQXFDLFdBQXJDLEVBQWtELEtBQWxELEVBQXlELElBQXpELEVBQStELFNBQS9EO0FBQ0EsMEJBQU0sS0FBTixFQUFhLElBQWIsRUFBbUIsU0FBbkIsRUFBOEIsVUFBQyxHQUFELEVBQU0sR0FBTjtBQUFBLCtCQUFjLE9BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixDQUFkO0FBQUEscUJBQTlCO0FBQ0EseUJBQUssTUFBTDtBQUNILGlCQXBCRjtBQXFCQywwQkFBVTtBQXJCWCxhQXJCSSxFQTJDSjtBQUNDLHNDQUREO0FBRUMsc0JBQU0sZ0JBQVk7QUFBQTs7QUFDZCx3QkFBSSxRQUFRLFdBQUssRUFBakI7QUFDQSx3QkFBSSxXQUFXLDBCQUEwQixLQUFLLGdCQUFMLEVBQTFCLEVBQW1ELFVBQUMsR0FBRCxFQUFNLEdBQU4sRUFBYztBQUM1RSw0QkFBSSxZQUFZLE9BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixFQUEyQixTQUEzQzs7QUFFQSw0QkFBSSxhQUFhLFVBQVUsT0FBVixDQUFrQixTQUFsQixNQUFpQyxDQUFDLENBQW5ELEVBQXNEO0FBQ2xELG1DQUFPLElBQVA7QUFDSDtBQUNKLHFCQU5jLENBQWY7O0FBUUEsd0JBQUksUUFBSixFQUFjO0FBQ1YsZ0NBQVEsb0JBQW9CLEtBQXBCLENBQVI7QUFDSDs7QUFFRCwyQkFBTyxLQUFQO0FBQ0gsaUJBakJGO0FBa0JDLDBCQUFVLG9CQUFZO0FBQUE7O0FBQ2xCLHdCQUFJLFFBQVEsS0FBSyxnQkFBTCxFQUFaO0FBQ0Esd0JBQUksY0FBYyxvQkFBb0IsS0FBcEIsRUFBMkIsVUFBQyxHQUFELEVBQU0sR0FBTjtBQUFBLCtCQUFjLE9BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixFQUEyQixTQUF6QztBQUFBLHFCQUEzQixDQUFsQjtBQUNBLHdCQUFJLE9BQU8sWUFBWDtBQUNBLHdCQUFJLFlBQVksU0FBaEI7O0FBRUEseUJBQUssUUFBTCxDQUFjLHFCQUFkLEVBQXFDLFdBQXJDLEVBQWtELEtBQWxELEVBQXlELElBQXpELEVBQStELFNBQS9EO0FBQ0EsMEJBQU0sS0FBTixFQUFhLElBQWIsRUFBbUIsU0FBbkIsRUFBOEIsVUFBQyxHQUFELEVBQU0sR0FBTjtBQUFBLCtCQUFjLE9BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixDQUFkO0FBQUEscUJBQTlCO0FBQ0EseUJBQUssTUFBTDtBQUNILGlCQTNCRjtBQTRCQywwQkFBVTtBQTVCWCxhQTNDSSxFQXdFSjtBQUNDLHdDQUREO0FBRUMsc0JBQU0sZ0JBQVk7QUFBQTs7QUFDZCx3QkFBSSxRQUFRLFdBQUssRUFBakI7QUFDQSx3QkFBSSxXQUFXLDBCQUEwQixLQUFLLGdCQUFMLEVBQTFCLEVBQW1ELFVBQUMsR0FBRCxFQUFNLEdBQU4sRUFBYztBQUM1RSw0QkFBSSxZQUFZLE9BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixFQUEyQixTQUEzQzs7QUFFQSw0QkFBSSxhQUFhLFVBQVUsT0FBVixDQUFrQixXQUFsQixNQUFtQyxDQUFDLENBQXJELEVBQXdEO0FBQ3BELG1DQUFPLElBQVA7QUFDSDtBQUNKLHFCQU5jLENBQWY7O0FBUUEsd0JBQUksUUFBSixFQUFjO0FBQ1YsZ0NBQVEsb0JBQW9CLEtBQXBCLENBQVI7QUFDSDs7QUFFRCwyQkFBTyxLQUFQO0FBQ0gsaUJBakJGO0FBa0JDLDBCQUFVLG9CQUFZO0FBQUE7O0FBQ2xCLHdCQUFJLFFBQVEsS0FBSyxnQkFBTCxFQUFaO0FBQ0Esd0JBQUksY0FBYyxvQkFBb0IsS0FBcEIsRUFBMkIsVUFBQyxHQUFELEVBQU0sR0FBTjtBQUFBLCtCQUFjLE9BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixFQUEyQixTQUF6QztBQUFBLHFCQUEzQixDQUFsQjtBQUNBLHdCQUFJLE9BQU8sWUFBWDtBQUNBLHdCQUFJLFlBQVksV0FBaEI7O0FBRUEseUJBQUssUUFBTCxDQUFjLHFCQUFkLEVBQXFDLFdBQXJDLEVBQWtELEtBQWxELEVBQXlELElBQXpELEVBQStELFNBQS9EO0FBQ0EsMEJBQU0sS0FBTixFQUFhLElBQWIsRUFBbUIsU0FBbkIsRUFBOEIsVUFBQyxHQUFELEVBQU0sR0FBTjtBQUFBLCtCQUFjLE9BQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixDQUFkO0FBQUEscUJBQTlCO0FBQ0EseUJBQUssTUFBTDtBQUNILGlCQTNCRjtBQTRCQywwQkFBVTtBQTVCWCxhQXhFSSxFQXFHSjtBQUNDLHNCQUFNO0FBRFAsYUFyR0ksRUF1R0o7QUFDQyxvQ0FERDtBQUVDLHNCQUFNLGdCQUFZO0FBQUE7O0FBQ2Qsd0JBQUksUUFBUSxXQUFLLEdBQWpCO0FBQ0Esd0JBQUksV0FBVywwQkFBMEIsS0FBSyxnQkFBTCxFQUExQixFQUFtRCxVQUFDLEdBQUQsRUFBTSxHQUFOLEVBQWM7QUFDNUUsNEJBQUksWUFBWSxPQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsRUFBMkIsU0FBM0M7QUFDQSw0QkFBSSxhQUFhLFVBQVUsT0FBVixDQUFrQixPQUFsQixNQUErQixDQUFDLENBQWpELEVBQW9EO0FBQ2hELG1DQUFPLElBQVA7QUFDSDtBQUNKLHFCQUxjLENBQWY7O0FBT0Esd0JBQUksUUFBSixFQUFjO0FBQ1YsZ0NBQVEsb0JBQW9CLEtBQXBCLENBQVI7QUFDSDtBQUNELDJCQUFPLEtBQVA7QUFDSCxpQkFmRjtBQWdCQywwQkFBVSxvQkFBWTtBQUFBOztBQUNsQix3QkFBSSxRQUFRLEtBQUssZ0JBQUwsRUFBWjtBQUNBLHdCQUFJLGNBQWMsb0JBQW9CLEtBQXBCLEVBQTJCLFVBQUMsR0FBRCxFQUFNLEdBQU47QUFBQSwrQkFBYyxRQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsRUFBMkIsU0FBekM7QUFBQSxxQkFBM0IsQ0FBbEI7QUFDQSx3QkFBSSxPQUFPLFVBQVg7QUFDQSx3QkFBSSxZQUFZLE9BQWhCOztBQUVBLHlCQUFLLFFBQUwsQ0FBYyxxQkFBZCxFQUFxQyxXQUFyQyxFQUFrRCxLQUFsRCxFQUF5RCxJQUF6RCxFQUErRCxTQUEvRDtBQUNBLDBCQUFNLEtBQU4sRUFBYSxJQUFiLEVBQW1CLFNBQW5CLEVBQThCLFVBQUMsR0FBRCxFQUFNLEdBQU47QUFBQSwrQkFBYyxRQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsQ0FBZDtBQUFBLHFCQUE5QjtBQUNBLHlCQUFLLE1BQUw7QUFDSCxpQkF6QkY7QUEwQkMsMEJBQVU7QUExQlgsYUF2R0ksRUFrSUo7QUFDQyx1Q0FERDtBQUVDLHNCQUFNLGdCQUFZO0FBQUE7O0FBQ2Qsd0JBQUksUUFBUSxXQUFLLEdBQWpCO0FBQ0Esd0JBQUksV0FBVywwQkFBMEIsS0FBSyxnQkFBTCxFQUExQixFQUFtRCxVQUFDLEdBQUQsRUFBTSxHQUFOLEVBQWM7QUFDNUUsNEJBQUksWUFBWSxRQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsRUFBMkIsU0FBM0M7O0FBRUEsNEJBQUksYUFBYSxVQUFVLE9BQVYsQ0FBa0IsVUFBbEIsTUFBa0MsQ0FBQyxDQUFwRCxFQUF1RDtBQUNuRCxtQ0FBTyxJQUFQO0FBQ0g7QUFDSixxQkFOYyxDQUFmOztBQVFBLHdCQUFJLFFBQUosRUFBYztBQUNWLGdDQUFRLG9CQUFvQixLQUFwQixDQUFSO0FBQ0g7O0FBRUQsMkJBQU8sS0FBUDtBQUNILGlCQWpCRjtBQWtCQywwQkFBVSxvQkFBWTtBQUFBOztBQUNsQix3QkFBSSxRQUFRLEtBQUssZ0JBQUwsRUFBWjtBQUNBLHdCQUFJLGNBQWMsb0JBQW9CLEtBQXBCLEVBQTJCLFVBQUMsR0FBRCxFQUFNLEdBQU47QUFBQSwrQkFBYyxRQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsRUFBMkIsU0FBekM7QUFBQSxxQkFBM0IsQ0FBbEI7QUFDQSx3QkFBSSxPQUFPLFVBQVg7QUFDQSx3QkFBSSxZQUFZLFVBQWhCOztBQUVBLHlCQUFLLFFBQUwsQ0FBYyxxQkFBZCxFQUFxQyxXQUFyQyxFQUFrRCxLQUFsRCxFQUF5RCxJQUF6RCxFQUErRCxTQUEvRDtBQUNBLDBCQUFNLEtBQU4sRUFBYSxJQUFiLEVBQW1CLFNBQW5CLEVBQThCLFVBQUMsR0FBRCxFQUFNLEdBQU47QUFBQSwrQkFBYyxRQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsQ0FBZDtBQUFBLHFCQUE5QjtBQUNBLHlCQUFLLE1BQUw7QUFDSCxpQkEzQkY7QUE0QkMsMEJBQVU7QUE1QlgsYUFsSUksRUErSko7QUFDQyx1Q0FERDtBQUVDLHNCQUFNLGdCQUFZO0FBQUE7O0FBQ2Qsd0JBQUksUUFBUSxXQUFLLEdBQWpCO0FBQ0Esd0JBQUksV0FBVywwQkFBMEIsS0FBSyxnQkFBTCxFQUExQixFQUFtRCxVQUFDLEdBQUQsRUFBTSxHQUFOLEVBQWM7QUFDNUUsNEJBQUksWUFBWSxRQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsRUFBMkIsU0FBM0M7O0FBRUEsNEJBQUksYUFBYSxVQUFVLE9BQVYsQ0FBa0IsVUFBbEIsTUFBa0MsQ0FBQyxDQUFwRCxFQUF1RDtBQUNuRCxtQ0FBTyxJQUFQO0FBQ0g7QUFDSixxQkFOYyxDQUFmOztBQVFBLHdCQUFJLFFBQUosRUFBYztBQUNWLGdDQUFRLG9CQUFvQixLQUFwQixDQUFSO0FBQ0g7O0FBRUQsMkJBQU8sS0FBUDtBQUNILGlCQWpCRjtBQWtCQywwQkFBVSxvQkFBWTtBQUFBOztBQUNsQix3QkFBSSxRQUFRLEtBQUssZ0JBQUwsRUFBWjtBQUNBLHdCQUFJLGNBQWMsb0JBQW9CLEtBQXBCLEVBQTJCLFVBQUMsR0FBRCxFQUFNLEdBQU47QUFBQSwrQkFBYyxRQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsRUFBMkIsU0FBekM7QUFBQSxxQkFBM0IsQ0FBbEI7QUFDQSx3QkFBSSxPQUFPLFVBQVg7QUFDQSx3QkFBSSxZQUFZLFVBQWhCOztBQUVBLHlCQUFLLFFBQUwsQ0FBYyxxQkFBZCxFQUFxQyxXQUFyQyxFQUFrRCxLQUFsRCxFQUF5RCxJQUF6RCxFQUErRCxTQUEvRDtBQUNBLDBCQUFNLEtBQU4sRUFBYSxJQUFiLEVBQW1CLFNBQW5CLEVBQThCLFVBQUMsR0FBRCxFQUFNLEdBQU47QUFBQSwrQkFBYyxRQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsR0FBdEIsQ0FBZDtBQUFBLHFCQUE5QjtBQUNBLHlCQUFLLE1BQUw7QUFDSCxpQkEzQkY7QUE0QkMsMEJBQVU7QUE1QlgsYUEvSkk7QUFERjtBQUxOLEtBQVA7QUFxTUg7O0FBR0QsU0FBUyx5QkFBVCxDQUFtQyxLQUFuQyxFQUEwQyxVQUExQyxFQUFzRDtBQUNsRCxRQUFJLFNBQVMsS0FBYjtBQUNBLFFBQUksS0FBSixFQUFXO0FBQ1AsY0FBTSxNQUFOLENBQWEsVUFBVSxHQUFWLEVBQWUsR0FBZixFQUFvQjtBQUM3QixnQkFBSSxXQUFXLEdBQVgsRUFBZ0IsR0FBaEIsQ0FBSixFQUEwQjtBQUN0Qix5QkFBUyxJQUFUO0FBQ0EsdUJBQU8sS0FBUDtBQUNIO0FBQ0osU0FMRDtBQU1IO0FBQ0QsV0FBTyxNQUFQO0FBQ0g7O0FBRUQsU0FBUyxtQkFBVCxDQUE2QixLQUE3QixFQUFvQztBQUNoQyxXQUFPLDRCQUE0QixPQUFPLFlBQVAsQ0FBb0IsS0FBcEIsQ0FBNUIsR0FBeUQsU0FBekQsR0FBcUUsS0FBNUU7QUFDSDs7QUFFRCxTQUFTLG1CQUFULENBQTZCLEtBQTdCLEVBQW9DLFFBQXBDLEVBQThDO0FBQzFDLFFBQU0sVUFBVSxFQUFoQjtBQUNBLFNBQUssSUFBSSxNQUFNLE1BQU0sSUFBTixDQUFXLEdBQTFCLEVBQStCLE9BQU8sTUFBTSxFQUFOLENBQVMsR0FBL0MsRUFBb0QsS0FBcEQsRUFBMkQ7QUFDdkQsYUFBSyxJQUFJLE1BQU0sTUFBTSxJQUFOLENBQVcsR0FBMUIsRUFBK0IsT0FBTyxNQUFNLEVBQU4sQ0FBUyxHQUEvQyxFQUFvRCxLQUFwRCxFQUEyRDtBQUN2RCxnQkFBSSxDQUFDLFFBQVEsR0FBUixDQUFMLEVBQW1CO0FBQ2Ysd0JBQVEsR0FBUixJQUFlLEVBQWY7QUFDSDtBQUNELG9CQUFRLEdBQVIsRUFBYSxHQUFiLElBQW9CLFNBQVMsR0FBVCxFQUFjLEdBQWQsQ0FBcEI7QUFDSDtBQUNKO0FBQ0QsV0FBTyxPQUFQO0FBQ0g7O0FBRUQsU0FBUyxLQUFULENBQWUsS0FBZixFQUFzQixJQUF0QixFQUE0QixTQUE1QixFQUF1QyxjQUF2QyxFQUF1RDtBQUNuRCxRQUFJLE1BQU0sSUFBTixDQUFXLEdBQVgsS0FBbUIsTUFBTSxFQUFOLENBQVMsR0FBNUIsSUFBbUMsTUFBTSxJQUFOLENBQVcsR0FBWCxLQUFtQixNQUFNLEVBQU4sQ0FBUyxHQUFuRSxFQUF3RTtBQUNwRSw0QkFBb0IsTUFBTSxJQUFOLENBQVcsR0FBL0IsRUFBb0MsTUFBTSxJQUFOLENBQVcsR0FBL0MsRUFBb0QsSUFBcEQsRUFBMEQsU0FBMUQsRUFBcUUsY0FBckU7QUFDSCxLQUZELE1BRU87QUFDSCxhQUFLLElBQUksTUFBTSxNQUFNLElBQU4sQ0FBVyxHQUExQixFQUErQixPQUFPLE1BQU0sRUFBTixDQUFTLEdBQS9DLEVBQW9ELEtBQXBELEVBQTJEO0FBQ3ZELGlCQUFLLElBQUksTUFBTSxNQUFNLElBQU4sQ0FBVyxHQUExQixFQUErQixPQUFPLE1BQU0sRUFBTixDQUFTLEdBQS9DLEVBQW9ELEtBQXBELEVBQTJEO0FBQ3ZELG9DQUFvQixHQUFwQixFQUF5QixHQUF6QixFQUE4QixJQUE5QixFQUFvQyxTQUFwQyxFQUErQyxjQUEvQztBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVELFNBQVMsbUJBQVQsQ0FBNkIsR0FBN0IsRUFBa0MsR0FBbEMsRUFBdUMsSUFBdkMsRUFBNkMsU0FBN0MsRUFBd0QsY0FBeEQsRUFBd0U7QUFDcEUsUUFBSSxXQUFXLGVBQWUsR0FBZixFQUFvQixHQUFwQixDQUFmO0FBQ0EsUUFBSSxZQUFZLFNBQWhCOztBQUVBLFFBQUksU0FBUyxTQUFiLEVBQXdCO0FBQ3BCLFlBQUksU0FBUyxVQUFiLEVBQXlCO0FBQ3JCLHdCQUFZLDBCQUEwQixTQUFTLFNBQW5DLEVBQThDLFNBQTlDLENBQVo7QUFDSCxTQUZELE1BRU87QUFDSCx3QkFBWSw0QkFBNEIsU0FBUyxTQUFyQyxFQUFnRCxTQUFoRCxDQUFaO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0EsYUFBUyxTQUFULEdBQXFCLFVBQVUsSUFBVixHQUFpQixLQUFqQixDQUF1QixPQUF2QixFQUFnQyxJQUFoQyxDQUFxQyxHQUFyQyxDQUFyQjtBQUNIOztBQUdELFNBQVMseUJBQVQsQ0FBbUMsU0FBbkMsRUFBOEMsU0FBOUMsRUFBeUQ7QUFDckQsUUFBSSxVQUFVLE9BQVYsQ0FBa0IsU0FBbEIsTUFBaUMsQ0FBQyxDQUF0QyxFQUF5QztBQUNyQyxlQUFPLFNBQVA7QUFDSDtBQUNELGdCQUFZLFVBQ1AsT0FETyxDQUNDLE9BREQsRUFDVSxFQURWLEVBRVAsT0FGTyxDQUVDLFVBRkQsRUFFYSxFQUZiLEVBR1AsT0FITyxDQUdDLFVBSEQsRUFHYSxFQUhiLENBQVo7O0FBS0EsaUJBQWEsTUFBTSxTQUFuQjtBQUNBLFdBQU8sU0FBUDtBQUNIOztBQUVELFNBQVMsMkJBQVQsQ0FBcUMsU0FBckMsRUFBZ0QsU0FBaEQsRUFBMkQ7QUFDdkQsUUFBSSxVQUFVLE9BQVYsQ0FBa0IsU0FBbEIsTUFBaUMsQ0FBQyxDQUF0QyxFQUF5QztBQUNyQyxlQUFPLFNBQVA7QUFDSDtBQUNELGdCQUFZLFVBQ1AsT0FETyxDQUNDLFFBREQsRUFDVyxFQURYLEVBRVAsT0FGTyxDQUVDLFVBRkQsRUFFYSxFQUZiLEVBR1AsT0FITyxDQUdDLFNBSEQsRUFHWSxFQUhaLEVBSVAsT0FKTyxDQUlDLFdBSkQsRUFJYyxFQUpkLENBQVo7O0FBTUEsaUJBQWEsTUFBTSxTQUFuQjtBQUNBLFdBQU8sU0FBUDtBQUNIOzs7Ozs7Ozs7Ozs7UUNuUmUsaUIsR0FBQSxpQjtRQWtCQSx1QixHQUFBLHVCOztBQWhDaEI7O0FBQ0E7O0FBRU8sSUFBSSxrQ0FBYTtBQUNwQixVQUFNLFdBQUssRUFEUztBQUVwQixjQUFVLG9CQUFZO0FBQUEsMkJBQ0ssS0FBSyxXQUFMLEVBREw7QUFBQTtBQUFBLFlBQ2IsRUFEYTtBQUFBLFlBQ1QsRUFEUztBQUFBLFlBQ0wsRUFESztBQUFBLFlBQ0QsRUFEQzs7QUFFbEIsWUFBSSxPQUFPLEVBQVAsSUFBYSxPQUFPLEVBQXhCLEVBQTRCO0FBQ3hCLG1CQUFPLElBQVA7QUFDSDtBQUNELGVBQU8sQ0FBQyxhQUFhLElBQWIsQ0FBa0IsSUFBbEIsRUFBd0IsU0FBeEIsQ0FBUjtBQUNIO0FBUm1CLENBQWpCOztBQVdBLFNBQVMsaUJBQVQsQ0FBMkIsS0FBM0IsRUFBa0MsS0FBbEMsRUFBeUMsR0FBekMsRUFBOEM7QUFDakQsVUFBTSxVQUFOLENBQ0ksTUFBTSxHQURWLEVBRUksTUFBTSxHQUZWLEVBR0ksSUFBSSxHQUFKLEdBQVUsTUFBTSxHQUFoQixHQUFzQixDQUgxQixFQUlJLElBQUksR0FBSixHQUFVLE1BQU0sR0FBaEIsR0FBc0IsQ0FKMUI7QUFNSDs7QUFHTSxJQUFJLDhDQUFtQjtBQUMxQixVQUFNLFdBQUssRUFEZTtBQUUxQixjQUFVLG9CQUFZO0FBQ2xCLGVBQU8sYUFBYSxJQUFiLENBQWtCLElBQWxCLEVBQXdCLFVBQXhCLENBQVA7QUFDSDtBQUp5QixDQUF2Qjs7QUFRQSxTQUFTLHVCQUFULENBQWlDLEtBQWpDLEVBQXdDLEtBQXhDLEVBQStDLEdBQS9DLEVBQW9EO0FBQ3ZELFVBQU0sWUFBTixDQUNJLE1BQU0sR0FEVixFQUVJLE1BQU0sR0FGVixFQUdJLElBQUksR0FBSixHQUFVLE1BQU0sR0FBaEIsR0FBc0IsQ0FIMUIsRUFJSSxJQUFJLEdBQUosR0FBVSxNQUFNLEdBQWhCLEdBQXNCLENBSjFCO0FBTUg7O0FBRUQsU0FBUyxZQUFULENBQXNCLElBQXRCLEVBQTRCO0FBQ3hCLFFBQUksU0FBUyxLQUFLLFdBQUwsR0FBbUIsVUFBaEM7QUFDQSxRQUFJLFVBQVUsT0FBTyxNQUFyQixFQUE2QjtBQUN6QixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxFQUFFLENBQXJDLEVBQXdDO0FBQUEsNEJBQ0QsT0FBTyxDQUFQLENBREM7QUFBQSxnQkFDL0IsR0FEK0IsYUFDL0IsR0FEK0I7QUFBQSxnQkFDMUIsR0FEMEIsYUFDMUIsR0FEMEI7QUFBQSxnQkFDckIsT0FEcUIsYUFDckIsT0FEcUI7QUFBQSxnQkFDWixPQURZLGFBQ1osT0FEWTs7QUFFcEMsZ0JBQUksbUJBQVcsSUFBWCxFQUNJLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxNQUFNLE9BQU4sR0FBZ0IsQ0FBM0IsRUFBOEIsTUFBTSxPQUFOLEdBQWdCLENBQTlDLENBREosRUFFSSxpQkFBaUIsS0FBSyxXQUFMLEVBQWpCLENBRkosQ0FBSixFQUUrQztBQUMzQyx1QkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsV0FBTyxJQUFQO0FBQ0g7O0FBRUQsU0FBUyxnQkFBVCxDQUEwQixDQUExQixFQUE2QjtBQUN6QixNQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUCxLQUFnQixFQUFFLENBQUYsSUFBTyxDQUFDLEVBQUUsQ0FBRixDQUFELEVBQU8sRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQWQsRUFBb0IsQ0FBcEIsQ0FBdkI7QUFDQSxNQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUCxLQUFnQixFQUFFLENBQUYsSUFBTyxDQUFDLEVBQUUsQ0FBRixDQUFELEVBQU8sRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQWQsRUFBb0IsQ0FBcEIsQ0FBdkI7QUFDQSxXQUFPLENBQVA7QUFDSDs7Ozs7Ozs7O1FDaERlLGdCLEdBQUEsZ0I7UUF3Q0EsZ0IsR0FBQSxnQjs7QUFwRGhCOztBQUVBO0FBQ0E7QUFDQTtBQUNPLElBQUksZ0NBQVk7QUFDbkIsVUFBTSxXQUFLLEVBRFE7QUFFbkIsWUFBUSxrQkFBWTtBQUNoQixlQUFPLENBQUMsS0FBSyxnQkFBTCxFQUFELElBQTRCLENBQUMsS0FBSyxTQUFMLENBQWUsY0FBZixDQUE4QixJQUFsRTtBQUNIO0FBSmtCLENBQWhCOztBQU9BLFNBQVMsZ0JBQVQsQ0FBMEIsS0FBMUIsRUFBaUMsS0FBakMsRUFBd0MsR0FBeEMsRUFBNkM7QUFDaEQsUUFBSSxTQUFTLEdBQUcsQ0FBaEI7O0FBRUEsVUFBTSxHQUFOLEdBQVksSUFBSSxHQUFoQixLQUF3QixNQUFNLEdBQU4sR0FBWSxDQUFDLElBQUksR0FBTCxFQUFVLElBQUksR0FBSixHQUFVLE1BQU0sR0FBMUIsRUFBK0IsQ0FBL0IsQ0FBcEM7O0FBRUEsU0FBSyxJQUFJLElBQUksTUFBTSxHQUFuQixFQUF3QixLQUFLLElBQUksR0FBakMsRUFBc0MsRUFBRSxDQUF4QyxFQUEyQztBQUN2QyxZQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1QscUJBQVMsTUFBTSxZQUFOLENBQW1CLFlBQW5CLENBQWdDLENBQWhDLENBQVQ7QUFDSCxTQUZELE1BRU8sSUFBSSxXQUFXLE1BQU0sWUFBTixDQUFtQixZQUFuQixDQUFnQyxDQUFoQyxDQUFmLEVBQW1EO0FBQ3RELHFCQUFTLEtBQVQ7QUFDQTtBQUNIO0FBQ0o7O0FBRUQsUUFBSSxNQUFNLFdBQVcsS0FBWCxHQUFtQixFQUFuQixHQUF5QixVQUFVLEVBQTdDOztBQUVBLFFBQUksWUFBWSxNQUFoQixFQUF3QjtBQUNwQixvQkFBWSxNQUFaLENBQW1CLFdBQUssR0FBeEIsRUFBNkIsR0FBN0IsRUFBa0MsVUFBVSxNQUFWLEVBQWtCO0FBQ2hELGdCQUFJLE1BQUosRUFBWTtBQUNSLDhCQUFjLEtBQWQsRUFBcUIsTUFBTSxHQUEzQixFQUFnQyxJQUFJLEdBQXBDLEVBQXlDLE1BQXpDO0FBQ0g7QUFDSixTQUpEO0FBS0gsS0FORCxNQU1PO0FBQ0gsWUFBSSxjQUFjLE1BQU0sWUFBTixDQUFtQixTQUFuQixDQUE2QixhQUE3QixDQUFsQjtBQUNBLG9CQUFZLEtBQVo7QUFDQSxZQUFJLFNBQVMsT0FBTyxXQUFLLEdBQVosRUFBaUIsR0FBakIsQ0FBYjtBQUNBLFlBQUksV0FBVyxJQUFmLEVBQXFCO0FBQ2pCLDBCQUFjLEtBQWQsRUFBcUIsTUFBTSxHQUEzQixFQUFnQyxJQUFJLEdBQXBDLEVBQXlDLE1BQXpDO0FBQ0g7QUFDSjtBQUNKOztBQUdNLElBQUksZ0NBQVk7QUFDbkIsVUFBTSxXQUFLLEVBRFE7QUFFbkIsWUFBUSxrQkFBWTtBQUNoQixlQUFPLENBQUMsS0FBSyxnQkFBTCxFQUFELElBQTRCLENBQUMsS0FBSyxTQUFMLENBQWUsY0FBZixDQUE4QixJQUFsRTtBQUNIO0FBSmtCLENBQWhCOztBQU9BLFNBQVMsZ0JBQVQsQ0FBMEIsS0FBMUIsRUFBaUMsS0FBakMsRUFBd0MsR0FBeEMsRUFBNkM7QUFDaEQsUUFBSSxRQUFRLEdBQUcsQ0FBZjs7QUFFQSxVQUFNLEdBQU4sR0FBWSxJQUFJLEdBQWhCLEtBQXdCLE1BQU0sR0FBTixHQUFZLENBQUMsSUFBSSxHQUFMLEVBQVUsSUFBSSxHQUFKLEdBQVUsTUFBTSxHQUExQixFQUErQixDQUEvQixDQUFwQzs7QUFFQSxTQUFLLElBQUksSUFBSSxNQUFNLEdBQW5CLEVBQXdCLEtBQUssSUFBSSxHQUFqQyxFQUFzQyxFQUFFLENBQXhDLEVBQTJDO0FBQ3ZDLFlBQUksQ0FBQyxLQUFMLEVBQVk7QUFDUixvQkFBUSxNQUFNLFlBQU4sQ0FBbUIsV0FBbkIsQ0FBK0IsQ0FBL0IsQ0FBUjtBQUNILFNBRkQsTUFFTyxJQUFJLFVBQVUsTUFBTSxZQUFOLENBQW1CLFdBQW5CLENBQStCLENBQS9CLENBQWQsRUFBaUQ7QUFDcEQsb0JBQVEsS0FBUjtBQUNBO0FBQ0g7QUFDSjs7QUFFRCxRQUFJLE1BQU0sVUFBVSxLQUFWLEdBQWtCLEVBQWxCLEdBQXdCLFNBQVMsRUFBM0M7O0FBRUEsUUFBSSxZQUFZLE1BQWhCLEVBQXdCO0FBQ3BCLG9CQUFZLE1BQVosQ0FBbUIsV0FBSyxHQUF4QixFQUE2QixHQUE3QixFQUFrQyxVQUFVLE1BQVYsRUFBa0I7QUFDaEQsZ0JBQUksTUFBSixFQUFZO0FBQ1IsNkJBQWEsS0FBYixFQUFvQixNQUFNLEdBQTFCLEVBQStCLElBQUksR0FBbkMsRUFBd0MsTUFBeEM7QUFDSDtBQUNKLFNBSkQ7QUFLSCxLQU5ELE1BTU87QUFDSCxZQUFJLGNBQWMsTUFBTSxZQUFOLENBQW1CLFNBQW5CLENBQTZCLGFBQTdCLENBQWxCO0FBQ0Esb0JBQVksS0FBWjtBQUNBLFlBQUksU0FBUyxPQUFPLFdBQUssR0FBWixFQUFpQixHQUFqQixDQUFiO0FBQ0EsWUFBSSxXQUFXLElBQWYsRUFBcUI7QUFDakIseUJBQWEsS0FBYixFQUFvQixNQUFNLEdBQTFCLEVBQStCLElBQUksR0FBbkMsRUFBd0MsTUFBeEM7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsU0FBUyxhQUFULENBQXVCLEtBQXZCLEVBQThCLEtBQTlCLEVBQXFDLEdBQXJDLEVBQTBDLEtBQTFDLEVBQWlEO0FBQzdDLFlBQVEsU0FBUyxRQUFULENBQWtCLEtBQWxCLEtBQTRCLEVBQXBDO0FBQ0EsUUFBSSxhQUFhLE1BQU0sWUFBTixDQUFtQixXQUFuQixHQUFpQyxVQUFqQyxJQUErQyxFQUFoRTtBQUNBLFNBQUssSUFBSSxJQUFJLEtBQWIsRUFBb0IsS0FBSyxHQUF6QixFQUE4QixFQUFFLENBQWhDLEVBQW1DO0FBQy9CLG1CQUFXLENBQVgsSUFBZ0IsS0FBaEI7QUFDSDtBQUNELFVBQU0sWUFBTixDQUFtQixjQUFuQixDQUFrQyxFQUFDLFlBQVksVUFBYixFQUFsQztBQUNIOztBQUVELFNBQVMsWUFBVCxDQUFzQixLQUF0QixFQUE2QixLQUE3QixFQUFvQyxHQUFwQyxFQUF5QyxLQUF6QyxFQUFnRDtBQUM1QyxZQUFRLFNBQVMsUUFBVCxDQUFrQixLQUFsQixLQUE0QixFQUFwQztBQUNBLFFBQUksWUFBWSxNQUFNLFlBQU4sQ0FBbUIsV0FBbkIsR0FBaUMsU0FBakMsSUFBOEMsRUFBOUQ7QUFDQSxTQUFLLElBQUksSUFBSSxLQUFiLEVBQW9CLEtBQUssR0FBekIsRUFBOEIsRUFBRSxDQUFoQyxFQUFtQztBQUMvQixrQkFBVSxDQUFWLElBQWUsS0FBZjtBQUNIO0FBQ0QsVUFBTSxZQUFOLENBQW1CLGNBQW5CLENBQWtDLEVBQUMsV0FBVyxTQUFaLEVBQWxDO0FBQ0g7Ozs7Ozs7OztBQ3BHRDs7QUFLQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxJQUFNLGdCQUFnQixTQUF0QjtBQUNBLElBQU0sYUFBYSxVQUFuQjtBQUNBLElBQU0sZ0JBQWdCLGtCQUF0QjtBQUNBLElBQU0sZ0JBQWdCLGtCQUF0QjtBQUNBLElBQU0sWUFBWSxjQUFsQjtBQUNBLElBQU0sV0FBVyxhQUFqQjtBQUNBLElBQU0sV0FBVyxhQUFqQjtBQUNBLElBQU0sV0FBVyxhQUFqQjs7QUFFQSxJQUFNLFdBQVcseUJBQWUsS0FBZixDQUFxQixRQUF0QztBQUNBLElBQU0sU0FBUyx5QkFBZSxLQUFmLENBQXFCLFNBQXBDOztBQUVBOzs7Ozs7QUFNQSxTQUFTLElBQVQsQ0FBYyxRQUFkLEVBQXdCO0FBQ3BCLFNBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNBOzs7QUFHQSxTQUFLLE9BQUwsR0FBZSx1Q0FBZjtBQUNBLFNBQUssWUFBTCxHQUFvQix1Q0FBcEI7QUFDQSxTQUFLLFVBQUwsR0FBa0IsSUFBSSxHQUFKLEVBQWxCO0FBQ0EsU0FBSyxXQUFMLEdBQW1CLFNBQVMsV0FBVCxDQUFxQixjQUFyQixFQUFuQjtBQUNBLFNBQUssV0FBTCxHQUFtQixTQUFTLFdBQVQsQ0FBcUIsY0FBckIsRUFBbkI7O0FBRUEsU0FBSyxPQUFMO0FBQ0EsU0FBSyxPQUFMO0FBQ0EsU0FBSyxNQUFMO0FBQ0g7O0FBRUQsS0FBSyxTQUFMLENBQWUsTUFBZixHQUF3QixZQUFZO0FBQ2hDLFNBQUssV0FBTCxDQUFpQixXQUFqQixDQUE2QixLQUFLLElBQWxDO0FBQ0gsQ0FGRDs7QUFJQTs7O0FBR0EsS0FBSyxTQUFMLENBQWUsT0FBZixHQUF5QixZQUFZO0FBQ2pDLFNBQUssSUFBTCxHQUFZLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0EsU0FBSyxPQUFMLEdBQWUsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWY7QUFDQSxTQUFLLEdBQUwsR0FBVyxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWDtBQUNBLFNBQUssRUFBTCxHQUFVLFNBQVMsYUFBVCxDQUF1QixJQUF2QixDQUFWOztBQUVBLFNBQUssSUFBTCxDQUFVLFNBQVYsQ0FBb0IsR0FBcEIsQ0FBd0IsVUFBeEI7QUFDQSxTQUFLLElBQUwsQ0FBVSxFQUFWLEdBQWUsS0FBSyxRQUFMLENBQWMsS0FBZCxFQUFmO0FBQ0EsU0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixHQUF2QixDQUEyQixhQUEzQjtBQUNBLFNBQUssR0FBTCxDQUFTLFNBQVQsQ0FBbUIsR0FBbkIsQ0FBdUIsU0FBdkI7QUFDQSxTQUFLLEVBQUwsQ0FBUSxTQUFSLENBQWtCLEdBQWxCLENBQXNCLFFBQXRCOztBQUVBLFNBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsS0FBSyxPQUEzQjtBQUNBLFNBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsS0FBSyxHQUEzQjtBQUNBLFNBQUssR0FBTCxDQUFTLFdBQVQsQ0FBcUIsS0FBSyxFQUExQjs7QUFFQTtBQUNBLFNBQUssZUFBTDtBQUNILENBbEJEOztBQW9CQTs7O0FBR0EsS0FBSyxTQUFMLENBQWUsT0FBZixHQUF5QixZQUFZO0FBQ2pDLFFBQUksU0FBUyxLQUFLLFFBQUwsQ0FBYyxXQUFkLENBQTBCLGNBQTFCLEVBQWI7QUFDQSxTQUFLLEtBQUwsR0FBYSxLQUFLLFFBQUwsQ0FBYyxLQUFkLElBQXVCLDJCQUFXLE1BQVgsRUFBbUIsS0FBbkIsQ0FBcEM7QUFDQSxTQUFLLE1BQUwsR0FBYyxLQUFLLFFBQUwsQ0FBYyxNQUFkLElBQXdCLDRCQUFZLE1BQVosRUFBb0IsS0FBcEIsQ0FBdEM7O0FBRUEsU0FBSyxJQUFMLENBQVUsS0FBVixDQUFnQixLQUFoQixHQUF3QixLQUFLLEtBQUwsR0FBYSxJQUFyQztBQUNBLFNBQUssSUFBTCxDQUFVLEtBQVYsQ0FBZ0IsTUFBaEIsR0FBeUIsS0FBSyxNQUFMLEdBQWMsSUFBdkM7QUFDSCxDQVBEOztBQVVBOzs7O0FBSUEsS0FBSyxTQUFMLENBQWUsU0FBZixHQUEyQixVQUFVLFNBQVYsRUFBcUI7QUFDNUMsUUFBSSxPQUFPLElBQVg7QUFDQSxRQUFJLEtBQUssU0FBUyxhQUFULENBQXVCLElBQXZCLENBQVQ7QUFDQSxRQUFJLFFBQVEsS0FBSyxXQUFMLEdBQW1CLEVBQW5CLEdBQXdCLGdCQUFwQzs7QUFFQSxPQUFHLFNBQUgsNkRBRWdCLFNBRmhCLDBDQUd1QixLQUh2QjtBQU1BLE9BQUcsU0FBSCxDQUFhLEdBQWIsQ0FBaUIsUUFBakI7QUFDQSxPQUFHLFlBQUgsQ0FBZ0IsWUFBaEIsRUFBOEIsU0FBOUI7O0FBR0EsUUFBSSxZQUFZLEtBQUssSUFBTCxDQUFVLGFBQVYsT0FBNEIsYUFBNUIsU0FBNkMsUUFBN0MsQ0FBaEI7QUFDQSxRQUFJLFNBQUosRUFBZTtBQUNYLG9DQUFZLFNBQVosRUFBdUIsRUFBdkI7QUFDSCxLQUZELE1BRU87QUFDSCxhQUFLLEVBQUwsQ0FBUSxXQUFSLENBQW9CLEVBQXBCO0FBQ0g7QUFDRCxTQUFLLE9BQUwsQ0FBYSxHQUFiLENBQWlCLFNBQWpCLEVBQTRCLEVBQTVCOztBQUVBLE9BQUcsZ0JBQUgsQ0FBb0IsT0FBcEIsRUFBNkIsVUFBVSxDQUFWLEVBQWE7QUFDdEMsWUFBSSxZQUFZLEtBQUssT0FBTCxDQUFhLEtBQTdCO0FBQ0EsWUFBSSxRQUFRLEtBQUssUUFBTCxDQUFjLFFBQWQsQ0FBdUIsU0FBdkIsQ0FBWjtBQUNBLGNBQU0sTUFBTjtBQUNBLG1EQUF5QixDQUF6QjtBQUNILEtBTEQ7O0FBT0EsUUFBSSxDQUFDLEtBQUssV0FBVixFQUF1QjtBQUNuQixXQUFHLGdCQUFILENBQW9CLFVBQXBCLEVBQWdDLFVBQVUsQ0FBVixFQUFhO0FBQ3pDLGlCQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0IsSUFBL0I7QUFDQSx1REFBeUIsQ0FBekI7QUFDSCxTQUhEOztBQUtBLFdBQUcsYUFBSCxDQUFpQixRQUFqQixFQUEyQixnQkFBM0IsQ0FBNEMsT0FBNUMsRUFBcUQsVUFBVSxDQUFWLEVBQWE7QUFDOUQsZ0JBQUksWUFBWSxHQUFHLE9BQUgsQ0FBVyxLQUEzQjtBQUNBLGdCQUFJO0FBQ0EscUJBQUssUUFBTCxDQUFjLFVBQWQsQ0FBeUIsU0FBekI7QUFDSCxhQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDUixvQkFBSSxtQ0FBSixFQUE2QjtBQUN6QiwwQkFBTSxFQUFFLE9BQVI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsMEJBQU0sQ0FBTjtBQUNIO0FBQ0o7QUFDRCx1REFBeUIsQ0FBekI7QUFDSCxTQVpEO0FBYUg7O0FBRUQsU0FBSyxhQUFMLENBQW1CLFNBQW5CO0FBQ0gsQ0FwREQ7O0FBdURBOzs7O0FBSUEsS0FBSyxTQUFMLENBQWUsU0FBZixHQUEyQixVQUFVLFNBQVYsRUFBcUI7QUFDNUMsUUFBSSxLQUFLLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsU0FBakIsQ0FBVDtBQUNBLFNBQUssRUFBTCxDQUFRLFdBQVIsQ0FBb0IsRUFBcEI7QUFDQSxTQUFLLE9BQUwsQ0FBYSxNQUFiLENBQW9CLFNBQXBCOztBQUVBLFNBQUssYUFBTCxDQUFtQixTQUFuQjtBQUNILENBTkQ7O0FBUUEsS0FBSyxTQUFMLENBQWUsZUFBZixHQUFpQyxZQUFZO0FBQ3pDLFFBQUksT0FBTyxJQUFYO0FBQ0EsUUFBSSxLQUFLLFNBQVMsYUFBVCxDQUF1QixJQUF2QixDQUFUO0FBQ0EsUUFBSSxZQUFZLEtBQUssV0FBTCxHQUFtQixRQUFuQixHQUE4QixHQUE5Qzs7QUFFQSxPQUFHLFNBQUgscUNBQStDLFNBQS9DO0FBQ0EsT0FBRyxTQUFILENBQWEsR0FBYixDQUFpQixRQUFqQjtBQUNBLFFBQUksQ0FBQyxLQUFLLFdBQVYsRUFBdUI7QUFDbkIsV0FBRyxTQUFILENBQWEsR0FBYixDQUFpQixTQUFqQjtBQUNIO0FBQ0QsU0FBSyxFQUFMLENBQVEsV0FBUixDQUFvQixFQUFwQjs7QUFFQSxRQUFJLENBQUMsS0FBSyxXQUFWLEVBQXVCO0FBQ25CLFdBQUcsZ0JBQUgsQ0FBb0IsT0FBcEIsRUFBNkIsWUFBWTtBQUNyQyxnQkFBSTtBQUNBLG9CQUFJLFdBQVcsS0FBSyxRQUFMLENBQWMsV0FBZCxFQUFmO0FBQ0EseUJBQVMsTUFBVDtBQUNILGFBSEQsQ0FHRSxPQUFPLENBQVAsRUFBVTtBQUNSLG9CQUFJLG1DQUFKLEVBQTZCO0FBQ3pCLDBCQUFNLEVBQUUsT0FBUjtBQUNILGlCQUZELE1BRU87QUFDSCwwQkFBTSxDQUFOO0FBQ0g7QUFDSjtBQUNKLFNBWEQ7QUFZSDtBQUNKLENBMUJEOztBQTRCQTs7OztBQUlBLEtBQUssU0FBTCxDQUFlLGNBQWYsR0FBZ0MsVUFBVSxFQUFWLEVBQWM7QUFDMUMsUUFBSSxPQUFPLElBQVg7QUFDQSxRQUFJLFlBQVksR0FBRyxPQUFILENBQVcsS0FBM0I7QUFDQSxRQUFJLE9BQU8sR0FBRyxvQkFBSCxDQUF3QixNQUF4QixFQUFnQyxDQUFoQyxDQUFYO0FBQ0EsUUFBSSxRQUFRLFNBQVMsYUFBVCxDQUF1QixPQUF2QixDQUFaOztBQUVBLFVBQU0sWUFBTixDQUFtQixNQUFuQixFQUEyQixNQUEzQjtBQUNBLFVBQU0sS0FBTixHQUFjLFNBQWQ7QUFDQSxVQUFNLFNBQU4sQ0FBZ0IsR0FBaEIsQ0FBb0IsV0FBcEI7QUFDQSxVQUFNLEtBQU4sQ0FBWSxLQUFaLEdBQW9CLDJCQUFXLElBQVgsSUFBbUIsRUFBbkIsR0FBd0IsSUFBNUMsQ0FUMEMsQ0FTUTs7QUFFbEQsVUFBTSxnQkFBTixDQUF1QixNQUF2QixFQUErQixZQUFZO0FBQ3ZDLFlBQUksUUFBUSxLQUFLLGFBQUwsQ0FBbUIsU0FBbkIsRUFBOEIsS0FBSyxLQUFuQyxDQUFaO0FBQ0EsWUFBSSxVQUFVLElBQWQsRUFBb0I7QUFDaEIsaUJBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsU0FBMUIsRUFBcUMsS0FBSyxLQUExQztBQUNILFNBRkQsTUFFTztBQUNILGtCQUFNLEtBQU4sRUFERyxDQUNXO0FBQ2QsaUJBQUssZUFBTCxDQUFxQixTQUFyQixFQUFnQyxLQUFLLEtBQXJDO0FBQ0g7QUFDSixLQVJEO0FBU0EsVUFBTSxnQkFBTixDQUF1QixVQUF2QixFQUFtQyxVQUFVLEtBQVYsRUFBaUI7QUFDaEQsWUFBSSxNQUFNLE9BQU4sS0FBa0IsRUFBdEIsRUFBMEI7QUFDdEIsaUJBQUssSUFBTDtBQUNIO0FBQ0osS0FKRDs7QUFNQSwwQkFBTSxJQUFOO0FBQ0EsU0FBSyxXQUFMLENBQWlCLEtBQWpCO0FBQ0EsVUFBTSxNQUFOO0FBQ0gsQ0E3QkQ7O0FBK0JBLEtBQUssU0FBTCxDQUFlLGFBQWYsR0FBK0IsVUFBVSxLQUFWLEVBQWlCLEtBQWpCLEVBQXdCO0FBQ25ELFFBQUksMEJBQWEsS0FBYixDQUFKLEVBQXlCO0FBQ3JCLGVBQU8sWUFBTSxFQUFiO0FBQ0g7QUFDRCxRQUFJLE9BQU8sSUFBUCxDQUFZLEtBQVosQ0FBSixFQUF3QjtBQUNwQixlQUFPLFlBQU0sRUFBYjtBQUNIO0FBQ0Q7QUFDQSxRQUFJLHVCQUFVLEtBQVYsTUFBcUIsdUJBQVUsS0FBVixDQUFyQixJQUF5QyxLQUFLLFFBQUwsQ0FBYyxZQUFkLENBQTJCLEtBQTNCLENBQTdDLEVBQWdGO0FBQzVFLGVBQU8sWUFBTSxFQUFiO0FBQ0g7QUFDRCxXQUFPLElBQVA7QUFDSCxDQVpEOztBQWNBO0FBQ0EsS0FBSyxTQUFMLENBQWUsU0FBZixHQUEyQixVQUFVLEtBQVYsRUFBaUIsS0FBakIsRUFBd0I7QUFDL0MsUUFBSSxLQUFLLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsS0FBakIsQ0FBVDtBQUNBLFFBQUksT0FBTyxHQUFHLG9CQUFILENBQXdCLE1BQXhCLEVBQWdDLENBQWhDLENBQVg7QUFDQSw4QkFBVSxJQUFWLEVBQWdCLEtBQWhCO0FBQ0EsT0FBRyxPQUFILENBQVcsS0FBWCxHQUFtQixLQUFuQjtBQUNBLFNBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsS0FBakIsRUFBd0IsRUFBeEI7QUFDQSxRQUFJLFVBQVUsS0FBSyxZQUFMLENBQWtCLEdBQWxCLENBQXNCLEtBQXRCLENBQWQ7QUFDQSxZQUFRLE9BQVIsQ0FBZ0IsS0FBaEIsR0FBd0IsS0FBeEI7QUFDQSxTQUFLLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBeUIsS0FBekI7QUFDQSxTQUFLLFlBQUwsQ0FBa0IsR0FBbEIsQ0FBc0IsS0FBdEIsRUFBNkIsT0FBN0I7O0FBRUEsUUFBSSxXQUFXLEtBQUssUUFBTCxDQUFjLFFBQWQsQ0FBdUIsS0FBdkIsQ0FBZjtBQUNBLGFBQVMsSUFBVCxDQUFjLGFBQWQsRUFBNkIsUUFBN0IsRUFBdUMsS0FBdkMsRUFBOEMsS0FBOUM7QUFDSCxDQWJEOztBQWVBO0FBQ0EsS0FBSyxTQUFMLENBQWUsZUFBZixHQUFpQyxVQUFVLEtBQVYsRUFBaUIsS0FBakIsRUFBd0I7QUFDckQsUUFBSSxLQUFLLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsS0FBakIsQ0FBVDtBQUNBLFFBQUksT0FBTyxHQUFHLG9CQUFILENBQXdCLE1BQXhCLEVBQWdDLENBQWhDLENBQVg7QUFDQSw4QkFBVSxJQUFWLEVBQWdCLEtBQWhCOztBQUVBLFFBQUksV0FBVyxLQUFLLFFBQUwsQ0FBYyxRQUFkLENBQXVCLEtBQXZCLENBQWY7QUFDQSxhQUFTLElBQVQsQ0FBYyxtQkFBZCxFQUFtQyxRQUFuQyxFQUE2QyxLQUE3QyxFQUFvRCxLQUFwRDtBQUNILENBUEQ7O0FBVUE7Ozs7QUFJQSxLQUFLLFNBQUwsQ0FBZSxhQUFmLEdBQStCLFVBQVUsU0FBVixFQUFxQjtBQUNoRCxRQUFJLFVBQVUsU0FBUyxhQUFULENBQXVCLFNBQXZCLENBQWQ7QUFDQSxRQUFJLEtBQUssU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQVQ7QUFDQSxRQUFJLE1BQU0sU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQVY7O0FBRUEsWUFBUSxZQUFSLENBQXFCLFlBQXJCLEVBQW1DLFNBQW5DO0FBQ0EsWUFBUSxXQUFSLENBQW9CLEVBQXBCO0FBQ0EsWUFBUSxXQUFSLENBQW9CLEdBQXBCO0FBQ0EsWUFBUSxTQUFSLENBQWtCLEdBQWxCLENBQXNCLGFBQXRCO0FBQ0EsZ0JBQVksUUFBUSxTQUFSLENBQWtCLEdBQWxCLENBQXNCLG1CQUF0QixDQUFaOztBQUVBLFNBQUssT0FBTCxDQUFhLFdBQWIsQ0FBeUIsT0FBekI7QUFDQSxTQUFLLFlBQUwsQ0FBa0IsR0FBbEIsQ0FBc0IsU0FBdEIsRUFBaUMsT0FBakM7O0FBRUEsU0FBSyxRQUFMLENBQWMsRUFBZCxFQUFrQixTQUFsQjtBQUNBLFNBQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixTQUF0QjtBQUNILENBaEJEOztBQW1CQSxLQUFLLFNBQUwsQ0FBZSxhQUFmLEdBQStCLFVBQVUsU0FBVixFQUFxQjtBQUNoRCxRQUFJLFVBQVUsS0FBSyxZQUFMLENBQWtCLEdBQWxCLENBQXNCLFNBQXRCLENBQWQ7QUFDQSxTQUFLLE9BQUwsQ0FBYSxXQUFiLENBQXlCLE9BQXpCO0FBQ0EsU0FBSyxZQUFMLENBQWtCLE1BQWxCLENBQXlCLFNBQXpCO0FBQ0gsQ0FKRDs7QUFNQTs7OztBQUlBLEtBQUssU0FBTCxDQUFlLFdBQWYsR0FBNkIsVUFBVSxTQUFWLEVBQXFCO0FBQzlDLFFBQUksVUFBVSxLQUFLLFlBQUwsQ0FBa0IsR0FBbEIsQ0FBc0IsU0FBdEIsQ0FBZDtBQUNBLFlBQVEsS0FBUixDQUFjLE9BQWQsR0FBd0IsTUFBeEI7QUFDSCxDQUhEOztBQU1BOzs7Ozs7QUFNQSxLQUFLLFNBQUwsQ0FBZSxRQUFmLEdBQTBCLFVBQVUsRUFBVixFQUFjLFNBQWQsRUFBeUI7QUFDL0MsT0FBRyxTQUFILENBQWEsR0FBYixDQUFpQixRQUFqQjtBQUNBLE9BQUcsU0FBSCxDQUFhLEdBQWIsQ0FBb0IsUUFBcEIsU0FBZ0MsU0FBaEM7QUFDSCxDQUhEOztBQUtBOzs7Ozs7Ozs7QUFTQSxLQUFLLFNBQUwsQ0FBZSxXQUFmLEdBQTZCLFVBQVUsR0FBVixFQUFlLFNBQWYsRUFBMEI7QUFBQTs7QUFDbkQsU0FBSyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLFNBQXBCLEVBQStCO0FBQzNCLG1CQUFXLEdBRGdCO0FBRTNCLGVBQU8sS0FBSyxLQUZlO0FBRzNCLGdCQUFRO0FBQUEsbUJBQU0sTUFBSyxNQUFMLEdBQWMsNEJBQVksTUFBSyxHQUFqQixDQUFwQjtBQUFBO0FBSG1CLEtBQS9CO0FBS0gsQ0FORDs7QUFRQTs7OztBQUlBLEtBQUssU0FBTCxDQUFlLFNBQWYsR0FBMkIsVUFBVSxTQUFWLEVBQXFCO0FBQzVDLFFBQUksU0FBUyxLQUFLLElBQUwsQ0FBVSxhQUFWLE9BQTRCLGFBQTVCLFNBQTZDLFFBQTdDLENBQWI7QUFDQSxjQUFVLE9BQU8sU0FBUCxDQUFpQixNQUFqQixDQUF3QixhQUF4QixDQUFWO0FBQ0EsUUFBSSxLQUFLLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsU0FBakIsQ0FBVDtBQUNBLE9BQUcsU0FBSCxDQUFhLEdBQWIsQ0FBaUIsYUFBakI7QUFDQSxTQUFLLGFBQUwsQ0FBbUIsU0FBbkI7QUFDSCxDQU5EOztBQVNBOzs7O0FBSUEsS0FBSyxTQUFMLENBQWUsYUFBZixHQUErQixVQUFVLFNBQVYsRUFBcUI7QUFDaEQsUUFBSSxVQUFVLEtBQUssWUFBTCxDQUFrQixHQUFsQixDQUFzQixTQUF0QixDQUFkO0FBQ0EsUUFBSSxTQUFTLEtBQUssb0JBQWxCO0FBQ0EsUUFBSSxNQUFKLEVBQVk7QUFDUixvQkFBWSxPQUFPLFNBQVAsQ0FBaUIsTUFBakIsQ0FBd0IsUUFBeEIsQ0FBWjtBQUNBLGVBQU8sS0FBUCxDQUFhLE9BQWIsR0FBdUIsTUFBdkI7QUFDSDtBQUNELFlBQVEsS0FBUixDQUFjLE9BQWQsR0FBd0IsT0FBeEI7QUFDQSxnQkFBWSxRQUFRLFNBQVIsQ0FBa0IsR0FBbEIsQ0FBc0IsUUFBdEIsQ0FBWjs7QUFFQSxTQUFLLG9CQUFMLEdBQTRCLE9BQTVCO0FBQ0gsQ0FYRDs7a0JBY2UsSTs7Ozs7Ozs7QUN2V1IsSUFBTSx3QkFBUTtBQUNqQixRQUFJLFlBRGE7QUFFakIsZ0dBRmlCO0FBR2pCLFFBQUk7QUFIYSxDQUFkOztBQU9BLElBQU0sc0JBQU87QUFDaEIsUUFBSSxPQURZO0FBRWhCLFFBQUksT0FGWTtBQUdoQixRQUFJLE9BSFk7QUFJaEIsUUFBSSxTQUpZO0FBS2hCLFFBQUksSUFMWTtBQU1oQixRQUFJLEtBTlk7QUFPaEIsUUFBSSxNQVBZO0FBUWhCLFFBQUksS0FSWTtBQVNoQixRQUFJLE1BVFk7QUFVaEIsU0FBSyxNQVZXO0FBV2hCLFNBQUssTUFYVztBQVloQixTQUFLLE1BWlc7QUFhaEIsU0FBSyxPQWJXO0FBY2hCLFNBQUs7QUFkVyxDQUFiOzs7Ozs7Ozs7Ozs7UUNvQ1MsYyxHQUFBLGM7UUFTQSxjLEdBQUEsYztRQUtBLFMsR0FBQSxTO1FBWUEsYSxHQUFBLGE7O0FBckVoQjs7OztBQUVBLElBQUksV0FBVyxJQUFJLEdBQUosRUFBZjs7QUFFQTs7OztJQUdNLE07O0FBRUY7Ozs7QUFJQSxvQkFBWSxXQUFaLEVBQXlCO0FBQUE7O0FBQ3JCOzs7QUFHQSxhQUFLLFdBQUwsR0FBbUIsV0FBbkI7QUFDQSxhQUFLLE9BQUwsR0FBZSxLQUFmO0FBQ0g7O0FBRUQ7Ozs7O3dDQUNnQixJLEVBQU07QUFBQTs7QUFDbEIsZ0JBQUksUUFBUSxLQUFLLFdBQUwsQ0FBaUIsV0FBakIsQ0FBNkIsU0FBekM7QUFDQSxrQkFBTSxJQUFOLElBQWM7QUFBQSx1QkFBTSxNQUFLLElBQUwsR0FBTjtBQUFBLGFBQWQ7QUFDSDs7O21DQUVVO0FBQ1AsbUJBQU8sS0FBUDtBQUNIOzs7aUNBRVEsQ0FFUjs7O2tDQUVTLENBRVQ7Ozs7OztRQUlHLE0sR0FBQSxNO0FBRUQsU0FBUyxjQUFULENBQXdCLENBQXhCLEVBQTJCO0FBQzlCLFFBQUksQ0FBQyxFQUFFLE1BQVAsRUFBZTtBQUNYLGNBQU0sNkJBQWdCLG1CQUFoQixDQUFOO0FBQ0g7QUFDRCxRQUFJLENBQUMsRUFBRSxPQUFQLEVBQWdCO0FBQ1osY0FBTSw2QkFBZ0Isb0JBQWhCLENBQU47QUFDSDtBQUNKOztBQUVNLFNBQVMsY0FBVCxDQUF3QixJQUF4QixFQUE4QixNQUE5QixFQUFzQztBQUN6QyxhQUFTLEdBQVQsQ0FBYSxJQUFiLEVBQW1CLE1BQW5CO0FBQ0EsV0FBTyxTQUFQLENBQWlCLFFBQWpCLEdBQTRCLElBQTVCO0FBQ0g7O0FBRU0sU0FBUyxTQUFULENBQW1CLElBQW5CLEVBQXlCO0FBQzVCLFFBQUksSUFBSSxTQUFTLEdBQVQsQ0FBYSxJQUFiLENBQVI7QUFDQSxRQUFJLENBQUMsQ0FBTCxFQUFRO0FBQ0osY0FBTSw2QkFBZ0IsV0FBVyxJQUEzQixDQUFOO0FBQ0g7QUFDRCxXQUFPLENBQVA7QUFDSDs7QUFFRDs7OztBQUlPLFNBQVMsYUFBVCxHQUF5QjtBQUM1QixXQUFPLFFBQVA7QUFDSDs7Ozs7Ozs7UUNyRWUsVyxHQUFBLFc7O0FBRmhCOztBQUVPLFNBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0QjtBQUMvQixTQUFLLElBQUwsR0FBWSxhQUFaO0FBQ0EsU0FBSyxPQUFMLEdBQWUsS0FBZjtBQUNIO0FBQ0QsWUFBWSxTQUFaLEdBQXdCLHdDQUF4QjtBQUNBLFlBQVksU0FBWixDQUFzQixXQUF0QixHQUFvQyxXQUFwQzs7Ozs7Ozs7Ozs7OztBQ1BBOztBQUNBOzs7Ozs7OztJQUVNLFU7OztBQUVGLHdCQUFZLEdBQVosRUFBaUI7QUFBQTs7QUFBQSw0SEFDUCxHQURPOztBQUdiLFlBQUksV0FBVyxNQUFLLFdBQUwsQ0FBaUIsUUFBaEM7O0FBRUEsWUFBSSxTQUFTLFVBQVQsS0FBd0IsSUFBNUIsRUFBa0M7QUFDOUI7QUFDQTs7O0FBR0Esa0JBQUssYUFBTCxHQUFxQixJQUFJLEtBQUosRUFBckI7QUFDSCxTQU5ELE1BTU87QUFDSDtBQUNBLGtCQUFLLGFBQUwsR0FBcUIsU0FBUyxVQUFULENBQW9CLEdBQXpDO0FBQ0g7O0FBRUQsY0FBSyxXQUFMLENBQWlCLFFBQWpCLEdBQTRCLGlCQUFRLElBQVIsQ0FBYSxNQUFLLGFBQWxCLEtBQW9DLFFBQWhFOztBQUVBLGNBQUssZUFBTCxDQUFxQixXQUFyQjtBQWxCYTtBQW1CaEI7Ozs7bUNBRVU7QUFDUCxtQkFBTyxDQUFDLENBQUMsS0FBSyxXQUFMLENBQWlCLFdBQWpCLEdBQStCLFVBQXhDO0FBQ0g7OztpQ0FFUTtBQUNMO0FBQ0g7OztrQ0FFUztBQUNOO0FBQ0g7OztvQ0FFVztBQUNSLGdCQUFJLE9BQU8sS0FBSyxXQUFMLENBQWlCLGVBQWpCLEVBQVg7QUFDQSw2QkFBUSxJQUFSLENBQWEsS0FBSyxhQUFsQixFQUFpQyxJQUFqQztBQUNIOzs7Ozs7a0JBSVUsVTs7Ozs7Ozs7Ozs7OztBQzdDZjs7O0lBR00sTzs7Ozs7Ozs2QkFFVSxHLEVBQUssSyxFQUFPO0FBQ3BCLGdCQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUMzQix3QkFBUSxLQUFLLFNBQUwsQ0FBZSxLQUFmLENBQVI7QUFDSDtBQUNELG1CQUFPLFlBQVAsQ0FBb0IsT0FBcEIsQ0FBNEIsUUFBUSxNQUFSLEdBQWlCLEdBQTdDLEVBQWtELEtBQWxEO0FBQ0g7Ozs2QkFFVyxHLEVBQUs7QUFDYixnQkFBSSxNQUFNLE9BQU8sWUFBUCxDQUFvQixPQUFwQixDQUE0QixRQUFRLE1BQVIsR0FBaUIsR0FBN0MsQ0FBVjtBQUNBLGdCQUFJO0FBQ0EsdUJBQU8sS0FBSyxLQUFMLENBQVcsR0FBWCxDQUFQO0FBQ0gsYUFGRCxDQUVFLE9BQU0sQ0FBTixFQUFTO0FBQ1AsdUJBQU8sR0FBUDtBQUNIO0FBQ0o7OzsrQkFFYSxHLEVBQUs7QUFDZixnQkFBSSxPQUFPLFlBQVAsQ0FBb0IsUUFBUSxNQUFSLEdBQWlCLEdBQXJDLENBQUosRUFBK0M7QUFDM0MsdUJBQU8sWUFBUCxDQUFvQixVQUFwQixDQUErQixRQUFRLE1BQVIsR0FBaUIsR0FBaEQ7QUFDSDtBQUNKOzs7Z0NBRWM7QUFDWCxtQkFBTyxZQUFQLENBQW9CLEtBQXBCO0FBQ0g7Ozs7OztBQUlMLFFBQVEsTUFBUixHQUFpQixrQkFBakI7O1FBRVEsTyxHQUFBLE87Ozs7Ozs7Ozs7OztBQ25DUjs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztBQUVBLElBQUksWUFBWSxhQUFhLE1BQWIsQ0FBb0IsU0FBcEM7QUFDQSxJQUFJLFFBQVEsYUFBYSxNQUFiLENBQW9CLEtBQWhDOztJQUVNLFk7QUFDRiwwQkFBWSxLQUFaLEVBQW1CO0FBQUE7O0FBRWYsYUFBSyxLQUFMLEdBQWEsS0FBYjs7QUFFQSxhQUFLLFlBQUwsR0FBb0IsTUFBTSxZQUExQjs7QUFFQSxhQUFLLE1BQUwsR0FBYyxNQUFNLE1BQXBCO0FBQ0g7Ozs7a0NBRVMsRyxFQUFLLE0sRUFBUSxhLEVBQWU7QUFDbEMsaUJBQUssTUFBTCxDQUFZLFFBQVosRUFBc0IsS0FBdEIsRUFBNkIsR0FBN0IsRUFBa0MsTUFBbEMsRUFBMEMsYUFBMUM7QUFDSDs7O2tDQUVTLEcsRUFBSyxNLEVBQVEsYSxFQUFlO0FBQ2xDLGlCQUFLLE1BQUwsQ0FBWSxRQUFaLEVBQXNCLEtBQXRCLEVBQTZCLEdBQTdCLEVBQWtDLENBQUMsTUFBbkMsRUFBMkMsYUFBM0M7QUFDSDs7O3FDQUVZLE0sRUFBUSxNLEVBQVEsYSxFQUFlO0FBQ3hDLGlCQUFLLE1BQUwsQ0FBWSxRQUFaLEVBQXNCLFFBQXRCLEVBQWdDLE1BQWhDLEVBQXdDLE1BQXhDLEVBQWdELGFBQWhEO0FBQ0g7OztxQ0FFWSxNLEVBQVEsTSxFQUFRLGEsRUFBZTtBQUN4QyxpQkFBSyxNQUFMLENBQVksUUFBWixFQUFzQixRQUF0QixFQUFnQyxNQUFoQyxFQUF3QyxDQUFDLE1BQXpDLEVBQWlELGFBQWpEO0FBQ0g7OzsrQkFFTSxNLEVBQVEsSSxFQUFNLEssRUFBTyxNLEVBQThCO0FBQUE7O0FBQUEsZ0JBQXRCLGFBQXNCLHVFQUFOLElBQU07O0FBQ3RELGdCQUFNLGFBQWEsU0FBYixVQUFhLENBQUMsSUFBRCxFQUFVO0FBQ3pCLHVCQUFPO0FBQ0gseUJBQUssU0FBUyxLQUFULEdBQWlCLEtBQWpCLEdBQXlCLEtBQUssR0FEaEM7QUFFSCw0QkFBUSxTQUFTLFFBQVQsR0FBb0IsS0FBcEIsR0FBNEIsS0FBSztBQUZ0QyxpQkFBUDtBQUlILGFBTEQ7QUFNQSxnQkFBTSxvQkFBb0IsU0FBcEIsaUJBQW9CLENBQUMsR0FBRCxFQUFNLE1BQU4sRUFBaUI7QUFDdkMsMEJBQVUsTUFBSyxNQUFMLENBQVksY0FBdEIsRUFBc0MsVUFBQyxJQUFELEVBQVU7QUFDNUMsd0JBQUksS0FBSyxJQUFMLEtBQWMsS0FBbEIsRUFBeUI7QUFDckIsNkJBQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixNQUF0QjtBQUNIO0FBQ0osaUJBSkQ7QUFLSCxhQU5EOztBQVFBLGdCQUFNLFlBQVksRUFBbEI7QUFDQSxnQkFBTSxjQUFjLEtBQUssR0FBTCxDQUFTLE1BQVQsSUFBbUIsQ0FBdkM7O0FBRUEsZ0JBQUksU0FBUyxLQUFiLEVBQW9CO0FBQ2hCLDBCQUFVLElBQVYsQ0FBZSxNQUFmLEVBQXVCLENBQXZCO0FBRUgsYUFIRCxNQUdPLElBQUksU0FBUyxRQUFiLEVBQXVCO0FBQzFCLDBCQUFVLElBQVYsQ0FBZSxDQUFmLEVBQWtCLE1BQWxCO0FBQ0g7O0FBRUQsZ0JBQUksV0FBVyxRQUFmLEVBQXlCO0FBQUE7QUFDckIsd0JBQUksaUJBQWlCLE1BQUssTUFBTCxDQUFZLHFCQUFaLHFCQUFvQyxJQUFwQyxFQUEyQyxLQUEzQyx1QkFBcUQsSUFBckQsRUFBNEQsUUFBUSxXQUFwRSxFQUFyQjtBQUNBLHdCQUFJLFdBQVcsRUFBZjs7QUFFQSw4QkFBVSxNQUFLLE1BQUwsQ0FBWSxJQUF0QixFQUE0QixVQUFDLElBQUQsRUFBVTtBQUNsQyxrQ0FBVSxjQUFWLEVBQTBCLFVBQUMsT0FBRCxFQUFhO0FBQ25DLGdDQUFJLENBQUMsS0FBSyxZQUFMLENBQWtCLE9BQWxCLENBQUwsRUFBaUM7QUFDN0I7QUFDSDs7QUFFRCxpQ0FBSyxlQUFMLENBQXFCLE9BQXJCO0FBQ0EsaUNBQUssUUFBTCxDQUFjLHFCQUFVLGtCQUF4Qjs7QUFFQSxzQ0FBVSxNQUFLLEtBQUwsQ0FBVyxtQkFBWCxDQUErQixLQUFLLEdBQXBDLEVBQXlDLEtBQUssTUFBOUMsQ0FBVixFQUFpRSxVQUFDLFNBQUQsRUFBZTtBQUM1RSwwQ0FBVSxRQUFWLENBQW1CLHFCQUFVLGtCQUE3QjtBQUNILDZCQUZEO0FBR0gseUJBWEQ7O0FBYUEsNEJBQUksS0FBSyxJQUFMLEtBQWMsS0FBZCxJQUF1QixLQUFLLElBQUwsS0FBZSxRQUFRLFdBQWxELEVBQWdFO0FBQzVELHFDQUFTLElBQVQsQ0FBYyxJQUFkO0FBQ0g7QUFDSixxQkFqQkQ7O0FBbUJBLDBCQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLFFBQW5CO0FBdkJxQjtBQXdCeEI7O0FBRUQsK0NBQXFCLFNBQXJCOztBQUVBLHNCQUFVLEtBQUssTUFBTCxDQUFZLElBQXRCLEVBQTRCLFVBQUMsSUFBRCxFQUFVO0FBQ2xDLG9CQUFNLFVBQVUsS0FBSyxHQUFyQjtBQUNBLG9CQUFNLGFBQWEsS0FBSyxNQUF4Qjs7QUFFQSxvQkFBSSxLQUFLLElBQUwsS0FBYyxLQUFsQixFQUF5QjtBQUNyQix5QkFBSyxXQUFMLGFBQW9CLFNBQXBCO0FBQ0EseUJBQUssUUFBTCxDQUFjLHFCQUFVLGtCQUF4QjtBQUNIOztBQUVELG9CQUFJLGFBQUosRUFBbUI7QUFDZix3QkFBTSxNQUFNLEtBQUssR0FBakI7QUFDQSx3QkFBTSxTQUFTLEtBQUssTUFBcEI7QUFDQSx3QkFBTSxRQUFRLE1BQUssWUFBTCxDQUFrQixtQkFBbEIsQ0FBc0MsR0FBdEMsRUFBMkMsTUFBM0MsQ0FBZDs7QUFFQSx3QkFBSSxnQ0FBb0IsS0FBcEIsQ0FBSixFQUFnQztBQUM1Qiw0QkFBTSxjQUFjLDJDQUF1QixLQUF2QixDQUFwQjs7QUFFQSxvQ0FBWSxTQUFaLENBQXNCLFdBQVcsRUFBQyxLQUFLLE9BQU4sRUFBZSxRQUFRLFVBQXZCLEVBQVgsQ0FBdEIsc0JBQXdFLElBQXhFLEVBQStFLE1BQS9FOztBQUVBLDhCQUFLLFlBQUwsQ0FBa0IsZ0JBQWxCLENBQW1DLEdBQW5DLEVBQXdDLE1BQXhDLEVBQWdELFlBQVksUUFBWixFQUFoRDtBQUNIO0FBQ0o7QUFDSixhQXRCRDtBQXVCQSxpQkFBSyxhQUFMLENBQW1CLFlBQW5CLEVBQWlDLE1BQWpDLEVBQXlDLElBQXpDLEVBQStDLEtBQS9DLEVBQXNELE1BQXREO0FBQ0g7OztrQ0FFUztBQUNOLGlCQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsaUJBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLGlCQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0g7Ozs7OztBQUdMLE1BQU0sWUFBTjs7UUFFUSxZLEdBQUEsWTs7Ozs7Ozs7Ozs7QUMxSFI7Ozs7QUFFQSxJQUFJLFdBQVcsYUFBYSxNQUFiLENBQW9CLFFBQW5DOztJQUVNLFE7QUFDRixzQkFBWSxHQUFaLEVBQWlCLE1BQWpCLEVBQXlCO0FBQUE7O0FBQ3JCLFlBQU0sWUFBWSxTQUFTLEdBQVQsQ0FBbEI7QUFDQSxZQUFNLGVBQWUsU0FBUyxNQUFULENBQXJCOztBQUVBLGFBQUssSUFBTCxHQUFZLFlBQVksSUFBSSxLQUFoQixHQUF3QixHQUFwQztBQUNBLGFBQUssV0FBTCxHQUFtQixZQUFZLElBQUksVUFBaEIsR0FBNkIsS0FBaEQ7QUFDQSxhQUFLLE9BQUwsR0FBZSxlQUFlLE9BQU8sS0FBdEIsR0FBOEIsTUFBN0M7QUFDQSxhQUFLLGNBQUwsR0FBc0IsZUFBZSxPQUFPLFVBQXRCLEdBQW1DLEtBQXpEO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLENBQWpCO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLENBQXBCOztBQUVBLGVBQU8sY0FBUCxDQUFzQixJQUF0QixFQUE0QixLQUE1QixFQUFtQztBQUMvQixpQkFBSyxlQUFZO0FBQ2IsdUJBQU8sS0FBSyxTQUFMLEdBQWlCLEtBQUssSUFBN0I7QUFDSCxhQUg4QjtBQUkvQixpQkFBSyxhQUFVLEdBQVYsRUFBZTtBQUNoQixxQkFBSyxJQUFMLEdBQVksR0FBWjtBQUNILGFBTjhCO0FBTy9CLHdCQUFZLElBUG1CO0FBUS9CLDBCQUFjO0FBUmlCLFNBQW5DO0FBVUEsZUFBTyxjQUFQLENBQXNCLElBQXRCLEVBQTRCLFFBQTVCLEVBQXNDO0FBQ2xDLGlCQUFLLGVBQVk7QUFDYix1QkFBTyxLQUFLLFlBQUwsR0FBb0IsS0FBSyxPQUFoQztBQUNILGFBSGlDO0FBSWxDLGlCQUFLLGFBQVUsTUFBVixFQUFrQjtBQUNuQixxQkFBSyxPQUFMLEdBQWUsTUFBZjtBQUNILGFBTmlDO0FBT2xDLHdCQUFZLElBUHNCO0FBUWxDLDBCQUFjO0FBUm9CLFNBQXRDO0FBVUg7Ozs7b0NBRVcsUyxFQUFXLFksRUFBYztBQUNqQyxpQkFBSyxHQUFMLEdBQVcsS0FBSyxHQUFMLEdBQVcsU0FBdEI7QUFDQSxpQkFBSyxNQUFMLEdBQWMsS0FBSyxNQUFMLEdBQWMsWUFBNUI7QUFDSDs7O2dDQUVPLEksRUFBTTtBQUNWLG1CQUFPLEtBQUssR0FBTCxLQUFhLEtBQUssR0FBbEIsSUFBeUIsS0FBSyxNQUFMLEtBQWdCLEtBQUssTUFBckQ7QUFDSDs7O21DQUVVO0FBQ1AsbUJBQU8sb0JBQ0gsRUFBQyxPQUFPLEtBQUssR0FBYixFQUFrQixZQUFZLEtBQUssV0FBbkMsRUFERyxFQUVILEVBQUMsT0FBTyxLQUFLLE1BQWIsRUFBcUIsWUFBWSxLQUFLLGNBQXRDLEVBRkcsQ0FBUDtBQUlIOzs7Ozs7a0JBR1UsUTs7Ozs7Ozs7Ozs7O0FDdkRmOzs7O0FBQ0E7Ozs7Ozs7Ozs7SUFFTSxhOzs7QUFDRiwyQkFBWSxHQUFaLEVBQWlCLE1BQWpCLEVBQXlCO0FBQUE7O0FBQUEsNkhBQ2YsR0FEZSxFQUNWLE1BRFU7QUFFeEI7Ozs7bUNBRVU7QUFDUCxtQkFBTyxvQkFDSCxFQUFDLE9BQU8sS0FBSyxHQUFiLEVBQWtCLFlBQVksS0FBOUIsRUFERyxFQUVILEVBQUMsT0FBTyxLQUFLLE1BQWIsRUFBcUIsWUFBWSxLQUFqQyxFQUZHLENBQVA7QUFJSDs7Ozs7O1FBR0csYSxHQUFBLGE7Ozs7Ozs7Ozs7OztBQ2hCUjs7OztBQUNBOzs7Ozs7Ozs7O0FBRUEsSUFBTSxxQkFBcUIsQ0FBM0I7QUFDQSxJQUFNLGtCQUFrQixDQUF4QjtBQUNBLElBQU0sbUJBQW1CLENBQXpCO0FBQ0EsSUFBTSxTQUFTLENBQUMsa0JBQUQsRUFBcUIsZUFBckIsRUFBc0MsZ0JBQXRDLENBQWY7O0FBRUEsSUFBSSxjQUFjLGFBQWEsTUFBYixDQUFvQixXQUF0Qzs7SUFHTSxTOzs7Ozs0QkFFOEI7QUFDNUIsbUJBQU8sQ0FBUDtBQUNIOzs7NEJBRTRCO0FBQ3pCLG1CQUFPLENBQVA7QUFDSDs7OzRCQUU2QjtBQUMxQixtQkFBTyxDQUFQO0FBQ0g7OztBQUVELHVCQUFZLEdBQVosRUFBaUIsTUFBakIsRUFBeUI7QUFBQTs7QUFBQSwwSEFDZixHQURlLEVBQ1YsTUFEVTs7QUFFckIsY0FBSyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsY0FBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLGNBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxjQUFLLEtBQUwsR0FBYSxVQUFVLGdCQUF2QjtBQUxxQjtBQU14Qjs7OztpQ0FFUSxLLEVBQU87QUFDWixpQkFBSyxLQUFMLEdBQWEsS0FBYjtBQUNIOzs7bUNBRVU7QUFDUCxtQkFBTyxLQUFLLEtBQVo7QUFDSDs7O2lDQUVRLEssRUFBTztBQUNaLGlCQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0g7OzttQ0FFVTtBQUNQLG1CQUFPLEtBQUssS0FBWjtBQUNIOzs7bUNBRVU7QUFDUCxtQkFBTyxLQUFLLEtBQUwsS0FBZSxJQUF0QjtBQUNIOzs7aUNBRVEsSyxFQUFPO0FBQ1osZ0JBQUksT0FBTyxPQUFQLENBQWUsS0FBZixNQUEwQixDQUFDLENBQS9CLEVBQWtDO0FBQzlCLHFEQUFlLEtBQWY7QUFDSDtBQUNELGlCQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0g7OztnQ0FFTyxLLEVBQU87QUFDWCxtQkFBTyxLQUFLLEtBQUwsS0FBZSxLQUF0QjtBQUNIOzs7cUNBRVksYSxFQUFlO0FBQ3hCLGdCQUFJLEtBQUssT0FBTCxDQUFhLGFBQWIsQ0FBSixFQUFpQztBQUM3QixzQkFBTSx1QkFBTjtBQUNIO0FBQ0QsZ0JBQUksQ0FBQyxLQUFLLFlBQUwsQ0FBa0IsYUFBbEIsQ0FBTCxFQUF1QztBQUNuQyxxQkFBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLGFBQXJCO0FBQ0g7QUFDSjs7O3dDQUVlLGEsRUFBZTtBQUMzQixnQkFBSSxLQUFLLE9BQUwsQ0FBYSxhQUFiLENBQUosRUFBaUM7QUFDN0Isc0JBQU0sdUJBQU47QUFDSDtBQUNELGlCQUFLLFVBQUwsR0FBa0IsWUFBWSxLQUFLLFVBQWpCLEVBQTZCLFVBQUMsSUFBRDtBQUFBLHVCQUFVLENBQUMsS0FBSyxPQUFMLENBQWEsYUFBYixDQUFYO0FBQUEsYUFBN0IsQ0FBbEI7QUFDSDs7O3dDQUVlO0FBQ1osbUJBQU8sS0FBSyxVQUFaO0FBQ0g7Ozt3Q0FFZTtBQUNaLG1CQUFPLEtBQUssVUFBTCxDQUFnQixNQUFoQixHQUF5QixDQUFoQztBQUNIOzs7cUNBRVksYSxFQUFlO0FBQ3hCLG1CQUFPLFlBQVksS0FBSyxVQUFqQixFQUE2QixVQUFDLElBQUQ7QUFBQSx1QkFBVSxLQUFLLE9BQUwsQ0FBYSxhQUFiLENBQVY7QUFBQSxhQUE3QixFQUFvRSxNQUFwRSxHQUE2RSxJQUE3RSxHQUFvRixLQUEzRjtBQUNIOzs7Ozs7UUFHRyxTLEdBQUEsUzs7Ozs7Ozs7Ozs7O0FDN0ZSOzs7O0FBRUEsSUFBSSxZQUFZLGFBQWEsTUFBYixDQUFvQixTQUFwQztBQUNBLElBQUksWUFBWSxhQUFhLE1BQWIsQ0FBb0IsU0FBcEM7O0lBR00sWTtBQUVGLDBCQUFZLEdBQVosRUFBaUI7QUFBQTs7QUFDYixhQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0EsYUFBSyxPQUFMLEdBQWUsRUFBZjtBQUNIOzs7O3VDQUVjLEcsRUFBSyxNLEVBQVEsSyxFQUFPO0FBQy9CLGdCQUFJLENBQUMsZ0NBQW9CLEtBQXBCLENBQUwsRUFBaUM7QUFDN0IscUJBQUssT0FBTCxDQUFhLGFBQWEsUUFBYixDQUFzQixHQUF0QixFQUEyQixNQUEzQixDQUFiLElBQW1ELEtBQW5EO0FBQ0g7QUFDSjs7O3VDQUVjO0FBQ1gsaUJBQUssT0FBTCxHQUFlLEVBQWY7QUFDSDs7O3NDQUVhLEcsRUFBSyxNLEVBQVE7QUFDdkIsbUJBQU8sT0FBTyxDQUFQLElBQVksTUFBTSxLQUFLLEdBQUwsQ0FBUyxTQUFULEVBQWxCLElBQTBDLFVBQVUsQ0FBcEQsSUFBeUQsU0FBUyxLQUFLLEdBQUwsQ0FBUyxTQUFULEVBQXpFO0FBQ0g7OztzQ0FFYSxHLEVBQUssTSxFQUFRO0FBQ3ZCLGdCQUFNLEtBQUssYUFBYSxRQUFiLENBQXNCLEdBQXRCLEVBQTJCLE1BQTNCLENBQVg7QUFDQSxnQkFBSSxlQUFKOztBQUVBLGdCQUFJLEtBQUssT0FBTCxDQUFhLGNBQWIsQ0FBNEIsRUFBNUIsQ0FBSixFQUFxQztBQUNqQyx5QkFBUyxLQUFLLE9BQUwsQ0FBYSxFQUFiLENBQVQ7QUFDSCxhQUZELE1BRU87QUFDSCx5QkFBUyxLQUFLLEdBQUwsQ0FBUyxhQUFULENBQXVCLEdBQXZCLEVBQTRCLE1BQTVCLENBQVQ7QUFDSDtBQUNELG1CQUFPLE1BQVA7QUFDSDs7OzZDQUVvQixTLEVBQVcsRyxFQUFLLE0sRUFBUTtBQUN6QyxnQkFBSSxRQUFRLEtBQUssUUFBTCxDQUFjLFFBQWQsQ0FBdUIsU0FBdkIsQ0FBWjtBQUNBLGdCQUFJLFdBQVcsTUFBTSxZQUFOLENBQW1CLFNBQW5CLENBQTZCLFdBQTdCLENBQWY7QUFDQSxtQkFBTyxTQUFTLEtBQVQsQ0FBZSxZQUFmLENBQTRCLGFBQTVCLENBQTBDLEdBQTFDLEVBQStDLE1BQS9DLENBQVA7QUFDSDs7O3VDQUVjLEksRUFBTSxPLEVBQVMsSSxFQUFNLE8sRUFBUztBQUFBOztBQUN6QyxnQkFBTSxTQUFTLEtBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsSUFBakIsRUFBdUIsT0FBdkIsRUFBZ0MsSUFBaEMsRUFBc0MsT0FBdEMsQ0FBZjs7QUFFQSxzQkFBVSxNQUFWLEVBQWtCLFVBQUMsT0FBRCxFQUFVLFFBQVYsRUFBdUI7QUFDckMsMEJBQVUsT0FBVixFQUFtQixVQUFDLEtBQUQsRUFBUSxXQUFSLEVBQXdCO0FBQ3ZDLHdCQUFNLEtBQUssYUFBYSxRQUFiLENBQXNCLFdBQVcsSUFBakMsRUFBdUMsY0FBYyxPQUFyRCxDQUFYOztBQUVBLHdCQUFJLE1BQUssT0FBTCxDQUFhLGNBQWIsQ0FBNEIsRUFBNUIsQ0FBSixFQUFxQztBQUNqQywrQkFBTyxRQUFQLEVBQWlCLFdBQWpCLElBQWdDLE1BQUssT0FBTCxDQUFhLEVBQWIsQ0FBaEM7QUFDSDtBQUNKLGlCQU5EO0FBT0gsYUFSRDs7QUFVQSxtQkFBTyxNQUFQO0FBQ0g7Ozs0Q0FFbUIsRyxFQUFLLE0sRUFBUTtBQUM3QixtQkFBTyxLQUFLLEdBQUwsQ0FBUyxtQkFBVCxDQUE2QixHQUE3QixFQUFrQyxNQUFsQyxDQUFQO0FBQ0g7Ozs2Q0FFb0IsSSxFQUFNLE8sRUFBUyxJLEVBQU0sTyxFQUFTO0FBQy9DLG1CQUFPLEtBQUssR0FBTCxDQUFTLGtCQUFULENBQTRCLElBQTVCLEVBQWtDLE9BQWxDLEVBQTJDLElBQTNDLEVBQWlELE9BQWpELENBQVA7QUFDSDs7O3lDQUVnQixHLEVBQUssTSxFQUFRLEssRUFBTztBQUNqQyxpQkFBSyxHQUFMLENBQVMsYUFBVCxHQUF5QixHQUF6QixFQUE4QixLQUFLLEdBQUwsQ0FBUyxTQUFULENBQW1CLE1BQW5CLENBQTlCLElBQTRELEtBQTVEO0FBQ0g7OztrQ0FNUztBQUNOLGlCQUFLLEdBQUwsR0FBVyxJQUFYO0FBQ0EsaUJBQUssT0FBTCxHQUFlLElBQWY7QUFDSDs7O2lDQVBlLEcsRUFBSyxNLEVBQVE7QUFDekIsbUJBQVUsR0FBVixTQUFpQixNQUFqQjtBQUNIOzs7Ozs7UUFRRyxZLEdBQUEsWTs7Ozs7Ozs7Ozs7O0FDbkZSOztBQUNBOzs7O0FBRUEsSUFBSSxZQUFZLGFBQWEsTUFBYixDQUFvQixTQUFwQztBQUNBLElBQUksY0FBYyxhQUFhLE1BQWIsQ0FBb0IsV0FBdEM7QUFDQSxJQUFJLGNBQWMsYUFBYSxNQUFiLENBQW9CLFdBQXRDOztJQUVNLE07QUFDRixzQkFBYztBQUFBOztBQUNWLGFBQUssSUFBTCxHQUFZLEVBQVo7QUFDQSxhQUFLLGNBQUwsR0FBc0IsRUFBdEI7QUFDSDs7OztrQ0FFUyxHLEVBQUssTSxFQUFRO0FBQ25CLGdCQUFJLFNBQVMsSUFBYjs7QUFFQSxzQkFBVSxLQUFLLElBQWYsRUFBcUIsVUFBQyxJQUFELEVBQVU7QUFDM0Isb0JBQUksS0FBSyxHQUFMLEtBQWEsR0FBYixJQUFvQixLQUFLLE1BQUwsS0FBZ0IsTUFBeEMsRUFBZ0Q7QUFDNUMsNkJBQVMsSUFBVDs7QUFFQSwyQkFBTyxLQUFQO0FBQ0g7QUFDSixhQU5EOztBQVFBLG1CQUFPLE1BQVA7QUFDSDs7OzRDQUVtQjtBQUNoQixtQkFBTyxZQUFZLEtBQUssSUFBakIsRUFBdUIsVUFBQyxJQUFEO0FBQUEsdUJBQVUsS0FBSyxPQUFMLENBQWEscUJBQVUsa0JBQXZCLENBQVY7QUFBQSxhQUF2QixDQUFQO0FBQ0g7Ozs0QkFFRyxTLEVBQVc7QUFDWCxnQkFBSSxDQUFDLFlBQVksS0FBSyxJQUFqQixFQUF1QixVQUFDLElBQUQ7QUFBQSx1QkFBVSxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQVY7QUFBQSxhQUF2QixFQUEwRCxNQUEvRCxFQUF1RTtBQUNuRSxxQkFBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQWY7QUFDSDtBQUNKOzs7K0JBRU0sUyxFQUFXO0FBQ2QsZ0JBQU0sVUFBVSxNQUFNLE9BQU4sQ0FBYyxTQUFkLENBQWhCO0FBQ0EsZ0JBQU0sVUFBVSxTQUFWLE9BQVUsQ0FBQyxJQUFELEVBQU8sU0FBUCxFQUFxQjtBQUNqQyxvQkFBSSxTQUFTLEtBQWI7O0FBRUEsb0JBQUksT0FBSixFQUFhO0FBQ1QsOEJBQVUsU0FBVixFQUFxQixVQUFDLEtBQUQsRUFBVztBQUM1Qiw0QkFBSSxLQUFLLE9BQUwsQ0FBYSxLQUFiLENBQUosRUFBeUI7QUFDckIscUNBQVMsSUFBVDs7QUFFQSxtQ0FBTyxLQUFQO0FBQ0g7QUFDSixxQkFORDtBQU9ILGlCQVJELE1BUU87QUFDSCw2QkFBUyxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQVQ7QUFDSDs7QUFFRCx1QkFBTyxNQUFQO0FBQ0gsYUFoQkQ7QUFpQkEsaUJBQUssSUFBTCxHQUFZLFlBQVksS0FBSyxJQUFqQixFQUF1QixVQUFDLElBQUQ7QUFBQSx1QkFBVSxDQUFDLFFBQVEsSUFBUixFQUFjLFNBQWQsQ0FBWDtBQUFBLGFBQXZCLENBQVo7QUFDSDs7O3dDQUVlLFMsRUFBVztBQUFBOztBQUN2QixnQkFBTSxrQkFBa0IsU0FBbEIsZUFBa0IsQ0FBQyxJQUFELEVBQVU7QUFDOUIsdUJBQU8sWUFBWSxNQUFLLElBQWpCLEVBQXVCLFVBQUMsR0FBRCxFQUFNLFNBQU4sRUFBb0I7QUFDOUMsd0JBQUksVUFBVSxZQUFWLENBQXVCLElBQXZCLEtBQWdDLElBQUksT0FBSixDQUFZLFNBQVosTUFBMkIsQ0FBQyxDQUFoRSxFQUFtRTtBQUMvRCw0QkFBSSxJQUFKLENBQVMsU0FBVDtBQUNIO0FBQ0QsMkJBQU8sR0FBUDtBQUNILGlCQUxNLEVBS0osRUFMSSxDQUFQO0FBTUgsYUFQRDs7QUFTQSxnQkFBTSx1QkFBdUIsU0FBdkIsb0JBQXVCLENBQUMsSUFBRCxFQUFVO0FBQ25DLG9CQUFJLE9BQU8sZ0JBQWdCLElBQWhCLENBQVg7O0FBRUEsb0JBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2IsOEJBQVUsSUFBVixFQUFnQixVQUFDLFNBQUQsRUFBZTtBQUMzQiw0QkFBSSxVQUFVLGFBQVYsRUFBSixFQUErQjtBQUMzQixtQ0FBTyxLQUFLLE1BQUwsQ0FBWSxxQkFBcUIsU0FBckIsQ0FBWixDQUFQO0FBQ0g7QUFDSixxQkFKRDtBQUtIO0FBQ0QsdUJBQU8sSUFBUDtBQUNILGFBWEQ7O0FBYUEsZ0JBQUk7QUFDQSx1QkFBTyxxQkFBcUIsU0FBckIsQ0FBUDtBQUNILGFBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNSO0FBQ0E7QUFDQSxvQkFBSSxhQUFhLHlCQUFjLFVBQVUsR0FBeEIsRUFBNkIsVUFBVSxNQUF2QyxDQUFqQjtBQUNBLDJCQUFXLFFBQVg7QUFDQSwyQkFBVyxRQUFYLENBQW9CLHFCQUFVLGdCQUE5QjtBQUNBLHVCQUFPLENBQUMsVUFBRCxDQUFQO0FBQ0g7QUFDSjs7O3dDQUdlLGEsRUFBZTtBQUMzQixnQkFBSSxDQUFDLFlBQVksS0FBSyxjQUFqQixFQUFpQyxVQUFDLElBQUQ7QUFBQSx1QkFBVSxLQUFLLE9BQUwsQ0FBYSxhQUFiLENBQVY7QUFBQSxhQUFqQyxFQUF3RSxNQUE3RSxFQUFxRjtBQUNqRixxQkFBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLGFBQXpCO0FBQ0g7QUFDSjs7OzJEQUU2RjtBQUFBLGdCQUFsRSxRQUFrRSxRQUF2RSxHQUF1RTtBQUFBLGdCQUFoRCxXQUFnRCxRQUF4RCxNQUF3RDtBQUFBLGdCQUE1QixNQUE0QixTQUFqQyxHQUFpQztBQUFBLGdCQUFaLFNBQVksU0FBcEIsTUFBb0I7O0FBQzFGLGdCQUFNLFVBQVUsRUFBaEI7O0FBRUEsZ0JBQU0sV0FBVyxTQUFYLFFBQVcsQ0FBQyxJQUFELEVBQVU7QUFDdkIsdUJBQU8sYUFBYSxLQUFLLENBQWxCLEdBQXNCLElBQXRCLEdBQTZCLEtBQUssR0FBTCxJQUFZLFFBQVosSUFBd0IsS0FBSyxHQUFMLElBQVksTUFBeEU7QUFDSCxhQUZEO0FBR0EsZ0JBQU0sV0FBVyxTQUFYLFFBQVcsQ0FBQyxJQUFELEVBQVU7QUFDdkIsdUJBQU8sZ0JBQWdCLEtBQUssQ0FBckIsR0FBeUIsSUFBekIsR0FBZ0MsS0FBSyxNQUFMLElBQWUsV0FBZixJQUE4QixLQUFLLE1BQUwsSUFBZSxTQUFwRjtBQUNILGFBRkQ7O0FBSUEsaUJBQUssY0FBTCxHQUFzQixZQUFZLEtBQUssY0FBakIsRUFBaUMsVUFBQyxJQUFELEVBQVU7QUFDN0Qsb0JBQUksU0FBUyxJQUFULEtBQWtCLFNBQVMsSUFBVCxDQUF0QixFQUFzQztBQUNsQyw0QkFBUSxJQUFSLENBQWEsSUFBYjs7QUFFQSwyQkFBTyxLQUFQO0FBQ0g7O0FBRUQsdUJBQU8sSUFBUDtBQUNILGFBUnFCLENBQXRCOztBQVVBLG1CQUFPLE9BQVA7QUFDSDs7O2dDQUVPO0FBQ0osaUJBQUssSUFBTCxDQUFVLE1BQVYsR0FBbUIsQ0FBbkI7QUFDQSxpQkFBSyxjQUFMLENBQW9CLE1BQXBCLEdBQTZCLENBQTdCO0FBQ0g7Ozs7OztRQUdHLE0sR0FBQSxNOzs7Ozs7Ozs7Ozs7QUNsSVI7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBTSxtQkFBbUIsQ0FBekI7QUFDQSxJQUFNLHFCQUFxQixDQUEzQjtBQUNBLElBQU0sMEJBQTBCLENBQWhDOztBQUVBLElBQUksWUFBWSxhQUFhLE1BQWIsQ0FBb0IsU0FBcEM7QUFDQSxJQUFJLFdBQVcsYUFBYSxNQUFiLENBQW9CLFFBQW5DO0FBQ0EsSUFBSSxZQUFZLGFBQWEsTUFBYixDQUFvQixTQUFwQztBQUNBLElBQUksYUFBYSxhQUFhLE1BQWIsQ0FBb0IsVUFBckM7QUFDQSxJQUFJLFFBQVEsYUFBYSxNQUFiLENBQW9CLEtBQWhDOztJQUdNLEs7QUFFRixtQkFBWSxZQUFaLEVBQTBCO0FBQUE7O0FBQUE7O0FBQ3RCLGFBQUssWUFBTCxHQUFvQixZQUFwQjtBQUNBLGFBQUssTUFBTCxHQUFjLG9CQUFkO0FBQ0EsYUFBSyxNQUFMLEdBQWMsb0JBQWQ7QUFDQSxhQUFLLFlBQUwsR0FBb0IsK0JBQWlCLElBQWpCLENBQXBCOztBQUVBLGFBQUssZUFBTCxHQUF1QixJQUF2QjtBQUNBLGFBQUssTUFBTCxHQUFjLHVCQUFkOztBQUVBLGFBQUssTUFBTCxDQUFZLEVBQVosQ0FBZSxlQUFmLEVBQWdDO0FBQUEsbUJBQWEsTUFBSyxnQkFBTCx3QkFBYjtBQUFBLFNBQWhDO0FBQ0EsYUFBSyxNQUFMLENBQVksRUFBWixDQUFlLGdCQUFmLEVBQWlDO0FBQUEsbUJBQWEsTUFBSyxpQkFBTCx3QkFBYjtBQUFBLFNBQWpDO0FBQ0EsYUFBSyxNQUFMLENBQVksRUFBWixDQUFlLHNCQUFmLEVBQXVDO0FBQUEsbUJBQWEsTUFBSyx1QkFBTCx3QkFBYjtBQUFBLFNBQXZDO0FBQ0EsYUFBSyxNQUFMLENBQVksRUFBWixDQUFlLHVCQUFmLEVBQXdDO0FBQUEsbUJBQWEsTUFBSyx3QkFBTCx3QkFBYjtBQUFBLFNBQXhDO0FBQ0EsYUFBSyxZQUFMLENBQWtCLFlBQWxCLENBQStCLFlBQS9CLEVBQTZDO0FBQUEsbUJBQWEsTUFBSyxhQUFMLHdCQUFiO0FBQUEsU0FBN0M7QUFDSDs7OztzQ0FFYTtBQUNWLG9CQUFRLEtBQUssTUFBYjtBQUNJLHFCQUFLLHVCQUFMO0FBQ0kseUJBQUssZUFBTDtBQUNBO0FBQ0oscUJBQUssa0JBQUw7QUFDSSx5QkFBSyxvQkFBTDtBQUNBO0FBTlI7QUFRSDs7OytDQUVzQjtBQUFBOztBQUNuQixnQkFBTSxRQUFRLEtBQUssTUFBTCxDQUFZLGlCQUFaLEVBQWQ7O0FBRUEsc0JBQVUsS0FBVixFQUFpQixVQUFDLFNBQUQsRUFBZTtBQUM1QixvQkFBTSxRQUFRLE9BQUssWUFBTCxDQUFrQixtQkFBbEIsQ0FBc0MsVUFBVSxHQUFoRCxFQUFxRCxVQUFVLE1BQS9ELENBQWQ7O0FBRUEsb0JBQUksZ0NBQW9CLEtBQXBCLENBQUosRUFBZ0M7QUFDNUIsMkJBQUssZUFBTCxDQUFxQixTQUFyQixFQUFnQyxNQUFNLE1BQU4sQ0FBYSxDQUFiLENBQWhDO0FBQ0g7QUFDSixhQU5EOztBQVFBLGlCQUFLLE1BQUwsR0FBYyxnQkFBZDtBQUNBLGlCQUFLLGFBQUwsQ0FBbUIsa0JBQW5CLEVBQXVDLEtBQXZDLEVBQThDLFdBQTlDO0FBQ0g7OzswQ0FFaUI7QUFBQTs7QUFDZCxnQkFBTSxRQUFRLEtBQUssWUFBTCxDQUFrQixvQkFBbEIsRUFBZDtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxLQUFaOztBQUVBLHNCQUFVLEtBQVYsRUFBaUIsVUFBQyxPQUFELEVBQVUsR0FBVixFQUFrQjtBQUMvQiwwQkFBVSxPQUFWLEVBQW1CLFVBQUMsS0FBRCxFQUFRLE1BQVIsRUFBbUI7QUFDbEMsd0JBQUksZ0NBQW9CLEtBQXBCLENBQUosRUFBZ0M7QUFDNUIsK0JBQUssZUFBTCxDQUFxQix5QkFBYyxHQUFkLEVBQW1CLE1BQW5CLENBQXJCLEVBQWlELE1BQU0sTUFBTixDQUFhLENBQWIsQ0FBakQ7QUFDSDtBQUNKLGlCQUpEO0FBS0gsYUFORDs7QUFRQSxpQkFBSyxNQUFMLEdBQWMsZ0JBQWQ7QUFDQSxpQkFBSyxhQUFMLENBQW1CLGtCQUFuQixFQUF1QyxLQUF2QyxFQUE4QyxNQUE5QztBQUNIOzs7b0NBRVcsSSxFQUFNLEssRUFBTztBQUNyQixpQkFBSyxNQUFMLENBQVksV0FBWixDQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUNIOzs7b0NBR1csSSxFQUFNO0FBQ2QsbUJBQU8sS0FBSyxNQUFMLENBQVksV0FBWixDQUF3QixJQUF4QixDQUFQO0FBQ0g7OztxQ0FHWSxHLEVBQUssTSxFQUFRLFEsRUFBVTtBQUNoQztBQUNBLGlCQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLEVBQUMsUUFBRCxFQUFNLGNBQU4sRUFBbkI7O0FBRUE7QUFDQSxnQkFBSSxnQ0FBb0IsUUFBcEIsQ0FBSixFQUFtQztBQUMvQixxQkFBSyxlQUFMLENBQXFCLHlCQUFjLEdBQWQsRUFBbUIsTUFBbkIsQ0FBckIsRUFBaUQsU0FBUyxNQUFULENBQWdCLENBQWhCLENBQWpEO0FBQ0g7O0FBRUQsZ0JBQU0sT0FBTyxLQUFLLG1CQUFMLENBQXlCLEdBQXpCLEVBQThCLE1BQTlCLENBQWI7O0FBRUEsc0JBQVUsSUFBVixFQUFnQixVQUFDLFNBQUQsRUFBZTtBQUMzQiwwQkFBVSxRQUFWLENBQW1CLHFCQUFVLGtCQUE3QjtBQUNILGFBRkQ7O0FBSUEsaUJBQUssTUFBTCxHQUFjLGtCQUFkO0FBQ0g7Ozt3Q0FFZSxTLEVBQVcsTyxFQUFTO0FBQ2hDLHNCQUFVLFFBQVYsQ0FBbUIscUJBQVUsZUFBN0I7QUFDQSxpQkFBSyxlQUFMLEdBQXVCLFNBQXZCOztBQUVBO0FBQ0E7O0FBTGdDLGdDQU9SLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsK0JBQW1CLE9BQW5CLENBQWxCLENBUFE7QUFBQSxnQkFPekIsS0FQeUIsaUJBT3pCLEtBUHlCO0FBQUEsZ0JBT2xCLE1BUGtCLGlCQU9sQixNQVBrQjs7QUFTaEMsc0JBQVUsUUFBVixDQUFtQixNQUFuQjtBQUNBLHNCQUFVLFFBQVYsQ0FBbUIsS0FBbkI7QUFDQSxzQkFBVSxRQUFWLENBQW1CLHFCQUFVLGdCQUE3Qjs7QUFFQSxpQkFBSyxNQUFMLENBQVksR0FBWixDQUFnQixTQUFoQjtBQUNBLGlCQUFLLGVBQUwsR0FBdUIsSUFBdkI7QUFDSDs7O2tDQUVTLEcsRUFBSyxNLEVBQVE7QUFDbkIsbUJBQU8sS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixHQUF0QixFQUEyQixNQUEzQixDQUFQO0FBQ0g7Ozs0Q0FFbUIsRyxFQUFLLE0sRUFBUTtBQUM3QixtQkFBTyxLQUFLLE1BQUwsQ0FBWSxlQUFaLENBQTRCLEVBQUMsUUFBRCxFQUFNLGNBQU4sRUFBNUIsQ0FBUDtBQUNIOzs7K0NBRStCLEksRUFBTTtBQUFBLGdCQUFwQixHQUFvQixRQUFwQixHQUFvQjtBQUFBLGdCQUFmLE1BQWUsUUFBZixNQUFlOztBQUNsQyxnQkFBTSxPQUFPLGlDQUFrQixHQUFsQixFQUF1QixNQUF2QixDQUFiOztBQUVBLGdCQUFJLENBQUMsS0FBSyxZQUFMLENBQWtCLGFBQWxCLENBQWdDLEtBQUssR0FBckMsRUFBMEMsS0FBSyxNQUEvQyxDQUFMLEVBQTZEO0FBQ3pELHNCQUFNLHVCQUFOO0FBQ0g7O0FBRUQsaUJBQUssTUFBTCxDQUFZLGVBQVosQ0FBNEIsSUFBNUI7QUFDQSxpQkFBSyxlQUFMLENBQXFCLFlBQXJCLENBQWtDLElBQWxDOztBQUVBLGlCQUFLLEtBQUssWUFBTCxDQUFrQixhQUFsQixDQUFnQyxLQUFLLEdBQXJDLEVBQTBDLEtBQUssTUFBL0MsQ0FBTDtBQUNIOzs7dURBRWlELEksRUFBTTtBQUFBLGdCQUEvQixTQUErQixTQUEvQixTQUErQjtBQUFBLGdCQUFwQixHQUFvQixTQUFwQixHQUFvQjtBQUFBLGdCQUFmLE1BQWUsU0FBZixNQUFlOztBQUNwRCxnQkFBTSxPQUFPLGlDQUFrQixHQUFsQixFQUF1QixNQUF2QixDQUFiOztBQUVBOztBQUVBLGlCQUFLLEtBQUssWUFBTCxDQUFrQixvQkFBbEIsQ0FBdUMsU0FBdkMsRUFBa0QsS0FBSyxHQUF2RCxFQUE0RCxLQUFLLE1BQWpFLENBQUw7QUFDSDs7O3dEQUV5RixJLEVBQU07QUFBQSxnQkFBeEUsUUFBd0UsU0FBN0UsR0FBNkU7QUFBQSxnQkFBdEQsV0FBc0QsU0FBOUQsTUFBOEQ7O0FBQUE7O0FBQUEsZ0JBQWxDLE1BQWtDLFNBQXZDLEdBQXVDO0FBQUEsZ0JBQWxCLFNBQWtCLFNBQTFCLE1BQTBCOztBQUM1RixzQkFBVSxTQUFTLEtBQW5CLEVBQTBCLE9BQU8sS0FBakMsRUFBd0MsVUFBQyxHQUFELEVBQVM7QUFDN0MsMEJBQVUsWUFBWSxLQUF0QixFQUE2QixVQUFVLEtBQXZDLEVBQThDLFVBQUMsTUFBRCxFQUFZO0FBQ3RELHdCQUFJLE9BQU8saUNBQWtCLEdBQWxCLEVBQXVCLE1BQXZCLENBQVg7O0FBRUEsMkJBQUssTUFBTCxDQUFZLGVBQVosQ0FBNEIsSUFBNUI7QUFDQSwyQkFBSyxlQUFMLENBQXFCLFlBQXJCLENBQWtDLElBQWxDO0FBQ0gsaUJBTEQ7QUFNSCxhQVBEO0FBUUEsaUJBQUssS0FBSyxZQUFMLENBQWtCLGNBQWxCLENBQWlDLFNBQVMsS0FBMUMsRUFBaUQsWUFBWSxLQUE3RCxFQUFvRSxPQUFPLEtBQTNFLEVBQWtGLFVBQVUsS0FBNUYsQ0FBTDtBQUNIOztBQUVEOzs7O2lEQUN5QixTLGdCQUFtRixJLEVBQU07QUFBQSxnQkFBeEUsUUFBd0UsU0FBN0UsR0FBNkU7QUFBQSxnQkFBdEQsV0FBc0QsU0FBOUQsTUFBOEQ7QUFBQSxnQkFBbEMsTUFBa0MsU0FBdkMsR0FBdUM7QUFBQSxnQkFBbEIsU0FBa0IsU0FBMUIsTUFBMEI7OztBQUc5RyxpQkFBSywwQkFBTDtBQUNIOzs7d0NBRWU7QUFDWixpQkFBSyxvQkFBTDtBQUNIOzs7a0NBRVM7QUFDTixpQkFBSyxZQUFMLENBQWtCLE9BQWxCO0FBQ0EsaUJBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLGlCQUFLLFlBQUwsQ0FBa0IsT0FBbEI7QUFDQSxpQkFBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsaUJBQUssTUFBTCxHQUFjLElBQWQ7QUFDQSxpQkFBSyxNQUFMLENBQVksS0FBWjtBQUNBLGlCQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0g7Ozs7OztBQUdMLE1BQU0sS0FBTjs7UUFFUSxLLEdBQUEsSzs7Ozs7Ozs7Ozs7O0FDOUxSOztBQUNBOzs7O0FBRUEsSUFBSSxZQUFZLGFBQWEsTUFBYixDQUFvQixTQUFwQztBQUNBLElBQUksWUFBWSxhQUFhLE1BQWIsQ0FBb0IsU0FBcEM7O0lBRU0sZ0I7QUFDRiw4QkFBWSxLQUFaLEVBQW1CO0FBQUE7O0FBQ2YsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGFBQUssS0FBTCxHQUFhLDBCQUFiO0FBQ0g7Ozs7NkJBRUksSSxFQUFNLEssRUFBTyxNLEVBQVE7QUFBQSx5QkFDUyxLQUFLLEtBRGQ7QUFBQSxnQkFDZixNQURlLFVBQ2YsTUFEZTtBQUFBLGdCQUNQLFlBRE8sVUFDUCxZQURPOztBQUV0QixnQkFBTSxVQUFVLEVBQWhCOztBQUVBLHNCQUFVLE9BQU8sSUFBakIsRUFBdUIsVUFBQyxTQUFELEVBQWU7QUFBQSxvQkFDM0IsR0FEMkIsR0FDWixTQURZLENBQzNCLEdBRDJCO0FBQUEsb0JBQ3RCLE1BRHNCLEdBQ1osU0FEWSxDQUN0QixNQURzQjs7O0FBR2xDLG9CQUFJLFVBQVUsSUFBVixJQUFrQixLQUFsQixJQUEyQixVQUFVLElBQVYsSUFBa0IsU0FBUyxTQUFTLENBQWxCLENBQWpELEVBQXVFO0FBQ25FLHdCQUFNLFFBQVEsYUFBYSxtQkFBYixDQUFpQyxHQUFqQyxFQUFzQyxNQUF0QyxDQUFkOztBQUVBLDRCQUFRLElBQVIsQ0FBYSxFQUFDLFFBQUQsRUFBTSxjQUFOLEVBQWMsWUFBZCxFQUFiO0FBQ0g7QUFDSixhQVJEOztBQVVBLGlCQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLEVBQUMsVUFBRCxFQUFPLFlBQVAsRUFBYyxjQUFkLEVBQXNCLGdCQUF0QixFQUFoQjtBQUNIOzs7a0NBRVM7QUFBQSwwQkFDeUIsS0FBSyxLQUQ5QjtBQUFBLGdCQUNDLE1BREQsV0FDQyxNQUREO0FBQUEsZ0JBQ1MsWUFEVCxXQUNTLFlBRFQ7O0FBQUEsNkJBRWlDLEtBQUssS0FBTCxDQUFXLEdBQVgsRUFGakM7QUFBQSxnQkFFQyxJQUZELGNBRUMsSUFGRDtBQUFBLGdCQUVPLEtBRlAsY0FFTyxLQUZQO0FBQUEsZ0JBRWMsTUFGZCxjQUVjLE1BRmQ7QUFBQSxnQkFFc0IsT0FGdEIsY0FFc0IsT0FGdEI7O0FBSU4sZ0JBQUksT0FBSixFQUFhO0FBQ1QsMEJBQVUsT0FBVixFQUFtQixVQUFDLE1BQUQsRUFBWTtBQUMzQix3QkFBSSxPQUFPLElBQVAsSUFBZSxTQUFTLFNBQVMsQ0FBbEIsQ0FBbkIsRUFBeUM7QUFDckMsK0JBQU8sSUFBUCxLQUFnQixNQUFoQjtBQUNIO0FBSDBCLHdCQUlwQixHQUpvQixHQUlFLE1BSkYsQ0FJcEIsR0FKb0I7QUFBQSx3QkFJZixNQUplLEdBSUUsTUFKRixDQUlmLE1BSmU7QUFBQSx3QkFJUCxLQUpPLEdBSUUsTUFKRixDQUlQLEtBSk87O0FBSzNCLHdCQUFNLFdBQVcsYUFBYSxtQkFBYixDQUFpQyxHQUFqQyxFQUFzQyxNQUF0QyxDQUFqQjs7QUFFQSx3QkFBSSxhQUFhLEtBQWpCLEVBQXdCO0FBQ3BCLHFDQUFhLGdCQUFiLENBQThCLEdBQTlCLEVBQW1DLE1BQW5DLEVBQTJDLEtBQTNDO0FBQ0EsK0JBQU8sU0FBUCxDQUFpQixHQUFqQixFQUFzQixNQUF0QixFQUE4QixRQUE5QixDQUF1QyxxQkFBVSxrQkFBakQ7QUFDSDtBQUNKLGlCQVhEO0FBWUg7QUFDSjs7O2tDQUVTO0FBQ04saUJBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxpQkFBSyxLQUFMLEdBQWEsSUFBYjtBQUNIOzs7Ozs7UUFHRyxnQixHQUFBLGdCOzs7Ozs7Ozs7O3lwQkN2RFI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUVBOztBQU1BOztBQUNBOztBQUNBOztBQUdBLElBQUksWUFBWSxhQUFhLE1BQWIsQ0FBb0IsU0FBcEM7QUFDQSxJQUFJLFdBQVcsYUFBYSxNQUFiLENBQW9CLFFBQW5DO0FBQ0EsSUFBSSxhQUFhLGFBQWEsTUFBYixDQUFvQixVQUFyQzs7QUFFQSxTQUFTLFNBQVQsQ0FBbUIsV0FBbkIsRUFBZ0M7QUFDNUIsaUJBQWEsT0FBYixDQUFxQixVQUFyQixDQUFnQyxJQUFoQyxDQUFxQyxJQUFyQyxFQUEyQyxXQUEzQztBQUNBLFNBQUssV0FBTCxHQUFtQixhQUFhLE9BQWIsQ0FBcUIsVUFBeEM7O0FBRUEsU0FBSyxZQUFMLEdBQW9CLElBQUksYUFBYSxZQUFqQixFQUFwQjtBQUNBLFNBQUssWUFBTCxHQUFvQiwrQkFBaUIsS0FBSyxHQUF0QixDQUFwQjtBQUNBLFNBQUssS0FBTCxHQUFhLGlCQUFVLEtBQUssWUFBZixDQUFiO0FBQ0EsU0FBSyxnQkFBTCxHQUF3Qix1Q0FBcUIsS0FBSyxLQUExQixDQUF4Qjs7QUFFQSxTQUFLLGNBQUwsR0FBc0IsS0FBdEI7QUFDSDs7QUFFRCxVQUFVLFNBQVYsR0FBc0IsT0FBTyxNQUFQLENBQWMsYUFBYSxPQUFiLENBQXFCLFVBQXJCLENBQWdDLFNBQTlDLEVBQXlEO0FBQzNFLGlCQUFhO0FBQ1Qsa0JBQVUsSUFERDtBQUVULHNCQUFjLElBRkw7QUFHVCxlQUFPO0FBSEU7QUFEOEQsQ0FBekQsQ0FBdEI7O0FBU0EsVUFBVSxTQUFWLENBQW9CLFNBQXBCLEdBQWdDLFlBQVk7QUFDeEMsV0FBTyxDQUFDLENBQUMsS0FBSyxHQUFMLENBQVMsV0FBVCxHQUF1QixTQUFoQztBQUNILENBRkQ7O0FBSUE7Ozs7O0FBS0EsVUFBVSxTQUFWLENBQW9CLFlBQXBCLEdBQW1DLFlBQVk7QUFBQTs7QUFDM0MsUUFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDZDtBQUNIOztBQUVELFFBQU0sV0FBVyxLQUFLLEdBQUwsQ0FBUyxXQUFULEVBQWpCO0FBQ0EsUUFBSSxDQUFDLFNBQVMsa0JBQWQsRUFBa0M7QUFDOUIsY0FBTSxrQkFBTjtBQUNIOztBQUVELFFBQU0sbUJBQW1CLFNBQVMsUUFBbEM7QUFDQSxRQUFJLFNBQVMsZ0JBQVQsQ0FBSixFQUFnQztBQUM1QixZQUFJLFNBQVMsaUJBQWlCLFNBQTFCLENBQUosRUFBMEM7QUFDdEMsdUJBQVcsaUJBQWlCLFNBQTVCLEVBQXVDLFVBQUMsS0FBRCxFQUFRLElBQVI7QUFBQSx1QkFBaUIsTUFBSyxXQUFMLENBQWlCLElBQWpCLEVBQXVCLEtBQXZCLENBQWpCO0FBQUEsYUFBdkM7QUFDSDtBQUNKOztBQUVEO0FBQ0EsUUFBSSxZQUFZLEtBQUssWUFBTCxDQUFrQixTQUFsQixHQUE4QixLQUFLLEdBQUwsQ0FBUyxXQUFULEdBQXVCLE1BQXJFO0FBQ0EsU0FBSyxZQUFMLENBQWtCLFFBQWxCLEdBQTZCLFVBQVUsUUFBdkM7O0FBRUEsU0FBSyxPQUFMLENBQWEsZ0JBQWIsRUFBK0I7QUFBQSxlQUFhLE1BQUssZ0JBQUwsd0JBQWI7QUFBQSxLQUEvQjtBQUNBLFNBQUssT0FBTCxDQUFhLGdCQUFiLEVBQStCO0FBQUEsZUFBYSxNQUFLLGdCQUFMLHdCQUFiO0FBQUEsS0FBL0I7QUFDQSxTQUFLLE9BQUwsQ0FBYSxlQUFiLEVBQThCO0FBQUEsZUFBTSxNQUFLLGVBQUwsRUFBTjtBQUFBLEtBQTlCO0FBQ0EsU0FBSyxPQUFMLENBQWEsZ0JBQWIsRUFBK0I7QUFBQSxlQUFhLE1BQUssZ0JBQUwsd0JBQWI7QUFBQSxLQUEvQjtBQUNBLFNBQUssT0FBTCxDQUFhLGdCQUFiLEVBQStCO0FBQUEsZUFBYSxNQUFLLGdCQUFMLHdCQUFiO0FBQUEsS0FBL0I7QUFDQSxTQUFLLE9BQUwsQ0FBYSxvQkFBYixFQUFtQztBQUFBLGVBQWEsTUFBSyxvQkFBTCx3QkFBYjtBQUFBLEtBQW5DO0FBQ0EsU0FBSyxPQUFMLENBQWEsdUJBQWIsRUFBc0M7QUFBQSxlQUFhLE1BQUssb0JBQUwsd0JBQWI7QUFBQSxLQUF0QztBQUNBO0FBQ0EsU0FBSyxPQUFMLENBQWEsaUJBQWIsRUFBZ0M7QUFBQSxlQUFhLE1BQUssaUJBQUwsd0JBQWI7QUFBQSxLQUFoQztBQUNBLFNBQUssT0FBTCxDQUFhLGlCQUFiLEVBQWdDO0FBQUEsZUFBYSxNQUFLLGlCQUFMLHdCQUFiO0FBQUEsS0FBaEM7QUFDQSxTQUFLLE9BQUwsQ0FBYSxpQkFBYixFQUFnQztBQUFBLGVBQWEsTUFBSyxpQkFBTCx3QkFBYjtBQUFBLEtBQWhDO0FBQ0EsU0FBSyxPQUFMLENBQWEsaUJBQWIsRUFBZ0M7QUFBQSxlQUFhLE1BQUssaUJBQUwsd0JBQWI7QUFBQSxLQUFoQztBQUNBLFNBQUssT0FBTCxDQUFhLGdCQUFiLEVBQStCO0FBQUEsZUFBYSxNQUFLLGdCQUFMLHdCQUFiO0FBQUEsS0FBL0I7QUFDQSxTQUFLLE9BQUwsQ0FBYSxtQkFBYixFQUFrQztBQUFBLGVBQWEsTUFBSyxtQkFBTCx3QkFBYjtBQUFBLEtBQWxDO0FBQ0EsU0FBSyxPQUFMLENBQWEsWUFBYixFQUEyQjtBQUFBLGVBQWEsTUFBSyxZQUFMLHdCQUFiO0FBQUEsS0FBM0I7O0FBRUEsU0FBSyxLQUFMLENBQVcsWUFBWCxDQUF3QixrQkFBeEIsRUFBNEM7QUFBQSxlQUFhLE1BQUssdUJBQUwsd0JBQWI7QUFBQSxLQUE1Qzs7QUFFQSxTQUFLLFdBQUwsQ0FBaUIsU0FBakIsQ0FBMkIsWUFBM0IsQ0FBd0MsSUFBeEMsQ0FBNkMsSUFBN0M7QUFDSCxDQXhDRDs7QUEyQ0E7Ozs7QUFJQSxVQUFVLFNBQVYsQ0FBb0IsYUFBcEIsR0FBb0MsWUFBWTtBQUM1QyxTQUFLLFdBQUwsQ0FBaUIsU0FBakIsQ0FBMkIsYUFBM0IsQ0FBeUMsSUFBekMsQ0FBOEMsSUFBOUM7QUFDSCxDQUZEOztBQUlBOzs7O0FBSUEsVUFBVSxTQUFWLENBQW9CLFlBQXBCLEdBQW1DLFlBQVk7QUFDM0MsU0FBSyxhQUFMO0FBQ0EsU0FBSyxZQUFMO0FBQ0EsU0FBSyxXQUFMLENBQWlCLFNBQWpCLENBQTJCLFlBQTNCLENBQXdDLElBQXhDLENBQTZDLElBQTdDO0FBQ0gsQ0FKRDs7QUFNQTs7O0FBR0EsVUFBVSxTQUFWLENBQW9CLE9BQXBCLEdBQThCLFlBQVk7QUFDdEMsU0FBSyxZQUFMLENBQWtCLE9BQWxCO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsU0FBSyxLQUFMLENBQVcsT0FBWDtBQUNBLFNBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxTQUFLLFdBQUwsQ0FBaUIsU0FBakIsQ0FBMkIsT0FBM0IsQ0FBbUMsSUFBbkMsQ0FBd0MsSUFBeEM7QUFDSCxDQU5EOztBQVNBOztBQUVBO0FBQ0EsVUFBVSxTQUFWLENBQW9CLGFBQXBCLEdBQW9DLFVBQVUsS0FBVixFQUFpQixLQUFqQixFQUF3QixLQUF4QixFQUErQixDQUdsRSxDQUhEOztBQUtBLFVBQVUsU0FBVixDQUFvQix1QkFBcEIsR0FBOEMsVUFBVSxLQUFWLEVBQWlCO0FBQzNELFFBQUksS0FBSyxjQUFULEVBQXlCO0FBQ3JCLGFBQUssY0FBTCxHQUFzQixLQUF0QjtBQUNBO0FBQ0g7QUFDRCxRQUFNLE1BQU0sS0FBSyxHQUFqQjs7QUFFQSxjQUFVLEtBQVYsRUFBaUIsZ0JBQW1CO0FBQUEsWUFBakIsR0FBaUIsUUFBakIsR0FBaUI7QUFBQSxZQUFaLE1BQVksUUFBWixNQUFZOztBQUNoQyxZQUFJLFlBQUosQ0FDSSxJQUFJLGFBQUosQ0FBa0IsR0FBbEIsRUFBdUIsTUFBdkIsQ0FESixFQUVJLElBQUksV0FBSixDQUFnQixHQUFoQixFQUFxQixNQUFyQixDQUZKLEVBR0ksWUFBTSxDQUNMLENBSkw7QUFNSCxLQVBEO0FBUUEsUUFBSSxNQUFKO0FBQ0gsQ0FoQkQ7O0FBbUJBOzs7OztBQUtBLFVBQVUsU0FBVixDQUFvQixlQUFwQixHQUFzQyxVQUFVLEtBQVYsRUFBaUIsQ0FFdEQsQ0FGRDs7QUFJQSxVQUFVLFNBQVYsQ0FBb0IsWUFBcEIsR0FBbUMsVUFBVSxHQUFWLEVBQWUsTUFBZixFQUF1QixXQUF2QixFQUFvQyxNQUFwQyxFQUE0QztBQUMzRSxRQUFJLFdBQVcsS0FBWCxJQUFvQixLQUFLLG9CQUFMLENBQTBCLEdBQTFCLEVBQStCLE1BQS9CLENBQXhCLEVBQWdFO0FBQzVELG9CQUFZLEtBQVosR0FBb0IsS0FBSyxZQUFMLENBQWtCLEdBQWxCLEVBQXVCLE1BQXZCLENBQXBCO0FBQ0gsS0FGRCxNQUVPLElBQUksV0FBVyxLQUFYLElBQW9CLGdDQUFvQixZQUFZLEtBQWhDLENBQXhCLEVBQWdFO0FBQ25FLG9CQUFZLEtBQVosR0FBb0IsK0JBQW1CLFlBQVksS0FBL0IsQ0FBcEI7QUFDSDtBQUNKLENBTkQ7O0FBUUEsVUFBVSxTQUFWLENBQW9CLG1CQUFwQixHQUEwQyxVQUFVLEtBQVYsRUFBaUI7QUFDdkQsUUFBSSx1Q0FBMkIsS0FBM0IsQ0FBSixFQUF1QztBQUNuQyxnQkFBUSxzQ0FBMEIsS0FBMUIsQ0FBUjtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0gsQ0FMRDs7QUFPQSxVQUFVLFNBQVYsQ0FBb0IsZ0JBQXBCLEdBQXVDLFVBQVUsS0FBVixFQUFpQixHQUFqQixFQUFzQixJQUF0QixFQUE0QjtBQUMvRCxRQUFNLFNBQVMsS0FBSyxHQUFMLENBQVMsU0FBVCxDQUFtQixJQUFuQixDQUFmOztBQUVBLFFBQUksS0FBSyxvQkFBTCxDQUEwQixHQUExQixFQUErQixNQUEvQixDQUFKLEVBQTRDO0FBQ3hDLGdCQUFRLEtBQUssWUFBTCxDQUFrQixHQUFsQixFQUF1QixNQUF2QixDQUFSO0FBQ0g7O0FBRUQsV0FBTyxLQUFQO0FBQ0gsQ0FSRDs7QUFVQSxVQUFVLFNBQVYsQ0FBb0Isb0JBQXBCLEdBQTJDLFVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQjtBQUFBOztBQUNsRSxRQUFJLFdBQVcsVUFBZixFQUEyQjtBQUN2QjtBQUNIOztBQUVELFNBQUssWUFBTCxDQUFrQixZQUFsQjtBQUNBLGNBQVUsT0FBVixFQUFtQixpQkFBdUM7QUFBQTtBQUFBLFlBQXJDLEdBQXFDO0FBQUEsWUFBaEMsTUFBZ0M7QUFBQSxZQUF4QixRQUF3QjtBQUFBLFlBQWQsUUFBYzs7QUFDdEQsaUJBQVMsT0FBSyxHQUFMLENBQVMsU0FBVCxDQUFtQixNQUFuQixDQUFUO0FBQ0EsWUFBSSxnQ0FBb0IsUUFBcEIsQ0FBSixFQUFtQztBQUMvQix1QkFBVywrQkFBbUIsUUFBbkIsQ0FBWDtBQUNIO0FBQ0QsZUFBSyxZQUFMLENBQWtCLGNBQWxCLENBQWlDLEdBQWpDLEVBQXNDLE1BQXRDLEVBQThDLFFBQTlDO0FBQ0EsWUFBSSxhQUFhLFFBQWpCLEVBQTJCO0FBQ3ZCLG1CQUFLLEtBQUwsQ0FBVyxZQUFYLENBQXdCLEdBQXhCLEVBQTZCLE1BQTdCLEVBQXFDLFFBQXJDO0FBQ0g7QUFDSixLQVREO0FBVUEsU0FBSyxXQUFMO0FBQ0gsQ0FqQkQ7O0FBbUJBLFVBQVUsU0FBVixDQUFvQixpQkFBcEIsR0FBd0MsVUFBVSxHQUFWLEVBQWUsTUFBZixFQUF1QixNQUF2QixFQUErQjtBQUNuRSxRQUFJLFdBQVcsZUFBZixFQUFnQztBQUM1QixhQUFLLGdCQUFMLENBQXNCLE9BQXRCO0FBQ0g7QUFDSixDQUpEOztBQU1BLFVBQVUsU0FBVixDQUFvQixnQkFBcEIsR0FBdUMsVUFBVSxHQUFWLEVBQWUsTUFBZixFQUF1QixNQUF2QixFQUErQjtBQUNsRSxTQUFLLEtBQUwsQ0FBVyxZQUFYLENBQXdCLFNBQXhCLENBQWtDLEdBQWxDLEVBQXVDLE1BQXZDLEVBQStDLFdBQVcsZUFBMUQ7QUFDSCxDQUZEOztBQUlBLFVBQVUsU0FBVixDQUFvQixpQkFBcEIsR0FBd0MsVUFBVSxHQUFWLEVBQWUsTUFBZixFQUF1QjtBQUMzRDtBQUNILENBRkQ7O0FBSUEsVUFBVSxTQUFWLENBQW9CLGdCQUFwQixHQUF1QyxVQUFVLEdBQVYsRUFBZSxNQUFmLEVBQXVCO0FBQzFELFNBQUssS0FBTCxDQUFXLFlBQVgsQ0FBd0IsU0FBeEIsQ0FBa0MsR0FBbEMsRUFBdUMsTUFBdkM7QUFDSCxDQUZEOztBQUlBLFVBQVUsU0FBVixDQUFvQixpQkFBcEIsR0FBd0MsVUFBVSxNQUFWLEVBQWtCLE1BQWxCLEVBQTBCLE1BQTFCLEVBQWtDO0FBQ3RFLFFBQUksV0FBVyxlQUFmLEVBQWdDO0FBQzVCLGFBQUssZ0JBQUwsQ0FBc0IsT0FBdEI7QUFDSDtBQUNKLENBSkQ7O0FBTUEsVUFBVSxTQUFWLENBQW9CLGdCQUFwQixHQUF1QyxVQUFVLE1BQVYsRUFBa0IsTUFBbEIsRUFBMEIsTUFBMUIsRUFBa0M7QUFDckUsU0FBSyxLQUFMLENBQVcsWUFBWCxDQUF3QixZQUF4QixDQUFxQyxNQUFyQyxFQUE2QyxNQUE3QyxFQUFxRCxXQUFXLGVBQWhFO0FBQ0gsQ0FGRDs7QUFJQSxVQUFVLFNBQVYsQ0FBb0IsaUJBQXBCLEdBQXdDLFVBQVUsTUFBVixFQUFrQixNQUFsQixFQUEwQjtBQUM5RDtBQUNILENBRkQ7O0FBSUEsVUFBVSxTQUFWLENBQW9CLGdCQUFwQixHQUF1QyxVQUFVLE1BQVYsRUFBa0IsTUFBbEIsRUFBMEI7QUFDN0QsU0FBSyxLQUFMLENBQVcsWUFBWCxDQUF3QixZQUF4QixDQUFxQyxNQUFyQyxFQUE2QyxNQUE3QztBQUNILENBRkQ7O0FBSUEsVUFBVSxTQUFWLENBQW9CLGVBQXBCLEdBQXNDLFlBQVk7QUFDOUMsU0FBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsU0FBSyxlQUFMO0FBQ0gsQ0FIRDs7QUFLQTs7QUFFQSxVQUFVLFNBQVYsQ0FBb0IsWUFBcEIsR0FBbUMsVUFBVSxHQUFWLEVBQWUsTUFBZixFQUF1QjtBQUN0RCxRQUFNLE9BQU8sS0FBSyxLQUFMLENBQVcsU0FBWCxDQUFxQixHQUFyQixFQUEwQixNQUExQixDQUFiO0FBQ0EsV0FBTyxPQUFRLEtBQUssUUFBTCxNQUFtQixLQUFLLFFBQUwsRUFBM0IsR0FBOEMsS0FBSyxDQUExRDtBQUNILENBSEQ7O0FBS0EsVUFBVSxTQUFWLENBQW9CLG9CQUFwQixHQUEyQyxVQUFVLEdBQVYsRUFBZSxNQUFmLEVBQXVCO0FBQzlELFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBTCxDQUFXLFNBQVgsQ0FBcUIsR0FBckIsRUFBMEIsTUFBMUIsQ0FBVDtBQUNILENBRkQ7O0FBSUEsVUFBVSxTQUFWLENBQW9CLFdBQXBCLEdBQWtDLFlBQVk7QUFDMUMsU0FBSyxLQUFMLENBQVcsV0FBWDtBQUNILENBRkQ7O0FBSUEsVUFBVSxTQUFWLENBQW9CLGVBQXBCLEdBQXNDLFlBQVk7QUFDOUMsU0FBSyxLQUFMLENBQVcsZUFBWDtBQUNILENBRkQ7O0FBSUEsVUFBVSxTQUFWLENBQW9CLG9CQUFwQixHQUEyQyxZQUFZO0FBQ25ELFNBQUssS0FBTCxDQUFXLG9CQUFYO0FBQ0gsQ0FGRDs7QUFJQSxVQUFVLFNBQVYsQ0FBb0IsV0FBcEIsR0FBa0MsVUFBVSxJQUFWLEVBQWdCLEtBQWhCLEVBQXVCO0FBQ3JELFNBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUIsSUFBdkIsRUFBNkIsS0FBN0I7QUFDSCxDQUZEOztBQUlBLFVBQVUsU0FBVixDQUFvQixXQUFwQixHQUFrQyxVQUFVLElBQVYsRUFBZ0I7QUFDOUMsV0FBTyxLQUFLLEtBQUwsQ0FBVyxXQUFYLENBQXVCLElBQXZCLENBQVA7QUFDSCxDQUZEOztBQUlBLGFBQWEsT0FBYixDQUFxQixjQUFyQixDQUFvQyxXQUFwQyxFQUFpRCxTQUFqRDs7UUFFUSxTLEdBQUEsUzs7Ozs7Ozs7Ozs7Ozs7QUN0U1I7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFJLFlBQVksYUFBYSxNQUFiLENBQW9CLFNBQXBDO0FBQ0EsSUFBSSxjQUFjLGFBQWEsTUFBYixDQUFvQixXQUF0QztBQUNBLElBQUksUUFBUSxhQUFhLE1BQWIsQ0FBb0IsS0FBaEM7O0FBRUEsSUFBTSx5QkFBeUIsbUJBQS9CO0FBQ0EsSUFBTSxrQkFBa0IsaUJBQXhCO0FBQ0EsSUFBTSxhQUFhLDJEQUFuQjtBQUNBLElBQU0sY0FBYyx3Q0FBcEI7QUFDQSxJQUFNLHVCQUF1QixxR0FBN0I7O0lBR00sa0I7QUFDRixnQ0FBWSxVQUFaLEVBQXdCO0FBQUE7O0FBRXBCOzs7O0FBSUEsYUFBSyxVQUFMLEdBQWtCLEVBQWxCOztBQUVBLGFBQUssS0FBTCxHQUFhLEVBQWI7O0FBRUEsWUFBSSxPQUFPLFVBQVAsS0FBc0IsUUFBMUIsRUFBb0M7QUFDaEMsaUJBQUssYUFBTCxDQUFtQixVQUFuQjtBQUNIO0FBQ0o7Ozs7c0NBRWEsVSxFQUFZO0FBQ3RCLGlCQUFLLEtBQUwsQ0FBVyxNQUFYLEdBQW9CLENBQXBCO0FBQ0EsaUJBQUssVUFBTCxHQUFrQiwrQkFBbUIsVUFBbkIsQ0FBbEI7O0FBRUEsaUJBQUssYUFBTDtBQUNBLGlCQUFLLGtCQUFMOztBQUVBLG1CQUFPLElBQVA7QUFDSDs7OytDQUVtRjtBQUFBLGdCQUFwRSxPQUFvRSxRQUF6RSxHQUF5RTtBQUFBLGdCQUFuRCxVQUFtRCxRQUEzRCxNQUEyRDtBQUFBLGdCQUFoQyxRQUFnQyxTQUFyQyxHQUFxQztBQUFBLGdCQUFkLFdBQWMsU0FBdEIsTUFBc0I7O0FBQ2hGLHNCQUFVLEtBQUssS0FBZixFQUFzQixVQUFDLElBQUQsRUFBVTtBQUM1QixvQkFBSSxZQUFZLElBQWhCLEVBQXNCO0FBQ2xCLHVDQUFtQixjQUFuQixDQUFrQyxJQUFsQyxFQUF3QyxLQUF4QyxFQUErQyxPQUEvQyxFQUF3RCxRQUF4RDtBQUNIO0FBQ0Qsb0JBQUksZUFBZSxJQUFuQixFQUF5QjtBQUNyQix1Q0FBbUIsY0FBbkIsQ0FBa0MsSUFBbEMsRUFBd0MsUUFBeEMsRUFBa0QsVUFBbEQsRUFBOEQsV0FBOUQ7QUFDSDtBQUNKLGFBUEQ7O0FBU0EsbUJBQU8sSUFBUDtBQUNIOzs7bUNBRVU7QUFBQTs7QUFDUCxnQkFBSSxhQUFhLEtBQUssVUFBTCxDQUFnQixPQUFoQixDQUF3QixvQkFBeEIsRUFBOEMsVUFBQyxLQUFELEVBQVEsRUFBUixFQUFZLEVBQVosRUFBbUI7QUFDOUUsb0JBQU0sZUFBZSxNQUFNLE9BQU4sQ0FBYyxHQUFkLE1BQXVCLENBQUMsQ0FBN0M7QUFDQSxvQkFBSSxTQUFTLEtBQWI7QUFDQSxvQkFBSSxZQUFZLEtBQWhCO0FBQ0Esb0JBQUksc0JBQXNCLElBQTFCOztBQUVBLG9CQUFJLFlBQUosRUFBa0I7QUFDZCxnQ0FBWSx1QkFBdUIsSUFBdkIsQ0FBNEIsRUFBNUIsSUFBa0MsRUFBbEMsR0FBdUMsRUFBbkQ7QUFDSDtBQUNELG9CQUFNLE9BQU8sTUFBSyxXQUFMLENBQWlCLFNBQWpCLENBQWI7O0FBRUEsb0JBQUksSUFBSixFQUFVO0FBQ04sMENBQXNCLEtBQUssUUFBTCxHQUFnQixzQ0FBaEIsR0FBbUMsS0FBSyxPQUFMLEVBQXpEOztBQUVBLHdCQUFJLFlBQUosRUFBa0I7QUFDZCxpQ0FBUyxNQUFNLE9BQU4sQ0FBYyxTQUFkLEVBQXlCLG1CQUF6QixDQUFUO0FBQ0gscUJBRkQsTUFFTztBQUNILGlDQUFTLG1CQUFUO0FBQ0g7QUFDSjs7QUFFRCx1QkFBTyxNQUFQO0FBQ0gsYUF0QmdCLENBQWpCOztBQXdCQSxnQkFBSSxDQUFDLFdBQVcsVUFBWCxDQUFzQixHQUF0QixDQUFMLEVBQWlDO0FBQzdCLDZCQUFhLE1BQU0sVUFBbkI7QUFDSDs7QUFFRCxtQkFBTyxVQUFQO0FBQ0g7Ozt3Q0FxRGU7QUFBQTs7QUFDWixnQkFBTSxVQUFVLEtBQUssVUFBTCxDQUFnQixLQUFoQixDQUFzQixVQUF0QixDQUFoQjs7QUFFQSxnQkFBSSxDQUFDLE9BQUwsRUFBYztBQUNWO0FBQ0g7QUFDRCxzQkFBVSxPQUFWLEVBQW1CLFVBQUMsS0FBRCxFQUFXO0FBQzFCLHdCQUFRLE1BQU0sS0FBTixDQUFZLGVBQVosQ0FBUjs7QUFFQSxvQkFBSSxDQUFDLEtBQUwsRUFBWTtBQUNSO0FBQ0g7O0FBTHlCLG9DQU1KLDBCQUFhLE1BQU0sQ0FBTixDQUFiLENBTkk7QUFBQTtBQUFBLG9CQU1uQixHQU5tQjtBQUFBLG9CQU1kLE1BTmM7O0FBUTFCLHVCQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLE9BQUssV0FBTCxDQUFpQixFQUFDLFFBQUQsRUFBTSxjQUFOLEVBQWpCLEVBQWdDLEVBQUMsUUFBRCxFQUFNLGNBQU4sRUFBaEMsRUFBK0MsTUFBTSxDQUFOLENBQS9DLENBQWhCO0FBQ0gsYUFURDtBQVVIOzs7NkNBRW9CO0FBQUE7O0FBQ2pCLGdCQUFNLFVBQVUsS0FBSyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLFdBQXRCLENBQWhCOztBQUVBLGdCQUFJLENBQUMsT0FBTCxFQUFjO0FBQ1Y7QUFDSDtBQUNELHNCQUFVLE9BQVYsRUFBbUIsVUFBQyxLQUFELEVBQVc7QUFBQSxtQ0FDTCxNQUFNLEtBQU4sQ0FBWSxHQUFaLENBREs7QUFBQTtBQUFBLG9CQUNuQixLQURtQjtBQUFBLG9CQUNaLEdBRFk7O0FBQUEscUNBRU0sMEJBQWEsS0FBYixDQUZOO0FBQUE7QUFBQSxvQkFFbkIsUUFGbUI7QUFBQSxvQkFFVCxXQUZTOztBQUFBLHFDQUdFLDBCQUFhLEdBQWIsQ0FIRjtBQUFBO0FBQUEsb0JBR25CLE1BSG1CO0FBQUEsb0JBR1gsU0FIVzs7QUFJMUIsb0JBQU0sWUFBWTtBQUNkLHlCQUFLLFFBRFM7QUFFZCw0QkFBUTtBQUZNLGlCQUFsQjtBQUlBLG9CQUFNLFVBQVU7QUFDWix5QkFBSyxNQURPO0FBRVosNEJBQVE7QUFGSSxpQkFBaEI7O0FBS0EsdUJBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsT0FBSyxXQUFMLENBQWlCLFNBQWpCLEVBQTRCLE9BQTVCLEVBQXFDLEtBQXJDLENBQWhCO0FBQ0gsYUFkRDtBQWVIOzs7b0NBR1csSyxFQUFPO0FBQUEsK0JBQ0EsWUFBWSxLQUFLLEtBQWpCLEVBQXdCLFVBQUMsSUFBRDtBQUFBLHVCQUFVLEtBQUssU0FBTCxLQUFtQixLQUE3QjtBQUFBLGFBQXhCLENBREE7QUFBQTtBQUFBLGdCQUNSLElBRFE7O0FBR2YsbUJBQU8sUUFBUSxJQUFmO0FBQ0g7OztvQ0FFVyxLLEVBQU8sRyxFQUFLLEssRUFBTztBQUMzQixtQkFBTztBQUNILDRCQURHO0FBRUgsd0JBRkc7QUFHSCwyQkFBVyxLQUhSO0FBSUgsc0JBQU0sTUFBTSxPQUFOLENBQWMsR0FBZCxNQUF1QixDQUFDLENBQXhCLEdBQTRCLE1BQTVCLEdBQXFDLE9BSnhDO0FBS0gsMEJBQVUsS0FMUDtBQU1ILHlCQUFTLG1CQUFZO0FBQ2pCLHdCQUFJLFFBQVEscUJBQVEsS0FBSyxLQUFMLENBQVcsR0FBbkIsRUFBd0IsS0FBSyxLQUFMLENBQVcsTUFBbkMsQ0FBWjs7QUFFQSx3QkFBSSxLQUFLLElBQUwsS0FBYyxPQUFsQixFQUEyQjtBQUN2QixpQ0FBUyxNQUFNLHFCQUFRLEtBQUssR0FBTCxDQUFTLEdBQWpCLEVBQXNCLEtBQUssR0FBTCxDQUFTLE1BQS9CLENBQWY7QUFDSDs7QUFFRCwyQkFBTyxLQUFQO0FBQ0g7QUFkRSxhQUFQO0FBZ0JIOzs7dUNBcEhxQixJLEVBQU0sUSxFQUFvQztBQUFBLGdCQUExQixTQUEwQix1RUFBZCxDQUFjO0FBQUEsZ0JBQVgsS0FBVyx1RUFBSCxDQUFHO0FBQUEsZ0JBQ3JELElBRHFELEdBQ2pDLElBRGlDLENBQ3JELElBRHFEO0FBQUEsZ0JBQy9DLEtBRCtDLEdBQ2pDLElBRGlDLENBQy9DLEtBRCtDO0FBQUEsZ0JBQ3hDLEdBRHdDLEdBQ2pDLElBRGlDLENBQ3hDLEdBRHdDOztBQUU1RCxnQkFBSSxhQUFhLE1BQU0sUUFBTixFQUFnQixLQUFqQztBQUNBLGdCQUFJLFdBQVcsSUFBSSxRQUFKLEVBQWMsS0FBN0I7QUFDQSxnQkFBSSxhQUFhLEtBQWpCO0FBQ0EsZ0JBQUksV0FBVyxLQUFmO0FBQ0EsZ0JBQUksV0FBVyxLQUFmO0FBQ0EsZ0JBQU0sY0FBYyxLQUFLLEdBQUwsQ0FBUyxLQUFULElBQWtCLENBQXRDOztBQUVBO0FBQ0EsZ0JBQUksUUFBUSxDQUFaLEVBQWU7QUFDWCxvQkFBSSxZQUFZLFVBQWhCLEVBQTRCO0FBQ3hCLGlDQUFhLENBQWI7QUFDSDtBQUNELG9CQUFJLFlBQVksUUFBaEIsRUFBMEI7QUFDdEIsK0JBQVcsQ0FBWDtBQUNIO0FBQ0osYUFQRCxNQU9PO0FBQUU7QUFDTCxvQkFBSSxjQUFjLFNBQWQsSUFBMkIsWUFBWSxZQUFZLFdBQXZELEVBQW9FO0FBQ2hFLCtCQUFXLElBQVg7QUFDSDtBQUNELG9CQUFJLENBQUMsUUFBRCxJQUFhLFNBQVMsTUFBMUIsRUFBa0M7QUFDOUIsd0JBQUksYUFBYSxVQUFqQixFQUE2QjtBQUN6QixxQ0FBYSxDQUFiO0FBQ0EsbUNBQVcsQ0FBWDtBQUNIO0FBQ0o7QUFDRCxvQkFBSSxDQUFDLFFBQUQsSUFBYSxTQUFTLE9BQTFCLEVBQW1DO0FBQy9CLHdCQUFJLGFBQWEsVUFBakIsRUFBNkI7QUFDekIscUNBQWEsQ0FBYjtBQUNIO0FBQ0Qsd0JBQUksWUFBWSxRQUFoQixFQUEwQjtBQUN0QixtQ0FBVyxDQUFYO0FBRUgscUJBSEQsTUFHTyxJQUFJLFlBQVksWUFBWSxXQUE1QixFQUF5QztBQUM1QyxvQ0FBWSxLQUFLLEdBQUwsQ0FBUyxZQUFZLFlBQVksV0FBeEIsQ0FBVCxFQUErQyxDQUEvQyxDQUFaO0FBQ0g7QUFDSjtBQUNKOztBQUVELGdCQUFJLGNBQWMsQ0FBQyxRQUFuQixFQUE2QjtBQUN6QixzQkFBTSxRQUFOLEVBQWdCLEtBQWhCLEdBQXdCLEtBQUssR0FBTCxDQUFTLGFBQWEsVUFBdEIsRUFBa0MsQ0FBbEMsQ0FBeEI7QUFDSDtBQUNELGdCQUFJLFlBQVksQ0FBQyxRQUFqQixFQUEyQjtBQUN2QixvQkFBSSxRQUFKLEVBQWMsS0FBZCxHQUFzQixLQUFLLEdBQUwsQ0FBUyxXQUFXLFFBQXBCLEVBQThCLENBQTlCLENBQXRCO0FBQ0g7QUFDRCxnQkFBSSxRQUFKLEVBQWM7QUFDVixxQkFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0g7QUFDSjs7Ozs7O0FBc0VMLE1BQU0sa0JBQU47O1FBRVEsa0IsR0FBQSxrQjs7Ozs7Ozs7Ozs7a0JDMUxnQixLOzs7O0FBdEJqQixJQUFNLHdCQUFRLE9BQWQ7QUFDQSxJQUFNLDBDQUFpQixPQUF2QjtBQUNBLElBQU0sa0NBQWEsTUFBbkI7QUFDQSxJQUFNLGdEQUFvQixhQUExQjtBQUNBLElBQU0sb0RBQXNCLEtBQTVCO0FBQ0EsSUFBTSxrQ0FBYSxNQUFuQjtBQUNBLElBQU0sZ0NBQVksS0FBbEI7QUFDQSxJQUFNLGdDQUFZLEtBQWxCO0FBQ0EsSUFBTSxvQ0FBYyxPQUFwQjs7QUFFUCxJQUFNLGlEQUNILEtBREcsRUFDSyxTQURMLDRCQUVILGNBRkcsRUFFYyxTQUZkLDRCQUdILFVBSEcsRUFHVSxRQUhWLDRCQUlILGlCQUpHLEVBSWlCLGVBSmpCLDRCQUtILG1CQUxHLEVBS21CLE1BTG5CLDRCQU1ILFVBTkcsRUFNVSxRQU5WLDRCQU9ILFNBUEcsRUFPUyxPQVBULDRCQVFILFNBUkcsRUFRUyxPQVJULDRCQVNILFdBVEcsRUFTVyxTQVRYLFdBQU47O0FBWWUsU0FBUyxLQUFULENBQWUsSUFBZixFQUFxQjtBQUNsQyxNQUFJLGNBQUo7QUFDQSxTQUFPLENBQUMsT0FBTyxFQUFSLEVBQVksT0FBWixDQUFvQixTQUFwQixFQUErQixFQUEvQixDQUFQOztBQUVBLE1BQUksT0FBTyxJQUFQLENBQUosRUFBa0I7QUFDaEIsWUFBUSxPQUFPLElBQVAsQ0FBUjtBQUNEO0FBQ0QsU0FBTyxRQUFRLEtBQVIsR0FBZ0IsSUFBdkI7QUFDRDs7Ozs7Ozs7QUM5QkQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0VBLElBQUksVUFBVyxZQUFVO0FBQ3pCLFFBQUksSUFBRSxXQUFTLENBQVQsRUFBVyxDQUFYLEVBQWEsRUFBYixFQUFlLENBQWYsRUFBaUI7QUFBQyxhQUFJLEtBQUUsTUFBRyxFQUFMLEVBQVEsSUFBRSxFQUFFLE1BQWhCLEVBQXVCLEdBQXZCLEVBQTJCLEdBQUUsRUFBRSxDQUFGLENBQUYsSUFBUSxDQUFuQyxJQUFzQyxPQUFPLEVBQVA7QUFBUyxLQUF2RTtBQUFBLFFBQXdFLE1BQUksQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUE1RTtBQUFBLFFBQWtGLE1BQUksQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUF0RjtBQUFBLFFBQTRGLE1BQUksQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFoRztBQUFBLFFBQXNHLE1BQUksQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUExRztBQUFBLFFBQWdILE1BQUksQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFwSDtBQUFBLFFBQTBILE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUE5SDtBQUFBLFFBQXFJLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUF6STtBQUFBLFFBQWdKLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFwSjtBQUFBLFFBQTJKLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUEvSjtBQUFBLFFBQXNLLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUExSztBQUFBLFFBQWlMLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFyTDtBQUFBLFFBQTRMLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFoTTtBQUFBLFFBQXVNLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUEzTTtBQUFBLFFBQWtOLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUF0TjtBQUFBLFFBQTZOLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFqTztBQUFBLFFBQXdPLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUE1TztBQUFBLFFBQW1QLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUF2UDtBQUFBLFFBQThQLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFsUTtBQUFBLFFBQXlRLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUE3UTtBQUFBLFFBQW9SLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUF4UjtBQUFBLFFBQStSLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFuUztBQUFBLFFBQTBTLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUE5UztBQUFBLFFBQXFULE1BQUksQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLEVBQUwsRUFBUSxFQUFSLEVBQVcsRUFBWCxFQUFjLEVBQWQsRUFBaUIsRUFBakIsRUFBb0IsRUFBcEIsRUFBdUIsRUFBdkIsRUFBMEIsRUFBMUIsRUFBNkIsRUFBN0IsRUFBZ0MsRUFBaEMsRUFBbUMsRUFBbkMsRUFBc0MsRUFBdEMsQ0FBelQ7QUFBQSxRQUFtVyxNQUFJLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxFQUFMLEVBQVEsRUFBUixFQUFXLEVBQVgsRUFBYyxFQUFkLEVBQWlCLEVBQWpCLEVBQW9CLEVBQXBCLEVBQXVCLEVBQXZCLEVBQTBCLEVBQTFCLEVBQTZCLEVBQTdCLEVBQWdDLEVBQWhDLEVBQW1DLEVBQW5DLEVBQXNDLEVBQXRDLEVBQXlDLEVBQXpDLENBQXZXO0FBQUEsUUFBb1osTUFBSSxDQUFDLENBQUQsRUFBRyxFQUFILENBQXhaO0FBQUEsUUFBK1osTUFBSSxDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssRUFBTCxFQUFRLEVBQVIsRUFBVyxFQUFYLEVBQWMsRUFBZCxFQUFpQixFQUFqQixFQUFvQixFQUFwQixFQUF1QixFQUF2QixFQUEwQixFQUExQixFQUE2QixFQUE3QixFQUFnQyxFQUFoQyxFQUFtQyxFQUFuQyxFQUFzQyxFQUF0QyxFQUF5QyxFQUF6QyxDQUFuYTtBQUFBLFFBQWdkLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxFQUFNLEVBQU4sRUFBUyxFQUFULEVBQVksRUFBWixFQUFlLEVBQWYsRUFBa0IsRUFBbEIsRUFBcUIsRUFBckIsRUFBd0IsRUFBeEIsRUFBMkIsRUFBM0IsQ0FBcGQ7QUFBQSxRQUFtZixNQUFJLENBQUMsQ0FBRCxFQUFHLEVBQUgsRUFBTSxFQUFOLEVBQVMsRUFBVCxFQUFZLEVBQVosRUFBZSxFQUFmLEVBQWtCLEVBQWxCLEVBQXFCLEVBQXJCLENBQXZmO0FBQUEsUUFBZ2hCLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxFQUFNLEVBQU4sRUFBUyxFQUFULEVBQVksRUFBWixFQUFlLEVBQWYsRUFBa0IsRUFBbEIsRUFBcUIsRUFBckIsRUFBd0IsRUFBeEIsRUFBMkIsRUFBM0IsRUFBOEIsRUFBOUIsRUFBaUMsRUFBakMsQ0FBcGhCO0FBQUEsUUFBeWpCLE1BQUksQ0FBQyxFQUFELEVBQUksRUFBSixFQUFPLEVBQVAsQ0FBN2pCO0FBQUEsUUFBd2tCLE1BQUksQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLEVBQUwsRUFBUSxFQUFSLEVBQVcsRUFBWCxFQUFjLEVBQWQsRUFBaUIsRUFBakIsRUFBb0IsRUFBcEIsRUFBdUIsRUFBdkIsRUFBMEIsRUFBMUIsRUFBNkIsRUFBN0IsRUFBZ0MsRUFBaEMsRUFBbUMsRUFBbkMsRUFBc0MsRUFBdEMsRUFBeUMsRUFBekMsRUFBNEMsRUFBNUMsQ0FBNWtCO0FBQ0EsUUFBSSxTQUFTLEVBQUMsT0FBTyxTQUFTLEtBQVQsR0FBaUIsQ0FBRyxDQUE1QjtBQUNiLFlBQUksRUFEUztBQUViLGtCQUFVLEVBQUMsU0FBUSxDQUFULEVBQVcsZUFBYyxDQUF6QixFQUEyQixjQUFhLENBQXhDLEVBQTBDLE9BQU0sQ0FBaEQsRUFBa0Qsb0JBQW1CLENBQXJFLEVBQXVFLFVBQVMsQ0FBaEYsRUFBa0YsVUFBUyxDQUEzRixFQUE2RixLQUFJLENBQWpHLEVBQW1HLEtBQUksRUFBdkcsRUFBMEcsS0FBSSxFQUE5RyxFQUFpSCxLQUFJLEVBQXJILEVBQXdILEtBQUksRUFBNUgsRUFBK0gsS0FBSSxFQUFuSSxFQUFzSSxLQUFJLEVBQTFJLEVBQTZJLE9BQU0sRUFBbkosRUFBc0osS0FBSSxFQUExSixFQUE2SixLQUFJLEVBQWpLLEVBQW9LLEtBQUksRUFBeEssRUFBMkssS0FBSSxFQUEvSyxFQUFrTCxZQUFXLEVBQTdMLEVBQWdNLFVBQVMsRUFBek0sRUFBNE0sU0FBUSxFQUFwTixFQUF1TixRQUFPLEVBQTlOLEVBQWlPLGNBQWEsRUFBOU8sRUFBaVAsS0FBSSxFQUFyUCxFQUF3UCxpQkFBZ0IsRUFBeFEsRUFBMlEsaUJBQWdCLEVBQTNSLEVBQThSLGNBQWEsRUFBM1MsRUFBOFMsS0FBSSxFQUFsVCxFQUFxVCxTQUFRLEVBQTdULEVBQWdVLEtBQUksRUFBcFUsRUFBdVUsS0FBSSxFQUEzVSxFQUE4VSxZQUFXLEVBQXpWLEVBQTRWLFdBQVUsRUFBdFcsRUFBeVcsVUFBUyxFQUFsWCxFQUFxWCxLQUFJLEVBQXpYLEVBQTRYLEtBQUksRUFBaFksRUFBbVksV0FBVSxDQUE3WSxFQUErWSxRQUFPLENBQXRaLEVBRkc7QUFHYixvQkFBWSxFQUFDLEdBQUUsS0FBSCxFQUFTLEdBQUUsUUFBWCxFQUFvQixHQUFFLEdBQXRCLEVBQTBCLElBQUcsR0FBN0IsRUFBaUMsSUFBRyxHQUFwQyxFQUF3QyxJQUFHLEdBQTNDLEVBQStDLElBQUcsR0FBbEQsRUFBc0QsSUFBRyxHQUF6RCxFQUE2RCxJQUFHLEdBQWhFLEVBQW9FLElBQUcsS0FBdkUsRUFBNkUsSUFBRyxHQUFoRixFQUFvRixJQUFHLEdBQXZGLEVBQTJGLElBQUcsR0FBOUYsRUFBa0csSUFBRyxHQUFyRyxFQUF5RyxJQUFHLFVBQTVHLEVBQXVILElBQUcsWUFBMUgsRUFBdUksSUFBRyxHQUExSSxFQUE4SSxJQUFHLGVBQWpKLEVBQWlLLElBQUcsZUFBcEssRUFBb0wsSUFBRyxZQUF2TCxFQUFvTSxJQUFHLEdBQXZNLEVBQTJNLElBQUcsT0FBOU0sRUFBc04sSUFBRyxHQUF6TixFQUE2TixJQUFHLEdBQWhPLEVBQW9PLElBQUcsVUFBdk8sRUFBa1AsSUFBRyxTQUFyUCxFQUErUCxJQUFHLFFBQWxRLEVBQTJRLElBQUcsR0FBOVEsRUFBa1IsSUFBRyxHQUFyUixFQUhDO0FBSWIsc0JBQWMsQ0FBQyxDQUFELEVBQUcsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFILEVBQVMsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFULEVBQWUsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFmLEVBQXFCLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBckIsRUFBMkIsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUEzQixFQUFpQyxDQUFDLENBQUQsRUFBRyxDQUFILENBQWpDLEVBQXVDLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBdkMsRUFBNkMsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUE3QyxFQUFtRCxDQUFDLENBQUQsRUFBRyxDQUFILENBQW5ELEVBQXlELENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBekQsRUFBK0QsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUEvRCxFQUFxRSxDQUFDLENBQUQsRUFBRyxDQUFILENBQXJFLEVBQTJFLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBM0UsRUFBaUYsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFqRixFQUF1RixDQUFDLENBQUQsRUFBRyxDQUFILENBQXZGLEVBQTZGLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBN0YsRUFBbUcsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFuRyxFQUF5RyxDQUFDLENBQUQsRUFBRyxDQUFILENBQXpHLEVBQStHLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBL0csRUFBcUgsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFySCxFQUEySCxDQUFDLENBQUQsRUFBRyxDQUFILENBQTNILEVBQWlJLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBakksRUFBdUksQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUF2SSxFQUE2SSxDQUFDLENBQUQsRUFBRyxDQUFILENBQTdJLEVBQW1KLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBbkosRUFBeUosQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUF6SixFQUErSixDQUFDLEVBQUQsRUFBSSxDQUFKLENBQS9KLEVBQXNLLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBdEssRUFBNkssQ0FBQyxFQUFELEVBQUksQ0FBSixDQUE3SyxFQUFvTCxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQXBMLEVBQTJMLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBM0wsRUFBa00sQ0FBQyxFQUFELEVBQUksQ0FBSixDQUFsTSxFQUF5TSxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQXpNLEVBQWdOLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBaE4sRUFBdU4sQ0FBQyxFQUFELEVBQUksQ0FBSixDQUF2TixFQUE4TixDQUFDLEVBQUQsRUFBSSxDQUFKLENBQTlOLEVBQXFPLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBck8sRUFBNE8sQ0FBQyxFQUFELEVBQUksQ0FBSixDQUE1TyxFQUFtUCxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQW5QLEVBQTBQLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBMVAsRUFBaVEsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUFqUSxFQUF3USxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQXhRLEVBQStRLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBL1EsRUFBc1IsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUF0UixFQUE2UixDQUFDLEVBQUQsRUFBSSxDQUFKLENBQTdSLEVBQW9TLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBcFMsRUFBMlMsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUEzUyxFQUFrVCxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQWxULEVBQXlULENBQUMsRUFBRCxFQUFJLENBQUosQ0FBelQsRUFBZ1UsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUFoVSxFQUF1VSxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQXZVLEVBQThVLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBOVUsRUFBcVYsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUFyVixFQUE0VixDQUFDLEVBQUQsRUFBSSxDQUFKLENBQTVWLEVBQW1XLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBblcsRUFBeVcsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUF6VyxFQUErVyxDQUFDLENBQUQsRUFBRyxDQUFILENBQS9XLEVBQXFYLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBclgsRUFBMlgsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUEzWCxFQUFpWSxDQUFDLENBQUQsRUFBRyxDQUFILENBQWpZLEVBQXVZLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBdlksQ0FKRDtBQUtiLHVCQUFlLFNBQVMsU0FBVCxDQUFtQixNQUFuQixFQUEyQixNQUEzQixFQUFtQyxRQUFuQyxFQUE2QyxFQUE3QyxFQUFpRCxPQUFqRCxDQUF5RCxlQUF6RCxFQUEwRSxFQUExRSxDQUE2RSxZQUE3RSxFQUEyRixFQUEzRixDQUE4RixZQUE5RixFQUE0RztBQUMzSDs7QUFFQSxnQkFBSSxLQUFLLEdBQUcsTUFBSCxHQUFZLENBQXJCO0FBQ0Esb0JBQVEsT0FBUjtBQUNBLHFCQUFLLENBQUw7O0FBRVEsMkJBQU8sR0FBRyxLQUFHLENBQU4sQ0FBUDs7QUFFUjtBQUNBLHFCQUFLLENBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsWUFBSCxDQUFnQixHQUFHLEVBQUgsRUFBTyxDQUFQLENBQWhCLENBQVQ7O0FBRVI7QUFDQSxxQkFBSyxDQUFMOztBQUVRLHlCQUFLLENBQUwsR0FBUyxHQUFHLFFBQUgsQ0FBWSxHQUFHLEVBQUgsQ0FBWixDQUFUOztBQUVSO0FBQ0EscUJBQUssQ0FBTDs7QUFFUSx5QkFBSyxDQUFMLEdBQVMsR0FBRyxTQUFILENBQWEsR0FBRyxFQUFILENBQWIsQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLENBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsa0JBQUgsQ0FBc0IsR0FBdEIsRUFBMkIsQ0FBQyxHQUFHLEtBQUcsQ0FBTixDQUFELEVBQVcsR0FBRyxFQUFILENBQVgsQ0FBM0IsQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLENBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsa0JBQUgsQ0FBc0IsR0FBdEIsRUFBMkIsQ0FBQyxHQUFHLEtBQUcsQ0FBTixDQUFELEVBQVcsR0FBRyxFQUFILENBQVgsQ0FBM0IsQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLENBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsa0JBQUgsQ0FBc0IsR0FBdEIsRUFBMkIsQ0FBQyxHQUFHLEtBQUcsQ0FBTixDQUFELEVBQVcsR0FBRyxFQUFILENBQVgsQ0FBM0IsQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLENBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsUUFBSCxDQUFZLEdBQUcsS0FBRyxDQUFOLENBQVosQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLENBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsa0JBQUgsQ0FBc0IsSUFBdEIsRUFBNEIsQ0FBQyxHQUFHLEtBQUcsQ0FBTixDQUFELEVBQVcsR0FBRyxFQUFILENBQVgsQ0FBNUIsQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLEVBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsa0JBQUgsQ0FBc0IsSUFBdEIsRUFBNEIsQ0FBQyxHQUFHLEtBQUcsQ0FBTixDQUFELEVBQVcsR0FBRyxFQUFILENBQVgsQ0FBNUIsQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLEVBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsa0JBQUgsQ0FBc0IsSUFBdEIsRUFBNEIsQ0FBQyxHQUFHLEtBQUcsQ0FBTixDQUFELEVBQVcsR0FBRyxFQUFILENBQVgsQ0FBNUIsQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLEVBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsa0JBQUgsQ0FBc0IsS0FBdEIsRUFBNkIsQ0FBQyxHQUFHLEtBQUcsQ0FBTixDQUFELEVBQVcsR0FBRyxFQUFILENBQVgsQ0FBN0IsQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLEVBQUw7O0FBRVEseUJBQUssQ0FBTCxHQUFTLEdBQUcsa0JBQUgsQ0FBc0IsR0FBdEIsRUFBMkIsQ0FBQyxHQUFHLEtBQUcsQ0FBTixDQUFELEVBQVcsR0FBRyxFQUFILENBQVgsQ0FBM0IsQ0FBVDs7QUFFUjtBQUNBLHFCQUFLLEVBQUw7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QVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUNBO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLENBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxHQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxHQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sR0FBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEdBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFR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a016QixPQWxNeUIsRUFtTXpCLFFBbk15QixFQW9NekIsTUFwTXlCLEVBcU16QixNQXJNeUIsRUFzTXpCLE9BdE15QixFQXVNekIsS0F2TXlCLEVBd016QixNQXhNeUIsRUF5TXpCLEtBek15QixFQTBNekIsUUExTXlCLEVBMk16QixJQTNNeUIsRUE0TXpCLEtBNU15QixFQTZNekIsT0E3TXlCLEVBOE16QixRQTlNeUIsRUErTXpCLGNBL015QixFQWdOekIsYUFoTnlCLEVBaU56QixhQWpOeUIsRUFrTnpCLFlBbE55QixFQW1OekIsT0FuTnlCLEVBb056QixJQXBOeUIsRUFxTnpCLEtBck55QixFQXNOekIsT0F0TnlCLEVBdU56QixLQXZOeUIsRUF3TnpCLE1BeE55QixFQXlOekIsUUF6TnlCLEVBME56QixLQTFOeUIsRUEyTnpCLEtBM055QixFQTROekIsTUE1TnlCLEVBNk56QixPQTdOeUIsRUE4TnpCLFFBOU55QixFQStOekIsTUEvTnlCLEVBZ096QixLQWhPeUIsRUFpT3pCLFdBak95QixFQWtPekIsV0FsT3lCLEVBbU96QixVQW5PeUIsRUFvT3pCLFVBcE95QixFQXFPekIsT0FyT3lCLEVBc096QixRQXRPeUIsRUF1T3pCLGFBdk95QixFQXdPekIsVUF4T3lCLEVBeU96QixJQXpPeUIsRUEwT3pCLGVBMU95QixFQTJPekIsY0EzT3lCLEVBNE96QixhQTVPeUIsRUE2T3pCLFNBN095QixFQThPekIsV0E5T3lCLEVBK096QixVQS9PeUIsRUFnUHpCLGFBaFB5QixFQWlQekIsWUFqUHlCLEVBa1B6QixVQWxQeUIsRUFtUHpCLFNBblB5QixFQW9QekIsV0FwUHlCLEVBcVB6QixVQXJQeUIsRUFzUHpCLEtBdFB5QixFQXVQekIsS0F2UHlCLEVBd1B6QixNQXhQeUIsRUF5UHpCLEtBelB5QixFQTBQekIsU0ExUHlCLEVBMlB6QixTQTNQeUIsRUE0UHpCLFNBNVB5QixFQTZQekIsU0E3UHlCLEVBOFB6QixTQTlQeUIsRUErUHpCLEtBL1B5QixFQWdRekIsSUFoUXlCLEVBaVF6QixXQWpReUIsRUFrUXpCLFNBbFF5QixFQW1RekIsZUFuUXlCLEVBb1F6QixlQXBReUIsRUFxUXpCLGdCQXJReUIsRUFzUXpCLGdCQXRReUIsRUF1UXpCLFFBdlF5QixFQXdRekIsY0F4UXlCLEVBeVF6QixLQXpReUIsRUEwUXpCLElBMVF5QixFQTJRekIsS0EzUXlCLEVBNFF6QixjQTVReUIsRUE2UXpCLGFBN1F5QixFQThRekIsS0E5UXlCLEVBK1F6QixPQS9ReUIsRUFnUnpCLE1BaFJ5QixFQWlSekIsTUFqUnlCLEVBa1J6QixTQWxSeUIsRUFtUnpCLFFBblJ5QixFQW9SekIsSUFwUnlCLEVBcVJ6QixjQXJSeUIsRUFzUnpCLGNBdFJ5QixFQXVSekIsYUF2UnlCLEVBd1J6QixhQXhSeUIsRUF5UnpCLFVBelJ5QixFQTBSekIsU0ExUnlCLEVBMlJ6QixNQTNSeUIsRUE0UnpCLGFBNVJ5QixFQTZSekIsVUE3UnlCLEVBOFJ6QixTQTlSeUIsRUErUnpCLFNBL1J5QixFQWdTekIsUUFoU3lCLEVBaVN6QixNQWpTeUIsRUFrU3pCLFdBbFN5QixFQW1TekIsY0FuU3lCLEVBb1N6QixZQXBTeUIsRUFxU3pCLGNBclN5QixFQXNTekIsU0F0U3lCLEVBdVN6QixNQXZTeUIsRUF3U3pCLE9BeFN5QixFQXlTekIsT0F6U3lCLEVBMFN6QixPQTFTeUIsRUEyU3pCLFdBM1N5QixFQTRTekIsU0E1U3lCLEVBNlN6QixLQTdTeUIsRUE4U3pCLE1BOVN5QixFQStTekIsS0EvU3lCLEVBZ1R6QixLQWhUeUIsRUFpVHpCLFFBalR5QixFQWtUekIsS0FsVHlCLEVBbVR6QixNQW5UeUIsRUFvVHpCLFFBcFR5QixFQXFUekIsV0FyVHlCLEVBc1R6QixNQXRUeUIsRUF1VHpCLEtBdlR5QixFQXdUekIsTUF4VHlCLEVBeVR6QixNQXpUeUIsRUEwVHpCLFFBMVR5QixFQTJUekIsT0EzVHlCLEVBNFR6QixLQTVUeUIsRUE2VHpCLE9BN1R5QixFQThUekIsT0E5VHlCLEVBK1R6QixPQS9UeUIsRUFnVXpCLE9BaFV5QixFQWlVekIsTUFqVXlCLEVBa1V6QixRQWxVeUIsRUFtVXpCLGFBblV5QixFQW9VekIsU0FwVXlCLEVBcVV6QixTQXJVeUIsRUFzVXpCLFFBdFV5QixFQXVVekIsUUF2VXlCLEVBd1V6QixTQXhVeUIsRUF5VXpCLFFBelV5QixFQTBVekIsT0ExVXlCLEVBMlV6QixZQTNVeUIsRUE0VXpCLFVBNVV5QixFQTZVekIsS0E3VXlCLEVBOFV6QixPQTlVeUIsRUErVXpCLFFBL1V5QixFQWdWekIsWUFoVnlCLEVBaVZ6QixPQWpWeUIsRUFrVnpCLFVBbFZ5QixFQW1WekIsVUFuVnlCLEVBb1Z6QixTQXBWeUIsRUFxVnpCLFFBclZ5QixFQXNWekIsS0F0VnlCLEVBdVZ6QixHQXZWeUIsRUF3VnpCLFFBeFZ5QixFQXlWekIsV0F6VnlCLEVBMFZ6QixXQTFWeUIsRUEyVnpCLE9BM1Z5QixFQTRWekIsVUE1VnlCLEVBNlZ6QixLQTdWeUIsRUE4VnpCLE1BOVZ5QixFQStWekIsU0EvVnlCLEVBZ1d6QixZQWhXeUIsRUFpV3pCLFlBald5QixFQWtXekIsT0FsV3lCLEVBbVd6QixTQW5XeUIsRUFvV3pCLFNBcFd5QixFQXFXekIsTUFyV3lCLEVBc1d6QixNQXRXeUIsRUF1V3pCLFdBdld5QixFQXdXekIsTUF4V3lCLEVBeVd6QixRQXpXeUIsRUEwV3pCLE9BMVd5QixFQTJXekIsV0EzV3lCLEVBNFd6QixPQTVXeUIsRUE2V3pCLE1BN1d5QixFQThXekIsVUE5V3lCLEVBK1d6QixNQS9XeUIsRUFnWHpCLE9BaFh5QixFQWlYekIsU0FqWHlCLEVBa1h6QixTQWxYeUIsRUFtWHpCLFFBblh5QixFQW9YekIsT0FwWHlCLEVBcVh6QixPQXJYeUIsRUFzWHpCLE9BdFh5QixFQXVYekIsT0F2WHlCLEVBd1h6QixNQXhYeUIsRUF5WHpCLE1Belh5QixFQTBYekIsT0ExWHlCLEVBMlh6QixNQTNYeUIsRUE0WHpCLFNBNVh5QixFQTZYekIsU0E3WHlCLEVBOFh6QixjQTlYeUIsRUErWHpCLGFBL1h5QixFQWdZekIsU0FoWXlCLEVBaVl6QixNQWpZeUIsRUFrWXpCLE1BbFl5QixFQW1ZekIsS0FuWXlCLEVBb1l6QixNQXBZeUIsRUFxWXpCLFVBcll5QixDQUEzQjs7UUF3WThCLE8sR0FBdEIsa0I7Ozs7Ozs7Ozs7O1FDbFlRLFksR0FBQSxZO1FBaUJBLE8sR0FBQSxPO1FBU0Esa0IsR0FBQSxrQjtRQWNBLGtCLEdBQUEsa0I7UUFZQSxlLEdBQUEsZTtRQVdBLGUsR0FBQSxlO1FBU0EsUSxHQUFBLFE7UUFlQSxZLEdBQUEsWTtRQVNBLFMsR0FBQSxTO0FBdEdoQjs7OztBQUlBLElBQU0sdUJBQXVCLG1DQUE3Qjs7QUFFTyxTQUFTLFlBQVQsQ0FBc0IsS0FBdEIsRUFBNkI7QUFDaEMsUUFBSSxDQUFDLHFCQUFxQixJQUFyQixDQUEwQixLQUExQixDQUFMLEVBQXVDO0FBQ25DLGVBQU8sRUFBUDtBQUNIOztBQUgrQix1QkFJVyxNQUFNLEtBQU4sQ0FBWSxvQkFBWixDQUpYO0FBQUE7QUFBQSxRQUl2QixTQUp1QjtBQUFBLFFBSVosTUFKWTtBQUFBLFFBSUosTUFKSTtBQUFBLFFBSUksR0FKSjs7QUFNaEMsV0FBTyxDQUFDO0FBQ0osZUFBTyxnQkFBZ0IsR0FBaEIsQ0FESDtBQUVKLGVBQU8sR0FGSDtBQUdKLG9CQUFZLFdBQVc7QUFIbkIsS0FBRCxFQUlKO0FBQ0MsZUFBTyxtQkFBbUIsTUFBbkIsQ0FEUjtBQUVDLGVBQU8sTUFGUjtBQUdDLG9CQUFZLGNBQWM7QUFIM0IsS0FKSSxDQUFQO0FBU0g7O0FBRU0sU0FBUyxPQUFULENBQWlCLEdBQWpCLEVBQXNCLE1BQXRCLEVBQThCO0FBQ2pDLFFBQU0sV0FBVyxDQUFDLElBQUksVUFBSixHQUFpQixHQUFqQixHQUF1QixFQUF4QixJQUE4QixnQkFBZ0IsSUFBSSxLQUFwQixDQUEvQztBQUNBLFFBQU0sY0FBYyxDQUFDLE9BQU8sVUFBUCxHQUFvQixHQUFwQixHQUEwQixFQUEzQixJQUFpQyxtQkFBbUIsT0FBTyxLQUExQixDQUFyRDtBQUNBLFdBQU8sY0FBYyxRQUFyQjtBQUNIOztBQUVELElBQU0sb0JBQW9CLDRCQUExQjtBQUNBLElBQU0sMkJBQTJCLGtCQUFrQixNQUFuRDs7QUFFTyxTQUFTLGtCQUFULENBQTRCLEtBQTVCLEVBQW1DO0FBQ3RDLFFBQUksU0FBUyxDQUFiOztBQUVBLFFBQUksS0FBSixFQUFXO0FBQ1AsYUFBSyxJQUFJLElBQUksQ0FBUixFQUFXLElBQUksTUFBTSxNQUFOLEdBQWUsQ0FBbkMsRUFBc0MsSUFBSSxNQUFNLE1BQWhELEVBQXdELEtBQUssQ0FBTCxFQUFRLEtBQUssQ0FBckUsRUFBd0U7QUFDcEUsc0JBQVUsS0FBSyxHQUFMLENBQVMsd0JBQVQsRUFBbUMsQ0FBbkMsS0FBeUMsa0JBQWtCLE9BQWxCLENBQTBCLE1BQU0sQ0FBTixDQUExQixJQUFzQyxDQUEvRSxDQUFWO0FBQ0g7QUFDSjtBQUNELE1BQUUsTUFBRjs7QUFFQSxXQUFPLE1BQVA7QUFDSDs7QUFHTSxTQUFTLGtCQUFULENBQTRCLE1BQTVCLEVBQW9DO0FBQ3ZDLFFBQUksU0FBUyxFQUFiOztBQUVBLFdBQU8sVUFBVSxDQUFqQixFQUFvQjtBQUNoQixpQkFBUyxPQUFPLFlBQVAsQ0FBb0IsU0FBUyx3QkFBVCxHQUFvQyxFQUF4RCxJQUE4RCxNQUF2RTtBQUNBLGlCQUFTLEtBQUssS0FBTCxDQUFXLFNBQVMsd0JBQXBCLElBQWdELENBQXpEO0FBQ0g7O0FBRUQsV0FBTyxPQUFPLFdBQVAsRUFBUDtBQUNIOztBQUdNLFNBQVMsZUFBVCxDQUF5QixLQUF6QixFQUFnQztBQUNuQyxRQUFJLFNBQVMsU0FBUyxLQUFULEVBQWdCLEVBQWhCLENBQWI7O0FBRUEsUUFBSSxPQUFPLEtBQVAsQ0FBYSxNQUFiLENBQUosRUFBMEI7QUFDdEIsaUJBQVMsQ0FBQyxDQUFWO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsaUJBQVMsS0FBSyxHQUFMLENBQVMsU0FBUyxDQUFsQixFQUFxQixDQUFDLENBQXRCLENBQVQ7QUFDSDtBQUNELFdBQU8sTUFBUDtBQUNIOztBQUVNLFNBQVMsZUFBVCxDQUF5QixHQUF6QixFQUE4QjtBQUNqQyxXQUFPLE9BQU8sQ0FBUCxTQUFjLE1BQU0sQ0FBcEIsSUFBMEIsRUFBakM7QUFDSDs7QUFHRDs7OztBQUlPLFNBQVMsUUFBVCxDQUFrQixNQUFsQixFQUEwQjtBQUM3QixRQUFJLGVBQUo7QUFDQSxRQUFJLE9BQU8sTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM1QixpQkFBUyxNQUFUO0FBQ0gsS0FGRCxNQUVPLElBQUksT0FBTyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQ25DLGlCQUFTLE9BQU8sT0FBUCxDQUFlLEdBQWYsSUFBc0IsQ0FBQyxDQUF2QixHQUEyQixXQUFXLE1BQVgsQ0FBM0IsR0FBZ0QsU0FBUyxNQUFULEVBQWlCLEVBQWpCLENBQXpEO0FBQ0g7QUFDRCxXQUFPLE1BQVA7QUFDSDs7QUFFRDs7Ozs7QUFLTyxTQUFTLFlBQVQsQ0FBc0IsTUFBdEIsRUFBOEI7QUFDakMsV0FBTyxDQUFDLENBQUQsR0FBSyxTQUFTLE1BQVQsQ0FBWjtBQUNIOztBQUdEOzs7O0FBSU8sU0FBUyxTQUFULENBQW1CLE1BQW5CLEVBQXVDO0FBQUEsUUFBWixNQUFZLHVFQUFILENBQUc7O0FBQzFDLGFBQVMsT0FBTyxTQUFQLENBQWlCLE1BQWpCLEVBQXlCLE9BQU8sTUFBUCxHQUFnQixNQUF6QyxDQUFUO0FBQ0EsV0FBTyxNQUFQO0FBQ0g7Ozs7Ozs7O1FDbEdlLG1CLEdBQUEsbUI7UUFVQSwwQixHQUFBLDBCO1FBVUEseUIsR0FBQSx5QjtRQVVBLGtCLEdBQUEsa0I7O0FBcENoQjs7Ozs7O0FBTU8sU0FBUyxtQkFBVCxDQUE2QixVQUE3QixFQUF5QztBQUM1QyxXQUFPLGNBQWMsQ0FBQyxhQUFhLEVBQWQsRUFBa0IsTUFBbEIsQ0FBeUIsQ0FBekIsTUFBZ0MsR0FBOUMsR0FBb0QsSUFBcEQsR0FBMkQsS0FBbEU7QUFDSDs7QUFFRDs7Ozs7O0FBTU8sU0FBUywwQkFBVCxDQUFvQyxVQUFwQyxFQUFnRDtBQUNuRCxXQUFPLGNBQWUsQ0FBQyxhQUFhLEVBQWQsRUFBa0IsTUFBbEIsQ0FBeUIsQ0FBekIsTUFBZ0MsSUFBaEMsSUFBeUMsQ0FBQyxhQUFhLEVBQWQsRUFBa0IsTUFBbEIsQ0FBeUIsQ0FBekIsTUFBZ0MsR0FBeEYsR0FBZ0csSUFBaEcsR0FBdUcsS0FBOUc7QUFDSDs7QUFFRDs7Ozs7O0FBTU8sU0FBUyx5QkFBVCxDQUFtQyxVQUFuQyxFQUErQztBQUNsRCxXQUFPLDJCQUEyQixVQUEzQixJQUF5QyxXQUFXLE1BQVgsQ0FBa0IsQ0FBbEIsQ0FBekMsR0FBZ0UsVUFBdkU7QUFDSDs7QUFFRDs7Ozs7O0FBTU8sU0FBUyxrQkFBVCxDQUE0QixVQUE1QixFQUF3QztBQUMzQyxRQUFNLFVBQVUsd0RBQWhCO0FBQ0EsUUFBTSxVQUFVLFdBQVcsS0FBWCxDQUFpQixPQUFqQixLQUE2QixFQUE3QztBQUNBLFFBQUksUUFBUSxDQUFDLENBQWI7O0FBRUEsV0FBTyxXQUFXLFdBQVgsR0FBeUIsT0FBekIsQ0FBaUMsT0FBakMsRUFBMEMsWUFBVztBQUN4RCxVQUFFLEtBQUY7O0FBRUEsZUFBTyxRQUFRLEtBQVIsQ0FBUDtBQUNILEtBSk0sQ0FBUDtBQUtIOzs7Ozs7OztrQkMzQ3VCLFE7QUFKeEI7Ozs7QUFJZSxTQUFTLFFBQVQsQ0FBa0IsRUFBbEIsRUFBc0I7O0FBRWpDOztBQUVBO0FBQ0EsUUFBSSxDQUFDLEdBQUcsTUFBSCxDQUFVLEtBQWYsRUFBc0I7QUFDbEIsV0FBRyxNQUFILENBQVUsS0FBVixHQUFrQixVQUFVLENBQVYsRUFBYTtBQUMzQixtQkFBTyxNQUFNLENBQWI7QUFDSCxTQUZEO0FBR0g7O0FBRUQ7QUFDQSxRQUFJLE9BQU8sR0FBRyxNQUFILENBQVUsU0FBVixDQUFvQixRQUEzQixLQUF3QyxXQUE1QyxFQUF5RDtBQUNyRCxXQUFHLE1BQUgsQ0FBVSxTQUFWLENBQW9CLFFBQXBCLEdBQStCLFVBQVUsR0FBVixFQUFlO0FBQzFDLG1CQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBVjtBQUNILFNBRkQ7QUFHSDs7QUFFRDtBQUNBLFFBQUksQ0FBQyxPQUFPLFNBQVAsQ0FBaUIsVUFBdEIsRUFBa0M7QUFDOUIsZUFBTyxTQUFQLENBQWlCLFVBQWpCLEdBQThCLFVBQVUsWUFBVixFQUF3QixRQUF4QixFQUFrQztBQUM1RCx1QkFBVyxZQUFZLENBQXZCO0FBQ0EsbUJBQU8sS0FBSyxNQUFMLENBQVksUUFBWixFQUFzQixhQUFhLE1BQW5DLE1BQStDLFlBQXREO0FBQ0gsU0FIRDtBQUlIOztBQUdEOztBQUVBO0FBQ0EsUUFBSSxFQUFFLGVBQWUsU0FBUyxlQUExQixDQUFKLEVBQWdEO0FBQzVDLGVBQU8sY0FBUCxDQUFzQixZQUFZLFNBQWxDLEVBQTZDLFdBQTdDLEVBQTBEO0FBQ3RELGlCQUFLLGVBQVk7QUFDYixvQkFBSSxPQUFPLElBQVg7O0FBRUEseUJBQVMsTUFBVCxDQUFnQixFQUFoQixFQUFvQjtBQUNoQiwyQkFBTyxVQUFVLEtBQVYsRUFBaUI7QUFDcEIsNEJBQUksVUFBVSxLQUFLLFNBQUwsQ0FBZSxLQUFmLENBQXFCLE1BQXJCLENBQWQ7QUFDQSw0QkFBSSxRQUFRLFFBQVEsT0FBUixDQUFnQixLQUFoQixDQUFaOztBQUVBLDJCQUFHLE9BQUgsRUFBWSxLQUFaLEVBQW1CLEtBQW5CO0FBQ0EsNkJBQUssU0FBTCxHQUFpQixRQUFRLElBQVIsQ0FBYSxHQUFiLENBQWpCO0FBQ0gscUJBTkQ7QUFPSDs7QUFFRCx1QkFBTztBQUNILHlCQUFLLE9BQU8sVUFBVSxPQUFWLEVBQW1CLEtBQW5CLEVBQTBCLEtBQTFCLEVBQWlDO0FBQ3pDLDRCQUFJLENBQUMsQ0FBQyxLQUFOLEVBQWE7QUFDVCxvQ0FBUSxJQUFSLENBQWEsS0FBYjtBQUNIO0FBQ0oscUJBSkksQ0FERjs7QUFPSCw0QkFBUSxPQUFPLFVBQVUsT0FBVixFQUFtQixLQUFuQixFQUEwQjtBQUNyQyw0QkFBSSxDQUFDLEtBQUwsRUFBWTtBQUNSLG9DQUFRLE1BQVIsQ0FBZSxLQUFmLEVBQXNCLENBQXRCO0FBQ0g7QUFDSixxQkFKTyxDQVBMOztBQWFILDRCQUFRLE9BQU8sVUFBVSxPQUFWLEVBQW1CLEtBQW5CLEVBQTBCLEtBQTFCLEVBQWlDO0FBQzVDLDRCQUFJLENBQUMsS0FBTCxFQUFZO0FBQ1Isb0NBQVEsTUFBUixDQUFlLEtBQWYsRUFBc0IsQ0FBdEI7QUFDSCx5QkFGRCxNQUVPO0FBQ0gsb0NBQVEsSUFBUixDQUFhLEtBQWI7QUFDSDtBQUNKLHFCQU5PLENBYkw7O0FBcUJILDhCQUFVLGtCQUFVLEtBQVYsRUFBaUI7QUFDdkIsK0JBQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFMLENBQWUsS0FBZixDQUFxQixNQUFyQixFQUE2QixPQUE3QixDQUFxQyxLQUFyQyxDQUFWO0FBQ0gscUJBdkJFOztBQXlCSCwwQkFBTSxjQUFVLENBQVYsRUFBYTtBQUNmLCtCQUFPLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsTUFBckIsRUFBNkIsQ0FBN0IsS0FBbUMsSUFBMUM7QUFDSDtBQTNCRSxpQkFBUDtBQTZCSDtBQTNDcUQsU0FBMUQ7QUE2Q0g7QUFFSjs7Ozs7Ozs7QUNsRkQ7OztBQUdBLElBQUksaUJBQWlCO0FBQ2pCLGNBQVUsWUFETztBQUVqQix1QkFBbUIsV0FGRjs7QUFJakIsV0FBTzs7QUFFSDs7O0FBR0Esb0JBQVksS0FMVDs7QUFPSDs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxtQkFBVyxrQkF2QlI7O0FBeUJILGtCQUFVO0FBekJQOztBQUpVLENBQXJCOztBQW1DQTs7O0FBR0EsSUFBSSxrQkFBa0I7O0FBRWxCLGNBQVU7QUFDTixxQkFBYSxNQURQO0FBRU4sZ0JBQVEsQ0FBQztBQUNMLGtCQUFNO0FBREQsU0FBRDtBQUZGLEtBRlE7O0FBU2xCLGdCQUFZOztBQVRNLENBQXRCOztRQWFRLGMsR0FBQSxjO1FBQWdCLGUsR0FBQSxlOzs7Ozs7OztBQ3REeEI7Ozs7OztBQU1BLFNBQVMsT0FBVCxHQUFtQjtBQUNmO0FBQ0g7O0FBRUQsUUFBUSxTQUFSLEdBQW9COztBQUVoQjs7Ozs7OztBQU9BLFFBQUksWUFBVSxJQUFWLEVBQWdCLFFBQWhCLEVBQTBCLEdBQTFCLEVBQStCO0FBQy9CLFlBQUksSUFBSSxLQUFLLENBQUwsS0FBVyxLQUFLLENBQUwsR0FBUyxFQUFwQixDQUFSOztBQUVBLFNBQUMsRUFBRSxJQUFGLE1BQVksRUFBRSxJQUFGLElBQVUsRUFBdEIsQ0FBRCxFQUE0QixJQUE1QixDQUFpQztBQUM3QixnQkFBSSxRQUR5QjtBQUU3QixpQkFBSztBQUZ3QixTQUFqQzs7QUFLQSxlQUFPLElBQVA7QUFDSCxLQWxCZTs7QUFvQmhCOzs7Ozs7O0FBT0EsVUFBTSxjQUFVLElBQVYsRUFBZ0IsUUFBaEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDakMsWUFBSSxPQUFPLElBQVg7O0FBRUEsaUJBQVMsUUFBVCxHQUFvQjtBQUNoQixpQkFBSyxHQUFMLENBQVMsSUFBVCxFQUFlLFFBQWY7QUFDQSxxQkFBUyxLQUFULENBQWUsR0FBZixFQUFvQixTQUFwQjtBQUNIOztBQUVELGlCQUFTLENBQVQsR0FBYSxRQUFiO0FBQ0EsZUFBTyxLQUFLLEVBQUwsQ0FBUSxJQUFSLEVBQWMsUUFBZCxFQUF3QixHQUF4QixDQUFQO0FBQ0gsS0FyQ2U7O0FBdUNoQjs7Ozs7QUFLQSxVQUFNLGNBQVUsSUFBVixFQUFnQjtBQUNsQixZQUFJLE9BQU8sR0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQWQsRUFBeUIsQ0FBekIsQ0FBWDtBQUNBLFlBQUksU0FBUyxDQUFDLENBQUMsS0FBSyxDQUFMLEtBQVcsS0FBSyxDQUFMLEdBQVMsRUFBcEIsQ0FBRCxFQUEwQixJQUExQixLQUFtQyxFQUFwQyxFQUF3QyxLQUF4QyxFQUFiO0FBQ0EsWUFBSSxJQUFJLENBQVI7QUFDQSxZQUFJLE1BQU0sT0FBTyxNQUFqQjs7QUFFQSxhQUFLLENBQUwsRUFBUSxJQUFJLEdBQVosRUFBaUIsR0FBakIsRUFBc0I7QUFDbEIsbUJBQU8sQ0FBUCxFQUFVLEVBQVYsQ0FBYSxLQUFiLENBQW1CLE9BQU8sQ0FBUCxFQUFVLEdBQTdCLEVBQWtDLElBQWxDO0FBQ0g7O0FBRUQsZUFBTyxJQUFQO0FBQ0gsS0F2RGU7O0FBeURoQjs7Ozs7O0FBTUEsU0FBSyxhQUFVLElBQVYsRUFBZ0IsUUFBaEIsRUFBMEI7QUFDM0IsWUFBSSxJQUFJLEtBQUssQ0FBTCxLQUFXLEtBQUssQ0FBTCxHQUFTLEVBQXBCLENBQVI7QUFDQSxZQUFJLE9BQU8sRUFBRSxJQUFGLENBQVg7QUFDQSxZQUFJLGFBQWEsRUFBakI7O0FBRUEsWUFBSSxRQUFRLFFBQVosRUFBc0I7QUFDbEIsaUJBQUssSUFBSSxJQUFJLENBQVIsRUFBVyxNQUFNLEtBQUssTUFBM0IsRUFBbUMsSUFBSSxHQUF2QyxFQUE0QyxHQUE1QyxFQUFpRDtBQUM3QyxvQkFBSSxLQUFLLENBQUwsRUFBUSxFQUFSLEtBQWUsUUFBZixJQUEyQixLQUFLLENBQUwsRUFBUSxFQUFSLENBQVcsQ0FBWCxLQUFpQixRQUFoRCxFQUEwRDtBQUN0RCwrQkFBVyxJQUFYLENBQWdCLEtBQUssQ0FBTCxDQUFoQjtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNDLG1CQUFXLE1BQVosR0FDTSxFQUFFLElBQUYsSUFBVSxVQURoQixHQUVNLE9BQU8sRUFBRSxJQUFGLENBRmI7O0FBSUEsZUFBTyxJQUFQO0FBQ0gsS0FsRmU7O0FBb0ZoQjs7O0FBR0Esc0JBQW9CLFlBQVk7QUFDNUIsWUFBSSxXQUFXLElBQUksT0FBSixFQUFmO0FBQ0EsZUFBTztBQUFBLG1CQUFNLFFBQU47QUFBQSxTQUFQO0FBQ0gsS0FIbUI7QUF2RkosQ0FBcEI7O2tCQTZGZSxPOztBQUVmOzs7O0FBR08sSUFBTSx3Q0FBZ0IsUUFBUSxTQUFSLENBQWtCLGdCQUFsQixFQUF0Qjs7Ozs7Ozs7UUN4R1MsTSxHQUFBLE07UUFPQSxVLEdBQUEsVTtRQXFCQSxhLEdBQUEsYTtRQVlBLFMsR0FBQSxTO1FBS0EsYyxHQUFBLGM7UUFXQSxZLEdBQUEsWTtRQWtCQSxZLEdBQUEsWTs7O0FBNUVoQjs7QUFFTyxTQUFTLE1BQVQsQ0FBZ0IsTUFBaEIsRUFBd0IsU0FBeEIsRUFBbUM7QUFDdEMsZUFBVyxTQUFYLEVBQXNCLFVBQUMsS0FBRCxFQUFRLEdBQVIsRUFBZ0I7QUFDbEMsZUFBTyxHQUFQLElBQWMsS0FBZDtBQUNILEtBRkQ7QUFHQSxXQUFPLE1BQVA7QUFDSDs7QUFFTSxTQUFTLFVBQVQsQ0FBb0IsTUFBcEIsRUFBNEIsUUFBNUIsRUFBc0M7QUFDekMsU0FBSyxJQUFJLEdBQVQsSUFBZ0IsTUFBaEIsRUFBd0I7QUFDcEIsWUFBSSxDQUFDLE9BQU8sY0FBUixJQUEyQixPQUFPLGNBQVAsSUFBeUIsT0FBTyxjQUFQLENBQXNCLEdBQXRCLENBQXhELEVBQXFGO0FBQ2pGLGdCQUFJLFNBQVMsT0FBTyxHQUFQLENBQVQsRUFBc0IsR0FBdEIsRUFBMkIsTUFBM0IsTUFBdUMsS0FBM0MsRUFBa0Q7QUFDOUM7QUFDSDtBQUNKO0FBQ0o7QUFDRCxXQUFPLE1BQVA7QUFDSDs7QUFFRDs7QUFFQSxJQUFJLFdBQVcsU0FBWCxRQUFXLEdBQVksQ0FDMUIsQ0FERDs7QUFHQTs7Ozs7QUFLTyxTQUFTLGFBQVQsR0FBdUM7QUFBQSxRQUFoQixNQUFnQix1RUFBUCxLQUFPOztBQUMxQyxRQUFJLE1BQUosRUFBWTtBQUNSLGVBQU8sWUFBWSxDQUNsQixDQUREO0FBRUg7QUFDRCxXQUFPLFFBQVA7QUFDSDs7QUFHRDs7O0FBR08sU0FBUyxTQUFULENBQW1CLEdBQW5CLEVBQXdCO0FBQzNCLFdBQU8sSUFBSSxXQUFKLEVBQVA7QUFDSDs7QUFHTSxTQUFTLGNBQVQsQ0FBd0IsR0FBeEIsRUFBNkI7QUFDaEMsV0FBTyxJQUFJLE9BQUosQ0FBWSxNQUFaLEVBQW9CO0FBQUEsZUFBSyxVQUFVLENBQVYsQ0FBTDtBQUFBLEtBQXBCLENBQVA7QUFDSDs7QUFLRDs7OztBQUlPLFNBQVMsWUFBVCxHQUF3QjtBQUMzQixhQUFTLEVBQVQsR0FBYztBQUNWLGVBQU8sS0FBSyxLQUFMLENBQVcsQ0FBQyxJQUFJLEtBQUssTUFBTCxFQUFMLElBQXNCLE9BQWpDLEVBQ0YsUUFERSxDQUNPLEVBRFAsRUFFRixTQUZFLENBRVEsQ0FGUixDQUFQO0FBR0g7QUFDRCxXQUFPLE9BQU8sSUFBUCxHQUFjLElBQWQsR0FBcUIsSUFBNUI7QUFDSDs7QUFHRDs7QUFFQTs7Ozs7O0FBTU8sU0FBUyxZQUFULENBQXNCLEtBQXRCLEVBQTZCO0FBQ2hDLFdBQVEsVUFBVSxFQUFWLElBQWdCLFVBQVUsSUFBMUIsSUFBa0MsT0FBTyxLQUFQLEtBQWlCLFdBQTNEO0FBQ0g7O0FBR0Q7OztBQUdBLElBQUksWUFBWSxTQUFaLFNBQVksQ0FBVSxFQUFWLEVBQWMsRUFBZCxFQUFrQjtBQUM5QixXQUFPLEdBQUcsQ0FBSCxNQUFVLEdBQUcsQ0FBSCxDQUFWLElBQW1CLEdBQUcsQ0FBSCxNQUFVLEdBQUcsQ0FBSCxDQUE3QixJQUFzQyxHQUFHLENBQUgsTUFBVSxHQUFHLENBQUgsQ0FBaEQsSUFBeUQsR0FBRyxDQUFILE1BQVUsR0FBRyxDQUFILENBQTFFO0FBQ0gsQ0FGRDs7QUFJQSxJQUFJLGlCQUFpQixTQUFqQixjQUFpQixDQUFVLEVBQVYsRUFBYyxFQUFkLEVBQWtCO0FBQ25DLFFBQUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxHQUFHLENBQUgsQ0FBVCxFQUFnQixHQUFHLENBQUgsQ0FBaEIsQ0FBVDtBQUNBLFFBQUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxHQUFHLENBQUgsQ0FBVCxFQUFnQixHQUFHLENBQUgsQ0FBaEIsQ0FBVDtBQUNBLFFBQUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxHQUFHLENBQUgsQ0FBVCxFQUFnQixHQUFHLENBQUgsQ0FBaEIsQ0FBVDtBQUNBLFFBQUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxHQUFHLENBQUgsQ0FBVCxFQUFnQixHQUFHLENBQUgsQ0FBaEIsQ0FBVDs7QUFFQSxRQUFJLE1BQU0sRUFBTixJQUFZLE1BQU0sRUFBdEIsRUFBMEI7QUFDdEIsZUFBTyxDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLEVBQWIsQ0FBUDtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0gsQ0FWRDs7QUFZQSxJQUFJLFFBQVEsU0FBUixLQUFRLENBQVUsQ0FBVixFQUFhO0FBQ3JCLFdBQU8sVUFBVSxFQUFWLEVBQWMsRUFBZCxFQUFrQjtBQUNyQixZQUFJLE1BQU0sZUFBZSxFQUFmLEVBQW1CLEVBQW5CLENBQVY7QUFDQSxZQUFJLEdBQUosRUFBUztBQUNMLG1CQUFPLFVBQVUsR0FBVixFQUFlLE1BQU0sS0FBTixHQUFjLEVBQWQsR0FBbUIsRUFBbEMsQ0FBUDtBQUNIO0FBQ0QsZUFBTyxLQUFQO0FBQ0gsS0FORDtBQU9ILENBUkQ7O0FBVU8sSUFBSSxrQ0FBYTs7QUFFcEI7Ozs7Ozs7Ozs7Ozs7O0FBY0EsYUFBUyxTQWhCVzs7QUFrQnBCOzs7O0FBSUEsa0JBQWMsY0F0Qk07O0FBd0JwQjs7OztBQUlBLGNBQVUsTUFBTSxLQUFOLENBNUJVOztBQThCcEI7Ozs7QUFJQSxnQkFBWSxNQUFNLEtBQU47QUFsQ1EsQ0FBakI7O0FBcUNQOzs7Ozs7Ozs7Ozs7QUNySkE7Ozs7QUFFQTs7O0lBR00sa0I7QUFFRixnQ0FBWSxRQUFaLEVBQXNCO0FBQUE7O0FBQ2xCLGFBQUssSUFBTCxHQUFZLElBQUksR0FBSixDQUFRLFFBQVIsQ0FBWjtBQUNBLGFBQUssS0FBTCxHQUFhLEVBQWI7QUFDSDs7Ozs0QkFFRyxHLEVBQUs7QUFDTCxnQkFBSSxRQUFRLEtBQUssS0FBTCxDQUFXLHVCQUFVLEdBQVYsQ0FBWCxDQUFaO0FBQ0EsbUJBQU8sS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLEtBQWQsQ0FBUDtBQUNIOzs7NEJBRUcsRyxFQUFLLEssRUFBTztBQUNaLGlCQUFLLEtBQUwsQ0FBVyx1QkFBVSxHQUFWLENBQVgsSUFBNkIsR0FBN0I7QUFDQSxtQkFBTyxLQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZCxFQUFtQixLQUFuQixDQUFQO0FBQ0g7Ozs0QkFFRyxHLEVBQUs7QUFDTCxtQkFBTyxLQUFLLEtBQUwsQ0FBVyx1QkFBVSxHQUFWLENBQVgsQ0FBUDtBQUNIOzs7aUNBRVEsRyxFQUFLO0FBQ1YsbUJBQU8sS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQsQ0FBUDtBQUNIOzs7Z0NBRU87QUFDSixpQkFBSyxLQUFMLEdBQWEsRUFBYjtBQUNBLG1CQUFPLEtBQUssSUFBTCxDQUFVLEtBQVYsRUFBUDtBQUNIOzs7Z0NBRU0sRyxFQUFLO0FBQ1IsZ0JBQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyx1QkFBVSxHQUFWLENBQVgsQ0FBWjtBQUNBLG1CQUFPLEtBQUssS0FBTCxDQUFXLHVCQUFVLEdBQVYsQ0FBWCxDQUFQO0FBQ0EsbUJBQU8sS0FBSyxJQUFMLENBQVUsTUFBVixDQUFpQixLQUFqQixDQUFQO0FBQ0g7OztrQ0FFUztBQUNOLG1CQUFPLEtBQUssSUFBTCxDQUFVLE9BQVYsRUFBUDtBQUNIOzs7Z0NBRU8sVSxFQUFZLE8sRUFBUztBQUN6QixtQkFBTyxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLFVBQWxCLEVBQThCLE9BQTlCLENBQVA7QUFDSDs7QUFFRDs7Ozs7OzsrQkFJTztBQUNILG1CQUFPLEtBQUssSUFBTCxDQUFVLElBQVYsRUFBUDtBQUNIOzs7aUNBRVE7QUFDTCxtQkFBTyxLQUFLLElBQUwsQ0FBVSxNQUFWLEVBQVA7QUFDSDs7O2dDQUVPO0FBQ0osbUJBQU8sS0FBSyxJQUFaO0FBQ0g7OzsrQkFFTTtBQUNILG1CQUFPLEtBQUssSUFBTCxDQUFVLElBQWpCO0FBQ0g7Ozs7OztBQUlMOzs7OztJQUdNLEs7QUFDRixxQkFBMEI7QUFBQSxZQUFkLE9BQWMsdUVBQUosRUFBSTs7QUFBQTs7QUFDdEIsYUFBSyxLQUFMLEdBQWEsT0FBYjtBQUNIOzs7OytCQUVjO0FBQUE7O0FBQ1gsMkJBQUssS0FBTCxFQUFXLElBQVg7QUFDSDs7OzhCQUVLO0FBQ0YsbUJBQU8sS0FBSyxLQUFMLENBQVcsR0FBWCxFQUFQO0FBQ0g7OzsrQkFFTTtBQUNILG1CQUFPLEtBQUssT0FBTCxLQUFpQixLQUFLLENBQXRCLEdBQTBCLEtBQUssS0FBTCxDQUFXLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsQ0FBL0IsQ0FBakM7QUFDSDs7O2tDQUVTO0FBQ04sbUJBQU8sQ0FBQyxLQUFLLElBQUwsRUFBUjtBQUNIOzs7K0JBRU07QUFDSCxtQkFBTyxLQUFLLEtBQUwsQ0FBVyxNQUFsQjtBQUNIOzs7Ozs7UUFJRyxrQixHQUFBLGtCO1FBQW9CLEssR0FBQSxLOzs7Ozs7OztRQzVGWixTLEdBQUEsUztRQXVCQSxXLEdBQUEsVztRQWlCQSxPLEdBQUEsTztRQWtCQSxLLEdBQUEsSztRQWtCQSxXLEdBQUEsVztRQW9CQSxVLEdBQUEsVTtBQXpHaEIsSUFBSSxxQkFBcUIsU0FBUyxjQUFULENBQXdCLE1BQXhCLEVBQWdDLFdBQWhDLEdBQThDLElBQTlDLEdBQXFELEtBQTlFOztBQUVBLElBQUksc0JBQXNCLGlCQUExQjs7QUFFQTs7Ozs7QUFLTyxTQUFTLFNBQVQsQ0FBbUIsT0FBbkIsRUFBNEIsT0FBNUIsRUFBcUM7QUFDeEMsUUFBSSxvQkFBb0IsSUFBcEIsQ0FBeUIsT0FBekIsQ0FBSixFQUF1QztBQUNuQyxnQkFBUSxTQUFSLEdBQW9CLE9BQXBCO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsWUFBSSxRQUFRLFFBQVEsVUFBcEI7QUFDQSxZQUFJLFNBQVMsTUFBTSxRQUFOLEtBQW1CLENBQTVCLElBQWlDLE1BQU0sV0FBTixLQUFzQixJQUEzRCxFQUFpRTtBQUM3RCxnQkFBSSxrQkFBSixFQUF3QjtBQUNwQixzQkFBTSxXQUFOLEdBQW9CLE9BQXBCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsc0JBQU0sSUFBTixHQUFhLE9BQWI7QUFDSDtBQUNKLFNBTkQsTUFNTztBQUNILGtCQUFNLE9BQU47QUFDQSxvQkFBUSxXQUFSLENBQW9CLFNBQVMsY0FBVCxDQUF3QixPQUF4QixDQUFwQjtBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7QUFLTyxTQUFTLFdBQVQsQ0FBcUIsT0FBckIsRUFBOEIsT0FBOUIsRUFBdUM7QUFDMUMsUUFBSSxvQkFBb0IsSUFBcEIsQ0FBeUIsT0FBekIsQ0FBSixFQUF1QztBQUNuQyxnQkFBUSxrQkFBUixDQUEyQixVQUEzQixFQUF1QyxPQUF2QztBQUNILEtBRkQsTUFFTztBQUNILFlBQUksUUFBUSxRQUFSLEtBQXFCLENBQXpCLEVBQTRCO0FBQ3hCLGdCQUFJLFFBQVEsV0FBWixFQUF5QjtBQUNyQix3QkFBUSxVQUFSLENBQW1CLFlBQW5CLENBQWdDLE9BQWhDLEVBQXlDLFFBQVEsV0FBakQ7QUFDSCxhQUZELE1BRU87QUFDSCx3QkFBUSxVQUFSLENBQW1CLFdBQW5CLENBQStCLE9BQS9CO0FBQ0g7QUFDSixTQU5ELE1BTU87QUFDSDtBQUNIO0FBQ0o7QUFDSjs7QUFHTSxTQUFTLE9BQVQsQ0FBaUIsT0FBakIsRUFBMEIsUUFBMUIsRUFBb0M7QUFDdkMsUUFBSSxHQUFKO0FBQ0EsT0FBRztBQUNDLGtCQUFVLFFBQVEsVUFBbEI7QUFDQSxZQUFJLENBQUMsT0FBRCxJQUFZLENBQUMsUUFBUSxhQUFyQixLQUF1QyxNQUFNLFFBQVEsYUFBUixDQUFzQixRQUF0QixDQUE3QyxDQUFKLEVBQW1GO0FBQy9FO0FBQ0g7QUFDSixLQUxELFFBS1MsT0FMVDs7QUFPQSxXQUFPLEdBQVA7QUFDSDs7QUFFRDs7Ozs7O0FBTU8sU0FBUyxLQUFULENBQWUsT0FBZixFQUF3QjtBQUMzQixRQUFJLEtBQUo7QUFDQSxXQUFPLFFBQVEsUUFBUSxTQUF2QixFQUFrQztBQUFFO0FBQ2hDLFlBQUk7QUFDQSxvQkFBUSxXQUFSLENBQW9CLEtBQXBCO0FBQ0gsU0FGRCxDQUVFLE9BQU8sQ0FBUCxFQUFVO0FBQ1I7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTLFdBQVQsQ0FBcUIsRUFBckIsRUFBNEM7QUFBQSxRQUFuQixVQUFtQix1RUFBTixJQUFNOztBQUMvQyxRQUFJLFNBQVMsR0FBRyxZQUFoQjtBQUNBLFFBQUksS0FBSjs7QUFFQSxRQUFJLGVBQWUsS0FBbkIsRUFBMEI7QUFDdEIsZUFBTyxNQUFQO0FBQ0g7QUFDRCxZQUFRLGlCQUFpQixFQUFqQixDQUFSO0FBQ0EsY0FBVSxTQUFTLE1BQU0sU0FBZixJQUE0QixTQUFTLE1BQU0sWUFBZixDQUF0QztBQUNBLFdBQU8sTUFBUDtBQUNIOztBQUdEOzs7Ozs7O0FBT08sU0FBUyxVQUFULENBQW9CLEVBQXBCLEVBQTJDO0FBQUEsUUFBbkIsVUFBbUIsdUVBQU4sSUFBTTs7QUFDOUMsUUFBSSxRQUFRLEdBQUcsV0FBZjtBQUNBLFFBQUksS0FBSjs7QUFFQSxRQUFJLGVBQWUsS0FBbkIsRUFBMEI7QUFDdEIsZUFBTyxLQUFQO0FBQ0g7QUFDRCxZQUFRLGlCQUFpQixFQUFqQixDQUFSO0FBQ0EsYUFBUyxTQUFTLE1BQU0sVUFBZixJQUE2QixTQUFTLE1BQU0sV0FBZixDQUF0QztBQUNBLFdBQU8sS0FBUDtBQUNIOzs7Ozs7OztRQy9HZSx3QixHQUFBLHdCO1FBU0EsZSxHQUFBLGU7QUFiaEI7Ozs7QUFJTyxTQUFTLHdCQUFULENBQWtDLEtBQWxDLEVBQXlDO0FBQzVDLFVBQU0sNkJBQU4sR0FBc0MsS0FBdEM7QUFDQSxVQUFNLFlBQU4sR0FBcUIsSUFBckI7QUFDSDs7QUFFRDs7OztBQUlPLFNBQVMsZUFBVCxDQUF5QixLQUF6QixFQUFnQztBQUNuQyxRQUFJLE9BQU8sTUFBTSxlQUFiLEtBQWlDLFVBQXJDLEVBQWlEO0FBQzdDLGNBQU0sZUFBTjtBQUNILEtBRkQsTUFFTztBQUNILGNBQU0sWUFBTixHQUFxQixJQUFyQjtBQUNIO0FBQ0o7Ozs7Ozs7O0FDbkJELElBQUksWUFBWSxhQUFhLE1BQWIsQ0FBb0IsU0FBcEM7QUFDQSxJQUFJLGVBQWUsYUFBYSxNQUFiLENBQW9CLFlBQXZDOztBQUVBLElBQU0sYUFBYSxZQUFuQjs7QUFFQTs7Ozs7QUFLQSxJQUFNLGFBQWE7O0FBRWYsaUJBQWEsT0FBTyxNQUFQLENBQWMsSUFBZCxDQUZFOztBQUlmOzs7Ozs7QUFNQSxrQkFBYyxzQkFBVSxHQUFWLEVBQWUsUUFBZixFQUF5QjtBQUNuQyxZQUFJLENBQUMsS0FBSyxXQUFMLENBQWlCLEdBQWpCLENBQUwsRUFBNEI7QUFDeEIsaUJBQUssV0FBTCxDQUFpQixHQUFqQixJQUF3QixFQUF4QjtBQUNIO0FBQ0QsYUFBSyxXQUFMLENBQWlCLEdBQWpCLEVBQXNCLElBQXRCLENBQTJCLFFBQTNCO0FBQ0gsS0FmYzs7QUFpQmY7Ozs7OztBQU1BLG1CQUFlLHVCQUFVLEdBQVYsRUFBMEI7QUFBQTs7QUFBQSwwQ0FBUixNQUFRO0FBQVIsa0JBQVE7QUFBQTs7QUFDckMsWUFBSSxLQUFLLFdBQUwsQ0FBaUIsR0FBakIsQ0FBSixFQUEyQjtBQUN2QixzQkFBVSxLQUFLLFdBQUwsQ0FBaUIsR0FBakIsQ0FBVixFQUFpQyxVQUFDLFFBQUQ7QUFBQSx1QkFBYyxTQUFTLEtBQVQsUUFBcUIsTUFBckIsQ0FBZDtBQUFBLGFBQWpDO0FBQ0g7QUFDSixLQTNCYzs7QUE2QmY7OztBQUdBLHFCQUFpQiwyQkFBWTtBQUN6QixhQUFLLFdBQUwsR0FBbUIsRUFBbkI7QUFDSDtBQWxDYyxDQUFuQjs7QUFxQ0EsYUFBYSxVQUFiLEVBQXlCLFlBQXpCLEVBQXVDLFVBQXZDLEVBQW1EO0FBQy9DLGNBQVUsS0FEcUM7QUFFL0MsZ0JBQVk7QUFGbUMsQ0FBbkQ7O2tCQUtlLFUiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibnVtZXJpY1wiKSwgcmVxdWlyZShcIm51bWVyYWxcIiksIHJlcXVpcmUoXCJqU3RhdFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJudW1lcmljXCIsIFwibnVtZXJhbFwiLCBcImpTdGF0XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZvcm11bGFqc1wiXSA9IGZhY3RvcnkocmVxdWlyZShcIm51bWVyaWNcIiksIHJlcXVpcmUoXCJudW1lcmFsXCIpLCByZXF1aXJlKFwialN0YXRcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImZvcm11bGFqc1wiXSA9IGZhY3Rvcnkocm9vdFtcIm51bWVyaWNcIl0sIHJvb3RbXCJudW1lcmFsXCJdLCByb290W1wialN0YXRcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzlfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgY2F0ZWdvcmllcyA9IFtcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTUpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTIpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTYpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMiksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg3KSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTApXG5cdF07XG5cblx0Zm9yICh2YXIgYyBpbiBjYXRlZ29yaWVzKSB7XG5cdCAgdmFyIGNhdGVnb3J5ID0gY2F0ZWdvcmllc1tjXTtcblx0ICBmb3IgKHZhciBmIGluIGNhdGVnb3J5KSB7XG5cdCAgICBleHBvcnRzW2ZdID0gZXhwb3J0c1tmXSB8fCBjYXRlZ29yeVtmXTtcblx0ICB9XG5cdH1cblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIG1hdGhUcmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIHN0YXRpc3RpY2FsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIGVuZ2luZWVyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdHZhciBkYXRlVGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG5cdGZ1bmN0aW9uIHNldChmbiwgcm9vdCkge1xuXHQgIGlmIChyb290KSB7XG5cdCAgICBmb3IgKHZhciBpIGluIHJvb3QpIHtcblx0ICAgICAgZm5baV0gPSByb290W2ldO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gZm47XG5cdH1cblxuXHRleHBvcnRzLkJFVEFESVNUID0gc3RhdGlzdGljYWwuQkVUQS5ESVNUO1xuXHRleHBvcnRzLkJFVEFJTlYgPSBzdGF0aXN0aWNhbC5CRVRBLklOVjtcblx0ZXhwb3J0cy5CSU5PTURJU1QgPSBzdGF0aXN0aWNhbC5CSU5PTS5ESVNUO1xuXHRleHBvcnRzLkNFSUxJTkcgPSBleHBvcnRzLklTT0NFSUxJTkcgPSBzZXQobWF0aFRyaWcuQ0VJTElORy5NQVRILCBtYXRoVHJpZy5DRUlMSU5HKTtcblx0ZXhwb3J0cy5DRUlMSU5HTUFUSCA9IG1hdGhUcmlnLkNFSUxJTkcuTUFUSDtcblx0ZXhwb3J0cy5DRUlMSU5HUFJFQ0lTRSA9IG1hdGhUcmlnLkNFSUxJTkcuUFJFQ0lTRTtcblx0ZXhwb3J0cy5DSElESVNUID0gc3RhdGlzdGljYWwuQ0hJU1EuRElTVDtcblx0ZXhwb3J0cy5DSElESVNUUlQgPSBzdGF0aXN0aWNhbC5DSElTUS5ESVNULlJUO1xuXHRleHBvcnRzLkNISUlOViA9IHN0YXRpc3RpY2FsLkNISVNRLklOVjtcblx0ZXhwb3J0cy5DSElJTlZSVCA9IHN0YXRpc3RpY2FsLkNISVNRLklOVi5SVDtcblx0ZXhwb3J0cy5DSElURVNUID0gc3RhdGlzdGljYWwuQ0hJU1EuVEVTVDtcblx0ZXhwb3J0cy5DT05GSURFTkNFID0gc2V0KHN0YXRpc3RpY2FsLkNPTkZJREVOQ0UuTk9STSwgc3RhdGlzdGljYWwuQ09ORklERU5DRSk7XG5cdGV4cG9ydHMuQ09WQVIgPSBzdGF0aXN0aWNhbC5DT1ZBUklBTkNFLlA7XG5cdGV4cG9ydHMuQ09WQVJJQU5DRVAgPSBzdGF0aXN0aWNhbC5DT1ZBUklBTkNFLlA7XG5cdGV4cG9ydHMuQ09WQVJJQU5DRVMgPSBzdGF0aXN0aWNhbC5DT1ZBUklBTkNFLlM7XG5cdGV4cG9ydHMuQ1JJVEJJTk9NID0gc3RhdGlzdGljYWwuQklOT00uSU5WO1xuXHRleHBvcnRzLkVYUE9ORElTVCA9IHN0YXRpc3RpY2FsLkVYUE9OLkRJU1Q7XG5cdGV4cG9ydHMuRVJGQ1BSRUNJU0UgPSBlbmdpbmVlcmluZy5FUkZDLlBSRUNJU0U7XG5cdGV4cG9ydHMuRVJGUFJFQ0lTRSA9IGVuZ2luZWVyaW5nLkVSRi5QUkVDSVNFO1xuXHRleHBvcnRzLkZESVNUID0gc3RhdGlzdGljYWwuRi5ESVNUO1xuXHRleHBvcnRzLkZESVNUUlQgPSBzdGF0aXN0aWNhbC5GLkRJU1QuUlQ7XG5cdGV4cG9ydHMuRklOVlJUID0gc3RhdGlzdGljYWwuRi5JTlYuUlQ7XG5cdGV4cG9ydHMuRklOViA9IHN0YXRpc3RpY2FsLkYuSU5WO1xuXHRleHBvcnRzLkZMT09SID0gc2V0KG1hdGhUcmlnLkZMT09SLk1BVEgsIG1hdGhUcmlnLkZMT09SKTtcblx0ZXhwb3J0cy5GTE9PUk1BVEggPSBtYXRoVHJpZy5GTE9PUi5NQVRIO1xuXHRleHBvcnRzLkZMT09SUFJFQ0lTRSA9IG1hdGhUcmlnLkZMT09SLlBSRUNJU0U7XG5cdGV4cG9ydHMuRlRFU1QgPSBzdGF0aXN0aWNhbC5GLlRFU1Q7XG5cdGV4cG9ydHMuR0FNTUFESVNUID0gc3RhdGlzdGljYWwuR0FNTUEuRElTVDtcblx0ZXhwb3J0cy5HQU1NQUlOViA9IHN0YXRpc3RpY2FsLkdBTU1BLklOVjtcblx0ZXhwb3J0cy5HQU1NQUxOUFJFQ0lTRSA9IHN0YXRpc3RpY2FsLkdBTU1BTE4uUFJFQ0lTRTtcblx0ZXhwb3J0cy5IWVBHRU9NRElTVCA9IHN0YXRpc3RpY2FsLkhZUEdFT00uRElTVDtcblx0ZXhwb3J0cy5MT0dJTlYgPSBzdGF0aXN0aWNhbC5MT0dOT1JNLklOVjtcblx0ZXhwb3J0cy5MT0dOT1JNSU5WID0gc3RhdGlzdGljYWwuTE9HTk9STS5JTlY7XG5cdGV4cG9ydHMuTE9HTk9STURJU1QgPSBzdGF0aXN0aWNhbC5MT0dOT1JNLkRJU1Q7XG5cdGV4cG9ydHMuTU9ERSA9IHNldChzdGF0aXN0aWNhbC5NT0RFLlNOR0wsIHN0YXRpc3RpY2FsLk1PREUpO1xuXHRleHBvcnRzLk1PREVNVUxUID0gc3RhdGlzdGljYWwuTU9ERS5NVUxUO1xuXHRleHBvcnRzLk1PREVTTkdMID0gc3RhdGlzdGljYWwuTU9ERS5TTkdMO1xuXHRleHBvcnRzLk5FR0JJTk9NRElTVCA9IHN0YXRpc3RpY2FsLk5FR0JJTk9NLkRJU1Q7XG5cdGV4cG9ydHMuTkVUV09SS0RBWVNJTlRMID0gZGF0ZVRpbWUuTkVUV09SS0RBWVMuSU5UTDtcblx0ZXhwb3J0cy5OT1JNRElTVCA9IHN0YXRpc3RpY2FsLk5PUk0uRElTVDtcblx0ZXhwb3J0cy5OT1JNSU5WID0gc3RhdGlzdGljYWwuTk9STS5JTlY7XG5cdGV4cG9ydHMuTk9STVNESVNUID0gc3RhdGlzdGljYWwuTk9STS5TLkRJU1Q7XG5cdGV4cG9ydHMuTk9STVNJTlYgPSBzdGF0aXN0aWNhbC5OT1JNLlMuSU5WO1xuXHRleHBvcnRzLlBFUkNFTlRJTEUgPSBzZXQoc3RhdGlzdGljYWwuUEVSQ0VOVElMRS5FWEMsIHN0YXRpc3RpY2FsLlBFUkNFTlRJTEUpO1xuXHRleHBvcnRzLlBFUkNFTlRJTEVFWEMgPSBzdGF0aXN0aWNhbC5QRVJDRU5USUxFLkVYQztcblx0ZXhwb3J0cy5QRVJDRU5USUxFSU5DID0gc3RhdGlzdGljYWwuUEVSQ0VOVElMRS5JTkM7XG5cdGV4cG9ydHMuUEVSQ0VOVFJBTksgPSBzZXQoc3RhdGlzdGljYWwuUEVSQ0VOVFJBTksuSU5DLCBzdGF0aXN0aWNhbC5QRVJDRU5UUkFOSyk7XG5cdGV4cG9ydHMuUEVSQ0VOVFJBTktFWEMgPSBzdGF0aXN0aWNhbC5QRVJDRU5UUkFOSy5FWEM7XG5cdGV4cG9ydHMuUEVSQ0VOVFJBTktJTkMgPSBzdGF0aXN0aWNhbC5QRVJDRU5UUkFOSy5JTkM7XG5cdGV4cG9ydHMuUE9JU1NPTiA9IHNldChzdGF0aXN0aWNhbC5QT0lTU09OLkRJU1QsIHN0YXRpc3RpY2FsLlBPSVNTT04pO1xuXHRleHBvcnRzLlBPSVNTT05ESVNUID0gc3RhdGlzdGljYWwuUE9JU1NPTi5ESVNUO1xuXHRleHBvcnRzLlFVQVJUSUxFID0gc2V0KHN0YXRpc3RpY2FsLlFVQVJUSUxFLklOQywgc3RhdGlzdGljYWwuUVVBUlRJTEUpO1xuXHRleHBvcnRzLlFVQVJUSUxFRVhDID0gc3RhdGlzdGljYWwuUVVBUlRJTEUuRVhDO1xuXHRleHBvcnRzLlFVQVJUSUxFSU5DID0gc3RhdGlzdGljYWwuUVVBUlRJTEUuSU5DO1xuXHRleHBvcnRzLlJBTksgPSBzZXQoc3RhdGlzdGljYWwuUkFOSy5FUSwgc3RhdGlzdGljYWwuUkFOSyk7XG5cdGV4cG9ydHMuUkFOS0FWRyA9IHN0YXRpc3RpY2FsLlJBTksuQVZHO1xuXHRleHBvcnRzLlJBTktFUSA9IHN0YXRpc3RpY2FsLlJBTksuRVE7XG5cdGV4cG9ydHMuU0tFV1AgPSBzdGF0aXN0aWNhbC5TS0VXLlA7XG5cdGV4cG9ydHMuU1RERVYgPSBzZXQoc3RhdGlzdGljYWwuU1RERVYuUywgc3RhdGlzdGljYWwuU1RERVYpO1xuXHRleHBvcnRzLlNUREVWUCA9IHN0YXRpc3RpY2FsLlNUREVWLlA7XG5cdGV4cG9ydHMuU1RERVZTID0gc3RhdGlzdGljYWwuU1RERVYuUztcblx0ZXhwb3J0cy5URElTVCA9IHN0YXRpc3RpY2FsLlQuRElTVDtcblx0ZXhwb3J0cy5URElTVFJUID0gc3RhdGlzdGljYWwuVC5ESVNULlJUO1xuXHRleHBvcnRzLlRJTlYgPSBzdGF0aXN0aWNhbC5ULklOVjtcblx0ZXhwb3J0cy5UVEVTVCA9IHN0YXRpc3RpY2FsLlQuVEVTVDtcblx0ZXhwb3J0cy5WQVIgPSBzZXQoc3RhdGlzdGljYWwuVkFSLlMsIHN0YXRpc3RpY2FsLlZBUik7XG5cdGV4cG9ydHMuVkFSUCA9IHN0YXRpc3RpY2FsLlZBUi5QO1xuXHRleHBvcnRzLlZBUlMgPSBzdGF0aXN0aWNhbC5WQVIuUztcblx0ZXhwb3J0cy5XRUlCVUxMID0gc2V0KHN0YXRpc3RpY2FsLldFSUJVTEwuRElTVCwgc3RhdGlzdGljYWwuV0VJQlVMTCk7XG5cdGV4cG9ydHMuV0VJQlVMTERJU1QgPSBzdGF0aXN0aWNhbC5XRUlCVUxMLkRJU1Q7XG5cdGV4cG9ydHMuV09SS0RBWUlOVEwgPSBkYXRlVGltZS5XT1JLREFZLklOVEw7XG5cdGV4cG9ydHMuWlRFU1QgPSBzdGF0aXN0aWNhbC5aLlRFU1Q7XG5cblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBudW1lcmljID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIHN0YXRpc3RpY2FsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIGluZm9ybWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblx0ZXhwb3J0cy5BQlMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguYWJzKHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQUNPUyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hY29zKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5BQ09TSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5sb2cobnVtYmVyICsgTWF0aC5zcXJ0KG51bWJlciAqIG51bWJlciAtIDEpKTtcblx0fTtcblxuXHRleHBvcnRzLkFDT1QgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguYXRhbigxIC8gbnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkFDT1RIID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiAwLjUgKiBNYXRoLmxvZygobnVtYmVyICsgMSkgLyAobnVtYmVyIC0gMSkpO1xuXHR9O1xuXG5cdC8vVE9ETzogdXNlIG9wdGlvbnNcblx0ZXhwb3J0cy5BR0dSRUdBVEUgPSBmdW5jdGlvbihmdW5jdGlvbl9udW0sIG9wdGlvbnMsIHJlZjEsIHJlZjIpIHtcblx0ICBmdW5jdGlvbl9udW0gPSB1dGlscy5wYXJzZU51bWJlcihmdW5jdGlvbl9udW0pO1xuXHQgIG9wdGlvbnMgPSB1dGlscy5wYXJzZU51bWJlcihmdW5jdGlvbl9udW0pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGZ1bmN0aW9uX251bSwgb3B0aW9ucykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgc3dpdGNoIChmdW5jdGlvbl9udW0pIHtcblx0ICAgIGNhc2UgMTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkFWRVJBR0UocmVmMSk7XG5cdCAgICBjYXNlIDI6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5DT1VOVChyZWYxKTtcblx0ICAgIGNhc2UgMzpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkNPVU5UQShyZWYxKTtcblx0ICAgIGNhc2UgNDpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLk1BWChyZWYxKTtcblx0ICAgIGNhc2UgNTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLk1JTihyZWYxKTtcblx0ICAgIGNhc2UgNjpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUFJPRFVDVChyZWYxKTtcblx0ICAgIGNhc2UgNzpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlNUREVWLlMocmVmMSk7XG5cdCAgICBjYXNlIDg6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TVERFVi5QKHJlZjEpO1xuXHQgICAgY2FzZSA5OlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5TVU0ocmVmMSk7XG5cdCAgICBjYXNlIDEwOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuVkFSLlMocmVmMSk7XG5cdCAgICBjYXNlIDExOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuVkFSLlAocmVmMSk7XG5cdCAgICBjYXNlIDEyOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTUVESUFOKHJlZjEpO1xuXHQgICAgY2FzZSAxMzpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLk1PREUuU05HTChyZWYxKTtcblx0ICAgIGNhc2UgMTQ6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5MQVJHRShyZWYxLCByZWYyKTtcblx0ICAgIGNhc2UgMTU6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TTUFMTChyZWYxLCByZWYyKTtcblx0ICAgIGNhc2UgMTY6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5QRVJDRU5USUxFLklOQyhyZWYxLCByZWYyKTtcblx0ICAgIGNhc2UgMTc6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5RVUFSVElMRS5JTkMocmVmMSwgcmVmMik7XG5cdCAgICBjYXNlIDE4OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuUEVSQ0VOVElMRS5FWEMocmVmMSwgcmVmMik7XG5cdCAgICBjYXNlIDE5OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuUVVBUlRJTEUuRVhDKHJlZjEsIHJlZjIpO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkFSQUJJQyA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICAvLyBDcmVkaXRzOiBSYWZhPyBLdWthd3NraVxuXHQgIGlmICghL15NKig/OkQ/Q3swLDN9fENbTURdKSg/Okw/WHswLDN9fFhbQ0xdKSg/OlY/SXswLDN9fElbWFZdKSQvLnRlc3QodGV4dCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHIgPSAwO1xuXHQgIHRleHQucmVwbGFjZSgvW01ETFZdfENbTURdP3xYW0NMXT98SVtYVl0/L2csIGZ1bmN0aW9uKGkpIHtcblx0ICAgIHIgKz0ge1xuXHQgICAgICBNOiAxMDAwLFxuXHQgICAgICBDTTogOTAwLFxuXHQgICAgICBEOiA1MDAsXG5cdCAgICAgIENEOiA0MDAsXG5cdCAgICAgIEM6IDEwMCxcblx0ICAgICAgWEM6IDkwLFxuXHQgICAgICBMOiA1MCxcblx0ICAgICAgWEw6IDQwLFxuXHQgICAgICBYOiAxMCxcblx0ICAgICAgSVg6IDksXG5cdCAgICAgIFY6IDUsXG5cdCAgICAgIElWOiA0LFxuXHQgICAgICBJOiAxXG5cdCAgICB9W2ldO1xuXHQgIH0pO1xuXHQgIHJldHVybiByO1xuXHR9O1xuXG5cdGV4cG9ydHMuQVNJTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hc2luKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5BU0lOSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5sb2cobnVtYmVyICsgTWF0aC5zcXJ0KG51bWJlciAqIG51bWJlciArIDEpKTtcblx0fTtcblxuXHRleHBvcnRzLkFUQU4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguYXRhbihudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQVRBTjIgPSBmdW5jdGlvbihudW1iZXJfeCwgbnVtYmVyX3kpIHtcblx0ICBudW1iZXJfeCA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcl94KTtcblx0ICBudW1iZXJfeSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcl95KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXJfeCwgbnVtYmVyX3kpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmF0YW4yKG51bWJlcl94LCBudW1iZXJfeSk7XG5cdH07XG5cblx0ZXhwb3J0cy5BVEFOSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5sb2coKDEgKyBudW1iZXIpIC8gKDEgLSBudW1iZXIpKSAvIDI7XG5cdH07XG5cblx0ZXhwb3J0cy5CQVNFID0gZnVuY3Rpb24obnVtYmVyLCByYWRpeCwgbWluX2xlbmd0aCkge1xuXHQgIG1pbl9sZW5ndGggPSBtaW5fbGVuZ3RoIHx8IDA7XG5cblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHJhZGl4ID0gdXRpbHMucGFyc2VOdW1iZXIocmFkaXgpO1xuXHQgIG1pbl9sZW5ndGggPSB1dGlscy5wYXJzZU51bWJlcihtaW5fbGVuZ3RoKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHJhZGl4LCBtaW5fbGVuZ3RoKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBtaW5fbGVuZ3RoID0gKG1pbl9sZW5ndGggPT09IHVuZGVmaW5lZCkgPyAwIDogbWluX2xlbmd0aDtcblx0ICB2YXIgcmVzdWx0ID0gbnVtYmVyLnRvU3RyaW5nKHJhZGl4KTtcblx0ICByZXR1cm4gbmV3IEFycmF5KE1hdGgubWF4KG1pbl9sZW5ndGggKyAxIC0gcmVzdWx0Lmxlbmd0aCwgMCkpLmpvaW4oJzAnKSArIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkNFSUxJTkcgPSBmdW5jdGlvbihudW1iZXIsIHNpZ25pZmljYW5jZSwgbW9kZSkge1xuXHQgIHNpZ25pZmljYW5jZSA9IChzaWduaWZpY2FuY2UgPT09IHVuZGVmaW5lZCkgPyAxIDogTWF0aC5hYnMoc2lnbmlmaWNhbmNlKTtcblx0ICBtb2RlID0gbW9kZSB8fCAwO1xuXG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBzaWduaWZpY2FuY2UgPSB1dGlscy5wYXJzZU51bWJlcihzaWduaWZpY2FuY2UpO1xuXHQgIG1vZGUgPSB1dGlscy5wYXJzZU51bWJlcihtb2RlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHNpZ25pZmljYW5jZSwgbW9kZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHNpZ25pZmljYW5jZSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXHQgIHZhciBwcmVjaXNpb24gPSAtTWF0aC5mbG9vcihNYXRoLmxvZyhzaWduaWZpY2FuY2UpIC8gTWF0aC5sb2coMTApKTtcblx0ICBpZiAobnVtYmVyID49IDApIHtcblx0ICAgIHJldHVybiBleHBvcnRzLlJPVU5EKE1hdGguY2VpbChudW1iZXIgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlLCBwcmVjaXNpb24pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAobW9kZSA9PT0gMCkge1xuXHQgICAgICByZXR1cm4gLWV4cG9ydHMuUk9VTkQoTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpIC8gc2lnbmlmaWNhbmNlKSAqIHNpZ25pZmljYW5jZSwgcHJlY2lzaW9uKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiAtZXhwb3J0cy5ST1VORChNYXRoLmNlaWwoTWF0aC5hYnMobnVtYmVyKSAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQ0VJTElORy5NQVRIID0gZXhwb3J0cy5DRUlMSU5HO1xuXG5cdGV4cG9ydHMuQ0VJTElORy5QUkVDSVNFID0gZXhwb3J0cy5DRUlMSU5HO1xuXG5cdGV4cG9ydHMuQ09NQklOID0gZnVuY3Rpb24obnVtYmVyLCBudW1iZXJfY2hvc2VuKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBudW1iZXJfY2hvc2VuID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyX2Nob3Nlbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBudW1iZXJfY2hvc2VuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gZXhwb3J0cy5GQUNUKG51bWJlcikgLyAoZXhwb3J0cy5GQUNUKG51bWJlcl9jaG9zZW4pICogZXhwb3J0cy5GQUNUKG51bWJlciAtIG51bWJlcl9jaG9zZW4pKTtcblx0fTtcblxuXHRleHBvcnRzLkNPTUJJTkEgPSBmdW5jdGlvbihudW1iZXIsIG51bWJlcl9jaG9zZW4pIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIG51bWJlcl9jaG9zZW4gPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXJfY2hvc2VuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIG51bWJlcl9jaG9zZW4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAobnVtYmVyID09PSAwICYmIG51bWJlcl9jaG9zZW4gPT09IDApID8gMSA6IGV4cG9ydHMuQ09NQklOKG51bWJlciArIG51bWJlcl9jaG9zZW4gLSAxLCBudW1iZXIgLSAxKTtcblx0fTtcblxuXHRleHBvcnRzLkNPUyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5jb3MobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkNPU0ggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIChNYXRoLmV4cChudW1iZXIpICsgTWF0aC5leHAoLW51bWJlcikpIC8gMjtcblx0fTtcblxuXHRleHBvcnRzLkNPVCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gMSAvIE1hdGgudGFuKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1RIID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHZhciBlMiA9IE1hdGguZXhwKDIgKiBudW1iZXIpO1xuXHQgIHJldHVybiAoZTIgKyAxKSAvIChlMiAtIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ1NDID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiAxIC8gTWF0aC5zaW4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkNTQ0ggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIDIgLyAoTWF0aC5leHAobnVtYmVyKSAtIE1hdGguZXhwKC1udW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLkRFQ0lNQUwgPSBmdW5jdGlvbihudW1iZXIsIHJhZGl4KSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cblx0ICByZXR1cm4gcGFyc2VJbnQobnVtYmVyLCByYWRpeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5ERUdSRUVTID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBudW1iZXIgKiAxODAgLyBNYXRoLlBJO1xuXHR9O1xuXG5cdGV4cG9ydHMuRVZFTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gZXhwb3J0cy5DRUlMSU5HKG51bWJlciwgLTIsIC0xKTtcblx0fTtcblxuXHRleHBvcnRzLkVYUCA9IE1hdGguZXhwO1xuXG5cdHZhciBNRU1PSVpFRF9GQUNUID0gW107XG5cdGV4cG9ydHMuRkFDVCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICB2YXIgbiA9IE1hdGguZmxvb3IobnVtYmVyKTtcblx0ICBpZiAobiA9PT0gMCB8fCBuID09PSAxKSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9IGVsc2UgaWYgKE1FTU9JWkVEX0ZBQ1Rbbl0gPiAwKSB7XG5cdCAgICByZXR1cm4gTUVNT0laRURfRkFDVFtuXTtcblx0ICB9IGVsc2Uge1xuXHQgICAgTUVNT0laRURfRkFDVFtuXSA9IGV4cG9ydHMuRkFDVChuIC0gMSkgKiBuO1xuXHQgICAgcmV0dXJuIE1FTU9JWkVEX0ZBQ1Rbbl07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuRkFDVERPVUJMRSA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICB2YXIgbiA9IE1hdGguZmxvb3IobnVtYmVyKTtcblx0ICBpZiAobiA8PSAwKSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIG4gKiBleHBvcnRzLkZBQ1RET1VCTEUobiAtIDIpO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkZMT09SID0gZnVuY3Rpb24obnVtYmVyLCBzaWduaWZpY2FuY2UpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHNpZ25pZmljYW5jZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNpZ25pZmljYW5jZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBzaWduaWZpY2FuY2UpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChzaWduaWZpY2FuY2UgPT09IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIGlmICghKG51bWJlciA+IDAgJiYgc2lnbmlmaWNhbmNlID4gMCkgJiYgIShudW1iZXIgPCAwICYmIHNpZ25pZmljYW5jZSA8IDApKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHNpZ25pZmljYW5jZSA9IE1hdGguYWJzKHNpZ25pZmljYW5jZSk7XG5cdCAgdmFyIHByZWNpc2lvbiA9IC1NYXRoLmZsb29yKE1hdGgubG9nKHNpZ25pZmljYW5jZSkgLyBNYXRoLmxvZygxMCkpO1xuXHQgIGlmIChudW1iZXIgPj0gMCkge1xuXHQgICAgcmV0dXJuIGV4cG9ydHMuUk9VTkQoTWF0aC5mbG9vcihudW1iZXIgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlLCBwcmVjaXNpb24pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gLWV4cG9ydHMuUk9VTkQoTWF0aC5jZWlsKE1hdGguYWJzKG51bWJlcikgLyBzaWduaWZpY2FuY2UpLCBwcmVjaXNpb24pO1xuXHQgIH1cblx0fTtcblxuXHQvL1RPRE86IFZlcmlmeVxuXHRleHBvcnRzLkZMT09SLk1BVEggPSBmdW5jdGlvbihudW1iZXIsIHNpZ25pZmljYW5jZSwgbW9kZSkge1xuXHQgIHNpZ25pZmljYW5jZSA9IChzaWduaWZpY2FuY2UgPT09IHVuZGVmaW5lZCkgPyAxIDogc2lnbmlmaWNhbmNlO1xuXHQgIG1vZGUgPSAobW9kZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBtb2RlO1xuXG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBzaWduaWZpY2FuY2UgPSB1dGlscy5wYXJzZU51bWJlcihzaWduaWZpY2FuY2UpO1xuXHQgIG1vZGUgPSB1dGlscy5wYXJzZU51bWJlcihtb2RlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHNpZ25pZmljYW5jZSwgbW9kZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHNpZ25pZmljYW5jZSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgc2lnbmlmaWNhbmNlID0gc2lnbmlmaWNhbmNlID8gTWF0aC5hYnMoc2lnbmlmaWNhbmNlKSA6IDE7XG5cdCAgdmFyIHByZWNpc2lvbiA9IC1NYXRoLmZsb29yKE1hdGgubG9nKHNpZ25pZmljYW5jZSkgLyBNYXRoLmxvZygxMCkpO1xuXHQgIGlmIChudW1iZXIgPj0gMCkge1xuXHQgICAgcmV0dXJuIGV4cG9ydHMuUk9VTkQoTWF0aC5mbG9vcihudW1iZXIgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlLCBwcmVjaXNpb24pO1xuXHQgIH0gZWxzZSBpZiAobW9kZSA9PT0gMCB8fCBtb2RlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiAtZXhwb3J0cy5ST1VORChNYXRoLmNlaWwoTWF0aC5hYnMobnVtYmVyKSAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdCAgfVxuXHQgIHJldHVybiAtZXhwb3J0cy5ST1VORChNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlLCBwcmVjaXNpb24pO1xuXHR9O1xuXG5cdC8vIERlcHJlY2F0ZWRcblx0ZXhwb3J0cy5GTE9PUi5QUkVDSVNFID0gZXhwb3J0cy5GTE9PUi5NQVRIO1xuXG5cdC8vIGFkYXB0ZWQgaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0dyZWF0ZXN0X2NvbW1vbl9kaXZpc29yI0phdmFTY3JpcHRcblx0ZXhwb3J0cy5HQ0QgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHIwID0gcmFuZ2VbMF07XG5cdCAgdmFyIHggPSByMCA8IDAgPyAtcjAgOiByMDtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHQgICAgdmFyIHJpID0gcmFuZ2VbaV07XG5cdCAgICB2YXIgeSA9IHJpIDwgMCA/IC1yaSA6IHJpO1xuXHQgICAgd2hpbGUgKHggJiYgeSkge1xuXHQgICAgICBpZiAoeCA+IHkpIHtcblx0ICAgICAgICB4ICU9IHk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgeSAlPSB4O1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICB4ICs9IHk7XG5cdCAgfVxuXHQgIHJldHVybiB4O1xuXHR9O1xuXG5cblx0ZXhwb3J0cy5JTlQgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcblx0fTtcblxuXHQvL1RPRE86IHZlcmlmeVxuXHRleHBvcnRzLklTTyA9IHtcblx0ICBDRUlMSU5HOiBleHBvcnRzLkNFSUxJTkdcblx0fTtcblxuXHRleHBvcnRzLkxDTSA9IGZ1bmN0aW9uKCkge1xuXHQgIC8vIENyZWRpdHM6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YVxuXHQgIHZhciBvID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChvIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBvO1xuXHQgIH1cblx0ICBmb3IgKHZhciBpLCBqLCBuLCBkLCByID0gMTtcblx0ICAgIChuID0gby5wb3AoKSkgIT09IHVuZGVmaW5lZDspIHtcblx0ICAgIHdoaWxlIChuID4gMSkge1xuXHQgICAgICBpZiAobiAlIDIpIHtcblx0ICAgICAgICBmb3IgKGkgPSAzLCBqID0gTWF0aC5mbG9vcihNYXRoLnNxcnQobikpOyBpIDw9IGogJiYgbiAlIGk7IGkgKz0gMikge1xuXHQgICAgICAgICAgLy9lbXB0eVxuXHQgICAgICAgIH1cblx0ICAgICAgICBkID0gKGkgPD0gaikgPyBpIDogbjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBkID0gMjtcblx0ICAgICAgfVxuXHQgICAgICBmb3IgKG4gLz0gZCwgciAqPSBkLCBpID0gby5sZW5ndGg7IGk7XG5cdCAgICAgICAgKG9bLS1pXSAlIGQpID09PSAwICYmIChvW2ldIC89IGQpID09PSAxICYmIG8uc3BsaWNlKGksIDEpKSB7XG5cdCAgICAgICAgLy9lbXB0eVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByO1xuXHR9O1xuXG5cdGV4cG9ydHMuTE4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgubG9nKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5MT0cgPSBmdW5jdGlvbihudW1iZXIsIGJhc2UpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGJhc2UgPSB1dGlscy5wYXJzZU51bWJlcihiYXNlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIGJhc2UpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGJhc2UgPSAoYmFzZSA9PT0gdW5kZWZpbmVkKSA/IDEwIDogYmFzZTtcblx0ICByZXR1cm4gTWF0aC5sb2cobnVtYmVyKSAvIE1hdGgubG9nKGJhc2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTE9HMTAgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgubG9nKG51bWJlcikgLyBNYXRoLmxvZygxMCk7XG5cdH07XG5cblx0ZXhwb3J0cy5NREVURVJNID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdCAgbWF0cml4ID0gdXRpbHMucGFyc2VNYXRyaXgobWF0cml4KTtcblx0ICBpZiAobWF0cml4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBtYXRyaXg7XG5cdCAgfVxuXHQgIHJldHVybiBudW1lcmljLmRldChtYXRyaXgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlOVkVSU0UgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0ICBtYXRyaXggPSB1dGlscy5wYXJzZU1hdHJpeChtYXRyaXgpO1xuXHQgIGlmIChtYXRyaXggaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG1hdHJpeDtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyaWMuaW52KG1hdHJpeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5NTVVMVCA9IGZ1bmN0aW9uKG1hdHJpeDEsIG1hdHJpeDIpIHtcblx0ICBtYXRyaXgxID0gdXRpbHMucGFyc2VNYXRyaXgobWF0cml4MSk7XG5cdCAgbWF0cml4MiA9IHV0aWxzLnBhcnNlTWF0cml4KG1hdHJpeDIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG1hdHJpeDEsIG1hdHJpeDIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBudW1lcmljLmRvdChtYXRyaXgxLCBtYXRyaXgyKTtcblx0fTtcblxuXHRleHBvcnRzLk1PRCA9IGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG5cdCAgZGl2aWRlbmQgPSB1dGlscy5wYXJzZU51bWJlcihkaXZpZGVuZCk7XG5cdCAgZGl2aXNvciA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpdmlzb3IpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRpdmlkZW5kLCBkaXZpc29yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoZGl2aXNvciA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLmRpdjA7XG5cdCAgfVxuXHQgIHZhciBtb2R1bHVzID0gTWF0aC5hYnMoZGl2aWRlbmQgJSBkaXZpc29yKTtcblx0ICByZXR1cm4gKGRpdmlzb3IgPiAwKSA/IG1vZHVsdXMgOiAtbW9kdWx1cztcblx0fTtcblxuXHQgIGV4cG9ydHMuTVJPVU5EID0gZnVuY3Rpb24obnVtYmVyLCBtdWx0aXBsZSkge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgbXVsdGlwbGUgPSB1dGlscy5wYXJzZU51bWJlcihtdWx0aXBsZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBtdWx0aXBsZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKG51bWJlciAqIG11bHRpcGxlIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgLyBtdWx0aXBsZSkgKiBtdWx0aXBsZTtcblx0fTtcblxuXHRleHBvcnRzLk1VTFRJTk9NSUFMID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKGFyZ3MgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGFyZ3M7XG5cdCAgfVxuXHQgIHZhciBzdW0gPSAwO1xuXHQgIHZhciBkaXZpc29yID0gMTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIHN1bSArPSBhcmdzW2ldO1xuXHQgICAgZGl2aXNvciAqPSBleHBvcnRzLkZBQ1QoYXJnc1tpXSk7XG5cdCAgfVxuXHQgIHJldHVybiBleHBvcnRzLkZBQ1Qoc3VtKSAvIGRpdmlzb3I7XG5cdH07XG5cblx0ZXhwb3J0cy5NVU5JVCA9IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuXHQgIGRpbWVuc2lvbiA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpbWVuc2lvbik7XG5cdCAgaWYgKGRpbWVuc2lvbiBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZGltZW5zaW9uO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtZXJpYy5pZGVudGl0eShkaW1lbnNpb24pO1xuXHR9O1xuXG5cdGV4cG9ydHMuT0REID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHZhciB0ZW1wID0gTWF0aC5jZWlsKE1hdGguYWJzKG51bWJlcikpO1xuXHQgIHRlbXAgPSAodGVtcCAmIDEpID8gdGVtcCA6IHRlbXAgKyAxO1xuXHQgIHJldHVybiAobnVtYmVyID4gMCkgPyB0ZW1wIDogLXRlbXA7XG5cdH07XG5cblx0ZXhwb3J0cy5QSSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBNYXRoLlBJO1xuXHR9O1xuXG5cdGV4cG9ydHMuUE9XRVIgPSBmdW5jdGlvbihudW1iZXIsIHBvd2VyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBwb3dlciA9IHV0aWxzLnBhcnNlTnVtYmVyKHBvd2VyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHBvd2VyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gTWF0aC5wb3cobnVtYmVyLCBwb3dlcik7XG5cdCAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlBST0RVQ1QgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAoYXJncyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gYXJncztcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IDE7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKj0gYXJnc1tpXTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlFVT1RJRU5UID0gZnVuY3Rpb24obnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuXHQgIG51bWVyYXRvciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWVyYXRvcik7XG5cdCAgZGVub21pbmF0b3IgPSB1dGlscy5wYXJzZU51bWJlcihkZW5vbWluYXRvcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtZXJhdG9yLCBkZW5vbWluYXRvcikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHBhcnNlSW50KG51bWVyYXRvciAvIGRlbm9taW5hdG9yLCAxMCk7XG5cdH07XG5cblx0ZXhwb3J0cy5SQURJQU5TID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBudW1iZXIgKiBNYXRoLlBJIC8gMTgwO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkFORCA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkFOREJFVFdFRU4gPSBmdW5jdGlvbihib3R0b20sIHRvcCkge1xuXHQgIGJvdHRvbSA9IHV0aWxzLnBhcnNlTnVtYmVyKGJvdHRvbSk7XG5cdCAgdG9wID0gdXRpbHMucGFyc2VOdW1iZXIodG9wKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihib3R0b20sIHRvcCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgLy8gQ3JlYXRpdmUgQ29tbW9ucyBBdHRyaWJ1dGlvbiAzLjAgTGljZW5zZVxuXHQgIC8vIENvcHlyaWdodCAoYykgMjAxMiBlcWNvZGVcblx0ICByZXR1cm4gYm90dG9tICsgTWF0aC5jZWlsKCh0b3AgLSBib3R0b20gKyAxKSAqIE1hdGgucmFuZG9tKCkpIC0gMTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuUk9NQU4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgLy8gVGhlIE1JVCBMaWNlbnNlXG5cdCAgLy8gQ29weXJpZ2h0IChjKSAyMDA4IFN0ZXZlbiBMZXZpdGhhblxuXHQgIHZhciBkaWdpdHMgPSBTdHJpbmcobnVtYmVyKS5zcGxpdCgnJyk7XG5cdCAgdmFyIGtleSA9IFsnJywgJ0MnLCAnQ0MnLCAnQ0NDJywgJ0NEJywgJ0QnLCAnREMnLCAnRENDJywgJ0RDQ0MnLCAnQ00nLCAnJywgJ1gnLCAnWFgnLCAnWFhYJywgJ1hMJywgJ0wnLCAnTFgnLCAnTFhYJywgJ0xYWFgnLCAnWEMnLCAnJywgJ0knLCAnSUknLCAnSUlJJywgJ0lWJywgJ1YnLCAnVkknLCAnVklJJywgJ1ZJSUknLCAnSVgnXTtcblx0ICB2YXIgcm9tYW4gPSAnJztcblx0ICB2YXIgaSA9IDM7XG5cdCAgd2hpbGUgKGktLSkge1xuXHQgICAgcm9tYW4gPSAoa2V5WytkaWdpdHMucG9wKCkgKyAoaSAqIDEwKV0gfHwgJycpICsgcm9tYW47XG5cdCAgfVxuXHQgIHJldHVybiBuZXcgQXJyYXkoK2RpZ2l0cy5qb2luKCcnKSArIDEpLmpvaW4oJ00nKSArIHJvbWFuO1xuXHR9O1xuXG5cdGV4cG9ydHMuUk9VTkQgPSBmdW5jdGlvbihudW1iZXIsIGRpZ2l0cykge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgZGlnaXRzID0gdXRpbHMucGFyc2VOdW1iZXIoZGlnaXRzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIGRpZ2l0cykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogTWF0aC5wb3coMTAsIGRpZ2l0cykpIC8gTWF0aC5wb3coMTAsIGRpZ2l0cyk7XG5cdH07XG5cblx0ZXhwb3J0cy5ST1VORERPV04gPSBmdW5jdGlvbihudW1iZXIsIGRpZ2l0cykge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgZGlnaXRzID0gdXRpbHMucGFyc2VOdW1iZXIoZGlnaXRzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIGRpZ2l0cykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHNpZ24gPSAobnVtYmVyID4gMCkgPyAxIDogLTE7XG5cdCAgcmV0dXJuIHNpZ24gKiAoTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpICogTWF0aC5wb3coMTAsIGRpZ2l0cykpKSAvIE1hdGgucG93KDEwLCBkaWdpdHMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUk9VTkRVUCA9IGZ1bmN0aW9uKG51bWJlciwgZGlnaXRzKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkaWdpdHMgPSB1dGlscy5wYXJzZU51bWJlcihkaWdpdHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgZGlnaXRzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgc2lnbiA9IChudW1iZXIgPiAwKSA/IDEgOiAtMTtcblx0ICByZXR1cm4gc2lnbiAqIChNYXRoLmNlaWwoTWF0aC5hYnMobnVtYmVyKSAqIE1hdGgucG93KDEwLCBkaWdpdHMpKSkgLyBNYXRoLnBvdygxMCwgZGlnaXRzKTtcblx0fTtcblxuXHRleHBvcnRzLlNFQyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gMSAvIE1hdGguY29zKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5TRUNIID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiAyIC8gKE1hdGguZXhwKG51bWJlcikgKyBNYXRoLmV4cCgtbnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5TRVJJRVNTVU0gPSBmdW5jdGlvbih4LCBuLCBtLCBjb2VmZmljaWVudHMpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIG0gPSB1dGlscy5wYXJzZU51bWJlcihtKTtcblx0ICBjb2VmZmljaWVudHMgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KGNvZWZmaWNpZW50cyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbiwgbSwgY29lZmZpY2llbnRzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gY29lZmZpY2llbnRzWzBdICogTWF0aC5wb3coeCwgbik7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb2VmZmljaWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSBjb2VmZmljaWVudHNbaV0gKiBNYXRoLnBvdyh4LCBuICsgaSAqIG0pO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU0lHTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICBpZiAobnVtYmVyIDwgMCkge1xuXHQgICAgcmV0dXJuIC0xO1xuXHQgIH0gZWxzZSBpZiAobnVtYmVyID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIDE7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuU0lOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLnNpbihudW1iZXIpO1xuXHR9O1xuXG5cdCAgZXhwb3J0cy5TSU5IID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgICAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgIHJldHVybiBudW1iZXI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKE1hdGguZXhwKG51bWJlcikgLSBNYXRoLmV4cCgtbnVtYmVyKSkgLyAyO1xuXHQgIH07XG5cblx0ICBleHBvcnRzLlNRUlQgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIG51bWJlcjtcblx0ICAgIH1cblx0ICAgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTWF0aC5zcXJ0KG51bWJlcik7XG5cdCAgfTtcblxuXHQgIGV4cG9ydHMuU1FSVFBJID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgICAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgIHJldHVybiBudW1iZXI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTWF0aC5zcXJ0KG51bWJlciAqIE1hdGguUEkpO1xuXHQgIH07XG5cblx0ZXhwb3J0cy5TVUJUT1RBTCA9IGZ1bmN0aW9uKGZ1bmN0aW9uX2NvZGUsIHJlZjEpIHtcblx0ICBmdW5jdGlvbl9jb2RlID0gdXRpbHMucGFyc2VOdW1iZXIoZnVuY3Rpb25fY29kZSk7XG5cdCAgaWYgKGZ1bmN0aW9uX2NvZGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uX2NvZGU7XG5cdCAgfVxuXHQgIHN3aXRjaCAoZnVuY3Rpb25fY29kZSkge1xuXHQgICAgY2FzZSAxOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQVZFUkFHRShyZWYxKTtcblx0ICAgIGNhc2UgMjpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkNPVU5UKHJlZjEpO1xuXHQgICAgY2FzZSAzOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQ09VTlRBKHJlZjEpO1xuXHQgICAgY2FzZSA0OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTUFYKHJlZjEpO1xuXHQgICAgY2FzZSA1OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTUlOKHJlZjEpO1xuXHQgICAgY2FzZSA2OlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QUk9EVUNUKHJlZjEpO1xuXHQgICAgY2FzZSA3OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuU1RERVYuUyhyZWYxKTtcblx0ICAgIGNhc2UgODpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlNUREVWLlAocmVmMSk7XG5cdCAgICBjYXNlIDk6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlNVTShyZWYxKTtcblx0ICAgIGNhc2UgMTA6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5WQVIuUyhyZWYxKTtcblx0ICAgIGNhc2UgMTE6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5WQVIuUChyZWYxKTtcblx0ICAgICAgLy8gbm8gaGlkZGVuIHZhbHVlcyBmb3IgdXNcblx0ICAgIGNhc2UgMTAxOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQVZFUkFHRShyZWYxKTtcblx0ICAgIGNhc2UgMTAyOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQ09VTlQocmVmMSk7XG5cdCAgICBjYXNlIDEwMzpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkNPVU5UQShyZWYxKTtcblx0ICAgIGNhc2UgMTA0OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTUFYKHJlZjEpO1xuXHQgICAgY2FzZSAxMDU6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NSU4ocmVmMSk7XG5cdCAgICBjYXNlIDEwNjpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUFJPRFVDVChyZWYxKTtcblx0ICAgIGNhc2UgMTA3OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuU1RERVYuUyhyZWYxKTtcblx0ICAgIGNhc2UgMTA4OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuU1RERVYuUChyZWYxKTtcblx0ICAgIGNhc2UgMTA5OlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5TVU0ocmVmMSk7XG5cdCAgICBjYXNlIDExMDpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlZBUi5TKHJlZjEpO1xuXHQgICAgY2FzZSAxMTE6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5WQVIuUChyZWYxKTtcblxuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkFERCA9IGZ1bmN0aW9uIChudW0xLCBudW0yKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBudW0xID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMSk7XG5cdCAgbnVtMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bTEsIG51bTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bTEgKyBudW0yO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlOVVMgPSBmdW5jdGlvbiAobnVtMSwgbnVtMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgbnVtMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTEpO1xuXHQgIG51bTIgPSB1dGlscy5wYXJzZU51bWJlcihudW0yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW0xLCBudW0yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBudW0xIC0gbnVtMjtcblx0fTtcblxuXHRleHBvcnRzLkRJVklERSA9IGZ1bmN0aW9uIChkaXZpZGVuZCwgZGl2aXNvcikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgZGl2aWRlbmQgPSB1dGlscy5wYXJzZU51bWJlcihkaXZpZGVuZCk7XG5cdCAgZGl2aXNvciA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpdmlzb3IpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRpdmlkZW5kLCBkaXZpc29yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChkaXZpc29yID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZGl2MDtcblx0ICB9XG5cblx0ICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xuXHR9O1xuXG5cdGV4cG9ydHMuTVVMVElQTFkgPSBmdW5jdGlvbiAoZmFjdG9yMSwgZmFjdG9yMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgZmFjdG9yMSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZhY3RvcjEpO1xuXHQgIGZhY3RvcjIgPSB1dGlscy5wYXJzZU51bWJlcihmYWN0b3IyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihmYWN0b3IxLCBmYWN0b3IyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBmYWN0b3IxICogZmFjdG9yMjtcblx0fTtcblxuXHRleHBvcnRzLkdURSA9IGZ1bmN0aW9uIChudW0xLCBudW0yKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBudW0xID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMSk7XG5cdCAgbnVtMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bTEsIG51bTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZXJyb3I7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bTEgPj0gbnVtMjtcblx0fTtcblxuXHRleHBvcnRzLkxUID0gZnVuY3Rpb24gKG51bTEsIG51bTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIG51bTEgPSB1dGlscy5wYXJzZU51bWJlcihudW0xKTtcblx0ICBudW0yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtMSwgbnVtMikpIHtcblx0ICAgIHJldHVybiBlcnJvci5lcnJvcjtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtMSA8IG51bTI7XG5cdH07XG5cblxuXHRleHBvcnRzLkxURSA9IGZ1bmN0aW9uIChudW0xLCBudW0yKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBudW0xID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMSk7XG5cdCAgbnVtMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bTEsIG51bTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZXJyb3I7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bTEgPD0gbnVtMjtcblx0fTtcblxuXHRleHBvcnRzLkVRID0gZnVuY3Rpb24gKHZhbHVlMSwgdmFsdWUyKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG5cdH07XG5cblx0ZXhwb3J0cy5ORSA9IGZ1bmN0aW9uICh2YWx1ZTEsIHZhbHVlMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHZhbHVlMSAhPT0gdmFsdWUyO1xuXHR9O1xuXG5cdGV4cG9ydHMuUE9XID0gZnVuY3Rpb24gKGJhc2UsIGV4cG9uZW50KSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBiYXNlID0gdXRpbHMucGFyc2VOdW1iZXIoYmFzZSk7XG5cdCAgZXhwb25lbnQgPSB1dGlscy5wYXJzZU51bWJlcihleHBvbmVudCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYmFzZSwgZXhwb25lbnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZXJyb3I7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGV4cG9ydHMuUE9XRVIoYmFzZSwgZXhwb25lbnQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgdmFyIGFyZ3NLZXlzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3NLZXlzLmxlbmd0aDsgKytpKSB7XG5cdCAgICB2YXIgZWx0ID0gYXJndW1lbnRzW2FyZ3NLZXlzW2ldXTtcblx0ICAgIGlmICh0eXBlb2YgZWx0ID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXN1bHQgKz0gZWx0O1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZWx0ID09PSAnc3RyaW5nJykge1xuXHQgICAgICB2YXIgcGFyc2VkID0gcGFyc2VGbG9hdChlbHQpO1xuXHQgICAgICAhaXNOYU4ocGFyc2VkKSAmJiAocmVzdWx0ICs9IHBhcnNlZCk7XG5cdCAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZWx0KSkge1xuXHQgICAgICByZXN1bHQgKz0gZXhwb3J0cy5TVU0uYXBwbHkobnVsbCwgZWx0KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNVTUlGID0gZnVuY3Rpb24ocmFuZ2UsIGNyaXRlcmlhKSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gKGV2YWwocmFuZ2VbaV0gKyBjcml0ZXJpYSkpID8gcmFuZ2VbaV0gOiAwOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNVTUlGUyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuYXJnc1RvQXJyYXkoYXJndW1lbnRzKTtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJncy5zaGlmdCgpKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIGNyaXRlcmlhID0gYXJncztcblxuXHQgIHZhciBuX3JhbmdlX2VsZW1lbnRzID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBuX2NyaXRlcmlhcyA9IGNyaXRlcmlhLmxlbmd0aDtcblxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbl9yYW5nZV9lbGVtZW50czsgaSsrKSB7XG5cdCAgICB2YXIgZWwgPSByYW5nZVtpXTtcblx0ICAgIHZhciBjb25kaXRpb24gPSAnJztcblx0ICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbl9jcml0ZXJpYXM7IGMrKykge1xuXHQgICAgICBjb25kaXRpb24gKz0gZWwgKyBjcml0ZXJpYVtjXTtcblx0ICAgICAgaWYgKGMgIT09IG5fY3JpdGVyaWFzIC0gMSkge1xuXHQgICAgICAgIGNvbmRpdGlvbiArPSAnJiYnO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoZXZhbChjb25kaXRpb24pKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICByZXN1bHQgKz0gZWw7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU1QUk9EVUNUID0gZnVuY3Rpb24oKSB7XG5cdCAgaWYgKCFhcmd1bWVudHMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgYXJyYXlzID0gYXJndW1lbnRzLmxlbmd0aCArIDE7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgdmFyIHByb2R1Y3Q7XG5cdCAgdmFyIGs7XG5cdCAgdmFyIF9pO1xuXHQgIHZhciBfaWo7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHNbMF0ubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmICghKGFyZ3VtZW50c1swXVtpXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgICBwcm9kdWN0ID0gMTtcblx0ICAgICAgZm9yIChrID0gMTsgayA8IGFycmF5czsgaysrKSB7XG5cdCAgICAgICAgX2kgPSB1dGlscy5wYXJzZU51bWJlcihhcmd1bWVudHNbayAtIDFdW2ldKTtcblx0ICAgICAgICBpZiAoX2kgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgcmV0dXJuIF9pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwcm9kdWN0ICo9IF9pO1xuXHQgICAgICB9XG5cdCAgICAgIHJlc3VsdCArPSBwcm9kdWN0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcmd1bWVudHNbMF1baV0ubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICBwcm9kdWN0ID0gMTtcblx0ICAgICAgICBmb3IgKGsgPSAxOyBrIDwgYXJyYXlzOyBrKyspIHtcblx0ICAgICAgICAgIF9paiA9IHV0aWxzLnBhcnNlTnVtYmVyKGFyZ3VtZW50c1trIC0gMV1baV1bal0pO1xuXHQgICAgICAgICAgaWYgKF9paiBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfaWo7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBwcm9kdWN0ICo9IF9pajtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ICs9IHByb2R1Y3Q7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNVTVNRID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIG51bWJlcnMgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKG51bWJlcnMgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcnM7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIHZhciBsZW5ndGggPSBudW1iZXJzLmxlbmd0aDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gKGluZm9ybWF0aW9uLklTTlVNQkVSKG51bWJlcnNbaV0pKSA/IG51bWJlcnNbaV0gKiBudW1iZXJzW2ldIDogMDtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNVTVgyTVkyID0gZnVuY3Rpb24oYXJyYXlfeCwgYXJyYXlfeSkge1xuXHQgIGFycmF5X3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeCkpO1xuXHQgIGFycmF5X3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5X3gsIGFycmF5X3kpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlfeC5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IGFycmF5X3hbaV0gKiBhcnJheV94W2ldIC0gYXJyYXlfeVtpXSAqIGFycmF5X3lbaV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU1YMlBZMiA9IGZ1bmN0aW9uKGFycmF5X3gsIGFycmF5X3kpIHtcblx0ICBhcnJheV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5X3gpKTtcblx0ICBhcnJheV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5X3kpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheV94LCBhcnJheV95KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBhcnJheV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5X3gpKTtcblx0ICBhcnJheV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5X3kpKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5X3gubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSBhcnJheV94W2ldICogYXJyYXlfeFtpXSArIGFycmF5X3lbaV0gKiBhcnJheV95W2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNWE1ZMiA9IGZ1bmN0aW9uKGFycmF5X3gsIGFycmF5X3kpIHtcblx0ICBhcnJheV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5X3gpKTtcblx0ICBhcnJheV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5X3kpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheV94LCBhcnJheV95KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBhcnJheV94ID0gdXRpbHMuZmxhdHRlbihhcnJheV94KTtcblx0ICBhcnJheV95ID0gdXRpbHMuZmxhdHRlbihhcnJheV95KTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5X3gubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSBNYXRoLnBvdyhhcnJheV94W2ldIC0gYXJyYXlfeVtpXSwgMik7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5UQU4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgudGFuKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5UQU5IID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHZhciBlMiA9IE1hdGguZXhwKDIgKiBudW1iZXIpO1xuXHQgIHJldHVybiAoZTIgLSAxKSAvIChlMiArIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVFJVTkMgPSBmdW5jdGlvbihudW1iZXIsIGRpZ2l0cykge1xuXHQgIGRpZ2l0cyA9IChkaWdpdHMgPT09IHVuZGVmaW5lZCkgPyAwIDogZGlnaXRzO1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgZGlnaXRzID0gdXRpbHMucGFyc2VOdW1iZXIoZGlnaXRzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIGRpZ2l0cykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHNpZ24gPSAobnVtYmVyID4gMCkgPyAxIDogLTE7XG5cdCAgcmV0dXJuIHNpZ24gKiAoTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpICogTWF0aC5wb3coMTAsIGRpZ2l0cykpKSAvIE1hdGgucG93KDEwLCBkaWdpdHMpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXztcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblx0ZnVuY3Rpb24gZmxhdHRlblNoYWxsb3coYXJyYXkpIHtcblx0ICBpZiAoIWFycmF5IHx8ICFhcnJheS5yZWR1Y2UpIHsgcmV0dXJuIGFycmF5OyB9XG5cdCAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG5cdCAgICB2YXIgYUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xuXHQgICAgdmFyIGJJc0FycmF5ID0gQXJyYXkuaXNBcnJheShiKTtcblx0ICAgIGlmIChhSXNBcnJheSAmJiBiSXNBcnJheSApIHtcblx0ICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuXHQgICAgfVxuXHQgICAgaWYgKGFJc0FycmF5KSB7XG5cdCAgICAgIGEucHVzaChiKTtcblx0ICAgICAgcmV0dXJuIGE7XG5cdCAgICB9XG5cdCAgICBpZiAoYklzQXJyYXkpIHtcblx0ICAgICAgcmV0dXJuIFthXS5jb25jYXQoYik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gW2EsIGJdO1xuXHQgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNGbGF0KGFycmF5KSB7XG5cdCAgaWYgKCFhcnJheSkgeyByZXR1cm4gZmFsc2U7IH1cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheVtpXSkpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGV4cG9ydHMuZmxhdHRlbiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByZXN1bHQgPSBleHBvcnRzLmFyZ3NUb0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgd2hpbGUgKCFpc0ZsYXQocmVzdWx0KSkge1xuXHQgICAgcmVzdWx0ID0gZmxhdHRlblNoYWxsb3cocmVzdWx0KTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLmFyZ3NUb0FycmF5ID0gZnVuY3Rpb24oYXJncykge1xuXHQgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAwKTtcblx0fTtcblxuXHRleHBvcnRzLm51bWJlcnMgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcG9zc2libGVOdW1iZXJzID0gdGhpcy5mbGF0dGVuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIHBvc3NpYmxlTnVtYmVycy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcblx0ICAgIHJldHVybiB0eXBlb2YgZWwgPT09ICdudW1iZXInO1xuXHQgIH0pO1xuXHR9O1xuXG5cdGV4cG9ydHMuY2xlYW5GbG9hdCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIHZhciBwb3dlciA9IDFlMTQ7XG5cdCAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogcG93ZXIpIC8gcG93ZXI7XG5cdH07XG5cblx0ZXhwb3J0cy5wYXJzZUJvb2wgPSBmdW5jdGlvbihib29sKSB7XG5cdCAgaWYgKHR5cGVvZiBib29sID09PSAnYm9vbGVhbicpIHtcblx0ICAgIHJldHVybiBib29sO1xuXHQgIH1cblxuXHQgIGlmIChib29sIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBib29sO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgYm9vbCA9PT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiBib29sICE9PSAwO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgYm9vbCA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHZhciB1cCA9IGJvb2wudG9VcHBlckNhc2UoKTtcblx0ICAgIGlmICh1cCA9PT0gJ1RSVUUnKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodXAgPT09ICdGQUxTRScpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmIChib29sIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oYm9vbCkpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBlcnJvci52YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLnBhcnNlTnVtYmVyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdCAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkIHx8IHN0cmluZyA9PT0gJycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKCFpc05hTihzdHJpbmcpKSB7XG5cdCAgICByZXR1cm4gcGFyc2VGbG9hdChzdHJpbmcpO1xuXHQgIH1cblx0ICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5wYXJzZU51bWJlckFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG5cdCAgdmFyIGxlbjtcblx0ICBpZiAoIWFyciB8fCAobGVuID0gYXJyLmxlbmd0aCkgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHBhcnNlZDtcblx0ICB3aGlsZSAobGVuLS0pIHtcblx0ICAgIHBhcnNlZCA9IGV4cG9ydHMucGFyc2VOdW1iZXIoYXJyW2xlbl0pO1xuXHQgICAgaWYgKHBhcnNlZCA9PT0gZXJyb3IudmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHBhcnNlZDtcblx0ICAgIH1cblx0ICAgIGFycltsZW5dID0gcGFyc2VkO1xuXHQgIH1cblx0ICByZXR1cm4gYXJyO1xuXHR9O1xuXG5cdGV4cG9ydHMucGFyc2VNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0ICB2YXIgbjtcblx0ICBpZiAoIW1hdHJpeCB8fCAobiA9IG1hdHJpeC5sZW5ndGgpID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBwbmFycjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdHJpeC5sZW5ndGg7IGkrKykge1xuXHQgICAgcG5hcnIgPSBleHBvcnRzLnBhcnNlTnVtYmVyQXJyYXkobWF0cml4W2ldKTtcblx0ICAgIG1hdHJpeFtpXSA9IHBuYXJyO1xuXHQgICAgaWYgKHBuYXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIHBuYXJyO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gbWF0cml4O1xuXHR9O1xuXG5cdHZhciBkMTkwMCA9IG5ldyBEYXRlKDE5MDAsIDAsIDEpO1xuXHRleHBvcnRzLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uKGRhdGUpIHtcblx0ICBpZiAoIWlzTmFOKGRhdGUpKSB7XG5cdCAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuXHQgICAgfVxuXHQgICAgdmFyIGQgPSBwYXJzZUludChkYXRlLCAxMCk7XG5cdCAgICBpZiAoZCA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblx0ICAgIGlmIChkIDw9IDYwKSB7XG5cdCAgICAgIHJldHVybiBuZXcgRGF0ZShkMTkwMC5nZXRUaW1lKCkgKyAoZCAtIDEpICogODY0MDAwMDApO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBEYXRlKGQxOTAwLmdldFRpbWUoKSArIChkIC0gMikgKiA4NjQwMDAwMCk7XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcblx0ICAgIGlmICghaXNOYU4oZGF0ZSkpIHtcblx0ICAgICAgcmV0dXJuIGRhdGU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBlcnJvci52YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLnBhcnNlRGF0ZUFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG5cdCAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cdCAgdmFyIHBhcnNlZDtcblx0ICB3aGlsZSAobGVuLS0pIHtcblx0ICAgIHBhcnNlZCA9IHRoaXMucGFyc2VEYXRlKGFycltsZW5dKTtcblx0ICAgIGlmIChwYXJzZWQgPT09IGVycm9yLnZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBwYXJzZWQ7XG5cdCAgICB9XG5cdCAgICBhcnJbbGVuXSA9IHBhcnNlZDtcblx0ICB9XG5cdCAgcmV0dXJuIGFycjtcblx0fTtcblxuXHRleHBvcnRzLmFueUlzRXJyb3IgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgd2hpbGUgKG4tLSkge1xuXHQgICAgaWYgKGFyZ3VtZW50c1tuXSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0ZXhwb3J0cy5hcnJheVZhbHVlc1RvTnVtYmVycyA9IGZ1bmN0aW9uKGFycikge1xuXHQgIHZhciBuID0gYXJyLmxlbmd0aDtcblx0ICB2YXIgZWw7XG5cdCAgd2hpbGUgKG4tLSkge1xuXHQgICAgZWwgPSBhcnJbbl07XG5cdCAgICBpZiAodHlwZW9mIGVsID09PSAnbnVtYmVyJykge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblx0ICAgIGlmIChlbCA9PT0gdHJ1ZSkge1xuXHQgICAgICBhcnJbbl0gPSAxO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblx0ICAgIGlmIChlbCA9PT0gZmFsc2UpIHtcblx0ICAgICAgYXJyW25dID0gMDtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuXHQgICAgICB2YXIgbnVtYmVyID0gdGhpcy5wYXJzZU51bWJlcihlbCk7XG5cdCAgICAgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgIGFycltuXSA9IDA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgYXJyW25dID0gbnVtYmVyO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBhcnI7XG5cdH07XG5cblx0ZXhwb3J0cy5yZXN0ID0gZnVuY3Rpb24oYXJyYXksIGlkeCkge1xuXHQgIGlkeCA9IGlkeCB8fCAxO1xuXHQgIGlmICghYXJyYXkgfHwgdHlwZW9mIGFycmF5LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICByZXR1cm4gYXJyYXk7XG5cdCAgfVxuXHQgIHJldHVybiBhcnJheS5zbGljZShpZHgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBpZHgpIHtcblx0ICBpZHggPSBpZHggfHwgMTtcblx0ICBpZiAoIWFycmF5IHx8IHR5cGVvZiBhcnJheS5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIGFycmF5O1xuXHQgIH1cblx0ICByZXR1cm4gYXJyYXkuc2xpY2UoMCwgYXJyYXkubGVuZ3RoIC0gaWR4KTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMubmlsID0gbmV3IEVycm9yKCcjTlVMTCEnKTtcblx0ZXhwb3J0cy5kaXYwID0gbmV3IEVycm9yKCcjRElWLzAhJyk7XG5cdGV4cG9ydHMudmFsdWUgPSBuZXcgRXJyb3IoJyNWQUxVRT8nKTtcblx0ZXhwb3J0cy5yZWYgPSBuZXcgRXJyb3IoJyNSRUYhJyk7XG5cdGV4cG9ydHMubmFtZSA9IG5ldyBFcnJvcignI05BTUU/Jyk7XG5cdGV4cG9ydHMubnVtID0gbmV3IEVycm9yKCcjTlVNIScpO1xuXHRleHBvcnRzLm5hID0gbmV3IEVycm9yKCcjTi9BJyk7XG5cdGV4cG9ydHMuZXJyb3IgPSBuZXcgRXJyb3IoJyNFUlJPUiEnKTtcblx0ZXhwb3J0cy5kYXRhID0gbmV3IEVycm9yKCcjR0VUVElOR19EQVRBJyk7XG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBtYXRoVHJpZyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciB0ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0dmFyIGpTdGF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5qU3RhdDtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIG1pc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuXHR2YXIgU1FSVDJQSSA9IDIuNTA2NjI4Mjc0NjMxMDAwMjtcblxuXHRleHBvcnRzLkFWRURFViA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQuc3VtKGpTdGF0KHJhbmdlKS5zdWJ0cmFjdChqU3RhdC5tZWFuKHJhbmdlKSkuYWJzKClbMF0pIC8gcmFuZ2UubGVuZ3RoO1xuXHR9O1xuXG5cdGV4cG9ydHMuQVZFUkFHRSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLm51bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc3VtID0gMDtcblx0ICB2YXIgY291bnQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBzdW0gKz0gcmFuZ2VbaV07XG5cdCAgICBjb3VudCArPSAxO1xuXHQgIH1cblx0ICByZXR1cm4gc3VtIC8gY291bnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5BVkVSQUdFQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc3VtID0gMDtcblx0ICB2YXIgY291bnQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICB2YXIgZWwgPSByYW5nZVtpXTtcblx0ICAgIGlmICh0eXBlb2YgZWwgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHN1bSArPSBlbDtcblx0ICAgIH1cblx0ICAgIGlmIChlbCA9PT0gdHJ1ZSkge1xuXHQgICAgICBzdW0rKztcblx0ICAgIH1cblx0ICAgIGlmIChlbCAhPT0gbnVsbCkge1xuXHQgICAgICBjb3VudCsrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gc3VtIC8gY291bnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5BVkVSQUdFSUYgPSBmdW5jdGlvbihyYW5nZSwgY3JpdGVyaWEsIGF2ZXJhZ2VfcmFuZ2UpIHtcblx0ICBhdmVyYWdlX3JhbmdlID0gYXZlcmFnZV9yYW5nZSB8fCByYW5nZTtcblx0ICByYW5nZSA9IHV0aWxzLmZsYXR0ZW4ocmFuZ2UpO1xuXHQgIGF2ZXJhZ2VfcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXZlcmFnZV9yYW5nZSkpO1xuXHQgIGlmIChhdmVyYWdlX3JhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBhdmVyYWdlX3JhbmdlO1xuXHQgIH1cblx0ICB2YXIgYXZlcmFnZV9jb3VudCA9IDA7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKGV2YWwocmFuZ2VbaV0gKyBjcml0ZXJpYSkpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgIHJlc3VsdCArPSBhdmVyYWdlX3JhbmdlW2ldO1xuXHQgICAgICBhdmVyYWdlX2NvdW50Kys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQgLyBhdmVyYWdlX2NvdW50O1xuXHR9O1xuXG5cdGV4cG9ydHMuQVZFUkFHRUlGUyA9IGZ1bmN0aW9uKCkge1xuXHQgIC8vIERvZXMgbm90IHdvcmsgd2l0aCBtdWx0aSBkaW1lbnNpb25hbCByYW5nZXMgeWV0IVxuXHQgIC8vaHR0cDovL29mZmljZS5taWNyb3NvZnQuY29tL2VuLTAwMS9leGNlbC1oZWxwL2F2ZXJhZ2VpZnMtZnVuY3Rpb24tSEEwMTAwNDc0OTMuYXNweFxuXHQgIHZhciBhcmdzID0gdXRpbHMuYXJnc1RvQXJyYXkoYXJndW1lbnRzKTtcblx0ICB2YXIgY3JpdGVyaWEgPSAoYXJncy5sZW5ndGggLSAxKSAvIDI7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmdzWzBdKTtcblx0ICB2YXIgY291bnQgPSAwO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2UubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBjb25kaXRpb24gPSAnJztcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3JpdGVyaWE7IGorKykge1xuXHQgICAgICBjb25kaXRpb24gKz0gYXJnc1syICogaiArIDFdW2ldICsgYXJnc1syICogaiArIDJdO1xuXHQgICAgICBpZiAoaiAhPT0gY3JpdGVyaWEgLSAxKSB7XG5cdCAgICAgICAgY29uZGl0aW9uICs9ICcmJic7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChldmFsKGNvbmRpdGlvbikpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgIHJlc3VsdCArPSByYW5nZVtpXTtcblx0ICAgICAgY291bnQrKztcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgYXZlcmFnZSA9IHJlc3VsdCAvIGNvdW50O1xuXHQgIGlmIChpc05hTihhdmVyYWdlKSkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBhdmVyYWdlO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkJFVEEgPSB7fTtcblxuXHRleHBvcnRzLkJFVEEuRElTVCA9IGZ1bmN0aW9uKHgsIGFscGhhLCBiZXRhLCBjdW11bGF0aXZlLCBBLCBCKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgQSA9IChBID09PSB1bmRlZmluZWQpID8gMCA6IEE7XG5cdCAgQiA9IChCID09PSB1bmRlZmluZWQpID8gMSA6IEI7XG5cblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgYWxwaGEgPSB1dGlscy5wYXJzZU51bWJlcihhbHBoYSk7XG5cdCAgYmV0YSA9IHV0aWxzLnBhcnNlTnVtYmVyKGJldGEpO1xuXHQgIEEgPSB1dGlscy5wYXJzZU51bWJlcihBKTtcblx0ICBCID0gdXRpbHMucGFyc2VOdW1iZXIoQik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgYWxwaGEsIGJldGEsIEEsIEIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgeCA9ICh4IC0gQSkgLyAoQiAtIEEpO1xuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5iZXRhLmNkZih4LCBhbHBoYSwgYmV0YSkgOiBqU3RhdC5iZXRhLnBkZih4LCBhbHBoYSwgYmV0YSk7XG5cdH07XG5cblx0ZXhwb3J0cy5CRVRBLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBhbHBoYSwgYmV0YSwgQSwgQikge1xuXHQgIEEgPSAoQSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBBO1xuXHQgIEIgPSAoQiA9PT0gdW5kZWZpbmVkKSA/IDEgOiBCO1xuXG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgYWxwaGEgPSB1dGlscy5wYXJzZU51bWJlcihhbHBoYSk7XG5cdCAgYmV0YSA9IHV0aWxzLnBhcnNlTnVtYmVyKGJldGEpO1xuXHQgIEEgPSB1dGlscy5wYXJzZU51bWJlcihBKTtcblx0ICBCID0gdXRpbHMucGFyc2VOdW1iZXIoQik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocHJvYmFiaWxpdHksIGFscGhhLCBiZXRhLCBBLCBCKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5iZXRhLmludihwcm9iYWJpbGl0eSwgYWxwaGEsIGJldGEpICogKEIgLSBBKSArIEE7XG5cdH07XG5cblx0ZXhwb3J0cy5CSU5PTSA9IHt9O1xuXG5cdGV4cG9ydHMuQklOT00uRElTVCA9IGZ1bmN0aW9uKHN1Y2Nlc3NlcywgdHJpYWxzLCBwcm9iYWJpbGl0eSwgY3VtdWxhdGl2ZSkge1xuXHQgIHN1Y2Nlc3NlcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHN1Y2Nlc3Nlcyk7XG5cdCAgdHJpYWxzID0gdXRpbHMucGFyc2VOdW1iZXIodHJpYWxzKTtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBjdW11bGF0aXZlID0gdXRpbHMucGFyc2VOdW1iZXIoY3VtdWxhdGl2ZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioc3VjY2Vzc2VzLCB0cmlhbHMsIHByb2JhYmlsaXR5LCBjdW11bGF0aXZlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQuYmlub21pYWwuY2RmKHN1Y2Nlc3NlcywgdHJpYWxzLCBwcm9iYWJpbGl0eSkgOiBqU3RhdC5iaW5vbWlhbC5wZGYoc3VjY2Vzc2VzLCB0cmlhbHMsIHByb2JhYmlsaXR5KTtcblx0fTtcblxuXHRleHBvcnRzLkJJTk9NLkRJU1QuUkFOR0UgPSBmdW5jdGlvbih0cmlhbHMsIHByb2JhYmlsaXR5LCBzdWNjZXNzZXMsIHN1Y2Nlc3NlczIpIHtcblx0ICBzdWNjZXNzZXMyID0gKHN1Y2Nlc3NlczIgPT09IHVuZGVmaW5lZCkgPyBzdWNjZXNzZXMgOiBzdWNjZXNzZXMyO1xuXG5cdCAgdHJpYWxzID0gdXRpbHMucGFyc2VOdW1iZXIodHJpYWxzKTtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBzdWNjZXNzZXMgPSB1dGlscy5wYXJzZU51bWJlcihzdWNjZXNzZXMpO1xuXHQgIHN1Y2Nlc3NlczIgPSB1dGlscy5wYXJzZU51bWJlcihzdWNjZXNzZXMyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih0cmlhbHMsIHByb2JhYmlsaXR5LCBzdWNjZXNzZXMsIHN1Y2Nlc3NlczIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IHN1Y2Nlc3NlczsgaSA8PSBzdWNjZXNzZXMyOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSBtYXRoVHJpZy5DT01CSU4odHJpYWxzLCBpKSAqIE1hdGgucG93KHByb2JhYmlsaXR5LCBpKSAqIE1hdGgucG93KDEgLSBwcm9iYWJpbGl0eSwgdHJpYWxzIC0gaSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5CSU5PTS5JTlYgPSBmdW5jdGlvbih0cmlhbHMsIHByb2JhYmlsaXR5LCBhbHBoYSkge1xuXHQgIHRyaWFscyA9IHV0aWxzLnBhcnNlTnVtYmVyKHRyaWFscyk7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgYWxwaGEgPSB1dGlscy5wYXJzZU51bWJlcihhbHBoYSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IodHJpYWxzLCBwcm9iYWJpbGl0eSwgYWxwaGEpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgdmFyIHggPSAwO1xuXHQgIHdoaWxlICh4IDw9IHRyaWFscykge1xuXHQgICAgaWYgKGpTdGF0LmJpbm9taWFsLmNkZih4LCB0cmlhbHMsIHByb2JhYmlsaXR5KSA+PSBhbHBoYSkge1xuXHQgICAgICByZXR1cm4geDtcblx0ICAgIH1cblx0ICAgIHgrKztcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5DSElTUSA9IHt9O1xuXG5cdGV4cG9ydHMuQ0hJU1EuRElTVCA9IGZ1bmN0aW9uKHgsIGssIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIGspKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LmNoaXNxdWFyZS5jZGYoeCwgaykgOiBqU3RhdC5jaGlzcXVhcmUucGRmKHgsIGspO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hJU1EuRElTVC5SVCA9IGZ1bmN0aW9uKHgsIGspIHtcblx0ICBpZiAoIXggfCAhaykge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICh4IDwgMSB8fCBrID4gTWF0aC5wb3coMTAsIDEwKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBrICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gMSAtICBqU3RhdC5jaGlzcXVhcmUuY2RmKHgsIGspO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hJU1EuSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIGspIHtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocHJvYmFiaWxpdHksIGspKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5jaGlzcXVhcmUuaW52KHByb2JhYmlsaXR5LCBrKTtcblx0fTtcblxuXHRleHBvcnRzLkNISVNRLklOVi5SVCA9IGZ1bmN0aW9uKHAsIGspIHtcblx0ICBpZiAoIXAgfCAhaykge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChwIDwgMCB8fCBwID4gMSB8fCBrIDwgMSB8fCBrID4gTWF0aC5wb3coMTAsIDEwKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiBwICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBrICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuY2hpc3F1YXJlLmludigxLjAgLSBwLCBrKTtcblx0fTtcblxuXHRleHBvcnRzLkNISVNRLlRFU1QgPSBmdW5jdGlvbihvYnNlcnZlZCwgZXhwZWN0ZWQpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICgoIShvYnNlcnZlZCBpbnN0YW5jZW9mIEFycmF5KSkgfHwgKCEoZXhwZWN0ZWQgaW5zdGFuY2VvZiBBcnJheSkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKG9ic2VydmVkLmxlbmd0aCAhPT0gZXhwZWN0ZWQubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKG9ic2VydmVkWzBdICYmIGV4cGVjdGVkWzBdICYmXG5cdCAgICAgIG9ic2VydmVkWzBdLmxlbmd0aCAhPT0gZXhwZWN0ZWRbMF0ubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgdmFyIHJvdyA9IG9ic2VydmVkLmxlbmd0aDtcblx0ICB2YXIgdG1wLCBpLCBqO1xuXG5cdCAgLy8gQ29udmVydCBzaW5nbGUtZGltZW5zaW9uIGFycmF5IGludG8gdHdvLWRpbWVuc2lvbiBhcnJheVxuXHQgIGZvciAoaSA9IDA7IGkgPCByb3c7IGkgKyspIHtcblx0ICAgIGlmICghKG9ic2VydmVkW2ldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICAgIHRtcCA9IG9ic2VydmVkW2ldO1xuXHQgICAgICBvYnNlcnZlZFtpXSA9IFtdO1xuXHQgICAgICBvYnNlcnZlZFtpXS5wdXNoKHRtcCk7XG5cdCAgICB9XG5cdCAgICBpZiAoIShleHBlY3RlZFtpXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgICB0bXAgPSBleHBlY3RlZFtpXTtcblx0ICAgICAgZXhwZWN0ZWRbaV0gPSBbXTtcblx0ICAgICAgZXhwZWN0ZWRbaV0ucHVzaCh0bXApO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBjb2wgPSBvYnNlcnZlZFswXS5sZW5ndGg7XG5cdCAgdmFyIGRvZiA9IChjb2wgPT09IDEpID8gcm93LTEgOiAocm93LTEpKihjb2wtMSk7XG5cdCAgdmFyIHhzcXIgPSAwO1xuXHQgIHZhciBQaSA9TWF0aC5QSTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCByb3c7IGkgKyspIHtcblx0ICAgIGZvciAoaiA9IDA7IGogPCBjb2w7IGogKyspIHtcblx0ICAgICAgeHNxciArPSBNYXRoLnBvdygob2JzZXJ2ZWRbaV1bal0gLSBleHBlY3RlZFtpXVtqXSksIDIpIC8gZXhwZWN0ZWRbaV1bal07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gR2V0IGluZGVwZW5kZW5jeSBieSBYIHNxdWFyZSBhbmQgaXRzIGRlZ3JlZSBvZiBmcmVlZG9tXG5cdCAgZnVuY3Rpb24gQ2hpU3EoeHNxciwgZG9mKSB7XG5cdCAgICB2YXIgcCA9IE1hdGguZXhwKC0wLjUgKiB4c3FyKTtcblx0ICAgIGlmKChkb2YlMikgPT09IDEpIHtcblx0ICAgICAgcCA9IHAgKiBNYXRoLnNxcnQoMiAqIHhzcXIvUGkpO1xuXHQgICAgfVxuXHQgICAgdmFyIGsgPSBkb2Y7XG5cdCAgICB3aGlsZShrID49IDIpIHtcblx0ICAgICAgcCA9IHAgKiB4c3FyL2s7XG5cdCAgICAgIGsgPSBrIC0gMjtcblx0ICAgIH1cblx0ICAgIHZhciB0ID0gcDtcblx0ICAgIHZhciBhID0gZG9mO1xuXHQgICAgd2hpbGUgKHQgPiAwLjAwMDAwMDAwMDEqcCkge1xuXHQgICAgICBhID0gYSArIDI7XG5cdCAgICAgIHQgPSB0ICogeHNxci9hO1xuXHQgICAgICBwID0gcCArIHQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gMS1wO1xuXHQgIH1cblxuXHQgIHJldHVybiBNYXRoLnJvdW5kKENoaVNxKHhzcXIsIGRvZikgKiAxMDAwMDAwKSAvIDEwMDAwMDA7XG5cdH07XG5cblx0ZXhwb3J0cy5DT0xVTU4gPSBmdW5jdGlvbihtYXRyaXgsIGluZGV4KSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoaW5kZXggPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICghKG1hdHJpeCBpbnN0YW5jZW9mIEFycmF5KSB8fCAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuY29sKG1hdHJpeCwgaW5kZXgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09MVU1OUyA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKCEobWF0cml4IGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKG1hdHJpeC5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5jb2xzKG1hdHJpeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5DT05GSURFTkNFID0ge307XG5cblx0ZXhwb3J0cy5DT05GSURFTkNFLk5PUk0gPSBmdW5jdGlvbihhbHBoYSwgc2QsIG4pIHtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBzZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNkKTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYWxwaGEsIHNkLCBuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQubm9ybWFsY2koMSwgYWxwaGEsIHNkLCBuKVsxXSAtIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5DT05GSURFTkNFLlQgPSBmdW5jdGlvbihhbHBoYSwgc2QsIG4pIHtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBzZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNkKTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYWxwaGEsIHNkLCBuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQudGNpKDEsIGFscGhhLCBzZCwgbilbMV0gLSAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09SUkVMID0gZnVuY3Rpb24oYXJyYXkxLCBhcnJheTIpIHtcblx0ICBhcnJheTEgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkxKSk7XG5cdCAgYXJyYXkyID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5MikpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5MSwgYXJyYXkyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQuY29ycmNvZWZmKGFycmF5MSwgYXJyYXkyKTtcblx0fTtcblxuXHRleHBvcnRzLkNPVU5UID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIHV0aWxzLm51bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKS5sZW5ndGg7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1VOVEEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIHJhbmdlLmxlbmd0aCAtIGV4cG9ydHMuQ09VTlRCTEFOSyhyYW5nZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1VOVElOID0gZnVuY3Rpb24gKHJhbmdlLCB2YWx1ZSkge1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2UubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChyYW5nZVtpXSA9PT0gdmFsdWUpIHtcblx0ICAgICAgcmVzdWx0Kys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblxuXHRleHBvcnRzLkNPVU5UQkxBTksgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgdmFyIGJsYW5rcyA9IDA7XG5cdCAgdmFyIGVsZW1lbnQ7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgZWxlbWVudCA9IHJhbmdlW2ldO1xuXHQgICAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gJycpIHtcblx0ICAgICAgYmxhbmtzKys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBibGFua3M7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1VOVElGID0gZnVuY3Rpb24ocmFuZ2UsIGNyaXRlcmlhKSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKHJhbmdlKTtcblx0ICBpZiAoIS9bPD49IV0vLnRlc3QoY3JpdGVyaWEpKSB7XG5cdCAgICBjcml0ZXJpYSA9ICc9PVwiJyArIGNyaXRlcmlhICsgJ1wiJztcblx0ICB9XG5cdCAgdmFyIG1hdGNoZXMgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2UubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmICh0eXBlb2YgcmFuZ2VbaV0gIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGlmIChldmFsKHJhbmdlW2ldICsgY3JpdGVyaWEpKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICAgIG1hdGNoZXMrKztcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKGV2YWwoJ1wiJyArIHJhbmdlW2ldICsgJ1wiJyArIGNyaXRlcmlhKSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgICBtYXRjaGVzKys7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG1hdGNoZXM7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1VOVElGUyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuYXJnc1RvQXJyYXkoYXJndW1lbnRzKTtcblx0ICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3NbMF0pLmxlbmd0aCk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHRzW2ldID0gdHJ1ZTtcblx0ICB9XG5cdCAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgIHZhciByYW5nZSA9IHV0aWxzLmZsYXR0ZW4oYXJnc1tpXSk7XG5cdCAgICB2YXIgY3JpdGVyaWEgPSBhcmdzW2kgKyAxXTtcblx0ICAgIGlmICghL1s8Pj0hXS8udGVzdChjcml0ZXJpYSkpIHtcblx0ICAgICAgY3JpdGVyaWEgPSAnPT1cIicgKyBjcml0ZXJpYSArICdcIic7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJhbmdlLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgcmFuZ2Vbal0gIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgcmVzdWx0c1tqXSA9IHJlc3VsdHNbal0gJiYgZXZhbChyYW5nZVtqXSArIGNyaXRlcmlhKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmVzdWx0c1tqXSA9IHJlc3VsdHNbal0gJiYgZXZhbCgnXCInICsgcmFuZ2Vbal0gKyAnXCInICsgY3JpdGVyaWEpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHJlc3VsdHNbaV0pIHtcblx0ICAgICAgcmVzdWx0Kys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1VOVFVOSVFVRSA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gbWlzYy5VTklRVUUuYXBwbHkobnVsbCwgdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKS5sZW5ndGg7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1ZBUklBTkNFID0ge307XG5cblx0ZXhwb3J0cy5DT1ZBUklBTkNFLlAgPSBmdW5jdGlvbihhcnJheTEsIGFycmF5Mikge1xuXHQgIGFycmF5MSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheTEpKTtcblx0ICBhcnJheTIgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkyKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXkxLCBhcnJheTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBtZWFuMSA9IGpTdGF0Lm1lYW4oYXJyYXkxKTtcblx0ICB2YXIgbWVhbjIgPSBqU3RhdC5tZWFuKGFycmF5Mik7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgdmFyIG4gPSBhcnJheTEubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gKGFycmF5MVtpXSAtIG1lYW4xKSAqIChhcnJheTJbaV0gLSBtZWFuMik7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQgLyBuO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09WQVJJQU5DRS5TID0gZnVuY3Rpb24oYXJyYXkxLCBhcnJheTIpIHtcblx0ICBhcnJheTEgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkxKSk7XG5cdCAgYXJyYXkyID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5MikpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5MSwgYXJyYXkyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQuY292YXJpYW5jZShhcnJheTEsIGFycmF5Mik7XG5cdH07XG5cblx0ZXhwb3J0cy5ERVZTUSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgbWVhbiA9IGpTdGF0Lm1lYW4ocmFuZ2UpO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2UubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSBNYXRoLnBvdygocmFuZ2VbaV0gLSBtZWFuKSwgMik7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5FWFBPTiA9IHt9O1xuXG5cdGV4cG9ydHMuRVhQT04uRElTVCA9IGZ1bmN0aW9uKHgsIGxhbWJkYSwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBsYW1iZGEgPSB1dGlscy5wYXJzZU51bWJlcihsYW1iZGEpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIGxhbWJkYSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LmV4cG9uZW50aWFsLmNkZih4LCBsYW1iZGEpIDogalN0YXQuZXhwb25lbnRpYWwucGRmKHgsIGxhbWJkYSk7XG5cdH07XG5cblx0ZXhwb3J0cy5GID0ge307XG5cblx0ZXhwb3J0cy5GLkRJU1QgPSBmdW5jdGlvbih4LCBkMSwgZDIsIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgZDEgPSB1dGlscy5wYXJzZU51bWJlcihkMSk7XG5cdCAgZDIgPSB1dGlscy5wYXJzZU51bWJlcihkMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgZDEsIGQyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQuY2VudHJhbEYuY2RmKHgsIGQxLCBkMikgOiBqU3RhdC5jZW50cmFsRi5wZGYoeCwgZDEsIGQyKTtcblx0fTtcblxuXHRleHBvcnRzLkYuRElTVC5SVCA9IGZ1bmN0aW9uKHgsIGQxLCBkMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAzKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHggPCAwIHx8IGQxIDwgMSB8fCBkMiA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZDEgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGQyICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gMSAtIGpTdGF0LmNlbnRyYWxGLmNkZih4LCBkMSwgZDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRi5JTlYgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgZDEsIGQyKSB7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgZDEgPSB1dGlscy5wYXJzZU51bWJlcihkMSk7XG5cdCAgZDIgPSB1dGlscy5wYXJzZU51bWJlcihkMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocHJvYmFiaWxpdHksIGQxLCBkMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHByb2JhYmlsaXR5IDw9IDAuMCB8fCBwcm9iYWJpbGl0eSA+IDEuMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuY2VudHJhbEYuaW52KHByb2JhYmlsaXR5LCBkMSwgZDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRi5JTlYuUlQgPSBmdW5jdGlvbihwLCBkMSwgZDIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMykge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChwIDwgMCB8fCBwID4gMSB8fCBkMSA8IDEgfHwgZDEgPiBNYXRoLnBvdygxMCwgMTApIHx8IGQyIDwgMSB8fCBkMiA+IE1hdGgucG93KDEwLCAxMCkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgcCAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZDEgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGQyICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuY2VudHJhbEYuaW52KDEuMCAtIHAsIGQxLCBkMik7XG5cdH07XG5cblx0ZXhwb3J0cy5GLlRFU1QgPSBmdW5jdGlvbihhcnJheTEsIGFycmF5Mikge1xuXHQgIGlmICghYXJyYXkxIHx8ICFhcnJheTIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoIShhcnJheTEgaW5zdGFuY2VvZiBBcnJheSkgfHwgIShhcnJheTIgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoYXJyYXkxLmxlbmd0aCA8IDIgfHwgYXJyYXkyLmxlbmd0aCA8IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5kaXYwO1xuXHQgIH1cblxuXHQgIHZhciBzdW1PZlNxdWFyZXMgPSBmdW5jdGlvbih2YWx1ZXMsIHgxKSB7XG5cdCAgICB2YXIgc3VtID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHN1bSArPU1hdGgucG93KCh2YWx1ZXNbaV0gLSB4MSksIDIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHN1bTtcblx0ICB9O1xuXG5cdCAgdmFyIHgxID0gbWF0aFRyaWcuU1VNKGFycmF5MSkgLyBhcnJheTEubGVuZ3RoO1xuXHQgIHZhciB4MiA9IG1hdGhUcmlnLlNVTShhcnJheTIpIC8gYXJyYXkyLmxlbmd0aDtcblx0ICB2YXIgc3VtMSA9IHN1bU9mU3F1YXJlcyhhcnJheTEsIHgxKSAvIChhcnJheTEubGVuZ3RoIC0gMSk7XG5cdCAgdmFyIHN1bTIgPSBzdW1PZlNxdWFyZXMoYXJyYXkyLCB4MikgLyAoYXJyYXkyLmxlbmd0aCAtIDEpO1xuXG5cdCAgcmV0dXJuIHN1bTEgLyBzdW0yO1xuXHR9O1xuXG5cdGV4cG9ydHMuRklTSEVSID0gZnVuY3Rpb24oeCkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBpZiAoeCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4geDtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG5cdH07XG5cblx0ZXhwb3J0cy5GSVNIRVJJTlYgPSBmdW5jdGlvbih5KSB7XG5cdCAgeSA9IHV0aWxzLnBhcnNlTnVtYmVyKHkpO1xuXHQgIGlmICh5IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiB5O1xuXHQgIH1cblx0ICB2YXIgZTJ5ID0gTWF0aC5leHAoMiAqIHkpO1xuXHQgIHJldHVybiAoZTJ5IC0gMSkgLyAoZTJ5ICsgMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5GT1JFQ0FTVCA9IGZ1bmN0aW9uKHgsIGRhdGFfeSwgZGF0YV94KSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgZGF0YV95LCBkYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciB4bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV94KTtcblx0ICB2YXIgeW1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeSk7XG5cdCAgdmFyIG4gPSBkYXRhX3gubGVuZ3RoO1xuXHQgIHZhciBudW0gPSAwO1xuXHQgIHZhciBkZW4gPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBudW0gKz0gKGRhdGFfeFtpXSAtIHhtZWFuKSAqIChkYXRhX3lbaV0gLSB5bWVhbik7XG5cdCAgICBkZW4gKz0gTWF0aC5wb3coZGF0YV94W2ldIC0geG1lYW4sIDIpO1xuXHQgIH1cblx0ICB2YXIgYiA9IG51bSAvIGRlbjtcblx0ICB2YXIgYSA9IHltZWFuIC0gYiAqIHhtZWFuO1xuXHQgIHJldHVybiBhICsgYiAqIHg7XG5cdH07XG5cblx0ZXhwb3J0cy5GUkVRVUVOQ1kgPSBmdW5jdGlvbihkYXRhLCBiaW5zKSB7XG5cdCAgZGF0YSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhKSk7XG5cdCAgYmlucyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihiaW5zKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YSwgYmlucykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIG4gPSBkYXRhLmxlbmd0aDtcblx0ICB2YXIgYiA9IGJpbnMubGVuZ3RoO1xuXHQgIHZhciByID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYjsgaSsrKSB7XG5cdCAgICByW2ldID0gMDtcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG5cdCAgICAgIGlmIChpID09PSAwKSB7XG5cdCAgICAgICAgaWYgKGRhdGFbal0gPD0gYmluc1swXSkge1xuXHQgICAgICAgICAgclswXSArPSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChpIDwgYikge1xuXHQgICAgICAgIGlmIChkYXRhW2pdID4gYmluc1tpIC0gMV0gJiYgZGF0YVtqXSA8PSBiaW5zW2ldKSB7XG5cdCAgICAgICAgICByW2ldICs9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKGkgPT09IGIpIHtcblx0ICAgICAgICBpZiAoZGF0YVtqXSA+IGJpbnNbYiAtIDFdKSB7XG5cdCAgICAgICAgICByW2JdICs9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByO1xuXHR9O1xuXG5cblx0ZXhwb3J0cy5HQU1NQSA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblxuXHQgIGlmIChudW1iZXIgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKHBhcnNlSW50KG51bWJlciwgMTApID09PSBudW1iZXIgJiYgbnVtYmVyIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuZ2FtbWFmbihudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR0FNTUEuRElTVCA9IGZ1bmN0aW9uKHZhbHVlLCBhbHBoYSwgYmV0YSwgY3VtdWxhdGl2ZSkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSA0KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHZhbHVlIDwgMCB8fCBhbHBoYSA8PSAwIHx8IGJldGEgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBhbHBoYSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgYmV0YSAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGN1bXVsYXRpdmUgPyBqU3RhdC5nYW1tYS5jZGYodmFsdWUsIGFscGhhLCBiZXRhLCB0cnVlKSA6IGpTdGF0LmdhbW1hLnBkZih2YWx1ZSwgYWxwaGEsIGJldGEsIGZhbHNlKTtcblx0fTtcblxuXHRleHBvcnRzLkdBTU1BLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBhbHBoYSwgYmV0YSkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAzKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEgfHwgYWxwaGEgPD0gMCB8fCBiZXRhIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgcHJvYmFiaWxpdHkgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGFscGhhICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBiZXRhICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuZ2FtbWEuaW52KHByb2JhYmlsaXR5LCBhbHBoYSwgYmV0YSk7XG5cdH07XG5cblx0ZXhwb3J0cy5HQU1NQUxOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5nYW1tYWxuKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5HQU1NQUxOLlBSRUNJU0UgPSBmdW5jdGlvbih4KSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoeCA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuZ2FtbWFsbih4KTtcblx0fTtcblxuXHRleHBvcnRzLkdBVVNTID0gZnVuY3Rpb24oeikge1xuXHQgIHogPSB1dGlscy5wYXJzZU51bWJlcih6KTtcblx0ICBpZiAoeiBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gejtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0Lm5vcm1hbC5jZGYoeiwgMCwgMSkgLSAwLjU7XG5cdH07XG5cblx0ZXhwb3J0cy5HRU9NRUFOID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKGFyZ3MgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGFyZ3M7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5nZW9tZWFuKGFyZ3MpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR1JPV1RIID0gZnVuY3Rpb24oa25vd25feSwga25vd25feCwgbmV3X3gsIHVzZV9jb25zdCkge1xuXHQgIC8vIENyZWRpdHM6IElsbWFyaSBLYXJvbmVuIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0MTYxOTkwL2hvdy10by1pbXBsZW1lbnQtZ3Jvd3RoLWZ1bmN0aW9uLWluLWphdmFzY3JpcHQpXG5cblx0ICBrbm93bl95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheShrbm93bl95KTtcblx0ICBpZiAoa25vd25feSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4ga25vd25feTtcblx0ICB9XG5cblx0ICAvLyBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9uYWwgcGFyYW1ldGVyczpcblx0ICB2YXIgaTtcblx0ICBpZiAoa25vd25feCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBrbm93bl94ID0gW107XG5cdCAgICBmb3IgKGkgPSAxOyBpIDw9IGtub3duX3kubGVuZ3RoOyBpKyspIHtcblx0ICAgICAga25vd25feC5wdXNoKGkpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAobmV3X3ggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgbmV3X3ggPSBbXTtcblx0ICAgIGZvciAoaSA9IDE7IGkgPD0ga25vd25feS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBuZXdfeC5wdXNoKGkpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGtub3duX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KGtub3duX3gpO1xuXHQgIG5ld194ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheShuZXdfeCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioa25vd25feCwgbmV3X3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cblx0ICBpZiAodXNlX2NvbnN0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHVzZV9jb25zdCA9IHRydWU7XG5cdCAgfVxuXG5cdCAgLy8gQ2FsY3VsYXRlIHN1bXMgb3ZlciB0aGUgZGF0YTpcblx0ICB2YXIgbiA9IGtub3duX3kubGVuZ3RoO1xuXHQgIHZhciBhdmdfeCA9IDA7XG5cdCAgdmFyIGF2Z195ID0gMDtcblx0ICB2YXIgYXZnX3h5ID0gMDtcblx0ICB2YXIgYXZnX3h4ID0gMDtcblx0ICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICB2YXIgeCA9IGtub3duX3hbaV07XG5cdCAgICB2YXIgeSA9IE1hdGgubG9nKGtub3duX3lbaV0pO1xuXHQgICAgYXZnX3ggKz0geDtcblx0ICAgIGF2Z195ICs9IHk7XG5cdCAgICBhdmdfeHkgKz0geCAqIHk7XG5cdCAgICBhdmdfeHggKz0geCAqIHg7XG5cdCAgfVxuXHQgIGF2Z194IC89IG47XG5cdCAgYXZnX3kgLz0gbjtcblx0ICBhdmdfeHkgLz0gbjtcblx0ICBhdmdfeHggLz0gbjtcblxuXHQgIC8vIENvbXB1dGUgbGluZWFyIHJlZ3Jlc3Npb24gY29lZmZpY2llbnRzOlxuXHQgIHZhciBiZXRhO1xuXHQgIHZhciBhbHBoYTtcblx0ICBpZiAodXNlX2NvbnN0KSB7XG5cdCAgICBiZXRhID0gKGF2Z194eSAtIGF2Z194ICogYXZnX3kpIC8gKGF2Z194eCAtIGF2Z194ICogYXZnX3gpO1xuXHQgICAgYWxwaGEgPSBhdmdfeSAtIGJldGEgKiBhdmdfeDtcblx0ICB9IGVsc2Uge1xuXHQgICAgYmV0YSA9IGF2Z194eSAvIGF2Z194eDtcblx0ICAgIGFscGhhID0gMDtcblx0ICB9XG5cblx0ICAvLyBDb21wdXRlIGFuZCByZXR1cm4gcmVzdWx0IGFycmF5OlxuXHQgIHZhciBuZXdfeSA9IFtdO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBuZXdfeC5sZW5ndGg7IGkrKykge1xuXHQgICAgbmV3X3kucHVzaChNYXRoLmV4cChhbHBoYSArIGJldGEgKiBuZXdfeFtpXSkpO1xuXHQgIH1cblx0ICByZXR1cm4gbmV3X3k7XG5cdH07XG5cblx0ZXhwb3J0cy5IQVJNRUFOID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBkZW4gPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBkZW4gKz0gMSAvIHJhbmdlW2ldO1xuXHQgIH1cblx0ICByZXR1cm4gbiAvIGRlbjtcblx0fTtcblxuXHRleHBvcnRzLkhZUEdFT00gPSB7fTtcblxuXHRleHBvcnRzLkhZUEdFT00uRElTVCA9IGZ1bmN0aW9uKHgsIG4sIE0sIE4sIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIE0gPSB1dGlscy5wYXJzZU51bWJlcihNKTtcblx0ICBOID0gdXRpbHMucGFyc2VOdW1iZXIoTik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbiwgTSwgTikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBwZGYoeCwgbiwgTSwgTikge1xuXHQgICAgcmV0dXJuIG1hdGhUcmlnLkNPTUJJTihNLCB4KSAqIG1hdGhUcmlnLkNPTUJJTihOIC0gTSwgbiAtIHgpIC8gbWF0aFRyaWcuQ09NQklOKE4sIG4pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNkZih4LCBuLCBNLCBOKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHg7IGkrKykge1xuXHQgICAgICByZXN1bHQgKz0gcGRmKGksIG4sIE0sIE4pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8gY2RmKHgsIG4sIE0sIE4pIDogcGRmKHgsIG4sIE0sIE4pO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU5URVJDRVBUID0gZnVuY3Rpb24oa25vd25feSwga25vd25feCkge1xuXHQgIGtub3duX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KGtub3duX3kpO1xuXHQgIGtub3duX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KGtub3duX3gpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGtub3duX3ksIGtub3duX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChrbm93bl95Lmxlbmd0aCAhPT0ga25vd25feC5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cdCAgcmV0dXJuIGV4cG9ydHMuRk9SRUNBU1QoMCwga25vd25feSwga25vd25feCk7XG5cdH07XG5cblx0ZXhwb3J0cy5LVVJUID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBtZWFuID0galN0YXQubWVhbihyYW5nZSk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHNpZ21hID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgc2lnbWEgKz0gTWF0aC5wb3cocmFuZ2VbaV0gLSBtZWFuLCA0KTtcblx0ICB9XG5cdCAgc2lnbWEgPSBzaWdtYSAvIE1hdGgucG93KGpTdGF0LnN0ZGV2KHJhbmdlLCB0cnVlKSwgNCk7XG5cdCAgcmV0dXJuICgobiAqIChuICsgMSkpIC8gKChuIC0gMSkgKiAobiAtIDIpICogKG4gLSAzKSkpICogc2lnbWEgLSAzICogKG4gLSAxKSAqIChuIC0gMSkgLyAoKG4gLSAyKSAqIChuIC0gMykpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTEFSR0UgPSBmdW5jdGlvbihyYW5nZSwgaykge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCBrKSkge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICByZXR1cm4gcmFuZ2Uuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYiAtIGE7XG5cdCAgfSlbayAtIDFdO1xuXHR9O1xuXG5cdGV4cG9ydHMuTElORVNUID0gZnVuY3Rpb24oZGF0YV95LCBkYXRhX3gpIHtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRhdGFfeSwgZGF0YV94KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgeW1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeSk7XG5cdCAgdmFyIHhtZWFuID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciBuID0gZGF0YV94Lmxlbmd0aDtcblx0ICB2YXIgbnVtID0gMDtcblx0ICB2YXIgZGVuID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgbnVtICs9IChkYXRhX3hbaV0gLSB4bWVhbikgKiAoZGF0YV95W2ldIC0geW1lYW4pO1xuXHQgICAgZGVuICs9IE1hdGgucG93KGRhdGFfeFtpXSAtIHhtZWFuLCAyKTtcblx0ICB9XG5cdCAgdmFyIG0gPSBudW0gLyBkZW47XG5cdCAgdmFyIGIgPSB5bWVhbiAtIG0gKiB4bWVhbjtcblx0ICByZXR1cm4gW20sIGJdO1xuXHR9O1xuXG5cdC8vIEFjY29yZGluZyB0byBNaWNyb3NvZnQ6XG5cdC8vIGh0dHA6Ly9vZmZpY2UubWljcm9zb2Z0LmNvbS9lbi11cy9zdGFydGVyLWhlbHAvbG9nZXN0LWZ1bmN0aW9uLUhQMDEwMzQyNjY1LmFzcHhcblx0Ly8gTE9HRVNUIHJldHVybnMgYXJlIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgbGluZWFyIG1vZGVsOlxuXHQvLyBsbiB5ID0geDEgbG4gbTEgKyAuLi4gKyB4biBsbiBtbiArIGxuIGJcblx0ZXhwb3J0cy5MT0dFU1QgPSBmdW5jdGlvbihkYXRhX3ksIGRhdGFfeCkge1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV95LCBkYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YV95Lmxlbmd0aDsgaSArKykge1xuXHQgICAgZGF0YV95W2ldID0gTWF0aC5sb2coZGF0YV95W2ldKTtcblx0ICB9XG5cblx0ICB2YXIgcmVzdWx0ID0gZXhwb3J0cy5MSU5FU1QoZGF0YV95LCBkYXRhX3gpO1xuXHQgIHJlc3VsdFswXSA9IE1hdGgucm91bmQoTWF0aC5leHAocmVzdWx0WzBdKSoxMDAwMDAwKS8xMDAwMDAwO1xuXHQgIHJlc3VsdFsxXSA9IE1hdGgucm91bmQoTWF0aC5leHAocmVzdWx0WzFdKSoxMDAwMDAwKS8xMDAwMDAwO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5MT0dOT1JNID0ge307XG5cblx0ZXhwb3J0cy5MT0dOT1JNLkRJU1QgPSBmdW5jdGlvbih4LCBtZWFuLCBzZCwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBtZWFuID0gdXRpbHMucGFyc2VOdW1iZXIobWVhbik7XG5cdCAgc2QgPSB1dGlscy5wYXJzZU51bWJlcihzZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbWVhbiwgc2QpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5sb2dub3JtYWwuY2RmKHgsIG1lYW4sIHNkKSA6IGpTdGF0LmxvZ25vcm1hbC5wZGYoeCwgbWVhbiwgc2QpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTE9HTk9STS5JTlYgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgbWVhbiwgc2QpIHtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBtZWFuID0gdXRpbHMucGFyc2VOdW1iZXIobWVhbik7XG5cdCAgc2QgPSB1dGlscy5wYXJzZU51bWJlcihzZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocHJvYmFiaWxpdHksIG1lYW4sIHNkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQubG9nbm9ybWFsLmludihwcm9iYWJpbGl0eSwgbWVhbiwgc2QpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUFYID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHJldHVybiAocmFuZ2UubGVuZ3RoID09PSAwKSA/IDAgOiBNYXRoLm1heC5hcHBseShNYXRoLCByYW5nZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5NQVhBID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuYXJyYXlWYWx1ZXNUb051bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICByZXR1cm4gKHJhbmdlLmxlbmd0aCA9PT0gMCkgPyAwIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgcmFuZ2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUVESUFOID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuYXJyYXlWYWx1ZXNUb051bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICByZXR1cm4galN0YXQubWVkaWFuKHJhbmdlKTtcblx0fTtcblxuXHRleHBvcnRzLk1JTiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLm51bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICByZXR1cm4gKHJhbmdlLmxlbmd0aCA9PT0gMCkgPyAwIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgcmFuZ2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlOQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmFycmF5VmFsdWVzVG9OdW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgcmV0dXJuIChyYW5nZS5sZW5ndGggPT09IDApID8gMCA6IE1hdGgubWluLmFwcGx5KE1hdGgsIHJhbmdlKTtcblx0fTtcblxuXHRleHBvcnRzLk1PREUgPSB7fTtcblxuXHRleHBvcnRzLk1PREUuTVVMVCA9IGZ1bmN0aW9uKCkge1xuXHQgIC8vIENyZWRpdHM6IFJvw7ZuYcOkblxuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgY291bnQgPSB7fTtcblx0ICB2YXIgbWF4SXRlbXMgPSBbXTtcblx0ICB2YXIgbWF4ID0gMDtcblx0ICB2YXIgY3VycmVudEl0ZW07XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgY3VycmVudEl0ZW0gPSByYW5nZVtpXTtcblx0ICAgIGNvdW50W2N1cnJlbnRJdGVtXSA9IGNvdW50W2N1cnJlbnRJdGVtXSA/IGNvdW50W2N1cnJlbnRJdGVtXSArIDEgOiAxO1xuXHQgICAgaWYgKGNvdW50W2N1cnJlbnRJdGVtXSA+IG1heCkge1xuXHQgICAgICBtYXggPSBjb3VudFtjdXJyZW50SXRlbV07XG5cdCAgICAgIG1heEl0ZW1zID0gW107XG5cdCAgICB9XG5cdCAgICBpZiAoY291bnRbY3VycmVudEl0ZW1dID09PSBtYXgpIHtcblx0ICAgICAgbWF4SXRlbXNbbWF4SXRlbXMubGVuZ3RoXSA9IGN1cnJlbnRJdGVtO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gbWF4SXRlbXM7XG5cdH07XG5cblx0ZXhwb3J0cy5NT0RFLlNOR0wgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgcmV0dXJuIGV4cG9ydHMuTU9ERS5NVUxUKHJhbmdlKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9KVswXTtcblx0fTtcblxuXHRleHBvcnRzLk5FR0JJTk9NID0ge307XG5cblx0ZXhwb3J0cy5ORUdCSU5PTS5ESVNUID0gZnVuY3Rpb24oaywgciwgcCwgY3VtdWxhdGl2ZSkge1xuXHQgIGsgPSB1dGlscy5wYXJzZU51bWJlcihrKTtcblx0ICByID0gdXRpbHMucGFyc2VOdW1iZXIocik7XG5cdCAgcCA9IHV0aWxzLnBhcnNlTnVtYmVyKHApO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGssIHIsIHApKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5uZWdiaW4uY2RmKGssIHIsIHApIDogalN0YXQubmVnYmluLnBkZihrLCByLCBwKTtcblx0fTtcblxuXHRleHBvcnRzLk5PUk0gPSB7fTtcblxuXHRleHBvcnRzLk5PUk0uRElTVCA9IGZ1bmN0aW9uKHgsIG1lYW4sIHNkLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG1lYW4gPSB1dGlscy5wYXJzZU51bWJlcihtZWFuKTtcblx0ICBzZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNkKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBtZWFuLCBzZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHNkIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG5vcm1hbCBkaXN0cmlidXRpb24gY29tcHV0ZWQgYnkgalN0YXQgW2h0dHA6Ly9qc3RhdC5vcmddXG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0Lm5vcm1hbC5jZGYoeCwgbWVhbiwgc2QpIDogalN0YXQubm9ybWFsLnBkZih4LCBtZWFuLCBzZCk7XG5cdH07XG5cblx0ZXhwb3J0cy5OT1JNLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBtZWFuLCBzZCkge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIG1lYW4gPSB1dGlscy5wYXJzZU51bWJlcihtZWFuKTtcblx0ICBzZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNkKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgbWVhbiwgc2QpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5ub3JtYWwuaW52KHByb2JhYmlsaXR5LCBtZWFuLCBzZCk7XG5cdH07XG5cblx0ZXhwb3J0cy5OT1JNLlMgPSB7fTtcblxuXHRleHBvcnRzLk5PUk0uUy5ESVNUID0gZnVuY3Rpb24oeiwgY3VtdWxhdGl2ZSkge1xuXHQgIHogPSB1dGlscy5wYXJzZU51bWJlcih6KTtcblx0ICBpZiAoeiBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5ub3JtYWwuY2RmKHosIDAsIDEpIDogalN0YXQubm9ybWFsLnBkZih6LCAwLCAxKTtcblx0fTtcblxuXHRleHBvcnRzLk5PUk0uUy5JTlYgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSkge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGlmIChwcm9iYWJpbGl0eSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5ub3JtYWwuaW52KHByb2JhYmlsaXR5LCAwLCAxKTtcblx0fTtcblxuXHRleHBvcnRzLlBFQVJTT04gPSBmdW5jdGlvbihkYXRhX3gsIGRhdGFfeSkge1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV95LCBkYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciB4bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV94KTtcblx0ICB2YXIgeW1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeSk7XG5cdCAgdmFyIG4gPSBkYXRhX3gubGVuZ3RoO1xuXHQgIHZhciBudW0gPSAwO1xuXHQgIHZhciBkZW4xID0gMDtcblx0ICB2YXIgZGVuMiA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIG51bSArPSAoZGF0YV94W2ldIC0geG1lYW4pICogKGRhdGFfeVtpXSAtIHltZWFuKTtcblx0ICAgIGRlbjEgKz0gTWF0aC5wb3coZGF0YV94W2ldIC0geG1lYW4sIDIpO1xuXHQgICAgZGVuMiArPSBNYXRoLnBvdyhkYXRhX3lbaV0gLSB5bWVhbiwgMik7XG5cdCAgfVxuXHQgIHJldHVybiBudW0gLyBNYXRoLnNxcnQoZGVuMSAqIGRlbjIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVSQ0VOVElMRSA9IHt9O1xuXG5cdGV4cG9ydHMuUEVSQ0VOVElMRS5FWEMgPSBmdW5jdGlvbihhcnJheSwgaykge1xuXHQgIGFycmF5ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5KSk7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5LCBrKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBhcnJheSA9IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAge1xuXHQgICAgICByZXR1cm4gYSAtIGI7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG5cdCAgaWYgKGsgPCAxIC8gKG4gKyAxKSB8fCBrID4gMSAtIDEgLyAobiArIDEpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0ICB2YXIgbCA9IGsgKiAobiArIDEpIC0gMTtcblx0ICB2YXIgZmwgPSBNYXRoLmZsb29yKGwpO1xuXHQgIHJldHVybiB1dGlscy5jbGVhbkZsb2F0KChsID09PSBmbCkgPyBhcnJheVtsXSA6IGFycmF5W2ZsXSArIChsIC0gZmwpICogKGFycmF5W2ZsICsgMV0gLSBhcnJheVtmbF0pKTtcblx0fTtcblxuXHRleHBvcnRzLlBFUkNFTlRJTEUuSU5DID0gZnVuY3Rpb24oYXJyYXksIGspIHtcblx0ICBhcnJheSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheSkpO1xuXHQgIGsgPSB1dGlscy5wYXJzZU51bWJlcihrKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheSwgaykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgYXJyYXkgPSBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9KTtcblx0ICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcblx0ICB2YXIgbCA9IGsgKiAobiAtIDEpO1xuXHQgIHZhciBmbCA9IE1hdGguZmxvb3IobCk7XG5cdCAgcmV0dXJuIHV0aWxzLmNsZWFuRmxvYXQoKGwgPT09IGZsKSA/IGFycmF5W2xdIDogYXJyYXlbZmxdICsgKGwgLSBmbCkgKiAoYXJyYXlbZmwgKyAxXSAtIGFycmF5W2ZsXSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVSQ0VOVFJBTksgPSB7fTtcblxuXHRleHBvcnRzLlBFUkNFTlRSQU5LLkVYQyA9IGZ1bmN0aW9uKGFycmF5LCB4LCBzaWduaWZpY2FuY2UpIHtcblx0ICBzaWduaWZpY2FuY2UgPSAoc2lnbmlmaWNhbmNlID09PSB1bmRlZmluZWQpID8gMyA6IHNpZ25pZmljYW5jZTtcblx0ICBhcnJheSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheSkpO1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBzaWduaWZpY2FuY2UgPSB1dGlscy5wYXJzZU51bWJlcihzaWduaWZpY2FuY2UpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5LCB4LCBzaWduaWZpY2FuY2UpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGFycmF5ID0gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSk7XG5cdCAgdmFyIHVuaXF1ZXMgPSBtaXNjLlVOSVFVRS5hcHBseShudWxsLCBhcnJheSk7XG5cdCAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG5cdCAgdmFyIG0gPSB1bmlxdWVzLmxlbmd0aDtcblx0ICB2YXIgcG93ZXIgPSBNYXRoLnBvdygxMCwgc2lnbmlmaWNhbmNlKTtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICB2YXIgbWF0Y2ggPSBmYWxzZTtcblx0ICB2YXIgaSA9IDA7XG5cdCAgd2hpbGUgKCFtYXRjaCAmJiBpIDwgbSkge1xuXHQgICAgaWYgKHggPT09IHVuaXF1ZXNbaV0pIHtcblx0ICAgICAgcmVzdWx0ID0gKGFycmF5LmluZGV4T2YodW5pcXVlc1tpXSkgKyAxKSAvIChuICsgMSk7XG5cdCAgICAgIG1hdGNoID0gdHJ1ZTtcblx0ICAgIH0gZWxzZSBpZiAoeCA+PSB1bmlxdWVzW2ldICYmICh4IDwgdW5pcXVlc1tpICsgMV0gfHwgaSA9PT0gbSAtIDEpKSB7XG5cdCAgICAgIHJlc3VsdCA9IChhcnJheS5pbmRleE9mKHVuaXF1ZXNbaV0pICsgMSArICh4IC0gdW5pcXVlc1tpXSkgLyAodW5pcXVlc1tpICsgMV0gLSB1bmlxdWVzW2ldKSkgLyAobiArIDEpO1xuXHQgICAgICBtYXRjaCA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpKys7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmZsb29yKHJlc3VsdCAqIHBvd2VyKSAvIHBvd2VyO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVSQ0VOVFJBTksuSU5DID0gZnVuY3Rpb24oYXJyYXksIHgsIHNpZ25pZmljYW5jZSkge1xuXHQgIHNpZ25pZmljYW5jZSA9IChzaWduaWZpY2FuY2UgPT09IHVuZGVmaW5lZCkgPyAzIDogc2lnbmlmaWNhbmNlO1xuXHQgIGFycmF5ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5KSk7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIHNpZ25pZmljYW5jZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNpZ25pZmljYW5jZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXksIHgsIHNpZ25pZmljYW5jZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgYXJyYXkgPSBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9KTtcblx0ICB2YXIgdW5pcXVlcyA9IG1pc2MuVU5JUVVFLmFwcGx5KG51bGwsIGFycmF5KTtcblx0ICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcblx0ICB2YXIgbSA9IHVuaXF1ZXMubGVuZ3RoO1xuXHQgIHZhciBwb3dlciA9IE1hdGgucG93KDEwLCBzaWduaWZpY2FuY2UpO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIHZhciBtYXRjaCA9IGZhbHNlO1xuXHQgIHZhciBpID0gMDtcblx0ICB3aGlsZSAoIW1hdGNoICYmIGkgPCBtKSB7XG5cdCAgICBpZiAoeCA9PT0gdW5pcXVlc1tpXSkge1xuXHQgICAgICByZXN1bHQgPSBhcnJheS5pbmRleE9mKHVuaXF1ZXNbaV0pIC8gKG4gLSAxKTtcblx0ICAgICAgbWF0Y2ggPSB0cnVlO1xuXHQgICAgfSBlbHNlIGlmICh4ID49IHVuaXF1ZXNbaV0gJiYgKHggPCB1bmlxdWVzW2kgKyAxXSB8fCBpID09PSBtIC0gMSkpIHtcblx0ICAgICAgcmVzdWx0ID0gKGFycmF5LmluZGV4T2YodW5pcXVlc1tpXSkgKyAoeCAtIHVuaXF1ZXNbaV0pIC8gKHVuaXF1ZXNbaSArIDFdIC0gdW5pcXVlc1tpXSkpIC8gKG4gLSAxKTtcblx0ICAgICAgbWF0Y2ggPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgaSsrO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5mbG9vcihyZXN1bHQgKiBwb3dlcikgLyBwb3dlcjtcblx0fTtcblxuXHRleHBvcnRzLlBFUk1VVCA9IGZ1bmN0aW9uKG51bWJlciwgbnVtYmVyX2Nob3Nlbikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgbnVtYmVyX2Nob3NlbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcl9jaG9zZW4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgbnVtYmVyX2Nob3NlbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIG1hdGhUcmlnLkZBQ1QobnVtYmVyKSAvIG1hdGhUcmlnLkZBQ1QobnVtYmVyIC0gbnVtYmVyX2Nob3Nlbik7XG5cdH07XG5cblx0ZXhwb3J0cy5QRVJNVVRBVElPTkEgPSBmdW5jdGlvbihudW1iZXIsIG51bWJlcl9jaG9zZW4pIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIG51bWJlcl9jaG9zZW4gPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXJfY2hvc2VuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIG51bWJlcl9jaG9zZW4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLnBvdyhudW1iZXIsIG51bWJlcl9jaG9zZW4pO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEhJID0gZnVuY3Rpb24oeCkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBpZiAoeCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmV4cCgtMC41ICogeCAqIHgpIC8gU1FSVDJQSTtcblx0fTtcblxuXHRleHBvcnRzLlBPSVNTT04gPSB7fTtcblxuXHRleHBvcnRzLlBPSVNTT04uRElTVCA9IGZ1bmN0aW9uKHgsIG1lYW4sIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbWVhbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG1lYW4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG1lYW4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5wb2lzc29uLmNkZih4LCBtZWFuKSA6IGpTdGF0LnBvaXNzb24ucGRmKHgsIG1lYW4pO1xuXHR9O1xuXG5cdGV4cG9ydHMuUFJPQiA9IGZ1bmN0aW9uKHJhbmdlLCBwcm9iYWJpbGl0eSwgbG93ZXIsIHVwcGVyKSB7XG5cdCAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblx0ICB1cHBlciA9ICh1cHBlciA9PT0gdW5kZWZpbmVkKSA/IGxvd2VyIDogdXBwZXI7XG5cblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHByb2JhYmlsaXR5KSk7XG5cdCAgbG93ZXIgPSB1dGlscy5wYXJzZU51bWJlcihsb3dlcik7XG5cdCAgdXBwZXIgPSB1dGlscy5wYXJzZU51bWJlcih1cHBlcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIHByb2JhYmlsaXR5LCBsb3dlciwgdXBwZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKGxvd2VyID09PSB1cHBlcikge1xuXHQgICAgcmV0dXJuIChyYW5nZS5pbmRleE9mKGxvd2VyKSA+PSAwKSA/IHByb2JhYmlsaXR5W3JhbmdlLmluZGV4T2YobG93ZXIpXSA6IDA7XG5cdCAgfVxuXG5cdCAgdmFyIHNvcnRlZCA9IHJhbmdlLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pO1xuXHQgIHZhciBuID0gc29ydGVkLmxlbmd0aDtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgaWYgKHNvcnRlZFtpXSA+PSBsb3dlciAmJiBzb3J0ZWRbaV0gPD0gdXBwZXIpIHtcblx0ICAgICAgcmVzdWx0ICs9IHByb2JhYmlsaXR5W3JhbmdlLmluZGV4T2Yoc29ydGVkW2ldKV07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5RVUFSVElMRSA9IHt9O1xuXG5cdGV4cG9ydHMuUVVBUlRJTEUuRVhDID0gZnVuY3Rpb24ocmFuZ2UsIHF1YXJ0KSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBxdWFydCA9IHV0aWxzLnBhcnNlTnVtYmVyKHF1YXJ0KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYW5nZSwgcXVhcnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHN3aXRjaCAocXVhcnQpIHtcblx0ICAgIGNhc2UgMTpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUEVSQ0VOVElMRS5FWEMocmFuZ2UsIDAuMjUpO1xuXHQgICAgY2FzZSAyOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QRVJDRU5USUxFLkVYQyhyYW5nZSwgMC41KTtcblx0ICAgIGNhc2UgMzpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUEVSQ0VOVElMRS5FWEMocmFuZ2UsIDAuNzUpO1xuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5RVUFSVElMRS5JTkMgPSBmdW5jdGlvbihyYW5nZSwgcXVhcnQpIHtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIHF1YXJ0ID0gdXRpbHMucGFyc2VOdW1iZXIocXVhcnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCBxdWFydCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgc3dpdGNoIChxdWFydCkge1xuXHQgICAgY2FzZSAxOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QRVJDRU5USUxFLklOQyhyYW5nZSwgMC4yNSk7XG5cdCAgICBjYXNlIDI6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBFUkNFTlRJTEUuSU5DKHJhbmdlLCAwLjUpO1xuXHQgICAgY2FzZSAzOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QRVJDRU5USUxFLklOQyhyYW5nZSwgMC43NSk7XG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLlJBTksgPSB7fTtcblxuXHRleHBvcnRzLlJBTksuQVZHID0gZnVuY3Rpb24obnVtYmVyLCByYW5nZSwgb3JkZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCByYW5nZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKHJhbmdlKTtcblx0ICBvcmRlciA9IG9yZGVyIHx8IGZhbHNlO1xuXHQgIHZhciBzb3J0ID0gKG9yZGVyKSA/IGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9IDogZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGIgLSBhO1xuXHQgIH07XG5cdCAgcmFuZ2UgPSByYW5nZS5zb3J0KHNvcnQpO1xuXG5cdCAgdmFyIGxlbmd0aCA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgY291bnQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChyYW5nZVtpXSA9PT0gbnVtYmVyKSB7XG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIChjb3VudCA+IDEpID8gKDIgKiByYW5nZS5pbmRleE9mKG51bWJlcikgKyBjb3VudCArIDEpIC8gMiA6IHJhbmdlLmluZGV4T2YobnVtYmVyKSArIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5SQU5LLkVRID0gZnVuY3Rpb24obnVtYmVyLCByYW5nZSwgb3JkZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCByYW5nZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgb3JkZXIgPSBvcmRlciB8fCBmYWxzZTtcblx0ICB2YXIgc29ydCA9IChvcmRlcikgPyBmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSA6IGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBiIC0gYTtcblx0ICB9O1xuXHQgIHJhbmdlID0gcmFuZ2Uuc29ydChzb3J0KTtcblx0ICByZXR1cm4gcmFuZ2UuaW5kZXhPZihudW1iZXIpICsgMTtcblx0fTtcblxuXHRleHBvcnRzLlJPVyA9IGZ1bmN0aW9uKG1hdHJpeCwgaW5kZXgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChpbmRleCA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCEobWF0cml4IGluc3RhbmNlb2YgQXJyYXkpIHx8ICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChtYXRyaXgubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5yb3cobWF0cml4LCBpbmRleCk7XG5cdH07XG5cblx0ZXhwb3J0cy5ST1dTID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoIShtYXRyaXggaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LnJvd3MobWF0cml4KTtcblx0fTtcblxuXHRleHBvcnRzLlJTUSA9IGZ1bmN0aW9uKGRhdGFfeCwgZGF0YV95KSB7IC8vIG5vIG5lZWQgdG8gZmxhdHRlbiBoZXJlLCBQRUFSU09OIHdpbGwgdGFrZSBjYXJlIG9mIHRoYXRcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRhdGFfeCwgZGF0YV95KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5wb3coZXhwb3J0cy5QRUFSU09OKGRhdGFfeCwgZGF0YV95KSwgMik7XG5cdH07XG5cblx0ZXhwb3J0cy5TS0VXID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBtZWFuID0galN0YXQubWVhbihyYW5nZSk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHNpZ21hID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgc2lnbWEgKz0gTWF0aC5wb3cocmFuZ2VbaV0gLSBtZWFuLCAzKTtcblx0ICB9XG5cdCAgcmV0dXJuIG4gKiBzaWdtYSAvICgobiAtIDEpICogKG4gLSAyKSAqIE1hdGgucG93KGpTdGF0LnN0ZGV2KHJhbmdlLCB0cnVlKSwgMykpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0tFVy5QID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBtZWFuID0galN0YXQubWVhbihyYW5nZSk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIG0yID0gMDtcblx0ICB2YXIgbTMgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBtMyArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDMpO1xuXHQgICAgbTIgKz0gTWF0aC5wb3cocmFuZ2VbaV0gLSBtZWFuLCAyKTtcblx0ICB9XG5cdCAgbTMgPSBtMyAvIG47XG5cdCAgbTIgPSBtMiAvIG47XG5cdCAgcmV0dXJuIG0zIC8gTWF0aC5wb3cobTIsIDMgLyAyKTtcblx0fTtcblxuXHRleHBvcnRzLlNMT1BFID0gZnVuY3Rpb24oZGF0YV95LCBkYXRhX3gpIHtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRhdGFfeSwgZGF0YV94KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgeG1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeCk7XG5cdCAgdmFyIHltZWFuID0galN0YXQubWVhbihkYXRhX3kpO1xuXHQgIHZhciBuID0gZGF0YV94Lmxlbmd0aDtcblx0ICB2YXIgbnVtID0gMDtcblx0ICB2YXIgZGVuID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgbnVtICs9IChkYXRhX3hbaV0gLSB4bWVhbikgKiAoZGF0YV95W2ldIC0geW1lYW4pO1xuXHQgICAgZGVuICs9IE1hdGgucG93KGRhdGFfeFtpXSAtIHhtZWFuLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIG51bSAvIGRlbjtcblx0fTtcblxuXHRleHBvcnRzLlNNQUxMID0gZnVuY3Rpb24ocmFuZ2UsIGspIHtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIGsgPSB1dGlscy5wYXJzZU51bWJlcihrKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYW5nZSwgaykpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgcmV0dXJuIHJhbmdlLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pW2sgLSAxXTtcblx0fTtcblxuXHRleHBvcnRzLlNUQU5EQVJESVpFID0gZnVuY3Rpb24oeCwgbWVhbiwgc2QpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbWVhbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG1lYW4pO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG1lYW4sIHNkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKHggLSBtZWFuKSAvIHNkO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1RERVYgPSB7fTtcblxuXHRleHBvcnRzLlNUREVWLlAgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgdiA9IGV4cG9ydHMuVkFSLlAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICByZXR1cm4gTWF0aC5zcXJ0KHYpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1RERVYuUyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciB2ID0gZXhwb3J0cy5WQVIuUy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIHJldHVybiBNYXRoLnNxcnQodik7XG5cdH07XG5cblx0ZXhwb3J0cy5TVERFVkEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgdiA9IGV4cG9ydHMuVkFSQS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIHJldHVybiBNYXRoLnNxcnQodik7XG5cdH07XG5cblx0ZXhwb3J0cy5TVERFVlBBID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHYgPSBleHBvcnRzLlZBUlBBLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIE1hdGguc3FydCh2KTtcblx0fTtcblxuXG5cdGV4cG9ydHMuU1RFWVggPSBmdW5jdGlvbihkYXRhX3ksIGRhdGFfeCkge1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV95LCBkYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciB4bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV94KTtcblx0ICB2YXIgeW1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeSk7XG5cdCAgdmFyIG4gPSBkYXRhX3gubGVuZ3RoO1xuXHQgIHZhciBsZnQgPSAwO1xuXHQgIHZhciBudW0gPSAwO1xuXHQgIHZhciBkZW4gPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBsZnQgKz0gTWF0aC5wb3coZGF0YV95W2ldIC0geW1lYW4sIDIpO1xuXHQgICAgbnVtICs9IChkYXRhX3hbaV0gLSB4bWVhbikgKiAoZGF0YV95W2ldIC0geW1lYW4pO1xuXHQgICAgZGVuICs9IE1hdGgucG93KGRhdGFfeFtpXSAtIHhtZWFuLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguc3FydCgobGZ0IC0gbnVtICogbnVtIC8gZGVuKSAvIChuIC0gMikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVFJBTlNQT1NFID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdCAgaWYgKCFtYXRyaXgpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LnRyYW5zcG9zZShtYXRyaXgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVCA9IHRleHQuVDtcblxuXHRleHBvcnRzLlQuRElTVCA9IGZ1bmN0aW9uKHgsIGRmLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGRmID0gdXRpbHMucGFyc2VOdW1iZXIoZGYpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIGRmKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQuc3R1ZGVudHQuY2RmKHgsIGRmKSA6IGpTdGF0LnN0dWRlbnR0LnBkZih4LCBkZik7XG5cdH07XG5cblx0ZXhwb3J0cy5ULkRJU1RbJzJUJ10gPSBmdW5jdGlvbih4LCBkZikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHggPCAwIHx8IGRmIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBkZiAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuICgxIC0galN0YXQuc3R1ZGVudHQuY2RmKHggLCBkZikpICogMjtcblx0fTtcblxuXHRleHBvcnRzLlQuRElTVC5SVCA9IGZ1bmN0aW9uKHgsIGRmKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoeCA8IDAgfHwgZGYgPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHggIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGRmICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gMSAtIGpTdGF0LnN0dWRlbnR0LmNkZih4ICwgZGYpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVC5JTlYgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgZGYpIHtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBkZiA9IHV0aWxzLnBhcnNlTnVtYmVyKGRmKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgZGYpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5zdHVkZW50dC5pbnYocHJvYmFiaWxpdHksIGRmKTtcblx0fTtcblxuXHRleHBvcnRzLlQuSU5WWycyVCddID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIGRmKSB7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgZGYgPSB1dGlscy5wYXJzZU51bWJlcihkZik7XG5cdCAgaWYgKHByb2JhYmlsaXR5IDw9IDAgfHwgcHJvYmFiaWxpdHkgPiAxIHx8IGRmIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocHJvYmFiaWxpdHksIGRmKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hYnMoalN0YXQuc3R1ZGVudHQuaW52KHByb2JhYmlsaXR5LzIsIGRmKSk7XG5cdH07XG5cblx0Ly8gVGhlIGFsZ29yaXRobSBjYW4gYmUgZm91bmQgaGVyZTpcblx0Ly8gaHR0cDovL3d3dy5jaGVtLnVvYS5nci9hcHBsZXRzL0FwcGxldFR0ZXN0L0FwcGxfVHRlc3QyLmh0bWxcblx0ZXhwb3J0cy5ULlRFU1QgPSBmdW5jdGlvbihkYXRhX3gsIGRhdGFfeSkge1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV94LCBkYXRhX3kpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgdmFyIG1lYW5feCA9IGpTdGF0Lm1lYW4oZGF0YV94KTtcblx0ICB2YXIgbWVhbl95ID0galN0YXQubWVhbihkYXRhX3kpO1xuXHQgIHZhciBzX3ggPSAwO1xuXHQgIHZhciBzX3kgPSAwO1xuXHQgIHZhciBpO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IGRhdGFfeC5sZW5ndGg7IGkrKykge1xuXHQgICAgc194ICs9IE1hdGgucG93KGRhdGFfeFtpXSAtIG1lYW5feCwgMik7XG5cdCAgfVxuXHQgIGZvciAoaSA9IDA7IGkgPCBkYXRhX3kubGVuZ3RoOyBpKyspIHtcblx0ICAgIHNfeSArPSBNYXRoLnBvdyhkYXRhX3lbaV0gLSBtZWFuX3ksIDIpO1xuXHQgIH1cblxuXHQgIHNfeCA9IHNfeCAvIChkYXRhX3gubGVuZ3RoLTEpO1xuXHQgIHNfeSA9IHNfeSAvIChkYXRhX3kubGVuZ3RoLTEpO1xuXG5cdCAgdmFyIHQgPSBNYXRoLmFicyhtZWFuX3ggLSBtZWFuX3kpIC8gTWF0aC5zcXJ0KHNfeC9kYXRhX3gubGVuZ3RoICsgc195L2RhdGFfeS5sZW5ndGgpO1xuXG5cdCAgcmV0dXJuIGV4cG9ydHMuVC5ESVNUWycyVCddKHQsIGRhdGFfeC5sZW5ndGgrZGF0YV95Lmxlbmd0aC0yKTtcblx0fTtcblxuXHRleHBvcnRzLlRSRU5EID0gZnVuY3Rpb24oZGF0YV95LCBkYXRhX3gsIG5ld19kYXRhX3gpIHtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIG5ld19kYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4obmV3X2RhdGFfeCkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRhdGFfeSwgZGF0YV94LCBuZXdfZGF0YV94KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgbGluZXN0ID0gZXhwb3J0cy5MSU5FU1QoZGF0YV95LCBkYXRhX3gpO1xuXHQgIHZhciBtID0gbGluZXN0WzBdO1xuXHQgIHZhciBiID0gbGluZXN0WzFdO1xuXHQgIHZhciByZXN1bHQgPSBbXTtcblxuXHQgIG5ld19kYXRhX3guZm9yRWFjaChmdW5jdGlvbih4KSB7XG5cdCAgICByZXN1bHQucHVzaChtICogeCArIGIpO1xuXHQgIH0pO1xuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlRSSU1NRUFOID0gZnVuY3Rpb24ocmFuZ2UsIHBlcmNlbnQpIHtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIHBlcmNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwZXJjZW50KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYW5nZSwgcGVyY2VudCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHRyaW0gPSBtYXRoVHJpZy5GTE9PUihyYW5nZS5sZW5ndGggKiBwZXJjZW50LCAyKSAvIDI7XG5cdCAgcmV0dXJuIGpTdGF0Lm1lYW4odXRpbHMuaW5pdGlhbCh1dGlscy5yZXN0KHJhbmdlLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pLCB0cmltKSwgdHJpbSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVkFSID0ge307XG5cblx0ZXhwb3J0cy5WQVIuUCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLm51bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc2lnbWEgPSAwO1xuXHQgIHZhciBtZWFuID0gZXhwb3J0cy5BVkVSQUdFKHJhbmdlKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgc2lnbWEgKz0gTWF0aC5wb3cocmFuZ2VbaV0gLSBtZWFuLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIHNpZ21hIC8gbjtcblx0fTtcblxuXHRleHBvcnRzLlZBUi5TID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzaWdtYSA9IDA7XG5cdCAgdmFyIG1lYW4gPSBleHBvcnRzLkFWRVJBR0UocmFuZ2UpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBzaWdtYSArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gc2lnbWEgLyAobiAtIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVkFSQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc2lnbWEgPSAwO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgdmFyIG1lYW4gPSBleHBvcnRzLkFWRVJBR0VBKHJhbmdlKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgdmFyIGVsID0gcmFuZ2VbaV07XG5cdCAgICBpZiAodHlwZW9mIGVsID09PSAnbnVtYmVyJykge1xuXHQgICAgICBzaWdtYSArPSBNYXRoLnBvdyhlbCAtIG1lYW4sIDIpO1xuXHQgICAgfSBlbHNlIGlmIChlbCA9PT0gdHJ1ZSkge1xuXHQgICAgICBzaWdtYSArPSBNYXRoLnBvdygxIC0gbWVhbiwgMik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzaWdtYSArPSBNYXRoLnBvdygwIC0gbWVhbiwgMik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlbCAhPT0gbnVsbCkge1xuXHQgICAgICBjb3VudCsrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gc2lnbWEgLyAoY291bnQgLSAxKTtcblx0fTtcblxuXHRleHBvcnRzLlZBUlBBID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzaWdtYSA9IDA7XG5cdCAgdmFyIGNvdW50ID0gMDtcblx0ICB2YXIgbWVhbiA9IGV4cG9ydHMuQVZFUkFHRUEocmFuZ2UpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICB2YXIgZWwgPSByYW5nZVtpXTtcblx0ICAgIGlmICh0eXBlb2YgZWwgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHNpZ21hICs9IE1hdGgucG93KGVsIC0gbWVhbiwgMik7XG5cdCAgICB9IGVsc2UgaWYgKGVsID09PSB0cnVlKSB7XG5cdCAgICAgIHNpZ21hICs9IE1hdGgucG93KDEgLSBtZWFuLCAyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNpZ21hICs9IE1hdGgucG93KDAgLSBtZWFuLCAyKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGVsICE9PSBudWxsKSB7XG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBzaWdtYSAvIGNvdW50O1xuXHR9O1xuXG5cdGV4cG9ydHMuV0VJQlVMTCA9IHt9O1xuXG5cdGV4cG9ydHMuV0VJQlVMTC5ESVNUID0gZnVuY3Rpb24oeCwgYWxwaGEsIGJldGEsIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgYWxwaGEgPSB1dGlscy5wYXJzZU51bWJlcihhbHBoYSk7XG5cdCAgYmV0YSA9IHV0aWxzLnBhcnNlTnVtYmVyKGJldGEpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIGFscGhhLCBiZXRhKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8gMSAtIE1hdGguZXhwKC1NYXRoLnBvdyh4IC8gYmV0YSwgYWxwaGEpKSA6IE1hdGgucG93KHgsIGFscGhhIC0gMSkgKiBNYXRoLmV4cCgtTWF0aC5wb3coeCAvIGJldGEsIGFscGhhKSkgKiBhbHBoYSAvIE1hdGgucG93KGJldGEsIGFscGhhKTtcblx0fTtcblxuXHRleHBvcnRzLlogPSB7fTtcblxuXHRleHBvcnRzLlouVEVTVCA9IGZ1bmN0aW9uKHJhbmdlLCB4LCBzZCkge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCB4KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHNkID0gc2QgfHwgZXhwb3J0cy5TVERFVi5TKHJhbmdlKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICByZXR1cm4gMSAtIGV4cG9ydHMuTk9STS5TLkRJU1QoKGV4cG9ydHMuQVZFUkFHRShyYW5nZSkgLSB4KSAvIChzZCAvIE1hdGguc3FydChuKSksIHRydWUpO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgbnVtZXJhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cblx0Ly9UT0RPXG5cdGV4cG9ydHMuQVNDID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0FTQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvL1RPRE9cblx0ZXhwb3J0cy5CQUhUVEVYVCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdCQUhUVEVYVCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkNIQVIgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkNMRUFOID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIHRleHQgPSB0ZXh0IHx8ICcnO1xuXHQgIHZhciByZSA9IC9bXFwwLVxceDFGXS9nO1xuXHQgIHJldHVybiB0ZXh0LnJlcGxhY2UocmUsIFwiXCIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09ERSA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICB0ZXh0ID0gdGV4dCB8fCAnJztcblx0ICByZXR1cm4gdGV4dC5jaGFyQ29kZUF0KDApO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09OQ0FURU5BVEUgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblxuXHQgIHZhciB0cnVlRm91bmQgPSAwO1xuXHQgIHdoaWxlICgodHJ1ZUZvdW5kID0gYXJncy5pbmRleE9mKHRydWUpKSA+IC0xKSB7XG5cdCAgICBhcmdzW3RydWVGb3VuZF0gPSAnVFJVRSc7XG5cdCAgfVxuXG5cdCAgdmFyIGZhbHNlRm91bmQgPSAwO1xuXHQgIHdoaWxlICgoZmFsc2VGb3VuZCA9IGFyZ3MuaW5kZXhPZihmYWxzZSkpID4gLTEpIHtcblx0ICAgIGFyZ3NbZmFsc2VGb3VuZF0gPSAnRkFMU0UnO1xuXHQgIH1cblxuXHQgIHJldHVybiBhcmdzLmpvaW4oJycpO1xuXHR9O1xuXG5cdC8vVE9ET1xuXHRleHBvcnRzLkRCQ1MgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignREJDUyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkRPTExBUiA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMpIHtcblx0ICBkZWNpbWFscyA9IChkZWNpbWFscyA9PT0gdW5kZWZpbmVkKSA/IDIgOiBkZWNpbWFscztcblxuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgZGVjaW1hbHMgPSB1dGlscy5wYXJzZU51bWJlcihkZWNpbWFscyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBkZWNpbWFscykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIGZvcm1hdCA9ICcnO1xuXHQgIGlmIChkZWNpbWFscyA8PSAwKSB7XG5cdCAgICBudW1iZXIgPSBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBkZWNpbWFscykpIC8gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcblx0ICAgIGZvcm1hdCA9ICcoJDAsMCknO1xuXHQgIH0gZWxzZSBpZiAoZGVjaW1hbHMgPiAwKSB7XG5cdCAgICBmb3JtYXQgPSAnKCQwLDAuJyArIG5ldyBBcnJheShkZWNpbWFscyArIDEpLmpvaW4oJzAnKSArICcpJztcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyYWwobnVtYmVyKS5mb3JtYXQoZm9ybWF0KTtcblx0fTtcblxuXHRleHBvcnRzLkVYQUNUID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG5cdCAgcmV0dXJuIHRleHQxID09PSB0ZXh0Mjtcblx0fTtcblxuXHRleHBvcnRzLkZJTkQgPSBmdW5jdGlvbihmaW5kX3RleHQsIHdpdGhpbl90ZXh0LCBwb3NpdGlvbikge1xuXHQgIHBvc2l0aW9uID0gKHBvc2l0aW9uID09PSB1bmRlZmluZWQpID8gMCA6IHBvc2l0aW9uO1xuXHQgIHJldHVybiB3aXRoaW5fdGV4dCA/IHdpdGhpbl90ZXh0LmluZGV4T2YoZmluZF90ZXh0LCBwb3NpdGlvbiAtIDEpICsgMSA6IG51bGw7XG5cdH07XG5cblx0ZXhwb3J0cy5GSVhFRCA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMsIG5vX2NvbW1hcykge1xuXHQgIGRlY2ltYWxzID0gKGRlY2ltYWxzID09PSB1bmRlZmluZWQpID8gMiA6IGRlY2ltYWxzO1xuXHQgIG5vX2NvbW1hcyA9IChub19jb21tYXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG5vX2NvbW1hcztcblxuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgZGVjaW1hbHMgPSB1dGlscy5wYXJzZU51bWJlcihkZWNpbWFscyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBkZWNpbWFscykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgZm9ybWF0ID0gbm9fY29tbWFzID8gJzAnIDogJzAsMCc7XG5cdCAgaWYgKGRlY2ltYWxzIDw9IDApIHtcblx0ICAgIG51bWJlciA9IE1hdGgucm91bmQobnVtYmVyICogTWF0aC5wb3coMTAsIGRlY2ltYWxzKSkgLyBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuXHQgIH0gZWxzZSBpZiAoZGVjaW1hbHMgPiAwKSB7XG5cdCAgICBmb3JtYXQgKz0gJy4nICsgbmV3IEFycmF5KGRlY2ltYWxzICsgMSkuam9pbignMCcpO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtZXJhbChudW1iZXIpLmZvcm1hdChmb3JtYXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSFRNTDJURVhUID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgdmFyIHJlc3VsdCA9ICcnO1xuXG5cdCAgaWYgKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHQgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG5cdCAgICAgICAgaWYgKHJlc3VsdCAhPT0gJycpIHtcblx0ICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ICs9IChsaW5lLnJlcGxhY2UoLzwoPzoufFxcbikqPz4vZ20sICcnKSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgvPCg/Oi58XFxuKSo/Pi9nbSwgJycpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5MRUZUID0gZnVuY3Rpb24odGV4dCwgbnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gKG51bWJlciA9PT0gdW5kZWZpbmVkKSA/IDEgOiBudW1iZXI7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiB0ZXh0ID8gdGV4dC5zdWJzdHJpbmcoMCwgbnVtYmVyKSA6IG51bGw7XG5cdH07XG5cblx0ZXhwb3J0cy5MRU4gPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5lcnJvcjtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gdGV4dCA/IHRleHQubGVuZ3RoIDogMDtcblx0ICB9XG5cblx0ICBpZiAodGV4dC5sZW5ndGgpIHtcblx0ICAgIHJldHVybiB0ZXh0Lmxlbmd0aDtcblx0ICB9XG5cblx0ICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5MT1dFUiA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiB0ZXh0ID8gdGV4dC50b0xvd2VyQ2FzZSgpIDogdGV4dDtcblx0fTtcblxuXHRleHBvcnRzLk1JRCA9IGZ1bmN0aW9uKHRleHQsIHN0YXJ0LCBudW1iZXIpIHtcblx0ICBzdGFydCA9IHV0aWxzLnBhcnNlTnVtYmVyKHN0YXJ0KTtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHN0YXJ0LCBudW1iZXIpIHx8IHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cblx0ICB2YXIgYmVnaW4gPSBzdGFydCAtIDE7XG5cdCAgdmFyIGVuZCA9IGJlZ2luICsgbnVtYmVyO1xuXG5cdCAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKGJlZ2luLCBlbmQpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5OVU1CRVJWQUxVRSA9IGZ1bmN0aW9uICh0ZXh0LCBkZWNpbWFsX3NlcGFyYXRvciwgZ3JvdXBfc2VwYXJhdG9yKSAge1xuXHQgIGRlY2ltYWxfc2VwYXJhdG9yID0gKHR5cGVvZiBkZWNpbWFsX3NlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcpID8gJy4nIDogZGVjaW1hbF9zZXBhcmF0b3I7XG5cdCAgZ3JvdXBfc2VwYXJhdG9yID0gKHR5cGVvZiBncm91cF9zZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnKSA/ICcsJyA6IGdyb3VwX3NlcGFyYXRvcjtcblx0ICByZXR1cm4gTnVtYmVyKHRleHQucmVwbGFjZShkZWNpbWFsX3NlcGFyYXRvciwgJy4nKS5yZXBsYWNlKGdyb3VwX3NlcGFyYXRvciwgJycpKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuUFJPTkVUSUMgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignUFJPTkVUSUMgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5QUk9QRVIgPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCB8fCB0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAodGV4dCA9PT0gdHJ1ZSkge1xuXHQgICAgdGV4dCA9ICdUUlVFJztcblx0ICB9XG5cdCAgaWYgKHRleHQgPT09IGZhbHNlKSB7XG5cdCAgICB0ZXh0ID0gJ0ZBTFNFJztcblx0ICB9XG5cdCAgaWYgKGlzTmFOKHRleHQpICYmIHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAodHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG5cdCAgICB0ZXh0ID0gJycgKyB0ZXh0O1xuXHQgIH1cblxuXHQgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcd1xcUyovZywgZnVuY3Rpb24odHh0KSB7XG5cdCAgICByZXR1cm4gdHh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHh0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkVHRVhFWFRSQUNUID0gZnVuY3Rpb24gKHRleHQsIHJlZ3VsYXJfZXhwcmVzc2lvbikge1xuXHQgIHZhciBtYXRjaCA9IHRleHQubWF0Y2gobmV3IFJlZ0V4cChyZWd1bGFyX2V4cHJlc3Npb24pKTtcblx0ICByZXR1cm4gbWF0Y2ggPyAobWF0Y2hbbWF0Y2gubGVuZ3RoID4gMSA/IG1hdGNoLmxlbmd0aCAtIDEgOiAwXSkgOiBudWxsO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkVHRVhNQVRDSCA9IGZ1bmN0aW9uICh0ZXh0LCByZWd1bGFyX2V4cHJlc3Npb24sIGZ1bGwpIHtcblx0ICB2YXIgbWF0Y2ggPSB0ZXh0Lm1hdGNoKG5ldyBSZWdFeHAocmVndWxhcl9leHByZXNzaW9uKSk7XG5cdCAgcmV0dXJuIGZ1bGwgPyBtYXRjaCA6ICEhbWF0Y2g7XG5cdH07XG5cblx0ZXhwb3J0cy5SRUdFWFJFUExBQ0UgPSBmdW5jdGlvbiAodGV4dCwgcmVndWxhcl9leHByZXNzaW9uLCByZXBsYWNlbWVudCkge1xuXHQgIHJldHVybiB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChyZWd1bGFyX2V4cHJlc3Npb24pLCByZXBsYWNlbWVudCk7XG5cdH07XG5cblx0ZXhwb3J0cy5SRVBMQUNFID0gZnVuY3Rpb24odGV4dCwgcG9zaXRpb24sIGxlbmd0aCwgbmV3X3RleHQpIHtcblx0ICBwb3NpdGlvbiA9IHV0aWxzLnBhcnNlTnVtYmVyKHBvc2l0aW9uKTtcblx0ICBsZW5ndGggPSB1dGlscy5wYXJzZU51bWJlcihsZW5ndGgpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHBvc2l0aW9uLCBsZW5ndGgpIHx8XG5cdCAgICB0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycgfHxcblx0ICAgIHR5cGVvZiBuZXdfdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQuc3Vic3RyKDAsIHBvc2l0aW9uIC0gMSkgKyBuZXdfdGV4dCArIHRleHQuc3Vic3RyKHBvc2l0aW9uIC0gMSArIGxlbmd0aCk7XG5cdH07XG5cblx0ZXhwb3J0cy5SRVBUID0gZnVuY3Rpb24odGV4dCwgbnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBuZXcgQXJyYXkobnVtYmVyICsgMSkuam9pbih0ZXh0KTtcblx0fTtcblxuXHRleHBvcnRzLlJJR0hUID0gZnVuY3Rpb24odGV4dCwgbnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gKG51bWJlciA9PT0gdW5kZWZpbmVkKSA/IDEgOiBudW1iZXI7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiB0ZXh0ID8gdGV4dC5zdWJzdHJpbmcodGV4dC5sZW5ndGggLSBudW1iZXIpIDogbnVsbDtcblx0fTtcblxuXHRleHBvcnRzLlNFQVJDSCA9IGZ1bmN0aW9uKGZpbmRfdGV4dCwgd2l0aGluX3RleHQsIHBvc2l0aW9uKSB7XG5cdCAgdmFyIGZvdW5kQXQ7XG5cdCAgaWYgKHR5cGVvZiBmaW5kX3RleHQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB3aXRoaW5fdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcG9zaXRpb24gPSAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkgPyAwIDogcG9zaXRpb247XG5cdCAgZm91bmRBdCA9IHdpdGhpbl90ZXh0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihmaW5kX3RleHQudG9Mb3dlckNhc2UoKSwgcG9zaXRpb24gLSAxKSsxO1xuXHQgIHJldHVybiAoZm91bmRBdCA9PT0gMCk/ZXJyb3IudmFsdWU6Zm91bmRBdDtcblx0fTtcblxuXHRleHBvcnRzLlNQTElUID0gZnVuY3Rpb24gKHRleHQsIHNlcGFyYXRvcikge1xuXHQgIHJldHVybiB0ZXh0LnNwbGl0KHNlcGFyYXRvcik7XG5cdH07XG5cblx0ZXhwb3J0cy5TVUJTVElUVVRFID0gZnVuY3Rpb24odGV4dCwgb2xkX3RleHQsIG5ld190ZXh0LCBvY2N1cnJlbmNlKSB7XG5cdCAgaWYgKCF0ZXh0IHx8ICFvbGRfdGV4dCB8fCAhbmV3X3RleHQpIHtcblx0ICAgIHJldHVybiB0ZXh0O1xuXHQgIH0gZWxzZSBpZiAob2NjdXJyZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAob2xkX3RleHQsICdnJyksIG5ld190ZXh0KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgIHZhciBpID0gMDtcblx0ICAgIHdoaWxlICh0ZXh0LmluZGV4T2Yob2xkX3RleHQsIGluZGV4KSA+IDApIHtcblx0ICAgICAgaW5kZXggPSB0ZXh0LmluZGV4T2Yob2xkX3RleHQsIGluZGV4ICsgMSk7XG5cdCAgICAgIGkrKztcblx0ICAgICAgaWYgKGkgPT09IG9jY3VycmVuY2UpIHtcblx0ICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgbmV3X3RleHQgKyB0ZXh0LnN1YnN0cmluZyhpbmRleCArIG9sZF90ZXh0Lmxlbmd0aCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5UID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgPyB2YWx1ZSA6ICcnO1xuXHR9O1xuXG5cdC8vIFRPRE8gaW5jb21wbGV0ZSBpbXBsZW1lbnRhdGlvblxuXHRleHBvcnRzLlRFWFQgPSBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0KSB7XG5cdCAgdmFsdWUgPSB1dGlscy5wYXJzZU51bWJlcih2YWx1ZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bWVyYWwodmFsdWUpLmZvcm1hdChmb3JtYXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVFJJTSA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyArL2csICcgJykudHJpbSgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVU5JQ0hBUiA9IHRoaXMuQ0hBUjtcblxuXHRleHBvcnRzLlVOSUNPREUgPSB0aGlzLkNPREU7XG5cblx0ZXhwb3J0cy5VUFBFUiA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiB0ZXh0LnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5WQUxVRSA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBudW1lcmFsKCkudW5mb3JtYXQodGV4dCk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X187XG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOV9fO1xuXG4vKioqLyB9LFxuLyogMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciB1dGlscyAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIG51bWVyYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG5cdGV4cG9ydHMuVU5JUVVFID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuXHQgICAgdmFyIGhhc0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgIHZhciBlbGVtZW50ICAgID0gYXJndW1lbnRzW2ldO1xuXG5cdCAgICAvLyBDaGVjayBpZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gdGhpcyBlbGVtZW50LlxuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXN1bHQubGVuZ3RoOyArK2opIHtcblx0ICAgICAgaGFzRWxlbWVudCA9IHJlc3VsdFtqXSA9PT0gZWxlbWVudDtcblx0ICAgICAgaWYgKGhhc0VsZW1lbnQpIHsgYnJlYWs7IH1cblx0ICAgIH1cblxuXHQgICAgLy8gSWYgd2UgZGlkIG5vdCBmaW5kIGl0LCBhZGQgaXQgdG8gdGhlIHJlc3VsdC5cblx0ICAgIGlmICghaGFzRWxlbWVudCkge1xuXHQgICAgICByZXN1bHQucHVzaChlbGVtZW50KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkZMQVRURU4gPSB1dGlscy5mbGF0dGVuO1xuXG5cdGV4cG9ydHMuQVJHUzJBUlJBWSA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0fTtcblxuXHRleHBvcnRzLlJFRkVSRU5DRSA9IGZ1bmN0aW9uIChjb250ZXh0LCByZWZlcmVuY2UpIHtcblx0ICB0cnkge1xuXHQgICAgdmFyIHBhdGggPSByZWZlcmVuY2Uuc3BsaXQoJy4nKTtcblx0ICAgIHZhciByZXN1bHQgPSBjb250ZXh0O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgIHZhciBzdGVwID0gcGF0aFtpXTtcblx0ICAgICAgaWYgKHN0ZXBbc3RlcC5sZW5ndGggLSAxXSA9PT0gJ10nKSB7XG5cdCAgICAgICAgdmFyIG9wZW5pbmcgPSBzdGVwLmluZGV4T2YoJ1snKTtcblx0ICAgICAgICB2YXIgaW5kZXggPSBzdGVwLnN1YnN0cmluZyhvcGVuaW5nICsgMSwgc3RlcC5sZW5ndGggLSAxKTtcblx0ICAgICAgICByZXN1bHQgPSByZXN1bHRbc3RlcC5zdWJzdHJpbmcoMCwgb3BlbmluZyldW2luZGV4XTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXN1bHQgPSByZXN1bHRbc3RlcF07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cdH07XG5cblx0ZXhwb3J0cy5KT0lOID0gZnVuY3Rpb24gKGFycmF5LCBzZXBhcmF0b3IpIHtcblx0ICByZXR1cm4gYXJyYXkuam9pbihzZXBhcmF0b3IpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTlVNQkVSUyA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgcG9zc2libGVOdW1iZXJzID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHJldHVybiBwb3NzaWJsZU51bWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuXHQgICAgcmV0dXJuIHR5cGVvZiBlbCA9PT0gJ251bWJlcic7XG5cdCAgfSk7XG5cdH07XG5cblx0ZXhwb3J0cy5OVU1FUkFMID0gZnVuY3Rpb24gKG51bWJlciwgZm9ybWF0KSB7XG5cdCAgcmV0dXJuIG51bWVyYWwobnVtYmVyKS5mb3JtYXQoZm9ybWF0KTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5DRUxMID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0NFTEwgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5FUlJPUiA9IHt9O1xuXHRleHBvcnRzLkVSUk9SLlRZUEUgPSBmdW5jdGlvbihlcnJvcl92YWwpIHtcblx0ICBzd2l0Y2ggKGVycm9yX3ZhbCkge1xuXHQgICAgY2FzZSBlcnJvci5uaWw6IHJldHVybiAxO1xuXHQgICAgY2FzZSBlcnJvci5kaXYwOiByZXR1cm4gMjtcblx0ICAgIGNhc2UgZXJyb3IudmFsdWU6IHJldHVybiAzO1xuXHQgICAgY2FzZSBlcnJvci5yZWY6IHJldHVybiA0O1xuXHQgICAgY2FzZSBlcnJvci5uYW1lOiByZXR1cm4gNTtcblx0ICAgIGNhc2UgZXJyb3IubnVtOiByZXR1cm4gNjtcblx0ICAgIGNhc2UgZXJyb3IubmE6IHJldHVybiA3O1xuXHQgICAgY2FzZSBlcnJvci5kYXRhOiByZXR1cm4gODtcblx0ICB9XG5cdCAgcmV0dXJuIGVycm9yLm5hO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5JTkZPID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0lORk8gaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5JU0JMQU5LID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG5cdH07XG5cblx0ZXhwb3J0cy5JU0JJTkFSWSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcblx0ICByZXR1cm4gKC9eWzAxXXsxLDEwfSQvKS50ZXN0KG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5JU0VSUiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIChbZXJyb3IudmFsdWUsIGVycm9yLnJlZiwgZXJyb3IuZGl2MCwgZXJyb3IubnVtLCBlcnJvci5uYW1lLCBlcnJvci5uaWxdKS5pbmRleE9mKHZhbHVlKSA+PSAwIHx8XG5cdCAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKTtcblx0fTtcblxuXHRleHBvcnRzLklTRVJST1IgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiBleHBvcnRzLklTRVJSKHZhbHVlKSB8fCB2YWx1ZSA9PT0gZXJyb3IubmE7XG5cdH07XG5cblx0ZXhwb3J0cy5JU0VWRU4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICByZXR1cm4gKE1hdGguZmxvb3IoTWF0aC5hYnMobnVtYmVyKSkgJiAxKSA/IGZhbHNlIDogdHJ1ZTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuSVNGT1JNVUxBID0gZnVuY3Rpb24oKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdJU0ZPUk1VTEEgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5JU0xPR0lDQUwgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG5cdH07XG5cblx0ZXhwb3J0cy5JU05BID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gdmFsdWUgPT09IGVycm9yLm5hO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNOT05URVhUID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mKHZhbHVlKSAhPT0gJ3N0cmluZyc7XG5cdH07XG5cblx0ZXhwb3J0cy5JU05VTUJFUiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgJiYgaXNGaW5pdGUodmFsdWUpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNPREQgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICByZXR1cm4gKE1hdGguZmxvb3IoTWF0aC5hYnMobnVtYmVyKSkgJiAxKSA/IHRydWUgOiBmYWxzZTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuSVNSRUYgPSBmdW5jdGlvbigpIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ0lTUkVGIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNURVhUID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ3N0cmluZyc7XG5cdH07XG5cblx0ZXhwb3J0cy5OID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICBpZiAodGhpcy5JU05VTUJFUih2YWx1ZSkpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKTtcblx0ICB9XG5cdCAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cdCAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXHQgIGlmICh0aGlzLklTRVJST1IodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAwO1xuXHR9O1xuXG5cdGV4cG9ydHMuTkEgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gZXJyb3IubmE7XG5cdH07XG5cblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuU0hFRVQgPSBmdW5jdGlvbigpIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ1NIRUVUIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5TSEVFVFMgPSBmdW5jdGlvbigpIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ1NIRUVUUyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLlRZUEUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIGlmICh0aGlzLklTTlVNQkVSKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIDE7XG5cdCAgfVxuXHQgIGlmICh0aGlzLklTVEVYVCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiAyO1xuXHQgIH1cblx0ICBpZiAodGhpcy5JU0xPR0lDQUwodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gNDtcblx0ICB9XG5cdCAgaWYgKHRoaXMuSVNFUlJPUih2YWx1ZSkpIHtcblx0ICAgIHJldHVybiAxNjtcblx0ICB9XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gNjQ7XG5cdCAgfVxuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIGpTdGF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5qU3RhdDtcblx0dmFyIHRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgYmVzc2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cblx0ZnVuY3Rpb24gaXNWYWxpZEJpbmFyeU51bWJlcihudW1iZXIpIHtcblx0ICByZXR1cm4gKC9eWzAxXXsxLDEwfSQvKS50ZXN0KG51bWJlcik7XG5cdH1cblxuXHRleHBvcnRzLkJFU1NFTEkgPSBmdW5jdGlvbih4LCBuKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gYmVzc2VsLmJlc3NlbGkoeCwgbik7XG5cdH07XG5cblx0ZXhwb3J0cy5CRVNTRUxKID0gZnVuY3Rpb24oeCwgbikge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGJlc3NlbC5iZXNzZWxqKHgsIG4pO1xuXHR9O1xuXG5cdGV4cG9ydHMuQkVTU0VMSyA9IGZ1bmN0aW9uKHgsIG4pIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBiZXNzZWwuYmVzc2Vsayh4LCBuKTtcblx0fTtcblxuXHRleHBvcnRzLkJFU1NFTFkgPSBmdW5jdGlvbih4LCBuKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gYmVzc2VsLmJlc3NlbHkoeCwgbik7XG5cdH07XG5cblx0ZXhwb3J0cy5CSU4yREVDID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgYmluYXJ5IG9yIGNvbnRhaW5zIG1vcmUgdGhhbiAxMCBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCFpc1ZhbGlkQmluYXJ5TnVtYmVyKG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBiaW5hcnkgbnVtYmVyIHRvIGRlY2ltYWxcblx0ICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQobnVtYmVyLCAyKTtcblxuXHQgIC8vIEhhbmRsZSBuZWdhdGl2ZSBudW1iZXJzXG5cdCAgdmFyIHN0cmluZ2lmaWVkID0gbnVtYmVyLnRvU3RyaW5nKCk7XG5cdCAgaWYgKHN0cmluZ2lmaWVkLmxlbmd0aCA9PT0gMTAgJiYgc3RyaW5naWZpZWQuc3Vic3RyaW5nKDAsIDEpID09PSAnMScpIHtcblx0ICAgIHJldHVybiBwYXJzZUludChzdHJpbmdpZmllZC5zdWJzdHJpbmcoMSksIDIpIC0gNTEyO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblx0fTtcblxuXG5cdGV4cG9ydHMuQklOMkhFWCA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgYmluYXJ5IG9yIGNvbnRhaW5zIG1vcmUgdGhhbiAxMCBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCFpc1ZhbGlkQmluYXJ5TnVtYmVyKG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIGhleGFkZWNpbWFsIG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICB2YXIgc3RyaW5naWZpZWQgPSBudW1iZXIudG9TdHJpbmcoKTtcblx0ICBpZiAoc3RyaW5naWZpZWQubGVuZ3RoID09PSAxMCAmJiBzdHJpbmdpZmllZC5zdWJzdHJpbmcoMCwgMSkgPT09ICcxJykge1xuXHQgICAgcmV0dXJuICgxMDk5NTExNjI3MjY0ICsgcGFyc2VJbnQoc3RyaW5naWZpZWQuc3Vic3RyaW5nKDEpLCAyKSkudG9TdHJpbmcoMTYpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgYmluYXJ5IG51bWJlciB0byBoZXhhZGVjaW1hbFxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChudW1iZXIsIDIpLnRvU3RyaW5nKDE2KTtcblxuXHQgIC8vIFJldHVybiBoZXhhZGVjaW1hbCBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAocGxhY2VzID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkJJTjJPQ1QgPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGJpbmFyeSBvciBjb250YWlucyBtb3JlIHRoYW4gMTAgY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghaXNWYWxpZEJpbmFyeU51bWJlcihudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBvY3RhbCBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgdmFyIHN0cmluZ2lmaWVkID0gbnVtYmVyLnRvU3RyaW5nKCk7XG5cdCAgaWYgKHN0cmluZ2lmaWVkLmxlbmd0aCA9PT0gMTAgJiYgc3RyaW5naWZpZWQuc3Vic3RyaW5nKDAsIDEpID09PSAnMScpIHtcblx0ICAgIHJldHVybiAoMTA3Mzc0MTMxMiArIHBhcnNlSW50KHN0cmluZ2lmaWVkLnN1YnN0cmluZygxKSwgMikpLnRvU3RyaW5nKDgpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgYmluYXJ5IG51bWJlciB0byBvY3RhbFxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChudW1iZXIsIDIpLnRvU3RyaW5nKDgpO1xuXG5cdCAgLy8gUmV0dXJuIG9jdGFsIG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmIChwbGFjZXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQklUQU5EID0gZnVuY3Rpb24obnVtYmVyMSwgbnVtYmVyMikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGEgbm9uLW51bWVyaWMgdmFsdWVcblx0ICBudW1iZXIxID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMSk7XG5cdCAgbnVtYmVyMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlcjEsIG51bWJlcjIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgbGVzcyB0aGFuIDBcblx0ICBpZiAobnVtYmVyMSA8IDAgfHwgbnVtYmVyMiA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgYSBub24taW50ZWdlclxuXHQgIGlmIChNYXRoLmZsb29yKG51bWJlcjEpICE9PSBudW1iZXIxIHx8IE1hdGguZmxvb3IobnVtYmVyMikgIT09IG51bWJlcjIpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgZ3JlYXRlciB0aGFuICgyXjQ4KS0xXG5cdCAgaWYgKG51bWJlcjEgPiAyODE0NzQ5NzY3MTA2NTUgfHwgbnVtYmVyMiA+IDI4MTQ3NDk3NjcxMDY1NSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYml0d2lzZSBBTkQgb2YgdHdvIG51bWJlcnNcblx0ICByZXR1cm4gbnVtYmVyMSAmIG51bWJlcjI7XG5cdH07XG5cblx0ZXhwb3J0cy5CSVRMU0hJRlQgPSBmdW5jdGlvbihudW1iZXIsIHNoaWZ0KSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBzaGlmdCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNoaWZ0KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHNoaWZ0KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbGVzcyB0aGFuIDBcblx0ICBpZiAobnVtYmVyIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGEgbm9uLWludGVnZXJcblx0ICBpZiAoTWF0aC5mbG9vcihudW1iZXIpICE9PSBudW1iZXIpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBncmVhdGVyIHRoYW4gKDJeNDgpLTFcblx0ICBpZiAobnVtYmVyID4gMjgxNDc0OTc2NzEwNjU1KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB0aGUgYWJzb2x1dGUgdmFsdWUgb2Ygc2hpZnQgaXMgZ3JlYXRlciB0aGFuIDUzXG5cdCAgaWYgKE1hdGguYWJzKHNoaWZ0KSA+IDUzKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBudW1iZXIgc2hpZnRlZCBieSBzaGlmdCBiaXRzIHRvIHRoZSBsZWZ0IG9yIHRvIHRoZSByaWdodCBpZiBzaGlmdCBpcyBuZWdhdGl2ZVxuXHQgIHJldHVybiAoc2hpZnQgPj0gMCkgPyBudW1iZXIgPDwgc2hpZnQgOiBudW1iZXIgPj4gLXNoaWZ0O1xuXHR9O1xuXG5cdGV4cG9ydHMuQklUT1IgPSBmdW5jdGlvbihudW1iZXIxLCBudW1iZXIyKSB7XG5cdCAgbnVtYmVyMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjEpO1xuXHQgIG51bWJlcjIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIxLCBudW1iZXIyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGxlc3MgdGhhbiAwXG5cdCAgaWYgKG51bWJlcjEgPCAwIHx8IG51bWJlcjIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGEgbm9uLWludGVnZXJcblx0ICBpZiAoTWF0aC5mbG9vcihudW1iZXIxKSAhPT0gbnVtYmVyMSB8fCBNYXRoLmZsb29yKG51bWJlcjIpICE9PSBudW1iZXIyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiAoMl40OCktMVxuXHQgIGlmIChudW1iZXIxID4gMjgxNDc0OTc2NzEwNjU1IHx8IG51bWJlcjIgPiAyODE0NzQ5NzY3MTA2NTUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGJpdHdpc2UgT1Igb2YgdHdvIG51bWJlcnNcblx0ICByZXR1cm4gbnVtYmVyMSB8IG51bWJlcjI7XG5cdH07XG5cblx0ZXhwb3J0cy5CSVRSU0hJRlQgPSBmdW5jdGlvbihudW1iZXIsIHNoaWZ0KSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBzaGlmdCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNoaWZ0KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHNoaWZ0KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbGVzcyB0aGFuIDBcblx0ICBpZiAobnVtYmVyIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGEgbm9uLWludGVnZXJcblx0ICBpZiAoTWF0aC5mbG9vcihudW1iZXIpICE9PSBudW1iZXIpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBncmVhdGVyIHRoYW4gKDJeNDgpLTFcblx0ICBpZiAobnVtYmVyID4gMjgxNDc0OTc2NzEwNjU1KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB0aGUgYWJzb2x1dGUgdmFsdWUgb2Ygc2hpZnQgaXMgZ3JlYXRlciB0aGFuIDUzXG5cdCAgaWYgKE1hdGguYWJzKHNoaWZ0KSA+IDUzKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBudW1iZXIgc2hpZnRlZCBieSBzaGlmdCBiaXRzIHRvIHRoZSByaWdodCBvciB0byB0aGUgbGVmdCBpZiBzaGlmdCBpcyBuZWdhdGl2ZVxuXHQgIHJldHVybiAoc2hpZnQgPj0gMCkgPyBudW1iZXIgPj4gc2hpZnQgOiBudW1iZXIgPDwgLXNoaWZ0O1xuXHR9O1xuXG5cdGV4cG9ydHMuQklUWE9SID0gZnVuY3Rpb24obnVtYmVyMSwgbnVtYmVyMikge1xuXHQgIG51bWJlcjEgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIxKTtcblx0ICBudW1iZXIyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyMSwgbnVtYmVyMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBsZXNzIHRoYW4gMFxuXHQgIGlmIChudW1iZXIxIDwgMCB8fCBudW1iZXIyIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBhIG5vbi1pbnRlZ2VyXG5cdCAgaWYgKE1hdGguZmxvb3IobnVtYmVyMSkgIT09IG51bWJlcjEgfHwgTWF0aC5mbG9vcihudW1iZXIyKSAhPT0gbnVtYmVyMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBncmVhdGVyIHRoYW4gKDJeNDgpLTFcblx0ICBpZiAobnVtYmVyMSA+IDI4MTQ3NDk3NjcxMDY1NSB8fCBudW1iZXIyID4gMjgxNDc0OTc2NzEwNjU1KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBiaXR3aXNlIFhPUiBvZiB0d28gbnVtYmVyc1xuXHQgIHJldHVybiBudW1iZXIxIF4gbnVtYmVyMjtcblx0fTtcblxuXHRleHBvcnRzLkNPTVBMRVggPSBmdW5jdGlvbihyZWFsLCBpbWFnaW5hcnksIHN1ZmZpeCkge1xuXHQgIHJlYWwgPSB1dGlscy5wYXJzZU51bWJlcihyZWFsKTtcblx0ICBpbWFnaW5hcnkgPSB1dGlscy5wYXJzZU51bWJlcihpbWFnaW5hcnkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJlYWwsIGltYWdpbmFyeSkpIHtcblx0ICAgIHJldHVybiByZWFsO1xuXHQgIH1cblxuXHQgIC8vIFNldCBzdWZmaXhcblx0ICBzdWZmaXggPSAoc3VmZml4ID09PSB1bmRlZmluZWQpID8gJ2knIDogc3VmZml4O1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHN1ZmZpeCBpcyBuZWl0aGVyIFwiaVwiIG5vciBcImpcIlxuXHQgIGlmIChzdWZmaXggIT09ICdpJyAmJiBzdWZmaXggIT09ICdqJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBjb21wbGV4IG51bWJlclxuXHQgIGlmIChyZWFsID09PSAwICYmIGltYWdpbmFyeSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfSBlbHNlIGlmIChyZWFsID09PSAwKSB7XG5cdCAgICByZXR1cm4gKGltYWdpbmFyeSA9PT0gMSkgPyBzdWZmaXggOiBpbWFnaW5hcnkudG9TdHJpbmcoKSArIHN1ZmZpeDtcblx0ICB9IGVsc2UgaWYgKGltYWdpbmFyeSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIHJlYWwudG9TdHJpbmcoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHNpZ24gPSAoaW1hZ2luYXJ5ID4gMCkgPyAnKycgOiAnJztcblx0ICAgIHJldHVybiByZWFsLnRvU3RyaW5nKCkgKyBzaWduICsgKChpbWFnaW5hcnkgPT09IDEpID8gc3VmZml4IDogaW1hZ2luYXJ5LnRvU3RyaW5nKCkgKyBzdWZmaXgpO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkNPTlZFUlQgPSBmdW5jdGlvbihudW1iZXIsIGZyb21fdW5pdCwgdG9fdW5pdCkge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblxuXHQgIC8vIExpc3Qgb2YgdW5pdHMgc3VwcG9ydGVkIGJ5IENPTlZFUlQgYW5kIHVuaXRzIGRlZmluZWQgYnkgdGhlIEludGVybmF0aW9uYWwgU3lzdGVtIG9mIFVuaXRzXG5cdCAgLy8gW05hbWUsIFN5bWJvbCwgQWx0ZXJuYXRlIHN5bWJvbHMsIFF1YW50aXR5LCBJU1UsIENPTlZFUlQsIENvbnZlcnNpb24gcmF0aW9dXG5cdCAgdmFyIHVuaXRzID0gW1xuXHQgICAgW1wiYS51LiBvZiBhY3Rpb25cIiwgXCI/XCIsIG51bGwsIFwiYWN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgMS4wNTQ1NzE2ODE4MTgxOGUtMzRdLFxuXHQgICAgW1wiYS51LiBvZiBjaGFyZ2VcIiwgXCJlXCIsIG51bGwsIFwiZWxlY3RyaWNfY2hhcmdlXCIsIGZhbHNlLCBmYWxzZSwgMS42MDIxNzY1MzE0MTQxNGUtMTldLFxuXHQgICAgW1wiYS51LiBvZiBlbmVyZ3lcIiwgXCJFaFwiLCBudWxsLCBcImVuZXJneVwiLCBmYWxzZSwgZmFsc2UsIDQuMzU5NzQ0MTc3NTc1NzZlLTE4XSxcblx0ICAgIFtcImEudS4gb2YgbGVuZ3RoXCIsIFwiYT9cIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIGZhbHNlLCA1LjI5MTc3MjEwODE4MTgyZS0xMV0sXG5cdCAgICBbXCJhLnUuIG9mIG1hc3NcIiwgXCJtP1wiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIGZhbHNlLCA5LjEwOTM4MjYxNjE2MTYyZS0zMV0sXG5cdCAgICBbXCJhLnUuIG9mIHRpbWVcIiwgXCI/L0VoXCIsIG51bGwsIFwidGltZVwiLCBmYWxzZSwgZmFsc2UsIDIuNDE4ODg0MzI2NTA1MTZlLTE3XSxcblx0ICAgIFtcImFkbWlyYWx0eSBrbm90XCIsIFwiYWRta25cIiwgbnVsbCwgXCJzcGVlZFwiLCBmYWxzZSwgdHJ1ZSwgMC41MTQ3NzMzMzNdLFxuXHQgICAgW1wiYW1wZXJlXCIsIFwiQVwiLCBudWxsLCBcImVsZWN0cmljX2N1cnJlbnRcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiYW1wZXJlIHBlciBtZXRlclwiLCBcIkEvbVwiLCBudWxsLCBcIm1hZ25ldGljX2ZpZWxkX2ludGVuc2l0eVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCLDpW5nc3Ryw7ZtXCIsIFwiw4VcIiwgW1wiYW5nXCJdLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMWUtMTBdLFxuXHQgICAgW1wiYXJlXCIsIFwiYXJcIiwgbnVsbCwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAxMDBdLFxuXHQgICAgW1wiYXN0cm9ub21pY2FsIHVuaXRcIiwgXCJ1YVwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgZmFsc2UsIDEuNDk1OTc4NzA2OTE2NjdlLTExXSxcblx0ICAgIFtcImJhclwiLCBcImJhclwiLCBudWxsLCBcInByZXNzdXJlXCIsIGZhbHNlLCBmYWxzZSwgMTAwMDAwXSxcblx0ICAgIFtcImJhcm5cIiwgXCJiXCIsIG51bGwsIFwiYXJlYVwiLCBmYWxzZSwgZmFsc2UsIDFlLTI4XSxcblx0ICAgIFtcImJlY3F1ZXJlbFwiLCBcIkJxXCIsIG51bGwsIFwicmFkaW9hY3Rpdml0eVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJiaXRcIiwgXCJiaXRcIiwgW1wiYlwiXSwgXCJpbmZvcm1hdGlvblwiLCBmYWxzZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJidHVcIiwgXCJCVFVcIiwgW1wiYnR1XCJdLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMTA1NS4wNTU4NTI2Ml0sXG5cdCAgICBbXCJieXRlXCIsIFwiYnl0ZVwiLCBudWxsLCBcImluZm9ybWF0aW9uXCIsIGZhbHNlLCB0cnVlLCA4XSxcblx0ICAgIFtcImNhbmRlbGFcIiwgXCJjZFwiLCBudWxsLCBcImx1bWlub3VzX2ludGVuc2l0eVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJjYW5kZWxhIHBlciBzcXVhcmUgbWV0cmVcIiwgXCJjZC9tP1wiLCBudWxsLCBcImx1bWluYW5jZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJjb3Vsb21iXCIsIFwiQ1wiLCBudWxsLCBcImVsZWN0cmljX2NoYXJnZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJjdWJpYyDDpW5nc3Ryw7ZtXCIsIFwiYW5nM1wiLCBbXCJhbmdeM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDFlLTMwXSxcblx0ICAgIFtcImN1YmljIGZvb3RcIiwgXCJmdDNcIiwgW1wiZnReM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDI4MzE2ODQ2NTkyXSxcblx0ICAgIFtcImN1YmljIGluY2hcIiwgXCJpbjNcIiwgW1wiaW5eM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwMDE2Mzg3MDY0XSxcblx0ICAgIFtcImN1YmljIGxpZ2h0LXllYXJcIiwgXCJseTNcIiwgW1wibHleM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDguNDY3ODY2NjQ2MjM3MTVlLTQ3XSxcblx0ICAgIFtcImN1YmljIG1ldHJlXCIsIFwibT9cIiwgbnVsbCwgXCJ2b2x1bWVcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJjdWJpYyBtaWxlXCIsIFwibWkzXCIsIFtcIm1pXjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCA0MTY4MTgxODI1LjQ0MDU4XSxcblx0ICAgIFtcImN1YmljIG5hdXRpY2FsIG1pbGVcIiwgXCJObWkzXCIsIFtcIk5taV4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgNjM1MjE4MjIwOF0sXG5cdCAgICBbXCJjdWJpYyBQaWNhXCIsIFwiUGljYTNcIiwgW1wiUGljYXB0M1wiLCBcIlBpY2FeM1wiLCBcIlBpY2FwdF4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgNy41ODY2MDM3MDM3MDM2OWUtOF0sXG5cdCAgICBbXCJjdWJpYyB5YXJkXCIsIFwieWQzXCIsIFtcInlkXjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjc2NDU1NDg1Nzk4NF0sXG5cdCAgICBbXCJjdXBcIiwgXCJjdXBcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwMjM2NTg4MjM2NV0sXG5cdCAgICBbXCJkYWx0b25cIiwgXCJEYVwiLCBbXCJ1XCJdLCBcIm1hc3NcIiwgZmFsc2UsIGZhbHNlLCAxLjY2MDUzODg2MjgyODI4ZS0yN10sXG5cdCAgICBbXCJkYXlcIiwgXCJkXCIsIFtcImRheVwiXSwgXCJ0aW1lXCIsIGZhbHNlLCB0cnVlLCA4NjQwMF0sXG5cdCAgICBbXCJkZWdyZWVcIiwgXCLCsFwiLCBudWxsLCBcImFuZ2xlXCIsIGZhbHNlLCBmYWxzZSwgMC4wMTc0NTMyOTI1MTk5NDMzXSxcblx0ICAgIFtcImRlZ3JlZXMgUmFua2luZVwiLCBcIlJhbmtcIiwgbnVsbCwgXCJ0ZW1wZXJhdHVyZVwiLCBmYWxzZSwgdHJ1ZSwgMC41NTU1NTU1NTU1NTU1NTZdLFxuXHQgICAgW1wiZHluZVwiLCBcImR5blwiLCBbXCJkeVwiXSwgXCJmb3JjZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAwMV0sXG5cdCAgICBbXCJlbGVjdHJvbnZvbHRcIiwgXCJlVlwiLCBbXCJldlwiXSwgXCJlbmVyZ3lcIiwgZmFsc2UsIHRydWUsIDEuNjAyMTc2NTY1MTQxNDFdLFxuXHQgICAgW1wiZWxsXCIsIFwiZWxsXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAxLjE0M10sXG5cdCAgICBbXCJlcmdcIiwgXCJlcmdcIiwgW1wiZVwiXSwgXCJlbmVyZ3lcIiwgZmFsc2UsIHRydWUsIDFlLTddLFxuXHQgICAgW1wiZmFyYWRcIiwgXCJGXCIsIG51bGwsIFwiZWxlY3RyaWNfY2FwYWNpdGFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiZmx1aWQgb3VuY2VcIiwgXCJvelwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAwMjk1NzM1Mjk1NjI1XSxcblx0ICAgIFtcImZvb3RcIiwgXCJmdFwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMC4zMDQ4XSxcblx0ICAgIFtcImZvb3QtcG91bmRcIiwgXCJmbGJcIiwgbnVsbCwgXCJlbmVyZ3lcIiwgZmFsc2UsIHRydWUsIDEuMzU1ODE3OTQ4MzMxNF0sXG5cdCAgICBbXCJnYWxcIiwgXCJHYWxcIiwgbnVsbCwgXCJhY2NlbGVyYXRpb25cIiwgZmFsc2UsIGZhbHNlLCAwLjAxXSxcblx0ICAgIFtcImdhbGxvblwiLCBcImdhbFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDM3ODU0MTE3ODRdLFxuXHQgICAgW1wiZ2F1c3NcIiwgXCJHXCIsIFtcImdhXCJdLCBcIm1hZ25ldGljX2ZsdXhfZGVuc2l0eVwiLCBmYWxzZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJncmFpblwiLCBcImdyYWluXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAwNjQ3OTg5XSxcblx0ICAgIFtcImdyYW1cIiwgXCJnXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgMC4wMDFdLFxuXHQgICAgW1wiZ3JheVwiLCBcIkd5XCIsIG51bGwsIFwiYWJzb3JiZWRfZG9zZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJncm9zcyByZWdpc3RlcmVkIHRvblwiLCBcIkdSVFwiLCBbXCJyZWd0b25cIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAyLjgzMTY4NDY1OTJdLFxuXHQgICAgW1wiaGVjdGFyZVwiLCBcImhhXCIsIG51bGwsIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMTAwMDBdLFxuXHQgICAgW1wiaGVucnlcIiwgXCJIXCIsIG51bGwsIFwiaW5kdWN0YW5jZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJoZXJ0elwiLCBcIkh6XCIsIG51bGwsIFwiZnJlcXVlbmN5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImhvcnNlcG93ZXJcIiwgXCJIUFwiLCBbXCJoXCJdLCBcInBvd2VyXCIsIGZhbHNlLCB0cnVlLCA3NDUuNjk5ODcxNTgyMjddLFxuXHQgICAgW1wiaG9yc2Vwb3dlci1ob3VyXCIsIFwiSFBoXCIsIFtcImhoXCIsIFwiaHBoXCJdLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMjY4NDUxOS41MzhdLFxuXHQgICAgW1wiaG91clwiLCBcImhcIiwgW1wiaHJcIl0sIFwidGltZVwiLCBmYWxzZSwgdHJ1ZSwgMzYwMF0sXG5cdCAgICBbXCJpbXBlcmlhbCBnYWxsb24gKFUuSy4pXCIsIFwidWtfZ2FsXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwNDU0NjA5XSxcblx0ICAgIFtcImltcGVyaWFsIGh1bmRyZWR3ZWlnaHRcIiwgXCJsY3d0XCIsIFtcInVrX2N3dFwiLCBcImh3ZWlnaHRcIl0sIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgNTAuODAyMzQ1XSxcblx0ICAgIFtcImltcGVyaWFsIHF1YXJ0IChVLkspXCIsIFwidWtfcXRcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAxMTM2NTIyNV0sXG5cdCAgICBbXCJpbXBlcmlhbCB0b25cIiwgXCJicnRvblwiLCBbXCJ1a190b25cIiwgXCJMVE9OXCJdLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDEwMTYuMDQ2OTA5XSxcblx0ICAgIFtcImluY2hcIiwgXCJpblwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMC4wMjU0XSxcblx0ICAgIFtcImludGVybmF0aW9uYWwgYWNyZVwiLCBcInVrX2FjcmVcIiwgbnVsbCwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCA0MDQ2Ljg1NjQyMjRdLFxuXHQgICAgW1wiSVQgY2Fsb3JpZVwiLCBcImNhbFwiLCBudWxsLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgNC4xODY4XSxcblx0ICAgIFtcImpvdWxlXCIsIFwiSlwiLCBudWxsLCBcImVuZXJneVwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcImthdGFsXCIsIFwia2F0XCIsIG51bGwsIFwiY2F0YWx5dGljX2FjdGl2aXR5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImtlbHZpblwiLCBcIktcIiwgW1wia2VsXCJdLCBcInRlbXBlcmF0dXJlXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wia2lsb2dyYW1cIiwgXCJrZ1wiLCBudWxsLCBcIm1hc3NcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJrbm90XCIsIFwia25cIiwgbnVsbCwgXCJzcGVlZFwiLCBmYWxzZSwgdHJ1ZSwgMC41MTQ0NDQ0NDQ0NDQ0NDRdLFxuXHQgICAgW1wibGlnaHQteWVhclwiLCBcImx5XCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCA5NDYwNzMwNDcyNTgwODAwXSxcblx0ICAgIFtcImxpdHJlXCIsIFwiTFwiLCBbXCJsXCIsIFwibHRcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMV0sXG5cdCAgICBbXCJsdW1lblwiLCBcImxtXCIsIG51bGwsIFwibHVtaW5vdXNfZmx1eFwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJsdXhcIiwgXCJseFwiLCBudWxsLCBcImlsbHVtaW5hbmNlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcIm1heHdlbGxcIiwgXCJNeFwiLCBudWxsLCBcIm1hZ25ldGljX2ZsdXhcIiwgZmFsc2UsIGZhbHNlLCAxZS0xOF0sXG5cdCAgICBbXCJtZWFzdXJlbWVudCB0b25cIiwgXCJNVE9OXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAxLjEzMjY3Mzg2MzY4XSxcblx0ICAgIFtcIm1ldGVyIHBlciBob3VyXCIsIFwibS9oXCIsIFtcIm0vaHJcIl0sIFwic3BlZWRcIiwgZmFsc2UsIHRydWUsIDAuMDAwMjc3Nzc3Nzc3Nzc3NzhdLFxuXHQgICAgW1wibWV0ZXIgcGVyIHNlY29uZFwiLCBcIm0vc1wiLCBbXCJtL3NlY1wiXSwgXCJzcGVlZFwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcIm1ldGVyIHBlciBzZWNvbmQgc3F1YXJlZFwiLCBcIm0/cz8/XCIsIG51bGwsIFwiYWNjZWxlcmF0aW9uXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcInBhcnNlY1wiLCBcInBjXCIsIFtcInBhcnNlY1wiXSwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDMwODU2Nzc1ODE0NjcxOTAwXSxcblx0ICAgIFtcIm1ldGVyIHNxdWFyZWQgcGVyIHNlY29uZFwiLCBcIm0/L3NcIiwgbnVsbCwgXCJraW5lbWF0aWNfdmlzY29zaXR5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcIm1ldHJlXCIsIFwibVwiLCBudWxsLCBcImxlbmd0aFwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcIm1pbGVzIHBlciBob3VyXCIsIFwibXBoXCIsIG51bGwsIFwic3BlZWRcIiwgZmFsc2UsIHRydWUsIDAuNDQ3MDRdLFxuXHQgICAgW1wibWlsbGltZXRyZSBvZiBtZXJjdXJ5XCIsIFwibW1IZ1wiLCBudWxsLCBcInByZXNzdXJlXCIsIGZhbHNlLCBmYWxzZSwgMTMzLjMyMl0sXG5cdCAgICBbXCJtaW51dGVcIiwgXCI/XCIsIG51bGwsIFwiYW5nbGVcIiwgZmFsc2UsIGZhbHNlLCAwLjAwMDI5MDg4ODIwODY2NTcyMl0sXG5cdCAgICBbXCJtaW51dGVcIiwgXCJtaW5cIiwgW1wibW5cIl0sIFwidGltZVwiLCBmYWxzZSwgdHJ1ZSwgNjBdLFxuXHQgICAgW1wibW9kZXJuIHRlYXNwb29uXCIsIFwidHNwbVwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAwMDVdLFxuXHQgICAgW1wibW9sZVwiLCBcIm1vbFwiLCBudWxsLCBcImFtb3VudF9vZl9zdWJzdGFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wibW9yZ2VuXCIsIFwiTW9yZ2VuXCIsIG51bGwsIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMjUwMF0sXG5cdCAgICBbXCJuLnUuIG9mIGFjdGlvblwiLCBcIj9cIiwgbnVsbCwgXCJhY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCAxLjA1NDU3MTY4MTgxODE4ZS0zNF0sXG5cdCAgICBbXCJuLnUuIG9mIG1hc3NcIiwgXCJtP1wiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIGZhbHNlLCA5LjEwOTM4MjYxNjE2MTYyZS0zMV0sXG5cdCAgICBbXCJuLnUuIG9mIHNwZWVkXCIsIFwiYz9cIiwgbnVsbCwgXCJzcGVlZFwiLCBmYWxzZSwgZmFsc2UsIDI5OTc5MjQ1OF0sXG5cdCAgICBbXCJuLnUuIG9mIHRpbWVcIiwgXCI/LyhtZT9jPz8pXCIsIG51bGwsIFwidGltZVwiLCBmYWxzZSwgZmFsc2UsIDEuMjg4MDg4NjY3Nzg2ODdlLTIxXSxcblx0ICAgIFtcIm5hdXRpY2FsIG1pbGVcIiwgXCJNXCIsIFtcIk5taVwiXSwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDE4NTJdLFxuXHQgICAgW1wibmV3dG9uXCIsIFwiTlwiLCBudWxsLCBcImZvcmNlXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wixZNyc3RlZFwiLCBcIk9lIFwiLCBudWxsLCBcIm1hZ25ldGljX2ZpZWxkX2ludGVuc2l0eVwiLCBmYWxzZSwgZmFsc2UsIDc5LjU3NzQ3MTU0NTk0NzddLFxuXHQgICAgW1wib2htXCIsIFwizqlcIiwgbnVsbCwgXCJlbGVjdHJpY19yZXNpc3RhbmNlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcIm91bmNlIG1hc3NcIiwgXCJvem1cIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCAwLjAyODM0OTUyMzEyNV0sXG5cdCAgICBbXCJwYXNjYWxcIiwgXCJQYVwiLCBudWxsLCBcInByZXNzdXJlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcInBhc2NhbCBzZWNvbmRcIiwgXCJQYT9zXCIsIG51bGwsIFwiZHluYW1pY192aXNjb3NpdHlcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wicGZlcmRlc3TDpHJrZVwiLCBcIlBTXCIsIG51bGwsIFwicG93ZXJcIiwgZmFsc2UsIHRydWUsIDczNS40OTg3NV0sXG5cdCAgICBbXCJwaG90XCIsIFwicGhcIiwgbnVsbCwgXCJpbGx1bWluYW5jZVwiLCBmYWxzZSwgZmFsc2UsIDAuMDAwMV0sXG5cdCAgICBbXCJwaWNhICgxLzYgaW5jaClcIiwgXCJwaWNhXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDM1Mjc3Nzc3Nzc3Nzc4XSxcblx0ICAgIFtcInBpY2EgKDEvNzIgaW5jaClcIiwgXCJQaWNhXCIsIFtcIlBpY2FwdFwiXSwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDAuMDA0MjMzMzMzMzMzMzMzMzNdLFxuXHQgICAgW1wicG9pc2VcIiwgXCJQXCIsIG51bGwsIFwiZHluYW1pY192aXNjb3NpdHlcIiwgZmFsc2UsIGZhbHNlLCAwLjFdLFxuXHQgICAgW1wicG9uZFwiLCBcInBvbmRcIiwgbnVsbCwgXCJmb3JjZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDk4MDY2NV0sXG5cdCAgICBbXCJwb3VuZCBmb3JjZVwiLCBcImxiZlwiLCBudWxsLCBcImZvcmNlXCIsIGZhbHNlLCB0cnVlLCA0LjQ0ODIyMTYxNTI2MDVdLFxuXHQgICAgW1wicG91bmQgbWFzc1wiLCBcImxibVwiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDAuNDUzNTkyMzddLFxuXHQgICAgW1wicXVhcnRcIiwgXCJxdFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDA5NDYzNTI5NDZdLFxuXHQgICAgW1wicmFkaWFuXCIsIFwicmFkXCIsIG51bGwsIFwiYW5nbGVcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wic2Vjb25kXCIsIFwiP1wiLCBudWxsLCBcImFuZ2xlXCIsIGZhbHNlLCBmYWxzZSwgMC4wMDAwMDQ4NDgxMzY4MTEwOTUzNl0sXG5cdCAgICBbXCJzZWNvbmRcIiwgXCJzXCIsIFtcInNlY1wiXSwgXCJ0aW1lXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wic2hvcnQgaHVuZHJlZHdlaWdodFwiLCBcImN3dFwiLCBbXCJzaHdlaWdodFwiXSwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCA0NS4zNTkyMzddLFxuXHQgICAgW1wic2llbWVuc1wiLCBcIlNcIiwgbnVsbCwgXCJlbGVjdHJpY2FsX2NvbmR1Y3RhbmNlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcInNpZXZlcnRcIiwgXCJTdlwiLCBudWxsLCBcImVxdWl2YWxlbnRfZG9zZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJzbHVnXCIsIFwic2dcIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCAxNC41OTM5MDI5NF0sXG5cdCAgICBbXCJzcXVhcmUgw6VuZ3N0csO2bVwiLCBcImFuZzJcIiwgW1wiYW5nXjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMWUtMjBdLFxuXHQgICAgW1wic3F1YXJlIGZvb3RcIiwgXCJmdDJcIiwgW1wiZnReMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAwLjA5MjkwMzA0XSxcblx0ICAgIFtcInNxdWFyZSBpbmNoXCIsIFwiaW4yXCIsIFtcImluXjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDA2NDUxNl0sXG5cdCAgICBbXCJzcXVhcmUgbGlnaHQteWVhclwiLCBcImx5MlwiLCBbXCJseV4yXCJdLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDguOTUwNTQyMTA3NDgxODllKzMxXSxcblx0ICAgIFtcInNxdWFyZSBtZXRlclwiLCBcIm0/XCIsIG51bGwsIFwiYXJlYVwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcInNxdWFyZSBtaWxlXCIsIFwibWkyXCIsIFtcIm1pXjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMjU4OTk4OC4xMTAzMzZdLFxuXHQgICAgW1wic3F1YXJlIG5hdXRpY2FsIG1pbGVcIiwgXCJObWkyXCIsIFtcIk5taV4yXCJdLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDM0Mjk5MDRdLFxuXHQgICAgW1wic3F1YXJlIFBpY2FcIiwgXCJQaWNhMlwiLCBbXCJQaWNhcHQyXCIsIFwiUGljYV4yXCIsIFwiUGljYXB0XjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAwMTc5MjExMTExMTExMV0sXG5cdCAgICBbXCJzcXVhcmUgeWFyZFwiLCBcInlkMlwiLCBbXCJ5ZF4yXCJdLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDAuODM2MTI3MzZdLFxuXHQgICAgW1wic3RhdHV0ZSBtaWxlXCIsIFwibWlcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDE2MDkuMzQ0XSxcblx0ICAgIFtcInN0ZXJhZGlhblwiLCBcInNyXCIsIG51bGwsIFwic29saWRfYW5nbGVcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wic3RpbGJcIiwgXCJzYlwiLCBudWxsLCBcImx1bWluYW5jZVwiLCBmYWxzZSwgZmFsc2UsIDAuMDAwMV0sXG5cdCAgICBbXCJzdG9rZXNcIiwgXCJTdFwiLCBudWxsLCBcImtpbmVtYXRpY192aXNjb3NpdHlcIiwgZmFsc2UsIGZhbHNlLCAwLjAwMDFdLFxuXHQgICAgW1wic3RvbmVcIiwgXCJzdG9uZVwiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDYuMzUwMjkzMThdLFxuXHQgICAgW1widGFibGVzcG9vblwiLCBcInRic1wiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAwMTQ3ODY4XSxcblx0ICAgIFtcInRlYXNwb29uXCIsIFwidHNwXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAwNDkyODkyXSxcblx0ICAgIFtcInRlc2xhXCIsIFwiVFwiLCBudWxsLCBcIm1hZ25ldGljX2ZsdXhfZGVuc2l0eVwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcInRoZXJtb2R5bmFtaWMgY2Fsb3JpZVwiLCBcImNcIiwgbnVsbCwgXCJlbmVyZ3lcIiwgZmFsc2UsIHRydWUsIDQuMTg0XSxcblx0ICAgIFtcInRvblwiLCBcInRvblwiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDkwNy4xODQ3NF0sXG5cdCAgICBbXCJ0b25uZVwiLCBcInRcIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCBmYWxzZSwgMTAwMF0sXG5cdCAgICBbXCJVLksuIHBpbnRcIiwgXCJ1a19wdFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDA1NjgyNjEyNV0sXG5cdCAgICBbXCJVLlMuIGJ1c2hlbFwiLCBcImJ1c2hlbFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMzUyMzkwN10sXG5cdCAgICBbXCJVLlMuIG9pbCBiYXJyZWxcIiwgXCJiYXJyZWxcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMTU4OTg3Mjk1XSxcblx0ICAgIFtcIlUuUy4gcGludFwiLCBcInB0XCIsIFtcInVzX3B0XCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDA0NzMxNzY0NzNdLFxuXHQgICAgW1wiVS5TLiBzdXJ2ZXkgbWlsZVwiLCBcInN1cnZleV9taVwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMTYwOS4zNDcyMTldLFxuXHQgICAgW1wiVS5TLiBzdXJ2ZXkvc3RhdHV0ZSBhY3JlXCIsIFwidXNfYWNyZVwiLCBudWxsLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDQwNDYuODcyNjFdLFxuXHQgICAgW1widm9sdFwiLCBcIlZcIiwgbnVsbCwgXCJ2b2x0YWdlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcIndhdHRcIiwgXCJXXCIsIG51bGwsIFwicG93ZXJcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJ3YXR0LWhvdXJcIiwgXCJXaFwiLCBbXCJ3aFwiXSwgXCJlbmVyZ3lcIiwgZmFsc2UsIHRydWUsIDM2MDBdLFxuXHQgICAgW1wid2ViZXJcIiwgXCJXYlwiLCBudWxsLCBcIm1hZ25ldGljX2ZsdXhcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wieWFyZFwiLCBcInlkXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAwLjkxNDRdLFxuXHQgICAgW1wieWVhclwiLCBcInlyXCIsIG51bGwsIFwidGltZVwiLCBmYWxzZSwgdHJ1ZSwgMzE1NTc2MDBdXG5cdCAgXTtcblxuXHQgIC8vIEJpbmFyeSBwcmVmaXhlc1xuXHQgIC8vIFtOYW1lLCBQcmVmaXggcG93ZXIgb2YgMiB2YWx1ZSwgUHJldml4IHZhbHVlLCBBYmJyZXZpYXRpb24sIERlcml2ZWQgZnJvbV1cblx0ICB2YXIgYmluYXJ5X3ByZWZpeGVzID0ge1xuXHQgICAgWWk6IFtcInlvYmlcIiwgODAsIDEyMDg5MjU4MTk2MTQ2MjkxNzQ3MDYxNzYsIFwiWWlcIiwgXCJ5b3R0YVwiXSxcblx0ICAgIFppOiBbXCJ6ZWJpXCIsIDcwLCAxMTgwNTkxNjIwNzE3NDExMzAzNDI0LCBcIlppXCIsIFwiemV0dGFcIl0sXG5cdCAgICBFaTogW1wiZXhiaVwiLCA2MCwgMTE1MjkyMTUwNDYwNjg0Njk3NiwgXCJFaVwiLCBcImV4YVwiXSxcblx0ICAgIFBpOiBbXCJwZWJpXCIsIDUwLCAxMTI1ODk5OTA2ODQyNjI0LCBcIlBpXCIsIFwicGV0YVwiXSxcblx0ICAgIFRpOiBbXCJ0ZWJpXCIsIDQwLCAxMDk5NTExNjI3Nzc2LCBcIlRpXCIsIFwidGVyYVwiXSxcblx0ICAgIEdpOiBbXCJnaWJpXCIsIDMwLCAxMDczNzQxODI0LCBcIkdpXCIsIFwiZ2lnYVwiXSxcblx0ICAgIE1pOiBbXCJtZWJpXCIsIDIwLCAxMDQ4NTc2LCBcIk1pXCIsIFwibWVnYVwiXSxcblx0ICAgIGtpOiBbXCJraWJpXCIsIDEwLCAxMDI0LCBcImtpXCIsIFwia2lsb1wiXVxuXHQgIH07XG5cblx0ICAvLyBVbml0IHByZWZpeGVzXG5cdCAgLy8gW05hbWUsIE11bHRpcGxpZXIsIEFiYnJldmlhdGlvbl1cblx0ICB2YXIgdW5pdF9wcmVmaXhlcyA9IHtcblx0ICAgIFk6IFtcInlvdHRhXCIsIDFlKzI0LCBcIllcIl0sXG5cdCAgICBaOiBbXCJ6ZXR0YVwiLCAxZSsyMSwgXCJaXCJdLFxuXHQgICAgRTogW1wiZXhhXCIsIDFlKzE4LCBcIkVcIl0sXG5cdCAgICBQOiBbXCJwZXRhXCIsIDFlKzE1LCBcIlBcIl0sXG5cdCAgICBUOiBbXCJ0ZXJhXCIsIDFlKzEyLCBcIlRcIl0sXG5cdCAgICBHOiBbXCJnaWdhXCIsIDFlKzA5LCBcIkdcIl0sXG5cdCAgICBNOiBbXCJtZWdhXCIsIDFlKzA2LCBcIk1cIl0sXG5cdCAgICBrOiBbXCJraWxvXCIsIDFlKzAzLCBcImtcIl0sXG5cdCAgICBoOiBbXCJoZWN0b1wiLCAxZSswMiwgXCJoXCJdLFxuXHQgICAgZTogW1wiZGVrYW9cIiwgMWUrMDEsIFwiZVwiXSxcblx0ICAgIGQ6IFtcImRlY2lcIiwgMWUtMDEsIFwiZFwiXSxcblx0ICAgIGM6IFtcImNlbnRpXCIsIDFlLTAyLCBcImNcIl0sXG5cdCAgICBtOiBbXCJtaWxsaVwiLCAxZS0wMywgXCJtXCJdLFxuXHQgICAgdTogW1wibWljcm9cIiwgMWUtMDYsIFwidVwiXSxcblx0ICAgIG46IFtcIm5hbm9cIiwgMWUtMDksIFwiblwiXSxcblx0ICAgIHA6IFtcInBpY29cIiwgMWUtMTIsIFwicFwiXSxcblx0ICAgIGY6IFtcImZlbXRvXCIsIDFlLTE1LCBcImZcIl0sXG5cdCAgICBhOiBbXCJhdHRvXCIsIDFlLTE4LCBcImFcIl0sXG5cdCAgICB6OiBbXCJ6ZXB0b1wiLCAxZS0yMSwgXCJ6XCJdLFxuXHQgICAgeTogW1wieW9jdG9cIiwgMWUtMjQsIFwieVwiXVxuXHQgIH07XG5cblx0ICAvLyBJbml0aWFsaXplIHVuaXRzIGFuZCBtdWx0aXBsaWVyc1xuXHQgIHZhciBmcm9tID0gbnVsbDtcblx0ICB2YXIgdG8gPSBudWxsO1xuXHQgIHZhciBiYXNlX2Zyb21fdW5pdCA9IGZyb21fdW5pdDtcblx0ICB2YXIgYmFzZV90b191bml0ID0gdG9fdW5pdDtcblx0ICB2YXIgZnJvbV9tdWx0aXBsaWVyID0gMTtcblx0ICB2YXIgdG9fbXVsdGlwbGllciA9IDE7XG5cdCAgdmFyIGFsdDtcblxuXHQgIC8vIExvb2t1cCBmcm9tIGFuZCB0byB1bml0c1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGFsdCA9ICh1bml0c1tpXVsyXSA9PT0gbnVsbCkgPyBbXSA6IHVuaXRzW2ldWzJdO1xuXHQgICAgaWYgKHVuaXRzW2ldWzFdID09PSBiYXNlX2Zyb21fdW5pdCB8fCBhbHQuaW5kZXhPZihiYXNlX2Zyb21fdW5pdCkgPj0gMCkge1xuXHQgICAgICBmcm9tID0gdW5pdHNbaV07XG5cdCAgICB9XG5cdCAgICBpZiAodW5pdHNbaV1bMV0gPT09IGJhc2VfdG9fdW5pdCB8fCBhbHQuaW5kZXhPZihiYXNlX3RvX3VuaXQpID49IDApIHtcblx0ICAgICAgdG8gPSB1bml0c1tpXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBMb29rdXAgZnJvbSBwcmVmaXhcblx0ICBpZiAoZnJvbSA9PT0gbnVsbCkge1xuXHQgICAgdmFyIGZyb21fYmluYXJ5X3ByZWZpeCA9IGJpbmFyeV9wcmVmaXhlc1tmcm9tX3VuaXQuc3Vic3RyaW5nKDAsIDIpXTtcblx0ICAgIHZhciBmcm9tX3VuaXRfcHJlZml4ID0gdW5pdF9wcmVmaXhlc1tmcm9tX3VuaXQuc3Vic3RyaW5nKDAsIDEpXTtcblxuXHQgICAgLy8gSGFuZGxlIGRla2FvIHVuaXQgcHJlZml4IChvbmx5IHVuaXQgcHJlZml4IHdpdGggdHdvIGNoYXJhY3RlcnMpXG5cdCAgICBpZiAoZnJvbV91bml0LnN1YnN0cmluZygwLCAyKSA9PT0gJ2RhJykge1xuXHQgICAgICBmcm9tX3VuaXRfcHJlZml4ID0gW1wiZGVrYW9cIiwgMWUrMDEsIFwiZGFcIl07XG5cdCAgICB9XG5cblx0ICAgIC8vIEhhbmRsZSBiaW5hcnkgcHJlZml4ZXMgZmlyc3QgKHNvIHRoYXQgJ1lpJyBpcyBwcm9jZXNzZWQgYmVmb3JlICdZJylcblx0ICAgIGlmIChmcm9tX2JpbmFyeV9wcmVmaXgpIHtcblx0ICAgICAgZnJvbV9tdWx0aXBsaWVyID0gZnJvbV9iaW5hcnlfcHJlZml4WzJdO1xuXHQgICAgICBiYXNlX2Zyb21fdW5pdCA9IGZyb21fdW5pdC5zdWJzdHJpbmcoMik7XG5cdCAgICB9IGVsc2UgaWYgKGZyb21fdW5pdF9wcmVmaXgpIHtcblx0ICAgICAgZnJvbV9tdWx0aXBsaWVyID0gZnJvbV91bml0X3ByZWZpeFsxXTtcblx0ICAgICAgYmFzZV9mcm9tX3VuaXQgPSBmcm9tX3VuaXQuc3Vic3RyaW5nKGZyb21fdW5pdF9wcmVmaXhbMl0ubGVuZ3RoKTtcblx0ICAgIH1cblxuXHQgICAgLy8gTG9va3VwIGZyb20gdW5pdFxuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCB1bml0cy5sZW5ndGg7IGorKykge1xuXHQgICAgICBhbHQgPSAodW5pdHNbal1bMl0gPT09IG51bGwpID8gW10gOiB1bml0c1tqXVsyXTtcblx0ICAgICAgaWYgKHVuaXRzW2pdWzFdID09PSBiYXNlX2Zyb21fdW5pdCB8fCBhbHQuaW5kZXhPZihiYXNlX2Zyb21fdW5pdCkgPj0gMCkge1xuXHQgICAgICAgIGZyb20gPSB1bml0c1tqXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIExvb2t1cCB0byBwcmVmaXhcblx0ICBpZiAodG8gPT09IG51bGwpIHtcblx0ICAgIHZhciB0b19iaW5hcnlfcHJlZml4ID0gYmluYXJ5X3ByZWZpeGVzW3RvX3VuaXQuc3Vic3RyaW5nKDAsIDIpXTtcblx0ICAgIHZhciB0b191bml0X3ByZWZpeCA9IHVuaXRfcHJlZml4ZXNbdG9fdW5pdC5zdWJzdHJpbmcoMCwgMSldO1xuXG5cdCAgICAvLyBIYW5kbGUgZGVrYW8gdW5pdCBwcmVmaXggKG9ubHkgdW5pdCBwcmVmaXggd2l0aCB0d28gY2hhcmFjdGVycylcblx0ICAgIGlmICh0b191bml0LnN1YnN0cmluZygwLCAyKSA9PT0gJ2RhJykge1xuXHQgICAgICB0b191bml0X3ByZWZpeCA9IFtcImRla2FvXCIsIDFlKzAxLCBcImRhXCJdO1xuXHQgICAgfVxuXG5cdCAgICAvLyBIYW5kbGUgYmluYXJ5IHByZWZpeGVzIGZpcnN0IChzbyB0aGF0ICdZaScgaXMgcHJvY2Vzc2VkIGJlZm9yZSAnWScpXG5cdCAgICBpZiAodG9fYmluYXJ5X3ByZWZpeCkge1xuXHQgICAgICB0b19tdWx0aXBsaWVyID0gdG9fYmluYXJ5X3ByZWZpeFsyXTtcblx0ICAgICAgYmFzZV90b191bml0ID0gdG9fdW5pdC5zdWJzdHJpbmcoMik7XG5cdCAgICB9IGVsc2UgaWYgKHRvX3VuaXRfcHJlZml4KSB7XG5cdCAgICAgIHRvX211bHRpcGxpZXIgPSB0b191bml0X3ByZWZpeFsxXTtcblx0ICAgICAgYmFzZV90b191bml0ID0gdG9fdW5pdC5zdWJzdHJpbmcodG9fdW5pdF9wcmVmaXhbMl0ubGVuZ3RoKTtcblx0ICAgIH1cblxuXHQgICAgLy8gTG9va3VwIHRvIHVuaXRcblx0ICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdW5pdHMubGVuZ3RoOyBrKyspIHtcblx0ICAgICAgYWx0ID0gKHVuaXRzW2tdWzJdID09PSBudWxsKSA/IFtdIDogdW5pdHNba11bMl07XG5cdCAgICAgIGlmICh1bml0c1trXVsxXSA9PT0gYmFzZV90b191bml0IHx8IGFsdC5pbmRleE9mKGJhc2VfdG9fdW5pdCkgPj0gMCkge1xuXHQgICAgICAgIHRvID0gdW5pdHNba107XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgYSB1bml0IGRvZXMgbm90IGV4aXN0XG5cdCAgaWYgKGZyb20gPT09IG51bGwgfHwgdG8gPT09IG51bGwpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgdW5pdHMgcmVwcmVzZW50IGRpZmZlcmVudCBxdWFudGl0aWVzXG5cdCAgaWYgKGZyb21bM10gIT09IHRvWzNdKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGNvbnZlcnRlZCBudW1iZXJcblx0ICByZXR1cm4gbnVtYmVyICogZnJvbVs2XSAqIGZyb21fbXVsdGlwbGllciAvICh0b1s2XSAqIHRvX211bHRpcGxpZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuREVDMkJJTiA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgZGVjaW1hbCwgaXMgbG93ZXIgdGhhbiAtNTEyLCBvciBpcyBncmVhdGVyIHRoYW4gNTExXG5cdCAgaWYgKCEvXi0/WzAtOV17MSwzfSQvLnRlc3QobnVtYmVyKSB8fCBudW1iZXIgPCAtNTEyIHx8IG51bWJlciA+IDUxMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgYmluYXJ5IG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICBpZiAobnVtYmVyIDwgMCkge1xuXHQgICAgcmV0dXJuICcxJyArIHRleHQuUkVQVCgnMCcsIDkgLSAoNTEyICsgbnVtYmVyKS50b1N0cmluZygyKS5sZW5ndGgpICsgKDUxMiArIG51bWJlcikudG9TdHJpbmcoMik7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBkZWNpbWFsIG51bWJlciB0byBiaW5hcnlcblx0ICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQobnVtYmVyLCAxMCkudG9TdHJpbmcoMik7XG5cblx0ICAvLyBSZXR1cm4gYmluYXJ5IG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmICh0eXBlb2YgcGxhY2VzID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuREVDMkhFWCA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgZGVjaW1hbCwgaXMgbG93ZXIgdGhhbiAtNTQ5NzU1ODEzODg4LCBvciBpcyBncmVhdGVyIHRoYW4gNTQ5NzU1ODEzODg3XG5cdCAgaWYgKCEvXi0/WzAtOV17MSwxMn0kLy50ZXN0KG51bWJlcikgfHwgbnVtYmVyIDwgLTU0OTc1NTgxMzg4OCB8fCBudW1iZXIgPiA1NDk3NTU4MTM4ODcpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIGhleGFkZWNpbWFsIG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICBpZiAobnVtYmVyIDwgMCkge1xuXHQgICAgcmV0dXJuICgxMDk5NTExNjI3Nzc2ICsgbnVtYmVyKS50b1N0cmluZygxNik7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBkZWNpbWFsIG51bWJlciB0byBoZXhhZGVjaW1hbFxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChudW1iZXIsIDEwKS50b1N0cmluZygxNik7XG5cblx0ICAvLyBSZXR1cm4gaGV4YWRlY2ltYWwgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHR5cGVvZiBwbGFjZXMgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5ERUMyT0NUID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBkZWNpbWFsLCBpcyBsb3dlciB0aGFuIC01NDk3NTU4MTM4ODgsIG9yIGlzIGdyZWF0ZXIgdGhhbiA1NDk3NTU4MTM4ODdcblx0ICBpZiAoIS9eLT9bMC05XXsxLDl9JC8udGVzdChudW1iZXIpIHx8IG51bWJlciA8IC01MzY4NzA5MTIgfHwgbnVtYmVyID4gNTM2ODcwOTExKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBvY3RhbCBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgIHJldHVybiAoMTA3Mzc0MTgyNCArIG51bWJlcikudG9TdHJpbmcoOCk7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBkZWNpbWFsIG51bWJlciB0byBvY3RhbFxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChudW1iZXIsIDEwKS50b1N0cmluZyg4KTtcblxuXHQgIC8vIFJldHVybiBvY3RhbCBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAodHlwZW9mIHBsYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkRFTFRBID0gZnVuY3Rpb24obnVtYmVyMSwgbnVtYmVyMikge1xuXHQgIC8vIFNldCBudW1iZXIyIHRvIHplcm8gaWYgdW5kZWZpbmVkXG5cdCAgbnVtYmVyMiA9IChudW1iZXIyID09PSB1bmRlZmluZWQpID8gMCA6IG51bWJlcjI7XG5cdCAgbnVtYmVyMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjEpO1xuXHQgIG51bWJlcjIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIxLCBudW1iZXIyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBkZWx0YVxuXHQgIHJldHVybiAobnVtYmVyMSA9PT0gbnVtYmVyMikgPyAxIDogMDtcblx0fTtcblxuXHQvLyBUT0RPOiB3aHkgaXMgdXBwZXJfYm91bmQgbm90IHVzZWQgPyBUaGUgZXhjZWwgZG9jdW1lbnRhdGlvbiBoYXMgbm8gZXhhbXBsZXMgd2l0aCB1cHBlcl9ib3VuZFxuXHRleHBvcnRzLkVSRiA9IGZ1bmN0aW9uKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkge1xuXHQgIC8vIFNldCBudW1iZXIyIHRvIHplcm8gaWYgdW5kZWZpbmVkXG5cdCAgdXBwZXJfYm91bmQgPSAodXBwZXJfYm91bmQgPT09IHVuZGVmaW5lZCkgPyAwIDogdXBwZXJfYm91bmQ7XG5cblx0ICBsb3dlcl9ib3VuZCA9IHV0aWxzLnBhcnNlTnVtYmVyKGxvd2VyX2JvdW5kKTtcblx0ICB1cHBlcl9ib3VuZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHVwcGVyX2JvdW5kKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmVyZihsb3dlcl9ib3VuZCk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkVSRi5QUkVDSVNFID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0VSRi5QUkVDSVNFIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRVJGQyA9IGZ1bmN0aW9uKHgpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgeCBpcyBub3QgYSBudW1iZXJcblx0ICBpZiAoaXNOYU4oeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuZXJmYyh4KTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuRVJGQy5QUkVDSVNFID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0VSRkMuUFJFQ0lTRSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkdFU1RFUCA9IGZ1bmN0aW9uKG51bWJlciwgc3RlcCkge1xuXHQgIHN0ZXAgPSBzdGVwIHx8IDA7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihzdGVwLCBudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBkZWx0YVxuXHQgIHJldHVybiAobnVtYmVyID49IHN0ZXApID8gMSA6IDA7XG5cdH07XG5cblx0ZXhwb3J0cy5IRVgyQklOID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBoZXhhZGVjaW1hbCBvciBjb250YWlucyBtb3JlIHRoYW4gdGVuIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIS9eWzAtOUEtRmEtZl17MSwxMH0kLy50ZXN0KG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ2hlY2sgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgdmFyIG5lZ2F0aXZlID0gKG51bWJlci5sZW5ndGggPT09IDEwICYmIG51bWJlci5zdWJzdHJpbmcoMCwgMSkudG9Mb3dlckNhc2UoKSA9PT0gJ2YnKSA/IHRydWUgOiBmYWxzZTtcblxuXHQgIC8vIENvbnZlcnQgaGV4YWRlY2ltYWwgbnVtYmVyIHRvIGRlY2ltYWxcblx0ICB2YXIgZGVjaW1hbCA9IChuZWdhdGl2ZSkgPyBwYXJzZUludChudW1iZXIsIDE2KSAtIDEwOTk1MTE2Mjc3NzYgOiBwYXJzZUludChudW1iZXIsIDE2KTtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbG93ZXIgdGhhbiAtNTEyIG9yIGdyZWF0ZXIgdGhhbiA1MTFcblx0ICBpZiAoZGVjaW1hbCA8IC01MTIgfHwgZGVjaW1hbCA+IDUxMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgYmluYXJ5IG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICBpZiAobmVnYXRpdmUpIHtcblx0ICAgIHJldHVybiAnMScgKyB0ZXh0LlJFUFQoJzAnLCA5IC0gKDUxMiArIGRlY2ltYWwpLnRvU3RyaW5nKDIpLmxlbmd0aCkgKyAoNTEyICsgZGVjaW1hbCkudG9TdHJpbmcoMik7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBkZWNpbWFsIG51bWJlciB0byBiaW5hcnlcblx0ICB2YXIgcmVzdWx0ID0gZGVjaW1hbC50b1N0cmluZygyKTtcblxuXHQgIC8vIFJldHVybiBiaW5hcnkgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHBsYWNlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5IRVgyREVDID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgaGV4YWRlY2ltYWwgb3IgY29udGFpbnMgbW9yZSB0aGFuIHRlbiBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCEvXlswLTlBLUZhLWZdezEsMTB9JC8udGVzdChudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgaGV4YWRlY2ltYWwgbnVtYmVyIHRvIGRlY2ltYWxcblx0ICB2YXIgZGVjaW1hbCA9IHBhcnNlSW50KG51bWJlciwgMTYpO1xuXG5cdCAgLy8gUmV0dXJuIGRlY2ltYWwgbnVtYmVyXG5cdCAgcmV0dXJuIChkZWNpbWFsID49IDU0OTc1NTgxMzg4OCkgPyBkZWNpbWFsIC0gMTA5OTUxMTYyNzc3NiA6IGRlY2ltYWw7XG5cdH07XG5cblx0ZXhwb3J0cy5IRVgyT0NUID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBoZXhhZGVjaW1hbCBvciBjb250YWlucyBtb3JlIHRoYW4gdGVuIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIS9eWzAtOUEtRmEtZl17MSwxMH0kLy50ZXN0KG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBoZXhhZGVjaW1hbCBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciBkZWNpbWFsID0gcGFyc2VJbnQobnVtYmVyLCAxNik7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIHBvc2l0aXZlIGFuZCBncmVhdGVyIHRoYW4gMHgxZmZmZmZmZiAoNTM2ODcwOTExKVxuXHQgIGlmIChkZWNpbWFsID4gNTM2ODcwOTExICYmIGRlY2ltYWwgPCAxMDk4OTc0NzU2ODY0KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBvY3RhbCBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKGRlY2ltYWwgPj0gMTA5ODk3NDc1Njg2NCkge1xuXHQgICAgcmV0dXJuIChkZWNpbWFsIC0gMTA5ODQzNzg4NTk1MikudG9TdHJpbmcoOCk7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBkZWNpbWFsIG51bWJlciB0byBvY3RhbFxuXHQgIHZhciByZXN1bHQgPSBkZWNpbWFsLnRvU3RyaW5nKDgpO1xuXG5cdCAgLy8gUmV0dXJuIG9jdGFsIG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmIChwbGFjZXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuSU1BQlMgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgZXhwb3J0cy5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBjb2VmZmljaWVudCBpcyBub3QgYSBudW1iZXJcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBhYnNvbHV0ZSB2YWx1ZSBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUFHSU5BUlkgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgaWYgKGludW1iZXIgPT09IHVuZGVmaW5lZCB8fCBpbnVtYmVyID09PSB0cnVlIHx8IGludW1iZXIgPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIDAgaWYgaW51bWJlciBpcyBlcXVhbCB0byAwXG5cdCAgaWYgKGludW1iZXIgPT09IDAgfHwgaW51bWJlciA9PT0gJzAnKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlc1xuXHQgIGlmIChbJ2knLCAnaiddLmluZGV4T2YoaW51bWJlcikgPj0gMCkge1xuXHQgICAgcmV0dXJuIDE7XG5cdCAgfVxuXG5cdCAgLy8gTm9ybWFsaXplIGltYWdpbmFyeSBjb2VmZmljaWVudFxuXHQgIGludW1iZXIgPSBpbnVtYmVyLnJlcGxhY2UoJytpJywgJysxaScpLnJlcGxhY2UoJy1pJywgJy0xaScpLnJlcGxhY2UoJytqJywgJysxaicpLnJlcGxhY2UoJy1qJywgJy0xaicpO1xuXG5cdCAgLy8gTG9va3VwIHNpZ25cblx0ICB2YXIgcGx1cyA9IGludW1iZXIuaW5kZXhPZignKycpO1xuXHQgIHZhciBtaW51cyA9IGludW1iZXIuaW5kZXhPZignLScpO1xuXHQgIGlmIChwbHVzID09PSAwKSB7XG5cdCAgICBwbHVzID0gaW51bWJlci5pbmRleE9mKCcrJywgMSk7XG5cdCAgfVxuXG5cdCAgaWYgKG1pbnVzID09PSAwKSB7XG5cdCAgICBtaW51cyA9IGludW1iZXIuaW5kZXhPZignLScsIDEpO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciBsYXN0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxLCBpbnVtYmVyLmxlbmd0aCk7XG5cdCAgdmFyIHVuaXQgPSAobGFzdCA9PT0gJ2knIHx8IGxhc3QgPT09ICdqJyk7XG5cblx0ICBpZiAocGx1cyA+PSAwIHx8IG1pbnVzID49IDApIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBpbWFnaW5hcnkgdW5pdCBpcyBuZWl0aGVyIGkgbm9yIGpcblx0ICAgIGlmICghdW5pdCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gaW1hZ2luYXJ5IGNvZWZmaWNpZW50IG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgICBpZiAocGx1cyA+PSAwKSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlci5zdWJzdHJpbmcoMCwgcGx1cykpIHx8IGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKHBsdXMgKyAxLCBpbnVtYmVyLmxlbmd0aCAtIDEpKSkgP1xuXHQgICAgICAgIGVycm9yLm51bSA6XG5cdCAgICAgICAgTnVtYmVyKGludW1iZXIuc3Vic3RyaW5nKHBsdXMgKyAxLCBpbnVtYmVyLmxlbmd0aCAtIDEpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlci5zdWJzdHJpbmcoMCwgbWludXMpKSB8fCBpc05hTihpbnVtYmVyLnN1YnN0cmluZyhtaW51cyArIDEsIGludW1iZXIubGVuZ3RoIC0gMSkpKSA/XG5cdCAgICAgICAgZXJyb3IubnVtIDpcblx0ICAgICAgICAtTnVtYmVyKGludW1iZXIuc3Vic3RyaW5nKG1pbnVzICsgMSwgaW51bWJlci5sZW5ndGggLSAxKSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICh1bml0KSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlci5zdWJzdHJpbmcoMCwgaW51bWJlci5sZW5ndGggLSAxKSkpID8gZXJyb3IubnVtIDogaW51bWJlci5zdWJzdHJpbmcoMCwgaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlcikpID8gZXJyb3IubnVtIDogMDtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5JTUFSR1VNRU5UID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIGV4cG9ydHMuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgY29lZmZpY2llbnQgaXMgbm90IGEgbnVtYmVyXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgaW51bWJlciBpcyBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLmRpdjA7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIFBJLzIgaWYgeCBpcyBlcXVhbCB0byB6ZXJvIGFuZCB5IGlzIHBvc2l0aXZlXG5cdCAgaWYgKHggPT09IDAgJiYgeSA+IDApIHtcblx0ICAgIHJldHVybiBNYXRoLlBJIC8gMjtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gLVBJLzIgaWYgeCBpcyBlcXVhbCB0byB6ZXJvIGFuZCB5IGlzIG5lZ2F0aXZlXG5cdCAgaWYgKHggPT09IDAgJiYgeSA8IDApIHtcblx0ICAgIHJldHVybiAtTWF0aC5QSSAvIDI7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHplcm8gaWYgeCBpcyBuZWdhdGl2ZSBhbmQgeSBpcyBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHkgPT09IDAgJiYgeCA+IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiB6ZXJvIGlmIHggaXMgbmVnYXRpdmUgYW5kIHkgaXMgZXF1YWwgdG8gemVyb1xuXHQgIGlmICh5ID09PSAwICYmIHggPCAwKSB7XG5cdCAgICByZXR1cm4gLU1hdGguUEk7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGFyZ3VtZW50IG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgaWYgKHggPiAwKSB7XG5cdCAgICByZXR1cm4gTWF0aC5hdGFuKHkgLyB4KTtcblx0ICB9IGVsc2UgaWYgKHggPCAwICYmIHkgPj0gMCkge1xuXHQgICAgcmV0dXJuIE1hdGguYXRhbih5IC8geCkgKyBNYXRoLlBJO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gTWF0aC5hdGFuKHkgLyB4KSAtIE1hdGguUEk7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuSU1DT05KVUdBVEUgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgZXhwb3J0cy5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gY29uanVnYXRlIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuICh5ICE9PSAwKSA/IGV4cG9ydHMuQ09NUExFWCh4LCAteSwgdW5pdCkgOiBpbnVtYmVyO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1DT1MgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgZXhwb3J0cy5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gY29zaW5lIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChNYXRoLmNvcyh4KSAqIChNYXRoLmV4cCh5KSArIE1hdGguZXhwKC15KSkgLyAyLCAtTWF0aC5zaW4oeCkgKiAoTWF0aC5leHAoeSkgLSBNYXRoLmV4cCgteSkpIC8gMiwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUNPU0ggPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgZXhwb3J0cy5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gaHlwZXJib2xpYyBjb3NpbmUgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGguY29zKHkpICogKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDIsIE1hdGguc2luKHkpICogKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDIsIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1DT1QgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gY290YW5nZW50IG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuSU1ESVYoZXhwb3J0cy5JTUNPUyhpbnVtYmVyKSwgZXhwb3J0cy5JTVNJTihpbnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTURJViA9IGZ1bmN0aW9uKGludW1iZXIxLCBpbnVtYmVyMikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciBhID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcjEpO1xuXHQgIHZhciBiID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcjEpO1xuXHQgIHZhciBjID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcjIpO1xuXHQgIHZhciBkID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcjIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYSwgYiwgYywgZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdDEgPSBpbnVtYmVyMS5zdWJzdHJpbmcoaW51bWJlcjEubGVuZ3RoIC0gMSk7XG5cdCAgdmFyIHVuaXQyID0gaW51bWJlcjIuc3Vic3RyaW5nKGludW1iZXIyLmxlbmd0aCAtIDEpO1xuXHQgIHZhciB1bml0ID0gJ2knO1xuXHQgIGlmICh1bml0MSA9PT0gJ2onKSB7XG5cdCAgICB1bml0ID0gJ2onO1xuXHQgIH0gZWxzZSBpZiAodW5pdDIgPT09ICdqJykge1xuXHQgICAgdW5pdCA9ICdqJztcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgaW51bWJlcjIgaXMgbnVsbFxuXHQgIGlmIChjID09PSAwICYmIGQgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGV4cG9uZW50aWFsIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgdmFyIGRlbiA9IGMgKiBjICsgZCAqIGQ7XG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWCgoYSAqIGMgKyBiICogZCkgLyBkZW4sIChiICogYyAtIGEgKiBkKSAvIGRlbiwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUVYUCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBleHBvbmVudGlhbCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHZhciBlID0gTWF0aC5leHAoeCk7XG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChlICogTWF0aC5jb3MoeSksIGUgKiBNYXRoLnNpbih5KSwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUxOID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGV4cG9uZW50aWFsIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChNYXRoLmxvZyhNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpLCBNYXRoLmF0YW4oeSAvIHgpLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNTE9HMTAgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGgubG9nKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSkgLyBNYXRoLmxvZygxMCksIE1hdGguYXRhbih5IC8geCkgLyBNYXRoLmxvZygxMCksIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1MT0cyID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGV4cG9uZW50aWFsIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChNYXRoLmxvZyhNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpIC8gTWF0aC5sb2coMiksIE1hdGguYXRhbih5IC8geCkgLyBNYXRoLmxvZygyKSwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVBPV0VSID0gZnVuY3Rpb24oaW51bWJlciwgbnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCB4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIENhbGN1bGF0ZSBwb3dlciBvZiBtb2R1bHVzXG5cdCAgdmFyIHAgPSBNYXRoLnBvdyhleHBvcnRzLklNQUJTKGludW1iZXIpLCBudW1iZXIpO1xuXG5cdCAgLy8gQ2FsY3VsYXRlIGFyZ3VtZW50XG5cdCAgdmFyIHQgPSBleHBvcnRzLklNQVJHVU1FTlQoaW51bWJlcik7XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKHAgKiBNYXRoLmNvcyhudW1iZXIgKiB0KSwgcCAqIE1hdGguc2luKG51bWJlciAqIHQpLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNUFJPRFVDVCA9IGZ1bmN0aW9uKCkge1xuXHQgIC8vIEluaXRpYWxpemUgcmVzdWx0XG5cdCAgdmFyIHJlc3VsdCA9IGFyZ3VtZW50c1swXTtcblxuXHQgIC8vIExvb3Agb24gYWxsIG51bWJlcnNcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgLy8gTG9va3VwIGNvZWZmaWNpZW50cyBvZiB0d28gY29tcGxleCBudW1iZXJzXG5cdCAgICB2YXIgYSA9IGV4cG9ydHMuSU1SRUFMKHJlc3VsdCk7XG5cdCAgICB2YXIgYiA9IGV4cG9ydHMuSU1BR0lOQVJZKHJlc3VsdCk7XG5cdCAgICB2YXIgYyA9IGV4cG9ydHMuSU1SRUFMKGFyZ3VtZW50c1tpXSk7XG5cdCAgICB2YXIgZCA9IGV4cG9ydHMuSU1BR0lOQVJZKGFyZ3VtZW50c1tpXSk7XG5cblx0ICAgIGlmICh1dGlscy5hbnlJc0Vycm9yKGEsIGIsIGMsIGQpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gQ29tcGx1dGUgcHJvZHVjdCBvZiB0d28gY29tcGxleCBudW1iZXJzXG5cdCAgICByZXN1bHQgPSBleHBvcnRzLkNPTVBMRVgoYSAqIGMgLSBiICogZCwgYSAqIGQgKyBiICogYyk7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHByb2R1Y3Qgb2YgY29tcGxleCBudW1iZXJzXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLklNUkVBTCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICBpZiAoaW51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGludW1iZXIgPT09IHRydWUgfHwgaW51bWJlciA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gMCBpZiBpbnVtYmVyIGlzIGVxdWFsIHRvIDBcblx0ICBpZiAoaW51bWJlciA9PT0gMCB8fCBpbnVtYmVyID09PSAnMCcpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2VzXG5cdCAgaWYgKFsnaScsICcraScsICcxaScsICcrMWknLCAnLWknLCAnLTFpJywgJ2onLCAnK2onLCAnMWonLCAnKzFqJywgJy1qJywgJy0xaiddLmluZGV4T2YoaW51bWJlcikgPj0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHNpZ25cblx0ICB2YXIgcGx1cyA9IGludW1iZXIuaW5kZXhPZignKycpO1xuXHQgIHZhciBtaW51cyA9IGludW1iZXIuaW5kZXhPZignLScpO1xuXHQgIGlmIChwbHVzID09PSAwKSB7XG5cdCAgICBwbHVzID0gaW51bWJlci5pbmRleE9mKCcrJywgMSk7XG5cdCAgfVxuXHQgIGlmIChtaW51cyA9PT0gMCkge1xuXHQgICAgbWludXMgPSBpbnVtYmVyLmluZGV4T2YoJy0nLCAxKTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgbGFzdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSwgaW51bWJlci5sZW5ndGgpO1xuXHQgIHZhciB1bml0ID0gKGxhc3QgPT09ICdpJyB8fCBsYXN0ID09PSAnaicpO1xuXG5cdCAgaWYgKHBsdXMgPj0gMCB8fCBtaW51cyA+PSAwKSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgaW1hZ2luYXJ5IHVuaXQgaXMgbmVpdGhlciBpIG5vciBqXG5cdCAgICBpZiAoIXVuaXQpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIHJlYWwgY29lZmZpY2llbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICAgIGlmIChwbHVzID49IDApIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyLnN1YnN0cmluZygwLCBwbHVzKSkgfHwgaXNOYU4oaW51bWJlci5zdWJzdHJpbmcocGx1cyArIDEsIGludW1iZXIubGVuZ3RoIC0gMSkpKSA/XG5cdCAgICAgICAgZXJyb3IubnVtIDpcblx0ICAgICAgICBOdW1iZXIoaW51bWJlci5zdWJzdHJpbmcoMCwgcGx1cykpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyLnN1YnN0cmluZygwLCBtaW51cykpIHx8IGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKG1pbnVzICsgMSwgaW51bWJlci5sZW5ndGggLSAxKSkpID9cblx0ICAgICAgICBlcnJvci5udW0gOlxuXHQgICAgICAgIE51bWJlcihpbnVtYmVyLnN1YnN0cmluZygwLCBtaW51cykpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAodW5pdCkge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKDAsIGludW1iZXIubGVuZ3RoIC0gMSkpKSA/IGVycm9yLm51bSA6IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIpKSA/IGVycm9yLm51bSA6IGludW1iZXI7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuSU1TRUMgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGludW1iZXIgaXMgYSBsb2dpY2FsIHZhbHVlXG5cdCAgaWYgKGludW1iZXIgPT09IHRydWUgfHwgaW51bWJlciA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBzZWNhbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5JTURJVignMScsIGV4cG9ydHMuSU1DT1MoaW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1TRUNIID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGh5cGVyYm9saWMgc2VjYW50IG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuSU1ESVYoJzEnLCBleHBvcnRzLklNQ09TSChpbnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNJTiA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBzaW5lIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChNYXRoLnNpbih4KSAqIChNYXRoLmV4cCh5KSArIE1hdGguZXhwKC15KSkgLyAyLCBNYXRoLmNvcyh4KSAqIChNYXRoLmV4cCh5KSAtIE1hdGguZXhwKC15KSkgLyAyLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNU0lOSCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBoeXBlcmJvbGljIHNpbmUgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGguY29zKHkpICogKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDIsIE1hdGguc2luKHkpICogKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDIsIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1TUVJUID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gQ2FsY3VsYXRlIHBvd2VyIG9mIG1vZHVsdXNcblx0ICB2YXIgcyA9IE1hdGguc3FydChleHBvcnRzLklNQUJTKGludW1iZXIpKTtcblxuXHQgIC8vIENhbGN1bGF0ZSBhcmd1bWVudFxuXHQgIHZhciB0ID0gZXhwb3J0cy5JTUFSR1VNRU5UKGludW1iZXIpO1xuXG5cdCAgLy8gUmV0dXJuIGV4cG9uZW50aWFsIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuQ09NUExFWChzICogTWF0aC5jb3ModCAvIDIpLCBzICogTWF0aC5zaW4odCAvIDIpLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNQ1NDID0gZnVuY3Rpb24gKGludW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgaW51bWJlciBpcyBhIGxvZ2ljYWwgdmFsdWVcblx0ICBpZiAoaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgY29lZmZpY2llbnQgaXMgbm90IGEgbnVtYmVyXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGNvc2VjYW50IG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuSU1ESVYoJzEnLCBleHBvcnRzLklNU0lOKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNQ1NDSCA9IGZ1bmN0aW9uIChpbnVtYmVyKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGludW1iZXIgaXMgYSBsb2dpY2FsIHZhbHVlXG5cdCAgaWYgKGludW1iZXIgPT09IHRydWUgfHwgaW51bWJlciA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIGNvZWZmaWNpZW50IGlzIG5vdCBhIG51bWJlclxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBoeXBlcmJvbGljIGNvc2VjYW50IG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIGV4cG9ydHMuSU1ESVYoJzEnLCBleHBvcnRzLklNU0lOSChpbnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNVQiA9IGZ1bmN0aW9uKGludW1iZXIxLCBpbnVtYmVyMikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciBhID0gdGhpcy5JTVJFQUwoaW51bWJlcjEpO1xuXHQgIHZhciBiID0gdGhpcy5JTUFHSU5BUlkoaW51bWJlcjEpO1xuXHQgIHZhciBjID0gdGhpcy5JTVJFQUwoaW51bWJlcjIpO1xuXHQgIHZhciBkID0gdGhpcy5JTUFHSU5BUlkoaW51bWJlcjIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYSwgYiwgYywgZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdDEgPSBpbnVtYmVyMS5zdWJzdHJpbmcoaW51bWJlcjEubGVuZ3RoIC0gMSk7XG5cdCAgdmFyIHVuaXQyID0gaW51bWJlcjIuc3Vic3RyaW5nKGludW1iZXIyLmxlbmd0aCAtIDEpO1xuXHQgIHZhciB1bml0ID0gJ2knO1xuXHQgIGlmICh1bml0MSA9PT0gJ2onKSB7XG5cdCAgICB1bml0ID0gJ2onO1xuXHQgIH0gZWxzZSBpZiAodW5pdDIgPT09ICdqJykge1xuXHQgICAgdW5pdCA9ICdqJztcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gXyBvZiB0d28gY29tcGxleCBudW1iZXJzXG5cdCAgcmV0dXJuIHRoaXMuQ09NUExFWChhIC0gYywgYiAtIGQsIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1TVU0gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblxuXHQgIC8vIEluaXRpYWxpemUgcmVzdWx0XG5cdCAgdmFyIHJlc3VsdCA9IGFyZ3NbMF07XG5cblx0ICAvLyBMb29wIG9uIGFsbCBudW1iZXJzXG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAvLyBMb29rdXAgY29lZmZpY2llbnRzIG9mIHR3byBjb21wbGV4IG51bWJlcnNcblx0ICAgIHZhciBhID0gdGhpcy5JTVJFQUwocmVzdWx0KTtcblx0ICAgIHZhciBiID0gdGhpcy5JTUFHSU5BUlkocmVzdWx0KTtcblx0ICAgIHZhciBjID0gdGhpcy5JTVJFQUwoYXJnc1tpXSk7XG5cdCAgICB2YXIgZCA9IHRoaXMuSU1BR0lOQVJZKGFyZ3NbaV0pO1xuXG5cdCAgICBpZiAodXRpbHMuYW55SXNFcnJvcihhLCBiLCBjLCBkKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIENvbXBsdXRlIHByb2R1Y3Qgb2YgdHdvIGNvbXBsZXggbnVtYmVyc1xuXHQgICAgcmVzdWx0ID0gdGhpcy5DT01QTEVYKGEgKyBjLCBiICsgZCk7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHN1bSBvZiBjb21wbGV4IG51bWJlcnNcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1UQU4gPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGludW1iZXIgaXMgYSBsb2dpY2FsIHZhbHVlXG5cdCAgaWYgKGludW1iZXIgPT09IHRydWUgfHwgaW51bWJlciA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiB0YW5nZW50IG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIHRoaXMuSU1ESVYodGhpcy5JTVNJTihpbnVtYmVyKSwgdGhpcy5JTUNPUyhpbnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5PQ1QyQklOID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBoZXhhZGVjaW1hbCBvciBjb250YWlucyBtb3JlIHRoYW4gdGVuIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIS9eWzAtN117MSwxMH0kLy50ZXN0KG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ2hlY2sgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgdmFyIG5lZ2F0aXZlID0gKG51bWJlci5sZW5ndGggPT09IDEwICYmIG51bWJlci5zdWJzdHJpbmcoMCwgMSkgPT09ICc3JykgPyB0cnVlIDogZmFsc2U7XG5cblx0ICAvLyBDb252ZXJ0IG9jdGFsIG51bWJlciB0byBkZWNpbWFsXG5cdCAgdmFyIGRlY2ltYWwgPSAobmVnYXRpdmUpID8gcGFyc2VJbnQobnVtYmVyLCA4KSAtIDEwNzM3NDE4MjQgOiBwYXJzZUludChudW1iZXIsIDgpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBsb3dlciB0aGFuIC01MTIgb3IgZ3JlYXRlciB0aGFuIDUxMVxuXHQgIGlmIChkZWNpbWFsIDwgLTUxMiB8fCBkZWNpbWFsID4gNTExKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBiaW5hcnkgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgcmV0dXJuICcxJyArIHRleHQuUkVQVCgnMCcsIDkgLSAoNTEyICsgZGVjaW1hbCkudG9TdHJpbmcoMikubGVuZ3RoKSArICg1MTIgKyBkZWNpbWFsKS50b1N0cmluZygyKTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIGJpbmFyeVxuXHQgIHZhciByZXN1bHQgPSBkZWNpbWFsLnRvU3RyaW5nKDIpO1xuXG5cdCAgLy8gUmV0dXJuIGJpbmFyeSBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAodHlwZW9mIHBsYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLk9DVDJERUMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBvY3RhbCBvciBjb250YWlucyBtb3JlIHRoYW4gdGVuIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIS9eWzAtN117MSwxMH0kLy50ZXN0KG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBvY3RhbCBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciBkZWNpbWFsID0gcGFyc2VJbnQobnVtYmVyLCA4KTtcblxuXHQgIC8vIFJldHVybiBkZWNpbWFsIG51bWJlclxuXHQgIHJldHVybiAoZGVjaW1hbCA+PSA1MzY4NzA5MTIpID8gZGVjaW1hbCAtIDEwNzM3NDE4MjQgOiBkZWNpbWFsO1xuXHR9O1xuXG5cdGV4cG9ydHMuT0NUMkhFWCA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3Qgb2N0YWwgb3IgY29udGFpbnMgbW9yZSB0aGFuIHRlbiBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCEvXlswLTddezEsMTB9JC8udGVzdChudW1iZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgb2N0YWwgbnVtYmVyIHRvIGRlY2ltYWxcblx0ICB2YXIgZGVjaW1hbCA9IHBhcnNlSW50KG51bWJlciwgOCk7XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgb2N0YWwgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChkZWNpbWFsID49IDUzNjg3MDkxMikge1xuXHQgICAgcmV0dXJuICdmZicgKyAoZGVjaW1hbCArIDMyMjEyMjU0NzIpLnRvU3RyaW5nKDE2KTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIGhleGFkZWNpbWFsXG5cdCAgdmFyIHJlc3VsdCA9IGRlY2ltYWwudG9TdHJpbmcoMTYpO1xuXG5cdCAgLy8gUmV0dXJuIGhleGFkZWNpbWFsIG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmIChwbGFjZXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBNID0gTWF0aDtcblx0ZnVuY3Rpb24gX2hvcm5lcihhcnIsIHYpIHsgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24oeix3KXtyZXR1cm4gdiAqIHogKyB3O30sMCk7IH07XG5cdGZ1bmN0aW9uIF9iZXNzZWxfaXRlcih4LCBuLCBmMCwgZjEsIHNpZ24pIHtcblx0ICBpZighc2lnbikgc2lnbiA9IC0xO1xuXHQgIHZhciB0ZHggPSAyIC8geCwgZjI7XG5cdCAgaWYobiA9PT0gMCkgcmV0dXJuIGYwO1xuXHQgIGlmKG4gPT09IDEpIHJldHVybiBmMTtcblx0ICBmb3IodmFyIG8gPSAxOyBvICE9IG47ICsrbykge1xuXHQgICAgZjIgPSBmMSAqIG8gKiB0ZHggKyBzaWduICogZjA7XG5cdCAgICBmMCA9IGYxOyBmMSA9IGYyO1xuXHQgIH1cblx0ICByZXR1cm4gZjE7XG5cdH1cblx0ZnVuY3Rpb24gX2Jlc3NlbF93cmFwKGJlc3NlbDAsIGJlc3NlbDEsIG5hbWUsIG5vbnplcm8sIHNpZ24pIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gYmVzc2VsKHgsbikge1xuXHQgICAgaWYobiA9PT0gMCkgcmV0dXJuIGJlc3NlbDAoeCk7XG5cdCAgICBpZihuID09PSAxKSByZXR1cm4gYmVzc2VsMSh4KTtcblx0ICAgIGlmKG4gPCAwKSB0aHJvdyBuYW1lICsgJzogT3JkZXIgKCcgKyBuICsgJykgbXVzdCBiZSBub25uZWdhdGl2ZSc7XG5cdCAgICBpZihub256ZXJvID09IDEgJiYgeCA9PT0gMCkgdGhyb3cgbmFtZSArICc6IFVuZGVmaW5lZCB3aGVuIHggPT0gMCc7XG5cdCAgICBpZihub256ZXJvID09IDIgJiYgeCA8PSAwKSB0aHJvdyBuYW1lICsgJzogVW5kZWZpbmVkIHdoZW4geCA8PSAwJztcblx0ICAgIHZhciBiMCA9IGJlc3NlbDAoeCksIGIxID0gYmVzc2VsMSh4KTtcblx0ICAgIHJldHVybiBfYmVzc2VsX2l0ZXIoeCwgbiwgYjAsIGIxLCBzaWduKTtcblx0ICB9O1xuXHR9XG5cdHZhciBiZXNzZWxqID0gKGZ1bmN0aW9uKCkge1xuXHQgIHZhciBiMF9hMWEgPSBbNTc1Njg0OTA1NzQuMCwtMTMzNjI1OTAzNTQuMCw2NTE2MTk2NDAuNywtMTEyMTQ0MjQuMTgsNzczOTIuMzMwMTcsLTE4NC45MDUyNDU2XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIwX2EyYSA9IFs1NzU2ODQ5MDQxMS4wLDEwMjk1MzI5ODUuMCw5NDk0NjgwLjcxOCw1OTI3Mi42NDg1MywyNjcuODUzMjcxMiwxLjBdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYTFiID0gWzEuMCwgLTAuMTA5ODYyODYyN2UtMiwgMC4yNzM0NTEwNDA3ZS00LCAtMC4yMDczMzcwNjM5ZS01LCAwLjIwOTM4ODcyMTFlLTZdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYTJiID0gWy0wLjE1NjI0OTk5OTVlLTEsIDAuMTQzMDQ4ODc2NWUtMywgLTAuNjkxMTE0NzY1MWUtNSwgMC43NjIxMDk1MTYxZS02LCAtMC45MzQ5MzUxNTJlLTddLnJldmVyc2UoKTtcblx0ICB2YXIgVyA9IDAuNjM2NjE5NzcyOyAvLyAyIC8gTWF0aC5QSVxuXG5cdCAgZnVuY3Rpb24gYmVzc2VsMCh4KSB7XG5cdCAgICB2YXIgYSwgYTEsIGEyLCB5ID0geCAqIHgsIHh4ID0gTS5hYnMoeCkgLSAwLjc4NTM5ODE2NDtcblx0ICAgIGlmKE0uYWJzKHgpIDwgOCkge1xuXHQgICAgICBhMSA9IF9ob3JuZXIoYjBfYTFhLCB5KTtcblx0ICAgICAgYTIgPSBfaG9ybmVyKGIwX2EyYSwgeSk7XG5cdCAgICAgIGEgPSBhMS9hMjtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICB5ID0gNjQgLyB5O1xuXHQgICAgICBhMSA9IF9ob3JuZXIoYjBfYTFiLCB5KTtcblx0ICAgICAgYTIgPSBfaG9ybmVyKGIwX2EyYiwgeSk7XG5cdCAgICAgIGEgPSBNLnNxcnQoVy9NLmFicyh4KSkqKE0uY29zKHh4KSphMS1NLnNpbih4eCkqYTIqOC9NLmFicyh4KSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYTtcblx0ICB9XG5cdCAgdmFyIGIxX2ExYSA9IFs3MjM2MjYxNDIzMi4wLC03ODk1MDU5MjM1LjAsMjQyMzk2ODUzLjEsLTI5NzI2MTEuNDM5LCAxNTcwNC40ODI2MCwgLTMwLjE2MDM2NjA2XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIxX2EyYSA9IFsxNDQ3MjUyMjg0NDIuMCwgMjMwMDUzNTE3OC4wLCAxODU4MzMwNC43NCwgOTk0NDcuNDMzOTQsIDM3Ni45OTkxMzk3LCAxLjBdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTFiID0gWzEuMCwgMC4xODMxMDVlLTIsIC0wLjM1MTYzOTY0OTZlLTQsIDAuMjQ1NzUyMDE3NGUtNSwgLTAuMjQwMzM3MDE5ZS02XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIxX2EyYiA9IFswLjA0Njg3NDk5OTk1LCAtMC4yMDAyNjkwODczZS0zLCAwLjg0NDkxOTkwOTZlLTUsIC0wLjg4MjI4OTg3ZS02LCAwLjEwNTc4NzQxMmUtNl0ucmV2ZXJzZSgpO1xuXHQgIGZ1bmN0aW9uIGJlc3NlbDEoeCkge1xuXHQgICAgdmFyIGEsIGExLCBhMiwgeSA9IHgqeCwgeHggPSBNLmFicyh4KSAtIDIuMzU2MTk0NDkxO1xuXHQgICAgaWYoTWF0aC5hYnMoeCk8IDgpIHtcblx0ICAgICAgYTEgPSB4Kl9ob3JuZXIoYjFfYTFhLCB5KTtcblx0ICAgICAgYTIgPSBfaG9ybmVyKGIxX2EyYSwgeSk7XG5cdCAgICAgIGEgPSBhMSAvIGEyO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgeSA9IDY0IC8geTtcblx0ICAgICAgYTE9X2hvcm5lcihiMV9hMWIsIHkpO1xuXHQgICAgICBhMj1faG9ybmVyKGIxX2EyYiwgeSk7XG5cdCAgICAgIGE9TS5zcXJ0KFcvTS5hYnMoeCkpKihNLmNvcyh4eCkqYTEtTS5zaW4oeHgpKmEyKjgvTS5hYnMoeCkpO1xuXHQgICAgICBpZih4IDwgMCkgYSA9IC1hO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGE7XG5cdCAgfVxuXHQgIHJldHVybiBmdW5jdGlvbiBiZXNzZWxqKHgsIG4pIHtcblx0ICAgIG4gPSBNYXRoLnJvdW5kKG4pO1xuXHQgICAgaWYobiA9PT0gMCkgcmV0dXJuIGJlc3NlbDAoTS5hYnMoeCkpO1xuXHQgICAgaWYobiA9PT0gMSkgcmV0dXJuIGJlc3NlbDEoTS5hYnMoeCkpO1xuXHQgICAgaWYobiA8IDApIHRocm93ICdCRVNTRUxKOiBPcmRlciAoJyArIG4gKyAnKSBtdXN0IGJlIG5vbm5lZ2F0aXZlJztcblx0ICAgIGlmKE0uYWJzKHgpID09PSAwKSByZXR1cm4gMDtcblxuXHQgICAgdmFyIHJldCwgaiwgdG94ID0gMiAvIE0uYWJzKHgpLCBtLCBqc3VtLCBzdW0sIGJqcCwgYmosIGJqbTtcblx0ICAgIGlmKE0uYWJzKHgpID4gbikge1xuXHQgICAgICByZXQgPSBfYmVzc2VsX2l0ZXIoeCwgbiwgYmVzc2VsMChNLmFicyh4KSksIGJlc3NlbDEoTS5hYnMoeCkpLC0xKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG09MipNLmZsb29yKChuK00uZmxvb3IoTS5zcXJ0KDQwKm4pKSkvMik7XG5cdCAgICAgIGpzdW09MDtcblx0ICAgICAgYmpwPXJldD1zdW09MC4wO1xuXHQgICAgICBiaj0xLjA7XG5cdCAgICAgIGZvciAoaj1tO2o+MDtqLS0pIHtcblx0ICAgICAgICBiam09aip0b3gqYmotYmpwO1xuXHQgICAgICAgIGJqcD1iajtcblx0ICAgICAgICBiaj1iam07XG5cdCAgICAgICAgaWYgKE0uYWJzKGJqKSA+IDFFMTApIHtcblx0ICAgICAgICAgIGJqICo9IDFFLTEwO1xuXHQgICAgICAgICAgYmpwICo9IDFFLTEwO1xuXHQgICAgICAgICAgcmV0ICo9IDFFLTEwO1xuXHQgICAgICAgICAgc3VtICo9IDFFLTEwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoanN1bSkgc3VtICs9IGJqO1xuXHQgICAgICAgIGpzdW09IWpzdW07XG5cdCAgICAgICAgaWYgKGogPT0gbikgcmV0PWJqcDtcblx0ICAgICAgfVxuXHQgICAgICBzdW09Mi4wKnN1bS1iajtcblx0ICAgICAgcmV0IC89IHN1bTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB4IDwgMCAmJiAobiUyKSA/IC1yZXQgOiByZXQ7XG5cdCAgfTtcblx0fSkoKTtcblx0dmFyIGJlc3NlbHkgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGIwX2ExYSA9IFstMjk1NzgyMTM4OS4wLCA3MDYyODM0MDY1LjAsIC01MTIzNTk4MDMuNiwgMTA4Nzk4ODEuMjksIC04NjMyNy45Mjc1NywgMjI4LjQ2MjI3MzNdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYTJhID0gWzQwMDc2NTQ0MjY5LjAsIDc0NTI0OTk2NC44LCA3MTg5NDY2LjQzOCwgNDc0NDcuMjY0NzAsIDIyNi4xMDMwMjQ0LCAxLjBdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYTFiID0gWzEuMCwgLTAuMTA5ODYyODYyN2UtMiwgMC4yNzM0NTEwNDA3ZS00LCAtMC4yMDczMzcwNjM5ZS01LCAwLjIwOTM4ODcyMTFlLTZdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYTJiID0gWy0wLjE1NjI0OTk5OTVlLTEsIDAuMTQzMDQ4ODc2NWUtMywgLTAuNjkxMTE0NzY1MWUtNSwgMC43NjIxMDk1MTYxZS02LCAtMC45MzQ5NDUxNTJlLTddLnJldmVyc2UoKTtcblxuXHQgIHZhciBXID0gMC42MzY2MTk3NzI7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMCh4KSB7XG5cdCAgICB2YXIgYSwgYTEsIGEyLCB5ID0geCAqIHgsIHh4ID0geCAtIDAuNzg1Mzk4MTY0O1xuXHQgICAgaWYoeCA8IDgpIHtcblx0ICAgICAgYTEgPSBfaG9ybmVyKGIwX2ExYSwgeSk7XG5cdCAgICAgIGEyID0gX2hvcm5lcihiMF9hMmEsIHkpO1xuXHQgICAgICBhID0gYTEvYTIgKyBXICogYmVzc2Vsaih4LDApICogTS5sb2coeCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB5ID0gNjQgLyB5O1xuXHQgICAgICBhMSA9IF9ob3JuZXIoYjBfYTFiLCB5KTtcblx0ICAgICAgYTIgPSBfaG9ybmVyKGIwX2EyYiwgeSk7XG5cdCAgICAgIGEgPSBNLnNxcnQoVy94KSooTS5zaW4oeHgpKmExK00uY29zKHh4KSphMio4L3gpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGE7XG5cdCAgfVxuXG5cdCAgdmFyIGIxX2ExYSA9IFstMC40OTAwNjA0OTQzZTEzLCAwLjEyNzUyNzQzOTBlMTMsIC0wLjUxNTM0MzgxMzllMTEsIDAuNzM0OTI2NDU1MWU5LCAtMC40MjM3OTIyNzI2ZTcsIDAuODUxMTkzNzkzNWU0XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIxX2EyYSA9IFswLjI0OTk1ODA1NzBlMTQsIDAuNDI0NDQxOTY2NGUxMiwgMC4zNzMzNjUwMzY3ZTEwLCAwLjIyNDU5MDQwMDJlOCwgMC4xMDIwNDI2MDUwZTYsIDAuMzU0OTYzMjg4NWUzLCAxXS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIxX2ExYiA9IFsxLjAsIDAuMTgzMTA1ZS0yLCAtMC4zNTE2Mzk2NDk2ZS00LCAwLjI0NTc1MjAxNzRlLTUsIC0wLjI0MDMzNzAxOWUtNl0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMV9hMmIgPSBbMC4wNDY4NzQ5OTk5NSwgLTAuMjAwMjY5MDg3M2UtMywgMC44NDQ5MTk5MDk2ZS01LCAtMC44ODIyODk4N2UtNiwgMC4xMDU3ODc0MTJlLTZdLnJldmVyc2UoKTtcblx0ICBmdW5jdGlvbiBiZXNzZWwxKHgpIHtcblx0ICAgIHZhciBhLCBhMSwgYTIsIHkgPSB4KngsIHh4ID0geCAtIDIuMzU2MTk0NDkxO1xuXHQgICAgaWYoeCA8IDgpIHtcblx0ICAgICAgYTEgPSB4Kl9ob3JuZXIoYjFfYTFhLCB5KTtcblx0ICAgICAgYTIgPSBfaG9ybmVyKGIxX2EyYSwgeSk7XG5cdCAgICAgIGEgPSBhMS9hMiArIFcgKiAoYmVzc2Vsaih4LDEpICogTS5sb2coeCkgLSAxIC8geCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB5ID0gNjQgLyB5O1xuXHQgICAgICBhMT1faG9ybmVyKGIxX2ExYiwgeSk7XG5cdCAgICAgIGEyPV9ob3JuZXIoYjFfYTJiLCB5KTtcblx0ICAgICAgYT1NLnNxcnQoVy94KSooTS5zaW4oeHgpKmExK00uY29zKHh4KSphMio4L3gpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGE7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIF9iZXNzZWxfd3JhcChiZXNzZWwwLCBiZXNzZWwxLCAnQkVTU0VMWScsIDEsIC0xKTtcblx0fSkoKTtcblx0dmFyIGJlc3NlbGkgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGIwX2EgPSBbMS4wLCAzLjUxNTYyMjksIDMuMDg5OTQyNCwgMS4yMDY3NDkyLCAwLjI2NTk3MzIsIDAuMzYwNzY4ZS0xLCAwLjQ1ODEzZS0yXS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIwX2IgPSBbMC4zOTg5NDIyOCwgMC4xMzI4NTkyZS0xLCAwLjIyNTMxOWUtMiwgLTAuMTU3NTY1ZS0yLCAwLjkxNjI4MWUtMiwgLTAuMjA1NzcwNmUtMSwgMC4yNjM1NTM3ZS0xLCAtMC4xNjQ3NjMzZS0xLCAwLjM5MjM3N2UtMl0ucmV2ZXJzZSgpO1xuXHQgIGZ1bmN0aW9uIGJlc3NlbDAoeCkge1xuXHQgICAgaWYoeCA8PSAzLjc1KSByZXR1cm4gX2hvcm5lcihiMF9hLCB4KngvKDMuNzUqMy43NSkpO1xuXHQgICAgcmV0dXJuIE0uZXhwKE0uYWJzKHgpKS9NLnNxcnQoTS5hYnMoeCkpKl9ob3JuZXIoYjBfYiwgMy43NS9NLmFicyh4KSk7XG5cdCAgfVxuXG5cdCAgdmFyIGIxX2EgPSBbMC41LCAwLjg3ODkwNTk0LCAwLjUxNDk4ODY5LCAwLjE1MDg0OTM0LCAwLjI2NTg3MzNlLTEsIDAuMzAxNTMyZS0yLCAwLjMyNDExZS0zXS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIxX2IgPSBbMC4zOTg5NDIyOCwgLTAuMzk4ODAyNGUtMSwgLTAuMzYyMDE4ZS0yLCAwLjE2MzgwMWUtMiwgLTAuMTAzMTU1NWUtMSwgMC4yMjgyOTY3ZS0xLCAtMC4yODk1MzEyZS0xLCAwLjE3ODc2NTRlLTEsIC0wLjQyMDA1OWUtMl0ucmV2ZXJzZSgpO1xuXHQgIGZ1bmN0aW9uIGJlc3NlbDEoeCkge1xuXHQgICAgaWYoeCA8IDMuNzUpIHJldHVybiB4ICogX2hvcm5lcihiMV9hLCB4KngvKDMuNzUqMy43NSkpO1xuXHQgICAgcmV0dXJuICh4IDwgMCA/IC0xIDogMSkgKiBNLmV4cChNLmFicyh4KSkvTS5zcXJ0KE0uYWJzKHgpKSpfaG9ybmVyKGIxX2IsIDMuNzUvTS5hYnMoeCkpO1xuXHQgIH1cblxuXHQgIHJldHVybiBmdW5jdGlvbiBiZXNzZWxpKHgsIG4pIHtcblx0ICAgIG4gPSBNYXRoLnJvdW5kKG4pO1xuXHQgICAgaWYobiA9PT0gMCkgcmV0dXJuIGJlc3NlbDAoeCk7XG5cdCAgICBpZihuID09IDEpIHJldHVybiBiZXNzZWwxKHgpO1xuXHQgICAgaWYobiA8IDApIHRocm93ICdCRVNTRUxJIE9yZGVyICgnICsgbiArICcpIG11c3QgYmUgbm9ubmVnYXRpdmUnO1xuXHQgICAgaWYoTS5hYnMoeCkgPT09IDApIHJldHVybiAwO1xuXG5cdCAgICB2YXIgcmV0LCBqLCB0b3ggPSAyIC8gTS5hYnMoeCksIG0sIGJpcCwgYmksIGJpbTtcblx0ICAgIG09MipNLnJvdW5kKChuK00ucm91bmQoTS5zcXJ0KDQwKm4pKSkvMik7XG5cdCAgICBiaXA9cmV0PTAuMDtcblx0ICAgIGJpPTEuMDtcblx0ICAgIGZvciAoaj1tO2o+MDtqLS0pIHtcblx0ICAgICAgYmltPWoqdG94KmJpICsgYmlwO1xuXHQgICAgICBiaXA9Ymk7IGJpPWJpbTtcblx0ICAgICAgaWYgKE0uYWJzKGJpKSA+IDFFMTApIHtcblx0ICAgICAgICBiaSAqPSAxRS0xMDtcblx0ICAgICAgICBiaXAgKj0gMUUtMTA7XG5cdCAgICAgICAgcmV0ICo9IDFFLTEwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmKGogPT0gbikgcmV0ID0gYmlwO1xuXHQgICAgfVxuXHQgICAgcmV0ICo9IGJlc3NlbGkoeCwgMCkgLyBiaTtcblx0ICAgIHJldHVybiB4IDwgMCAmJiAobiUyKSA/IC1yZXQgOiByZXQ7XG5cdCAgfTtcblxuXHR9KSgpO1xuXG5cdHZhciBiZXNzZWxrID0gKGZ1bmN0aW9uKCkge1xuXHQgIHZhciBiMF9hID0gWy0wLjU3NzIxNTY2LCAwLjQyMjc4NDIwLCAwLjIzMDY5NzU2LCAwLjM0ODg1OTBlLTEsIDAuMjYyNjk4ZS0yLCAwLjEwNzUwZS0zLCAwLjc0ZS01XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIwX2IgPSBbMS4yNTMzMTQxNCwgLTAuNzgzMjM1OGUtMSwgMC4yMTg5NTY4ZS0xLCAtMC4xMDYyNDQ2ZS0xLCAwLjU4Nzg3MmUtMiwgLTAuMjUxNTQwZS0yLCAwLjUzMjA4ZS0zXS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMCh4KSB7XG5cdCAgICBpZih4IDw9IDIpIHJldHVybiAtTS5sb2coeC8yKSpiZXNzZWxpKHgsMCkgKyBfaG9ybmVyKGIwX2EsIHgqeC80KTtcblx0ICAgIHJldHVybiBNLmV4cCgteCkvTS5zcXJ0KHgpKl9ob3JuZXIoYjBfYiwgMi94KTtcblx0ICB9XG5cblx0ICB2YXIgYjFfYSA9IFsxLjAsIDAuMTU0NDMxNDQsIC0wLjY3Mjc4NTc5LCAtMC4xODE1Njg5NywgLTAuMTkxOTQwMmUtMSwgLTAuMTEwNDA0ZS0yLCAtMC40Njg2ZS00XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIxX2IgPSBbMS4yNTMzMTQxNCwgMC4yMzQ5ODYxOSwgLTAuMzY1NTYyMGUtMSwgMC4xNTA0MjY4ZS0xLCAtMC43ODAzNTNlLTIsIDAuMzI1NjE0ZS0yLCAtMC42ODI0NWUtM10ucmV2ZXJzZSgpO1xuXHQgIGZ1bmN0aW9uIGJlc3NlbDEoeCkge1xuXHQgICAgaWYoeCA8PSAyKSByZXR1cm4gTS5sb2coeC8yKSpiZXNzZWxpKHgsMSkgKyAoMS94KSpfaG9ybmVyKGIxX2EsIHgqeC80KTtcblx0ICAgIHJldHVybiBNLmV4cCgteCkvTS5zcXJ0KHgpKl9ob3JuZXIoYjFfYiwgMi94KTtcblx0ICB9XG5cblx0ICByZXR1cm4gX2Jlc3NlbF93cmFwKGJlc3NlbDAsIGJlc3NlbDEsICdCRVNTRUxLJywgMiwgMSk7XG5cdH0pKCk7XG5cdGlmKHRydWUpIHtcblx0ICBleHBvcnRzLmJlc3NlbGogPSBiZXNzZWxqO1xuXHQgIGV4cG9ydHMuYmVzc2VseSA9IGJlc3NlbHk7XG5cdCAgZXhwb3J0cy5iZXNzZWxpID0gYmVzc2VsaTtcblx0ICBleHBvcnRzLmJlc3NlbGsgPSBiZXNzZWxrO1xuXHR9XG5cblxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblx0dmFyIGQxOTAwID0gbmV3IERhdGUoMTkwMCwgMCwgMSk7XG5cdHZhciBXRUVLX1NUQVJUUyA9IFtcblx0ICB1bmRlZmluZWQsXG5cdCAgMCxcblx0ICAxLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIDEsXG5cdCAgMixcblx0ICAzLFxuXHQgIDQsXG5cdCAgNSxcblx0ICA2LFxuXHQgIDBcblx0XTtcblx0dmFyIFdFRUtfVFlQRVMgPSBbXG5cdCAgW10sXG5cdCAgWzEsIDIsIDMsIDQsIDUsIDYsIDddLFxuXHQgIFs3LCAxLCAyLCAzLCA0LCA1LCA2XSxcblx0ICBbNiwgMCwgMSwgMiwgMywgNCwgNV0sXG5cdCAgW10sXG5cdCAgW10sXG5cdCAgW10sXG5cdCAgW10sXG5cdCAgW10sXG5cdCAgW10sXG5cdCAgW10sXG5cdCAgWzcsIDEsIDIsIDMsIDQsIDUsIDZdLFxuXHQgIFs2LCA3LCAxLCAyLCAzLCA0LCA1XSxcblx0ICBbNSwgNiwgNywgMSwgMiwgMywgNF0sXG5cdCAgWzQsIDUsIDYsIDcsIDEsIDIsIDNdLFxuXHQgIFszLCA0LCA1LCA2LCA3LCAxLCAyXSxcblx0ICBbMiwgMywgNCwgNSwgNiwgNywgMV0sXG5cdCAgWzEsIDIsIDMsIDQsIDUsIDYsIDddXG5cdF07XG5cdHZhciBXRUVLRU5EX1RZUEVTID0gW1xuXHQgIFtdLFxuXHQgIFs2LCAwXSxcblx0ICBbMCwgMV0sXG5cdCAgWzEsIDJdLFxuXHQgIFsyLCAzXSxcblx0ICBbMywgNF0sXG5cdCAgWzQsIDVdLFxuXHQgIFs1LCA2XSxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCwgWzAsIDBdLFxuXHQgIFsxLCAxXSxcblx0ICBbMiwgMl0sXG5cdCAgWzMsIDNdLFxuXHQgIFs0LCA0XSxcblx0ICBbNSwgNV0sXG5cdCAgWzYsIDZdXG5cdF07XG5cblx0ZXhwb3J0cy5EQVRFID0gZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xuXHQgIHllYXIgPSB1dGlscy5wYXJzZU51bWJlcih5ZWFyKTtcblx0ICBtb250aCA9IHV0aWxzLnBhcnNlTnVtYmVyKG1vbnRoKTtcblx0ICBkYXkgPSB1dGlscy5wYXJzZU51bWJlcihkYXkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHllYXIsIG1vbnRoLCBkYXkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmICh5ZWFyIDwgMCB8fCBtb250aCA8IDAgfHwgZGF5IDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cdCAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSk7XG5cdCAgcmV0dXJuIGRhdGU7XG5cdH07XG5cblx0ZXhwb3J0cy5EQVRFVkFMVUUgPSBmdW5jdGlvbihkYXRlX3RleHQpIHtcblx0ICBpZiAodHlwZW9mIGRhdGVfdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIGRhdGUgPSBEYXRlLnBhcnNlKGRhdGVfdGV4dCk7XG5cdCAgaWYgKGlzTmFOKGRhdGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChkYXRlIDw9IC0yMjAzODkxMjAwMDAwKSB7XG5cdCAgICByZXR1cm4gKGRhdGUgLSBkMTkwMCkgLyA4NjQwMDAwMCArIDE7XG5cdCAgfVxuXHQgIHJldHVybiAoZGF0ZSAtIGQxOTAwKSAvIDg2NDAwMDAwICsgMjtcblx0fTtcblxuXHRleHBvcnRzLkRBWSA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIpIHtcblx0ICB2YXIgZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzZXJpYWxfbnVtYmVyKTtcblx0ICBpZiAoZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZGF0ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuREFZUyA9IGZ1bmN0aW9uKGVuZF9kYXRlLCBzdGFydF9kYXRlKSB7XG5cdCAgZW5kX2RhdGUgPSB1dGlscy5wYXJzZURhdGUoZW5kX2RhdGUpO1xuXHQgIHN0YXJ0X2RhdGUgPSB1dGlscy5wYXJzZURhdGUoc3RhcnRfZGF0ZSk7XG5cdCAgaWYgKGVuZF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlbmRfZGF0ZTtcblx0ICB9XG5cdCAgaWYgKHN0YXJ0X2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHN0YXJ0X2RhdGU7XG5cdCAgfVxuXHQgIHJldHVybiBzZXJpYWwoZW5kX2RhdGUpIC0gc2VyaWFsKHN0YXJ0X2RhdGUpO1xuXHR9O1xuXG5cdGV4cG9ydHMuREFZUzM2MCA9IGZ1bmN0aW9uKHN0YXJ0X2RhdGUsIGVuZF9kYXRlLCBtZXRob2QpIHtcblx0ICBtZXRob2QgPSB1dGlscy5wYXJzZUJvb2wobWV0aG9kKTtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGVuZF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKGVuZF9kYXRlKTtcblx0ICBpZiAoc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0ICB9XG5cdCAgaWYgKGVuZF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlbmRfZGF0ZTtcblx0ICB9XG5cdCAgaWYgKG1ldGhvZCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbWV0aG9kO1xuXHQgIH1cblx0ICB2YXIgc20gPSBzdGFydF9kYXRlLmdldE1vbnRoKCk7XG5cdCAgdmFyIGVtID0gZW5kX2RhdGUuZ2V0TW9udGgoKTtcblx0ICB2YXIgc2QsIGVkO1xuXHQgIGlmIChtZXRob2QpIHtcblx0ICAgIHNkID0gc3RhcnRfZGF0ZS5nZXREYXRlKCkgPT09IDMxID8gMzAgOiBzdGFydF9kYXRlLmdldERhdGUoKTtcblx0ICAgIGVkID0gZW5kX2RhdGUuZ2V0RGF0ZSgpID09PSAzMSA/IDMwIDogZW5kX2RhdGUuZ2V0RGF0ZSgpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgc21kID0gbmV3IERhdGUoc3RhcnRfZGF0ZS5nZXRGdWxsWWVhcigpLCBzbSArIDEsIDApLmdldERhdGUoKTtcblx0ICAgIHZhciBlbWQgPSBuZXcgRGF0ZShlbmRfZGF0ZS5nZXRGdWxsWWVhcigpLCBlbSArIDEsIDApLmdldERhdGUoKTtcblx0ICAgIHNkID0gc3RhcnRfZGF0ZS5nZXREYXRlKCkgPT09IHNtZCA/IDMwIDogc3RhcnRfZGF0ZS5nZXREYXRlKCk7XG5cdCAgICBpZiAoZW5kX2RhdGUuZ2V0RGF0ZSgpID09PSBlbWQpIHtcblx0ICAgICAgaWYgKHNkIDwgMzApIHtcblx0ICAgICAgICBlbSsrO1xuXHQgICAgICAgIGVkID0gMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlZCA9IDMwO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlZCA9IGVuZF9kYXRlLmdldERhdGUoKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIDM2MCAqIChlbmRfZGF0ZS5nZXRGdWxsWWVhcigpIC0gc3RhcnRfZGF0ZS5nZXRGdWxsWWVhcigpKSArXG5cdCAgICAzMCAqIChlbSAtIHNtKSArIChlZCAtIHNkKTtcblx0fTtcblxuXHRleHBvcnRzLkVEQVRFID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgbW9udGhzKSB7XG5cdCAgc3RhcnRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzdGFydF9kYXRlKTtcblx0ICBpZiAoc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0ICB9XG5cdCAgaWYgKGlzTmFOKG1vbnRocykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgbW9udGhzID0gcGFyc2VJbnQobW9udGhzLCAxMCk7XG5cdCAgc3RhcnRfZGF0ZS5zZXRNb250aChzdGFydF9kYXRlLmdldE1vbnRoKCkgKyBtb250aHMpO1xuXHQgIHJldHVybiBzZXJpYWwoc3RhcnRfZGF0ZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5FT01PTlRIID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgbW9udGhzKSB7XG5cdCAgc3RhcnRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzdGFydF9kYXRlKTtcblx0ICBpZiAoc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0ICB9XG5cdCAgaWYgKGlzTmFOKG1vbnRocykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgbW9udGhzID0gcGFyc2VJbnQobW9udGhzLCAxMCk7XG5cdCAgcmV0dXJuIHNlcmlhbChuZXcgRGF0ZShzdGFydF9kYXRlLmdldEZ1bGxZZWFyKCksIHN0YXJ0X2RhdGUuZ2V0TW9udGgoKSArIG1vbnRocyArIDEsIDApKTtcblx0fTtcblxuXHRleHBvcnRzLkhPVVIgPSBmdW5jdGlvbihzZXJpYWxfbnVtYmVyKSB7XG5cdCAgc2VyaWFsX251bWJlciA9IHV0aWxzLnBhcnNlRGF0ZShzZXJpYWxfbnVtYmVyKTtcblx0ICBpZiAoc2VyaWFsX251bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc2VyaWFsX251bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIHNlcmlhbF9udW1iZXIuZ2V0SG91cnMoKTtcblx0fTtcblxuXHRleHBvcnRzLklOVEVSVkFMID0gZnVuY3Rpb24gKHNlY29uZCkge1xuXHQgIGlmICh0eXBlb2Ygc2Vjb25kICE9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2Vjb25kICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBzZWNvbmQgPSBwYXJzZUludChzZWNvbmQsIDEwKTtcblx0ICB9XG5cblx0ICB2YXIgeWVhciAgPSBNYXRoLmZsb29yKHNlY29uZC85NDYwODAwMDApO1xuXHQgIHNlY29uZCAgICA9IHNlY29uZCU5NDYwODAwMDA7XG5cdCAgdmFyIG1vbnRoID0gTWF0aC5mbG9vcihzZWNvbmQvMjU5MjAwMCk7XG5cdCAgc2Vjb25kICAgID0gc2Vjb25kJTI1OTIwMDA7XG5cdCAgdmFyIGRheSAgID0gTWF0aC5mbG9vcihzZWNvbmQvODY0MDApO1xuXHQgIHNlY29uZCAgICA9IHNlY29uZCU4NjQwMDtcblxuXHQgIHZhciBob3VyICA9IE1hdGguZmxvb3Ioc2Vjb25kLzM2MDApO1xuXHQgIHNlY29uZCAgICA9IHNlY29uZCUzNjAwO1xuXHQgIHZhciBtaW4gICA9IE1hdGguZmxvb3Ioc2Vjb25kLzYwKTtcblx0ICBzZWNvbmQgICAgPSBzZWNvbmQlNjA7XG5cdCAgdmFyIHNlYyAgID0gc2Vjb25kO1xuXG5cdCAgeWVhciAgPSAoeWVhciAgPiAwKSA/IHllYXIgICsgJ1knIDogJyc7XG5cdCAgbW9udGggPSAobW9udGggPiAwKSA/IG1vbnRoICsgJ00nIDogJyc7XG5cdCAgZGF5ICAgPSAoZGF5ICAgPiAwKSA/IGRheSAgICsgJ0QnIDogJyc7XG5cdCAgaG91ciAgPSAoaG91ciAgPiAwKSA/IGhvdXIgICsgJ0gnIDogJyc7XG5cdCAgbWluICAgPSAobWluICAgPiAwKSA/IG1pbiAgICsgJ00nIDogJyc7XG5cdCAgc2VjICAgPSAoc2VjICAgPiAwKSA/IHNlYyAgICsgJ1MnIDogJyc7XG5cblx0ICByZXR1cm4gJ1AnICsgeWVhciArIG1vbnRoICsgZGF5ICtcblx0ICAnVCcgKyBob3VyICsgbWluICsgc2VjO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNPV0VFS05VTSA9IGZ1bmN0aW9uKGRhdGUpIHtcblx0ICBkYXRlID0gdXRpbHMucGFyc2VEYXRlKGRhdGUpO1xuXHQgIGlmIChkYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBkYXRlO1xuXHQgIH1cblxuXHQgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCk7XG5cdCAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgNCAtIChkYXRlLmdldERheSgpIHx8IDcpKTtcblx0ICB2YXIgeWVhclN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcblx0ICByZXR1cm4gTWF0aC5jZWlsKCgoKGRhdGUgLSB5ZWFyU3RhcnQpIC8gODY0MDAwMDApICsgMSkgLyA3KTtcblx0fTtcblxuXHRleHBvcnRzLk1JTlVURSA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gc2VyaWFsX251bWJlci5nZXRNaW51dGVzKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5NT05USCA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gc2VyaWFsX251bWJlci5nZXRNb250aCgpICsgMTtcblx0fTtcblxuXHRleHBvcnRzLk5FVFdPUktEQVlTID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZW5kX2RhdGUsIGhvbGlkYXlzKSB7XG5cdCAgcmV0dXJuIHRoaXMuTkVUV09SS0RBWVMuSU5UTChzdGFydF9kYXRlLCBlbmRfZGF0ZSwgMSwgaG9saWRheXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTkVUV09SS0RBWVMuSU5UTCA9IGZ1bmN0aW9uKHN0YXJ0X2RhdGUsIGVuZF9kYXRlLCB3ZWVrZW5kLCBob2xpZGF5cykge1xuXHQgIHN0YXJ0X2RhdGUgPSB1dGlscy5wYXJzZURhdGUoc3RhcnRfZGF0ZSk7XG5cdCAgaWYgKHN0YXJ0X2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHN0YXJ0X2RhdGU7XG5cdCAgfVxuXHQgIGVuZF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKGVuZF9kYXRlKTtcblx0ICBpZiAoZW5kX2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVuZF9kYXRlO1xuXHQgIH1cblx0ICBpZiAod2Vla2VuZCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB3ZWVrZW5kID0gV0VFS0VORF9UWVBFU1sxXTtcblx0ICB9IGVsc2Uge1xuXHQgICAgd2Vla2VuZCA9IFdFRUtFTkRfVFlQRVNbd2Vla2VuZF07XG5cdCAgfVxuXHQgIGlmICghKHdlZWtlbmQgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGhvbGlkYXlzID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGhvbGlkYXlzID0gW107XG5cdCAgfSBlbHNlIGlmICghKGhvbGlkYXlzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICBob2xpZGF5cyA9IFtob2xpZGF5c107XG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9saWRheXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBoID0gdXRpbHMucGFyc2VEYXRlKGhvbGlkYXlzW2ldKTtcblx0ICAgIGlmIChoIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIGg7XG5cdCAgICB9XG5cdCAgICBob2xpZGF5c1tpXSA9IGg7XG5cdCAgfVxuXHQgIHZhciBkYXlzID0gKGVuZF9kYXRlIC0gc3RhcnRfZGF0ZSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkgKyAxO1xuXHQgIHZhciB0b3RhbCA9IGRheXM7XG5cdCAgdmFyIGRheSA9IHN0YXJ0X2RhdGU7XG5cdCAgZm9yIChpID0gMDsgaSA8IGRheXM7IGkrKykge1xuXHQgICAgdmFyIGQgPSAobmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpID4gMCkgPyBkYXkuZ2V0VVRDRGF5KCkgOiBkYXkuZ2V0RGF5KCk7XG5cdCAgICB2YXIgZGVjID0gZmFsc2U7XG5cdCAgICBpZiAoZCA9PT0gd2Vla2VuZFswXSB8fCBkID09PSB3ZWVrZW5kWzFdKSB7XG5cdCAgICAgIGRlYyA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhvbGlkYXlzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgIHZhciBob2xpZGF5ID0gaG9saWRheXNbal07XG5cdCAgICAgIGlmIChob2xpZGF5LmdldERhdGUoKSA9PT0gZGF5LmdldERhdGUoKSAmJlxuXHQgICAgICAgIGhvbGlkYXkuZ2V0TW9udGgoKSA9PT0gZGF5LmdldE1vbnRoKCkgJiZcblx0ICAgICAgICBob2xpZGF5LmdldEZ1bGxZZWFyKCkgPT09IGRheS5nZXRGdWxsWWVhcigpKSB7XG5cdCAgICAgICAgZGVjID0gdHJ1ZTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGRlYykge1xuXHQgICAgICB0b3RhbC0tO1xuXHQgICAgfVxuXHQgICAgZGF5LnNldERhdGUoZGF5LmdldERhdGUoKSArIDEpO1xuXHQgIH1cblx0ICByZXR1cm4gdG90YWw7XG5cdH07XG5cblx0ZXhwb3J0cy5OT1cgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gbmV3IERhdGUoKTtcblx0fTtcblxuXHRleHBvcnRzLlNFQ09ORCA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gc2VyaWFsX251bWJlci5nZXRTZWNvbmRzKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5USU1FID0gZnVuY3Rpb24oaG91ciwgbWludXRlLCBzZWNvbmQpIHtcblx0ICBob3VyID0gdXRpbHMucGFyc2VOdW1iZXIoaG91cik7XG5cdCAgbWludXRlID0gdXRpbHMucGFyc2VOdW1iZXIobWludXRlKTtcblx0ICBzZWNvbmQgPSB1dGlscy5wYXJzZU51bWJlcihzZWNvbmQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaG91ciA8IDAgfHwgbWludXRlIDwgMCB8fCBzZWNvbmQgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0ICByZXR1cm4gKDM2MDAgKiBob3VyICsgNjAgKiBtaW51dGUgKyBzZWNvbmQpIC8gODY0MDA7XG5cdH07XG5cblx0ZXhwb3J0cy5USU1FVkFMVUUgPSBmdW5jdGlvbih0aW1lX3RleHQpIHtcblx0ICB0aW1lX3RleHQgPSB1dGlscy5wYXJzZURhdGUodGltZV90ZXh0KTtcblx0ICBpZiAodGltZV90ZXh0IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiB0aW1lX3RleHQ7XG5cdCAgfVxuXHQgIHJldHVybiAoMzYwMCAqIHRpbWVfdGV4dC5nZXRIb3VycygpICtcblx0ICAgIDYwICogdGltZV90ZXh0LmdldE1pbnV0ZXMoKSArXG5cdCAgICB0aW1lX3RleHQuZ2V0U2Vjb25kcygpKSAvIDg2NDAwO1xuXHR9O1xuXG5cdGV4cG9ydHMuVE9EQVkgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gbmV3IERhdGUoKTtcblx0fTtcblxuXHRleHBvcnRzLldFRUtEQVkgPSBmdW5jdGlvbihzZXJpYWxfbnVtYmVyLCByZXR1cm5fdHlwZSkge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIGlmIChyZXR1cm5fdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm5fdHlwZSA9IDE7XG5cdCAgfVxuXHQgIHZhciBkYXkgPSBzZXJpYWxfbnVtYmVyLmdldERheSgpO1xuXHQgIHJldHVybiBXRUVLX1RZUEVTW3JldHVybl90eXBlXVtkYXldO1xuXHR9O1xuXG5cdGV4cG9ydHMuV0VFS05VTSA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIsIHJldHVybl90eXBlKSB7XG5cdCAgc2VyaWFsX251bWJlciA9IHV0aWxzLnBhcnNlRGF0ZShzZXJpYWxfbnVtYmVyKTtcblx0ICBpZiAoc2VyaWFsX251bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc2VyaWFsX251bWJlcjtcblx0ICB9XG5cdCAgaWYgKHJldHVybl90eXBlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybl90eXBlID0gMTtcblx0ICB9XG5cdCAgaWYgKHJldHVybl90eXBlID09PSAyMSkge1xuXHQgICAgcmV0dXJuIHRoaXMuSVNPV0VFS05VTShzZXJpYWxfbnVtYmVyKTtcblx0ICB9XG5cdCAgdmFyIHdlZWtfc3RhcnQgPSBXRUVLX1NUQVJUU1tyZXR1cm5fdHlwZV07XG5cdCAgdmFyIGphbiA9IG5ldyBEYXRlKHNlcmlhbF9udW1iZXIuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG5cdCAgdmFyIGluYyA9IGphbi5nZXREYXkoKSA8IHdlZWtfc3RhcnQgPyAxIDogMDtcblx0ICBqYW4gLT0gTWF0aC5hYnMoamFuLmdldERheSgpIC0gd2Vla19zdGFydCkgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuXHQgIHJldHVybiBNYXRoLmZsb29yKCgoc2VyaWFsX251bWJlciAtIGphbikgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpIC8gNyArIDEpICsgaW5jO1xuXHR9O1xuXG5cdGV4cG9ydHMuV09SS0RBWSA9IGZ1bmN0aW9uKHN0YXJ0X2RhdGUsIGRheXMsIGhvbGlkYXlzKSB7XG5cdCAgcmV0dXJuIHRoaXMuV09SS0RBWS5JTlRMKHN0YXJ0X2RhdGUsIGRheXMsIDEsIGhvbGlkYXlzKTtcblx0fTtcblxuXHRleHBvcnRzLldPUktEQVkuSU5UTCA9IGZ1bmN0aW9uKHN0YXJ0X2RhdGUsIGRheXMsIHdlZWtlbmQsIGhvbGlkYXlzKSB7XG5cdCAgc3RhcnRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzdGFydF9kYXRlKTtcblx0ICBpZiAoc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0ICB9XG5cdCAgZGF5cyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRheXMpO1xuXHQgIGlmIChkYXlzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBkYXlzO1xuXHQgIH1cblx0ICBpZiAoZGF5cyA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHQgIGlmICh3ZWVrZW5kID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHdlZWtlbmQgPSBXRUVLRU5EX1RZUEVTWzFdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB3ZWVrZW5kID0gV0VFS0VORF9UWVBFU1t3ZWVrZW5kXTtcblx0ICB9XG5cdCAgaWYgKCEod2Vla2VuZCBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaG9saWRheXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgaG9saWRheXMgPSBbXTtcblx0ICB9IGVsc2UgaWYgKCEoaG9saWRheXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIGhvbGlkYXlzID0gW2hvbGlkYXlzXTtcblx0ICB9XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBob2xpZGF5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGggPSB1dGlscy5wYXJzZURhdGUoaG9saWRheXNbaV0pO1xuXHQgICAgaWYgKGggaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gaDtcblx0ICAgIH1cblx0ICAgIGhvbGlkYXlzW2ldID0gaDtcblx0ICB9XG5cdCAgdmFyIGQgPSAwO1xuXHQgIHdoaWxlIChkIDwgZGF5cykge1xuXHQgICAgc3RhcnRfZGF0ZS5zZXREYXRlKHN0YXJ0X2RhdGUuZ2V0RGF0ZSgpICsgMSk7XG5cdCAgICB2YXIgZGF5ID0gc3RhcnRfZGF0ZS5nZXREYXkoKTtcblx0ICAgIGlmIChkYXkgPT09IHdlZWtlbmRbMF0gfHwgZGF5ID09PSB3ZWVrZW5kWzFdKSB7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBob2xpZGF5cy5sZW5ndGg7IGorKykge1xuXHQgICAgICB2YXIgaG9saWRheSA9IGhvbGlkYXlzW2pdO1xuXHQgICAgICBpZiAoaG9saWRheS5nZXREYXRlKCkgPT09IHN0YXJ0X2RhdGUuZ2V0RGF0ZSgpICYmXG5cdCAgICAgICAgaG9saWRheS5nZXRNb250aCgpID09PSBzdGFydF9kYXRlLmdldE1vbnRoKCkgJiZcblx0ICAgICAgICBob2xpZGF5LmdldEZ1bGxZZWFyKCkgPT09IHN0YXJ0X2RhdGUuZ2V0RnVsbFllYXIoKSkge1xuXHQgICAgICAgIGQtLTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgZCsrO1xuXHQgIH1cblx0ICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0fTtcblxuXHRleHBvcnRzLllFQVIgPSBmdW5jdGlvbihzZXJpYWxfbnVtYmVyKSB7XG5cdCAgc2VyaWFsX251bWJlciA9IHV0aWxzLnBhcnNlRGF0ZShzZXJpYWxfbnVtYmVyKTtcblx0ICBpZiAoc2VyaWFsX251bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc2VyaWFsX251bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIHNlcmlhbF9udW1iZXIuZ2V0RnVsbFllYXIoKTtcblx0fTtcblxuXHRmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcblx0ICByZXR1cm4gbmV3IERhdGUoeWVhciwgMSwgMjkpLmdldE1vbnRoKCkgPT09IDE7XG5cdH1cblxuXHQvLyBUT0RPIDogVXNlIERBWVMgP1xuXHRmdW5jdGlvbiBkYXlzQmV0d2VlbihzdGFydF9kYXRlLCBlbmRfZGF0ZSkge1xuXHQgIHJldHVybiBNYXRoLmNlaWwoKGVuZF9kYXRlIC0gc3RhcnRfZGF0ZSkgLyAxMDAwIC8gNjAgLyA2MCAvIDI0KTtcblx0fVxuXG5cdGV4cG9ydHMuWUVBUkZSQUMgPSBmdW5jdGlvbihzdGFydF9kYXRlLCBlbmRfZGF0ZSwgYmFzaXMpIHtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBlbmRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShlbmRfZGF0ZSk7XG5cdCAgaWYgKGVuZF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlbmRfZGF0ZTtcblx0ICB9XG5cblx0ICBiYXNpcyA9IGJhc2lzIHx8IDA7XG5cdCAgdmFyIHNkID0gc3RhcnRfZGF0ZS5nZXREYXRlKCk7XG5cdCAgdmFyIHNtID0gc3RhcnRfZGF0ZS5nZXRNb250aCgpICsgMTtcblx0ICB2YXIgc3kgPSBzdGFydF9kYXRlLmdldEZ1bGxZZWFyKCk7XG5cdCAgdmFyIGVkID0gZW5kX2RhdGUuZ2V0RGF0ZSgpO1xuXHQgIHZhciBlbSA9IGVuZF9kYXRlLmdldE1vbnRoKCkgKyAxO1xuXHQgIHZhciBleSA9IGVuZF9kYXRlLmdldEZ1bGxZZWFyKCk7XG5cblx0ICBzd2l0Y2ggKGJhc2lzKSB7XG5cdCAgICBjYXNlIDA6XG5cdCAgICAgIC8vIFVTIChOQVNEKSAzMC8zNjBcblx0ICAgICAgaWYgKHNkID09PSAzMSAmJiBlZCA9PT0gMzEpIHtcblx0ICAgICAgICBzZCA9IDMwO1xuXHQgICAgICAgIGVkID0gMzA7XG5cdCAgICAgIH0gZWxzZSBpZiAoc2QgPT09IDMxKSB7XG5cdCAgICAgICAgc2QgPSAzMDtcblx0ICAgICAgfSBlbHNlIGlmIChzZCA9PT0gMzAgJiYgZWQgPT09IDMxKSB7XG5cdCAgICAgICAgZWQgPSAzMDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gKChlZCArIGVtICogMzAgKyBleSAqIDM2MCkgLSAoc2QgKyBzbSAqIDMwICsgc3kgKiAzNjApKSAvIDM2MDtcblx0ICAgIGNhc2UgMTpcblx0ICAgICAgLy8gQWN0dWFsL2FjdHVhbFxuXHQgICAgICB2YXIgZmViMjlCZXR3ZWVuID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XG5cdCAgICAgICAgdmFyIHllYXIxID0gZGF0ZTEuZ2V0RnVsbFllYXIoKTtcblx0ICAgICAgICB2YXIgbWFyMXllYXIxID0gbmV3IERhdGUoeWVhcjEsIDIsIDEpO1xuXHQgICAgICAgIGlmIChpc0xlYXBZZWFyKHllYXIxKSAmJiBkYXRlMSA8IG1hcjF5ZWFyMSAmJiBkYXRlMiA+PSBtYXIxeWVhcjEpIHtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgeWVhcjIgPSBkYXRlMi5nZXRGdWxsWWVhcigpO1xuXHQgICAgICAgIHZhciBtYXIxeWVhcjIgPSBuZXcgRGF0ZSh5ZWFyMiwgMiwgMSk7XG5cdCAgICAgICAgcmV0dXJuIChpc0xlYXBZZWFyKHllYXIyKSAmJiBkYXRlMiA+PSBtYXIxeWVhcjIgJiYgZGF0ZTEgPCBtYXIxeWVhcjIpO1xuXHQgICAgICB9O1xuXHQgICAgICB2YXIgeWxlbmd0aCA9IDM2NTtcblx0ICAgICAgaWYgKHN5ID09PSBleSB8fCAoKHN5ICsgMSkgPT09IGV5KSAmJiAoKHNtID4gZW0pIHx8ICgoc20gPT09IGVtKSAmJiAoc2QgPj0gZWQpKSkpIHtcblx0ICAgICAgICBpZiAoKHN5ID09PSBleSAmJiBpc0xlYXBZZWFyKHN5KSkgfHxcblx0ICAgICAgICAgICAgZmViMjlCZXR3ZWVuKHN0YXJ0X2RhdGUsIGVuZF9kYXRlKSB8fFxuXHQgICAgICAgICAgICAoZW0gPT09IDEgJiYgZWQgPT09IDI5KSkge1xuXHQgICAgICAgICAgeWxlbmd0aCA9IDM2Njtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGRheXNCZXR3ZWVuKHN0YXJ0X2RhdGUsIGVuZF9kYXRlKSAvIHlsZW5ndGg7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHllYXJzID0gKGV5IC0gc3kpICsgMTtcblx0ICAgICAgdmFyIGRheXMgPSAobmV3IERhdGUoZXkgKyAxLCAwLCAxKSAtIG5ldyBEYXRlKHN5LCAwLCAxKSkgLyAxMDAwIC8gNjAgLyA2MCAvIDI0O1xuXHQgICAgICB2YXIgYXZlcmFnZSA9IGRheXMgLyB5ZWFycztcblx0ICAgICAgcmV0dXJuIGRheXNCZXR3ZWVuKHN0YXJ0X2RhdGUsIGVuZF9kYXRlKSAvIGF2ZXJhZ2U7XG5cdCAgICBjYXNlIDI6XG5cdCAgICAgIC8vIEFjdHVhbC8zNjBcblx0ICAgICAgcmV0dXJuIGRheXNCZXR3ZWVuKHN0YXJ0X2RhdGUsIGVuZF9kYXRlKSAvIDM2MDtcblx0ICAgIGNhc2UgMzpcblx0ICAgICAgLy8gQWN0dWFsLzM2NVxuXHQgICAgICByZXR1cm4gZGF5c0JldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIC8gMzY1O1xuXHQgICAgY2FzZSA0OlxuXHQgICAgICAvLyBFdXJvcGVhbiAzMC8zNjBcblx0ICAgICAgcmV0dXJuICgoZWQgKyBlbSAqIDMwICsgZXkgKiAzNjApIC0gKHNkICsgc20gKiAzMCArIHN5ICogMzYwKSkgLyAzNjA7XG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNlcmlhbChkYXRlKSB7XG5cdCAgdmFyIGFkZE9uID0gKGRhdGUgPiAtMjIwMzg5MTIwMDAwMCk/MjoxO1xuXHQgIHJldHVybiAoZGF0ZSAtIGQxOTAwKSAvIDg2NDAwMDAwICsgYWRkT247XG5cdH1cblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgc3RhdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgbWF0aHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcblx0ICBpZiAoIWFycmF5KSB7IHJldHVybiBhcnJheTsgfVxuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG5cdCAgICBpZiAoIWFycmF5W2ldKSB7IGNvbnRpbnVlOyB9XG5cdCAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRleHBvcnRzLkZJTkRGSUVMRCA9IGZ1bmN0aW9uKGRhdGFiYXNlLCB0aXRsZSkge1xuXHQgIHZhciBpbmRleCA9IG51bGw7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhYmFzZS5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKGRhdGFiYXNlW2ldWzBdID09PSB0aXRsZSkge1xuXHQgICAgICBpbmRleCA9IGk7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB0aGUgaW5wdXQgZmllbGQgdGl0bGUgaXMgaW5jb3JyZWN0XG5cdCAgaWYgKGluZGV4ID09IG51bGwpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGluZGV4O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWFzKSB7XG5cdCAgdmFyIG1hdGNoZXMgPSB7fTtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGRhdGFiYXNlWzBdLmxlbmd0aDsgKytpKSB7XG5cdCAgICBtYXRjaGVzW2ldID0gdHJ1ZTtcblx0ICB9XG5cdCAgdmFyIG1heENyaXRlcmlhTGVuZ3RoID0gY3JpdGVyaWFzWzBdLmxlbmd0aDtcblx0ICBmb3IgKGkgPSAxOyBpIDwgY3JpdGVyaWFzLmxlbmd0aDsgKytpKSB7XG5cdCAgICBpZiAoY3JpdGVyaWFzW2ldLmxlbmd0aCA+IG1heENyaXRlcmlhTGVuZ3RoKSB7XG5cdCAgICAgIG1heENyaXRlcmlhTGVuZ3RoID0gY3JpdGVyaWFzW2ldLmxlbmd0aDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmb3IgKHZhciBrID0gMTsgayA8IGRhdGFiYXNlLmxlbmd0aDsgKytrKSB7XG5cdCAgICBmb3IgKHZhciBsID0gMTsgbCA8IGRhdGFiYXNlW2tdLmxlbmd0aDsgKytsKSB7XG5cdCAgICAgIHZhciBjdXJyZW50Q3JpdGVyaWFSZXN1bHQgPSBmYWxzZTtcblx0ICAgICAgdmFyIGhhc01hdGNoaW5nQ3JpdGVyaWEgICA9IGZhbHNlO1xuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNyaXRlcmlhcy5sZW5ndGg7ICsraikge1xuXHQgICAgICAgIHZhciBjcml0ZXJpYSA9IGNyaXRlcmlhc1tqXTtcblx0ICAgICAgICBpZiAoY3JpdGVyaWEubGVuZ3RoIDwgbWF4Q3JpdGVyaWFMZW5ndGgpIHtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBjcml0ZXJpYUZpZWxkID0gY3JpdGVyaWFbMF07XG5cdCAgICAgICAgaWYgKGRhdGFiYXNlW2tdWzBdICE9PSBjcml0ZXJpYUZpZWxkKSB7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaGFzTWF0Y2hpbmdDcml0ZXJpYSA9IHRydWU7XG5cdCAgICAgICAgZm9yICh2YXIgcCA9IDE7IHAgPCBjcml0ZXJpYS5sZW5ndGg7ICsrcCkge1xuXHQgICAgICAgICAgY3VycmVudENyaXRlcmlhUmVzdWx0ID0gY3VycmVudENyaXRlcmlhUmVzdWx0IHx8IGV2YWwoZGF0YWJhc2Vba11bbF0gKyBjcml0ZXJpYVtwXSk7ICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGhhc01hdGNoaW5nQ3JpdGVyaWEpIHtcblx0ICAgICAgICBtYXRjaGVzW2xdID0gbWF0Y2hlc1tsXSAmJiBjdXJyZW50Q3JpdGVyaWFSZXN1bHQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgZm9yICh2YXIgbiA9IDA7IG4gPCBkYXRhYmFzZVswXS5sZW5ndGg7ICsrbikge1xuXHQgICAgaWYgKG1hdGNoZXNbbl0pIHtcblx0ICAgICAgcmVzdWx0LnB1c2gobiAtIDEpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0Ly8gRGF0YWJhc2UgZnVuY3Rpb25zXG5cdGV4cG9ydHMuREFWRVJBR0UgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciBzdW0gPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgc3VtICs9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdEluZGV4ZXMubGVuZ3RoID09PSAwID8gZXJyb3IuZGl2MCA6IHN1bSAvIHJlc3VsdEluZGV4ZXMubGVuZ3RoO1xuXHR9O1xuXG5cdGV4cG9ydHMuRENPVU5UID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHJldHVybiBzdGF0cy5DT1VOVCh0YXJnZXRWYWx1ZXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRENPVU5UQSA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHRhcmdldFZhbHVlcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdGFyZ2V0VmFsdWVzW2ldID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICByZXR1cm4gc3RhdHMuQ09VTlRBKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblx0ZXhwb3J0cy5ER0VUID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbm8gcmVjb3JkIG1lZXRzIHRoZSBjcml0ZXJpYVxuXHQgIGlmIChyZXN1bHRJbmRleGVzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICAvLyBSZXR1cm5zIHRoZSAjTlVNISBlcnJvciB2YWx1ZSBiZWNhdXNlIG1vcmUgdGhhbiBvbmUgcmVjb3JkIG1lZXRzIHRoZVxuXHQgIC8vIGNyaXRlcmlhXG5cdCAgaWYgKHJlc3VsdEluZGV4ZXMubGVuZ3RoID4gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbMF1dO1xuXHR9O1xuXG5cdGV4cG9ydHMuRE1BWCA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIG1heFZhbHVlID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbMF1dO1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKG1heFZhbHVlIDwgdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dKSB7XG5cdCAgICAgIG1heFZhbHVlID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gbWF4VmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5ETUlOID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgbWluVmFsdWUgPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1swXV07XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAobWluVmFsdWUgPiB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV0pIHtcblx0ICAgICAgbWluVmFsdWUgPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBtaW5WYWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLkRQUk9EVUNUID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHRhcmdldFZhbHVlcyA9IGNvbXBhY3QodGFyZ2V0VmFsdWVzKTtcblx0ICB2YXIgcmVzdWx0ID0gMTtcblx0ICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKj0gdGFyZ2V0VmFsdWVzW2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuRFNUREVWID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHRhcmdldFZhbHVlcyA9IGNvbXBhY3QodGFyZ2V0VmFsdWVzKTtcblx0ICByZXR1cm4gc3RhdHMuU1RERVYuUyh0YXJnZXRWYWx1ZXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRFNUREVWUCA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHRhcmdldFZhbHVlcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdGFyZ2V0VmFsdWVzW2ldID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICB0YXJnZXRWYWx1ZXMgPSBjb21wYWN0KHRhcmdldFZhbHVlcyk7XG5cdCAgcmV0dXJuIHN0YXRzLlNUREVWLlAodGFyZ2V0VmFsdWVzKTtcblx0fTtcblxuXHRleHBvcnRzLkRTVU0gPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgcmV0dXJuIG1hdGhzLlNVTSh0YXJnZXRWYWx1ZXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRFZBUiA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHRhcmdldFZhbHVlcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdGFyZ2V0VmFsdWVzW2ldID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICByZXR1cm4gc3RhdHMuVkFSLlModGFyZ2V0VmFsdWVzKTtcblx0fTtcblxuXHRleHBvcnRzLkRWQVJQID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHJldHVybiBzdGF0cy5WQVIuUCh0YXJnZXRWYWx1ZXMpO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIGluZm9ybWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblx0ZXhwb3J0cy5BTkQgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICB2YXIgcmVzdWx0ID0gdHJ1ZTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmICghYXJnc1tpXSkge1xuXHQgICAgICByZXN1bHQgPSBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkNIT09TRSA9IGZ1bmN0aW9uKCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIHZhciBpbmRleCA9IGFyZ3VtZW50c1swXTtcblx0ICBpZiAoaW5kZXggPCAxIHx8IGluZGV4ID4gMjU0KSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCBpbmRleCArIDEpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gYXJndW1lbnRzW2luZGV4XTtcblx0fTtcblxuXHRleHBvcnRzLkZBTFNFID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdGV4cG9ydHMuSUYgPSBmdW5jdGlvbih0ZXN0LCB0aGVuX3ZhbHVlLCBvdGhlcndpc2VfdmFsdWUpIHtcblx0ICByZXR1cm4gdGVzdCA/IHRoZW5fdmFsdWUgOiBvdGhlcndpc2VfdmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5JRkVSUk9SID0gZnVuY3Rpb24odmFsdWUsIHZhbHVlSWZFcnJvcikge1xuXHQgIGlmIChpbmZvcm1hdGlvbi5JU0VSUk9SKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHZhbHVlSWZFcnJvcjtcblx0ICB9XG5cdCAgcmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMuSUZOQSA9IGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZV9pZl9uYSkge1xuXHQgIHJldHVybiB2YWx1ZSA9PT0gZXJyb3IubmEgPyB2YWx1ZV9pZl9uYSA6IHZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9UID0gZnVuY3Rpb24obG9naWNhbCkge1xuXHQgIHJldHVybiAhbG9naWNhbDtcblx0fTtcblxuXHRleHBvcnRzLk9SID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKGFyZ3NbaV0pIHtcblx0ICAgICAgcmVzdWx0ID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlRSVUUgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRleHBvcnRzLlhPUiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKGFyZ3NbaV0pIHtcblx0ICAgICAgcmVzdWx0Kys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiAoTWF0aC5mbG9vcihNYXRoLmFicyhyZXN1bHQpKSAmIDEpID8gdHJ1ZSA6IGZhbHNlO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1dJVENIID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciByZXN1bHQ7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSAge1xuXHQgICAgdmFyIHRhcmdldFZhbHVlID0gYXJndW1lbnRzWzBdO1xuXHQgICAgdmFyIGFyZ2MgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblx0ICAgIHZhciBzd2l0Y2hDb3VudCA9IE1hdGguZmxvb3IoYXJnYyAvIDIpO1xuXHQgICAgdmFyIHN3aXRjaFNhdGlzZmllZCA9IGZhbHNlO1xuXHQgICAgdmFyIGRlZmF1bHRDbGF1c2UgPSBhcmdjICUgMiA9PT0gMCA/IG51bGwgOiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXG5cdCAgICBpZiAoc3dpdGNoQ291bnQpIHtcblx0ICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN3aXRjaENvdW50OyBpbmRleCsrKSB7XG5cdCAgICAgICAgaWYgKHRhcmdldFZhbHVlID09PSBhcmd1bWVudHNbaW5kZXggKiAyICsgMV0pIHtcblx0ICAgICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1tpbmRleCAqIDIgKyAyXTtcblx0ICAgICAgICAgIHN3aXRjaFNhdGlzZmllZCA9IHRydWU7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKCFzd2l0Y2hTYXRpc2ZpZWQgJiYgZGVmYXVsdENsYXVzZSkge1xuXHQgICAgICByZXN1bHQgPSBkZWZhdWx0Q2xhdXNlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgZGF0ZVRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXHRmdW5jdGlvbiB2YWxpZERhdGUoZCkge1xuXHQgIHJldHVybiBkICYmIGQuZ2V0VGltZSAmJiAhaXNOYU4oZC5nZXRUaW1lKCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5zdXJlRGF0ZShkKSB7XG5cdCAgcmV0dXJuIChkIGluc3RhbmNlb2YgRGF0ZSk/ZDpuZXcgRGF0ZShkKTtcblx0fVxuXG5cdGV4cG9ydHMuQUNDUklOVCA9IGZ1bmN0aW9uKGlzc3VlLCBmaXJzdCwgc2V0dGxlbWVudCwgcmF0ZSwgcGFyLCBmcmVxdWVuY3ksIGJhc2lzKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBkYXRlIGlzIGludmFsaWRcblx0ICBpc3N1ZSAgICAgID0gZW5zdXJlRGF0ZShpc3N1ZSk7XG5cdCAgZmlyc3QgICAgICA9IGVuc3VyZURhdGUoZmlyc3QpO1xuXHQgIHNldHRsZW1lbnQgPSBlbnN1cmVEYXRlKHNldHRsZW1lbnQpO1xuXHQgIGlmICghdmFsaWREYXRlKGlzc3VlKSB8fCAhdmFsaWREYXRlKGZpcnN0KSB8fCAhdmFsaWREYXRlKHNldHRsZW1lbnQpKSB7XG5cdCAgICByZXR1cm4gJyNWQUxVRSEnO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgcmF0ZSBvciBwYXIgYXJlIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gemVyb1xuXHQgIGlmIChyYXRlIDw9IDAgfHwgcGFyIDw9IDApIHtcblx0ICAgIHJldHVybiAnI05VTSEnO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmcmVxdWVuY3kgaXMgbmVpdGhlciAxLCAyLCBvciA0XG5cdCAgaWYgKFsxLCAyLCA0XS5pbmRleE9mKGZyZXF1ZW5jeSkgPT09IC0xKSB7XG5cdCAgICByZXR1cm4gJyNOVU0hJztcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgYmFzaXMgaXMgbmVpdGhlciAwLCAxLCAyLCAzLCBvciA0XG5cdCAgaWYgKFswLCAxLCAyLCAzLCA0XS5pbmRleE9mKGJhc2lzKSA9PT0gLTEpIHtcblx0ICAgIHJldHVybiAnI05VTSEnO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBzZXR0bGVtZW50IGlzIGJlZm9yZSBvciBlcXVhbCB0byBpc3N1ZVxuXHQgIGlmIChzZXR0bGVtZW50IDw9IGlzc3VlKSB7XG5cdCAgICByZXR1cm4gJyNOVU0hJztcblx0ICB9XG5cblx0ICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXNcblx0ICBwYXIgICA9IHBhciAgIHx8IDA7XG5cdCAgYmFzaXMgPSBiYXNpcyB8fCAwO1xuXG5cdCAgLy8gQ29tcHV0ZSBhY2NydWVkIGludGVyZXN0XG5cdCAgcmV0dXJuIHBhciAqIHJhdGUgKiBkYXRlVGltZS5ZRUFSRlJBQyhpc3N1ZSwgc2V0dGxlbWVudCwgYmFzaXMpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5BQ0NSSU5UTSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdBQ0NSSU5UTSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQU1PUkRFR1JDID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0FNT1JERUdSQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQU1PUkxJTkMgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQU1PUkxJTkMgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNPVVBEQVlCUyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdDT1VQREFZQlMgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNPVVBEQVlTID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0NPVVBEQVlTIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5DT1VQREFZU05DID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0NPVVBEQVlTTkMgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNPVVBOQ0QgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ09VUE5DRCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ09VUE5VTSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdDT1VQTlVNIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5DT1VQUENEID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0NPVVBQQ0QgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5DVU1JUE1UID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcywgdmFsdWUsIHN0YXJ0LCBlbmQsIHR5cGUpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2Vcblx0ICAvLyBDcmVkaXRzOiBIYW5uZXMgU3RpZWJpdHpob2ZlciBmb3IgdGhlIHRyYW5zbGF0aW9ucyBvZiBmdW5jdGlvbiBhbmQgdmFyaWFibGUgbmFtZXNcblx0ICAvLyBSZXF1aXJlcyBleHBvcnRzLkZWKCkgYW5kIGV4cG9ydHMuUE1UKCkgZnJvbSBleHBvcnRzLmpzIFtodHRwOi8vc3RvaWMuY29tL2V4cG9ydHMvXVxuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICB2YWx1ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHZhbHVlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2RzLCB2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIHJhdGUsIHBlcmlvZHMsIG9yIHZhbHVlIGFyZSBsb3dlciB0aGFuIG9yIGVxdWFsIHRvIHplcm9cblx0ICBpZiAocmF0ZSA8PSAwIHx8IHBlcmlvZHMgPD0gMCB8fCB2YWx1ZSA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBzdGFydCA8IDEsIGVuZCA8IDEsIG9yIHN0YXJ0ID4gZW5kXG5cdCAgaWYgKHN0YXJ0IDwgMSB8fCBlbmQgPCAxIHx8IHN0YXJ0ID4gZW5kKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB0eXBlIGlzIG5laXRoZXIgMCBub3IgMVxuXHQgIGlmICh0eXBlICE9PSAwICYmIHR5cGUgIT09IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ29tcHV0ZSBjdW11bGF0aXZlIGludGVyZXN0XG5cdCAgdmFyIHBheW1lbnQgPSBleHBvcnRzLlBNVChyYXRlLCBwZXJpb2RzLCB2YWx1ZSwgMCwgdHlwZSk7XG5cdCAgdmFyIGludGVyZXN0ID0gMDtcblxuXHQgIGlmIChzdGFydCA9PT0gMSkge1xuXHQgICAgaWYgKHR5cGUgPT09IDApIHtcblx0ICAgICAgaW50ZXJlc3QgPSAtdmFsdWU7XG5cdCAgICAgIHN0YXJ0Kys7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG5cdCAgICBpZiAodHlwZSA9PT0gMSkge1xuXHQgICAgICBpbnRlcmVzdCArPSBleHBvcnRzLkZWKHJhdGUsIGkgLSAyLCBwYXltZW50LCB2YWx1ZSwgMSkgLSBwYXltZW50O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaW50ZXJlc3QgKz0gZXhwb3J0cy5GVihyYXRlLCBpIC0gMSwgcGF5bWVudCwgdmFsdWUsIDApO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpbnRlcmVzdCAqPSByYXRlO1xuXG5cdCAgLy8gUmV0dXJuIGN1bXVsYXRpdmUgaW50ZXJlc3Rcblx0ICByZXR1cm4gaW50ZXJlc3Q7XG5cdH07XG5cblx0ZXhwb3J0cy5DVU1QUklOQyA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZHMsIHZhbHVlLCBzdGFydCwgZW5kLCB0eXBlKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cdCAgLy8gQ3JlZGl0czogSGFubmVzIFN0aWViaXR6aG9mZXIgZm9yIHRoZSB0cmFuc2xhdGlvbnMgb2YgZnVuY3Rpb24gYW5kIHZhcmlhYmxlIG5hbWVzXG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHZhbHVlID0gdXRpbHMucGFyc2VOdW1iZXIodmFsdWUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMsIHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgcmF0ZSwgcGVyaW9kcywgb3IgdmFsdWUgYXJlIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gemVyb1xuXHQgIGlmIChyYXRlIDw9IDAgfHwgcGVyaW9kcyA8PSAwIHx8IHZhbHVlIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHN0YXJ0IDwgMSwgZW5kIDwgMSwgb3Igc3RhcnQgPiBlbmRcblx0ICBpZiAoc3RhcnQgPCAxIHx8IGVuZCA8IDEgfHwgc3RhcnQgPiBlbmQpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHR5cGUgaXMgbmVpdGhlciAwIG5vciAxXG5cdCAgaWYgKHR5cGUgIT09IDAgJiYgdHlwZSAhPT0gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb21wdXRlIGN1bXVsYXRpdmUgcHJpbmNpcGFsXG5cdCAgdmFyIHBheW1lbnQgPSBleHBvcnRzLlBNVChyYXRlLCBwZXJpb2RzLCB2YWx1ZSwgMCwgdHlwZSk7XG5cdCAgdmFyIHByaW5jaXBhbCA9IDA7XG5cdCAgaWYgKHN0YXJ0ID09PSAxKSB7XG5cdCAgICBpZiAodHlwZSA9PT0gMCkge1xuXHQgICAgICBwcmluY2lwYWwgPSBwYXltZW50ICsgdmFsdWUgKiByYXRlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcHJpbmNpcGFsID0gcGF5bWVudDtcblx0ICAgIH1cblx0ICAgIHN0YXJ0Kys7XG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuXHQgICAgaWYgKHR5cGUgPiAwKSB7XG5cdCAgICAgIHByaW5jaXBhbCArPSBwYXltZW50IC0gKGV4cG9ydHMuRlYocmF0ZSwgaSAtIDIsIHBheW1lbnQsIHZhbHVlLCAxKSAtIHBheW1lbnQpICogcmF0ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHByaW5jaXBhbCArPSBwYXltZW50IC0gZXhwb3J0cy5GVihyYXRlLCBpIC0gMSwgcGF5bWVudCwgdmFsdWUsIDApICogcmF0ZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gY3VtdWxhdGl2ZSBwcmluY2lwYWxcblx0ICByZXR1cm4gcHJpbmNpcGFsO1xuXHR9O1xuXG5cdGV4cG9ydHMuREIgPSBmdW5jdGlvbihjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QsIG1vbnRoKSB7XG5cdCAgLy8gSW5pdGlhbGl6ZSBtb250aFxuXHQgIG1vbnRoID0gKG1vbnRoID09PSB1bmRlZmluZWQpID8gMTIgOiBtb250aDtcblxuXHQgIGNvc3QgPSB1dGlscy5wYXJzZU51bWJlcihjb3N0KTtcblx0ICBzYWx2YWdlID0gdXRpbHMucGFyc2VOdW1iZXIoc2FsdmFnZSk7XG5cdCAgbGlmZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGxpZmUpO1xuXHQgIHBlcmlvZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZCk7XG5cdCAgbW9udGggPSB1dGlscy5wYXJzZU51bWJlcihtb250aCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoY29zdCwgc2FsdmFnZSwgbGlmZSwgcGVyaW9kLCBtb250aCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKGNvc3QgPCAwIHx8IHNhbHZhZ2UgPCAwIHx8IGxpZmUgPCAwIHx8IHBlcmlvZCA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG1vbnRoIGlzIG5vdCBhbiBpbnRlZ2VyIGJldHdlZW4gMSBhbmQgMTJcblx0ICBpZiAoWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTJdLmluZGV4T2YobW9udGgpID09PSAtMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcGVyaW9kIGlzIGdyZWF0ZXIgdGhhbiBsaWZlXG5cdCAgaWYgKHBlcmlvZCA+IGxpZmUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIDAgKHplcm8pIGlmIHNhbHZhZ2UgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGNvc3Rcblx0ICBpZiAoc2FsdmFnZSA+PSBjb3N0KSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICAvLyBSYXRlIGlzIHJvdW5kZWQgdG8gdGhyZWUgZGVjaW1hbHMgcGxhY2VzXG5cdCAgdmFyIHJhdGUgPSAoMSAtIE1hdGgucG93KHNhbHZhZ2UgLyBjb3N0LCAxIC8gbGlmZSkpLnRvRml4ZWQoMyk7XG5cblx0ICAvLyBDb21wdXRlIGluaXRpYWwgZGVwcmVjaWF0aW9uXG5cdCAgdmFyIGluaXRpYWwgPSBjb3N0ICogcmF0ZSAqIG1vbnRoIC8gMTI7XG5cblx0ICAvLyBDb21wdXRlIHRvdGFsIGRlcHJlY2lhdGlvblxuXHQgIHZhciB0b3RhbCA9IGluaXRpYWw7XG5cdCAgdmFyIGN1cnJlbnQgPSAwO1xuXHQgIHZhciBjZWlsaW5nID0gKHBlcmlvZCA9PT0gbGlmZSkgPyBsaWZlIC0gMSA6IHBlcmlvZDtcblx0ICBmb3IgKHZhciBpID0gMjsgaSA8PSBjZWlsaW5nOyBpKyspIHtcblx0ICAgIGN1cnJlbnQgPSAoY29zdCAtIHRvdGFsKSAqIHJhdGU7XG5cdCAgICB0b3RhbCArPSBjdXJyZW50O1xuXHQgIH1cblxuXHQgIC8vIERlcHJlY2lhdGlvbiBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IHBlcmlvZHMgYXJlIHNwZWNpYWwgY2FzZXNcblx0ICBpZiAocGVyaW9kID09PSAxKSB7XG5cdCAgICAvLyBGaXJzdCBwZXJpb2Rcblx0ICAgIHJldHVybiBpbml0aWFsO1xuXHQgIH0gZWxzZSBpZiAocGVyaW9kID09PSBsaWZlKSB7XG5cdCAgICAvLyBMYXN0IHBlcmlvZFxuXHQgICAgcmV0dXJuIChjb3N0IC0gdG90YWwpICogcmF0ZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGN1cnJlbnQ7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuRERCID0gZnVuY3Rpb24oY29zdCwgc2FsdmFnZSwgbGlmZSwgcGVyaW9kLCBmYWN0b3IpIHtcblx0ICAvLyBJbml0aWFsaXplIGZhY3RvclxuXHQgIGZhY3RvciA9IChmYWN0b3IgPT09IHVuZGVmaW5lZCkgPyAyIDogZmFjdG9yO1xuXG5cdCAgY29zdCA9IHV0aWxzLnBhcnNlTnVtYmVyKGNvc3QpO1xuXHQgIHNhbHZhZ2UgPSB1dGlscy5wYXJzZU51bWJlcihzYWx2YWdlKTtcblx0ICBsaWZlID0gdXRpbHMucGFyc2VOdW1iZXIobGlmZSk7XG5cdCAgcGVyaW9kID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kKTtcblx0ICBmYWN0b3IgPSB1dGlscy5wYXJzZU51bWJlcihmYWN0b3IpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGNvc3QsIHNhbHZhZ2UsIGxpZmUsIHBlcmlvZCwgZmFjdG9yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgaXMgbmVnYXRpdmUgb3IgaWYgZmFjdG9yIGlzIG51bGxcblx0ICBpZiAoY29zdCA8IDAgfHwgc2FsdmFnZSA8IDAgfHwgbGlmZSA8IDAgfHwgcGVyaW9kIDwgMCB8fCBmYWN0b3IgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcGVyaW9kIGlzIGdyZWF0ZXIgdGhhbiBsaWZlXG5cdCAgaWYgKHBlcmlvZCA+IGxpZmUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIDAgKHplcm8pIGlmIHNhbHZhZ2UgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGNvc3Rcblx0ICBpZiAoc2FsdmFnZSA+PSBjb3N0KSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICAvLyBDb21wdXRlIGRlcHJlY2lhdGlvblxuXHQgIHZhciB0b3RhbCA9IDA7XG5cdCAgdmFyIGN1cnJlbnQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDw9IHBlcmlvZDsgaSsrKSB7XG5cdCAgICBjdXJyZW50ID0gTWF0aC5taW4oKGNvc3QgLSB0b3RhbCkgKiAoZmFjdG9yIC8gbGlmZSksIChjb3N0IC0gc2FsdmFnZSAtIHRvdGFsKSk7XG5cdCAgICB0b3RhbCArPSBjdXJyZW50O1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBkZXByZWNpYXRpb25cblx0ICByZXR1cm4gY3VycmVudDtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuRElTQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdESVNDIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRE9MTEFSREUgPSBmdW5jdGlvbihkb2xsYXIsIGZyYWN0aW9uKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cblx0ICBkb2xsYXIgPSB1dGlscy5wYXJzZU51bWJlcihkb2xsYXIpO1xuXHQgIGZyYWN0aW9uID0gdXRpbHMucGFyc2VOdW1iZXIoZnJhY3Rpb24pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGRvbGxhciwgZnJhY3Rpb24pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZyYWN0aW9uIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKGZyYWN0aW9uIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZnJhY3Rpb24gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3MgdGhhbiAxXG5cdCAgaWYgKGZyYWN0aW9uID49IDAgJiYgZnJhY3Rpb24gPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZGl2MDtcblx0ICB9XG5cblx0ICAvLyBUcnVuY2F0ZSBmcmFjdGlvbiBpZiBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgIGZyYWN0aW9uID0gcGFyc2VJbnQoZnJhY3Rpb24sIDEwKTtcblxuXHQgIC8vIENvbXB1dGUgaW50ZWdlciBwYXJ0XG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KGRvbGxhciwgMTApO1xuXG5cdCAgLy8gQWRkIGRlY2ltYWwgcGFydFxuXHQgIHJlc3VsdCArPSAoZG9sbGFyICUgMSkgKiBNYXRoLnBvdygxMCwgTWF0aC5jZWlsKE1hdGgubG9nKGZyYWN0aW9uKSAvIE1hdGguTE4xMCkpIC8gZnJhY3Rpb247XG5cblx0ICAvLyBSb3VuZCByZXN1bHRcblx0ICB2YXIgcG93ZXIgPSBNYXRoLnBvdygxMCwgTWF0aC5jZWlsKE1hdGgubG9nKGZyYWN0aW9uKSAvIE1hdGguTE4yKSArIDEpO1xuXHQgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0ICogcG93ZXIpIC8gcG93ZXI7XG5cblx0ICAvLyBSZXR1cm4gY29udmVydGVkIGRvbGxhciBwcmljZVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5ET0xMQVJGUiA9IGZ1bmN0aW9uKGRvbGxhciwgZnJhY3Rpb24pIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIGRvbGxhciA9IHV0aWxzLnBhcnNlTnVtYmVyKGRvbGxhcik7XG5cdCAgZnJhY3Rpb24gPSB1dGlscy5wYXJzZU51bWJlcihmcmFjdGlvbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZG9sbGFyLCBmcmFjdGlvbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZnJhY3Rpb24gaXMgbmVnYXRpdmVcblx0ICBpZiAoZnJhY3Rpb24gPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmcmFjdGlvbiBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBhbmQgbGVzcyB0aGFuIDFcblx0ICBpZiAoZnJhY3Rpb24gPj0gMCAmJiBmcmFjdGlvbiA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5kaXYwO1xuXHQgIH1cblxuXHQgIC8vIFRydW5jYXRlIGZyYWN0aW9uIGlmIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgZnJhY3Rpb24gPSBwYXJzZUludChmcmFjdGlvbiwgMTApO1xuXG5cdCAgLy8gQ29tcHV0ZSBpbnRlZ2VyIHBhcnRcblx0ICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQoZG9sbGFyLCAxMCk7XG5cblx0ICAvLyBBZGQgZGVjaW1hbCBwYXJ0XG5cdCAgcmVzdWx0ICs9IChkb2xsYXIgJSAxKSAqIE1hdGgucG93KDEwLCAtTWF0aC5jZWlsKE1hdGgubG9nKGZyYWN0aW9uKSAvIE1hdGguTE4xMCkpICogZnJhY3Rpb247XG5cblx0ICAvLyBSZXR1cm4gY29udmVydGVkIGRvbGxhciBwcmljZVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkRVUkFUSU9OID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0RVUkFUSU9OIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRUZGRUNUID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcykge1xuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcmF0ZSA8PTAgb3IgcGVyaW9kcyA8IDFcblx0ICBpZiAocmF0ZSA8PSAwIHx8IHBlcmlvZHMgPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFRydW5jYXRlIHBlcmlvZHMgaWYgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICBwZXJpb2RzID0gcGFyc2VJbnQocGVyaW9kcywgMTApO1xuXG5cdCAgLy8gUmV0dXJuIGVmZmVjdGl2ZSBhbm51YWwgaW50ZXJlc3QgcmF0ZVxuXHQgIHJldHVybiBNYXRoLnBvdygxICsgcmF0ZSAvIHBlcmlvZHMsIHBlcmlvZHMpIC0gMTtcblx0fTtcblxuXHRleHBvcnRzLkZWID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcywgcGF5bWVudCwgdmFsdWUsIHR5cGUpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIHZhbHVlID0gdmFsdWUgfHwgMDtcblx0ICB0eXBlID0gdHlwZSB8fCAwO1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBwYXltZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocGF5bWVudCk7XG5cdCAgdmFsdWUgPSB1dGlscy5wYXJzZU51bWJlcih2YWx1ZSk7XG5cdCAgdHlwZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHR5cGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMsIHBheW1lbnQsIHZhbHVlLCB0eXBlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBmdXR1cmUgdmFsdWVcblx0ICB2YXIgcmVzdWx0O1xuXHQgIGlmIChyYXRlID09PSAwKSB7XG5cdCAgICByZXN1bHQgPSB2YWx1ZSArIHBheW1lbnQgKiBwZXJpb2RzO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgdGVybSA9IE1hdGgucG93KDEgKyByYXRlLCBwZXJpb2RzKTtcblx0ICAgIGlmICh0eXBlID09PSAxKSB7XG5cdCAgICAgIHJlc3VsdCA9IHZhbHVlICogdGVybSArIHBheW1lbnQgKiAoMSArIHJhdGUpICogKHRlcm0gLSAxKSAvIHJhdGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXN1bHQgPSB2YWx1ZSAqIHRlcm0gKyBwYXltZW50ICogKHRlcm0gLSAxKSAvIHJhdGU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiAtcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuRlZTQ0hFRFVMRSA9IGZ1bmN0aW9uKHByaW5jaXBhbCwgc2NoZWR1bGUpIHtcblx0ICBwcmluY2lwYWwgPSB1dGlscy5wYXJzZU51bWJlcihwcmluY2lwYWwpO1xuXHQgIHNjaGVkdWxlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHNjaGVkdWxlKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocHJpbmNpcGFsLCBzY2hlZHVsZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgbiA9IHNjaGVkdWxlLmxlbmd0aDtcblx0ICB2YXIgZnV0dXJlID0gcHJpbmNpcGFsO1xuXG5cdCAgLy8gQXBwbHkgYWxsIGludGVyZXN0cyBpbiBzY2hlZHVsZVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAvLyBBcHBseSBzY2hlZHVsZWQgaW50ZXJlc3Rcblx0ICAgIGZ1dHVyZSAqPSAxICsgc2NoZWR1bGVbaV07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGZ1dHVyZSB2YWx1ZVxuXHQgIHJldHVybiBmdXR1cmU7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLklOVFJBVEUgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignSU5UUkFURSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLklQTVQgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXG5cdCAgZnV0dXJlID0gZnV0dXJlIHx8IDA7XG5cdCAgdHlwZSA9IHR5cGUgfHwgMDtcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2QgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2QpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kLCBwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gQ29tcHV0ZSBwYXltZW50XG5cdCAgdmFyIHBheW1lbnQgPSBleHBvcnRzLlBNVChyYXRlLCBwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpO1xuXG5cdCAgLy8gQ29tcHV0ZSBpbnRlcmVzdFxuXHQgIHZhciBpbnRlcmVzdDtcblx0ICBpZiAocGVyaW9kID09PSAxKSB7XG5cdCAgICBpZiAodHlwZSA9PT0gMSkge1xuXHQgICAgICBpbnRlcmVzdCA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpbnRlcmVzdCA9IC1wcmVzZW50O1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAodHlwZSA9PT0gMSkge1xuXHQgICAgICBpbnRlcmVzdCA9IGV4cG9ydHMuRlYocmF0ZSwgcGVyaW9kIC0gMiwgcGF5bWVudCwgcHJlc2VudCwgMSkgLSBwYXltZW50O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaW50ZXJlc3QgPSBleHBvcnRzLkZWKHJhdGUsIHBlcmlvZCAtIDEsIHBheW1lbnQsIHByZXNlbnQsIDApO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBpbnRlcmVzdFxuXHQgIHJldHVybiBpbnRlcmVzdCAqIHJhdGU7XG5cdH07XG5cblx0ZXhwb3J0cy5JUlIgPSBmdW5jdGlvbih2YWx1ZXMsIGd1ZXNzKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cblx0ICBndWVzcyA9IGd1ZXNzIHx8IDA7XG5cblx0ICB2YWx1ZXMgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4odmFsdWVzKSk7XG5cdCAgZ3Vlc3MgPSB1dGlscy5wYXJzZU51bWJlcihndWVzcyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IodmFsdWVzLCBndWVzcykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBDYWxjdWxhdGVzIHRoZSByZXN1bHRpbmcgYW1vdW50XG5cdCAgdmFyIGlyclJlc3VsdCA9IGZ1bmN0aW9uKHZhbHVlcywgZGF0ZXMsIHJhdGUpIHtcblx0ICAgIHZhciByID0gcmF0ZSArIDE7XG5cdCAgICB2YXIgcmVzdWx0ID0gdmFsdWVzWzBdO1xuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgcmVzdWx0ICs9IHZhbHVlc1tpXSAvIE1hdGgucG93KHIsIChkYXRlc1tpXSAtIGRhdGVzWzBdKSAvIDM2NSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBDYWxjdWxhdGVzIHRoZSBmaXJzdCBkZXJpdmF0aW9uXG5cdCAgdmFyIGlyclJlc3VsdERlcml2ID0gZnVuY3Rpb24odmFsdWVzLCBkYXRlcywgcmF0ZSkge1xuXHQgICAgdmFyIHIgPSByYXRlICsgMTtcblx0ICAgIHZhciByZXN1bHQgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGZyYWMgPSAoZGF0ZXNbaV0gLSBkYXRlc1swXSkgLyAzNjU7XG5cdCAgICAgIHJlc3VsdCAtPSBmcmFjICogdmFsdWVzW2ldIC8gTWF0aC5wb3cociwgZnJhYyArIDEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgLy8gSW5pdGlhbGl6ZSBkYXRlcyBhbmQgY2hlY2sgdGhhdCB2YWx1ZXMgY29udGFpbnMgYXQgbGVhc3Qgb25lIHBvc2l0aXZlIHZhbHVlIGFuZCBvbmUgbmVnYXRpdmUgdmFsdWVcblx0ICB2YXIgZGF0ZXMgPSBbXTtcblx0ICB2YXIgcG9zaXRpdmUgPSBmYWxzZTtcblx0ICB2YXIgbmVnYXRpdmUgPSBmYWxzZTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgZGF0ZXNbaV0gPSAoaSA9PT0gMCkgPyAwIDogZGF0ZXNbaSAtIDFdICsgMzY1O1xuXHQgICAgaWYgKHZhbHVlc1tpXSA+IDApIHtcblx0ICAgICAgcG9zaXRpdmUgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlc1tpXSA8IDApIHtcblx0ICAgICAgbmVnYXRpdmUgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB2YWx1ZXMgZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcG9zaXRpdmUgdmFsdWUgYW5kIG9uZSBuZWdhdGl2ZSB2YWx1ZVxuXHQgIGlmICghcG9zaXRpdmUgfHwgIW5lZ2F0aXZlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIEluaXRpYWxpemUgZ3Vlc3MgYW5kIHJlc3VsdFJhdGVcblx0ICBndWVzcyA9IChndWVzcyA9PT0gdW5kZWZpbmVkKSA/IDAuMSA6IGd1ZXNzO1xuXHQgIHZhciByZXN1bHRSYXRlID0gZ3Vlc3M7XG5cblx0ICAvLyBTZXQgbWF4aW11bSBlcHNpbG9uIGZvciBlbmQgb2YgaXRlcmF0aW9uXG5cdCAgdmFyIGVwc01heCA9IDFlLTEwO1xuXG5cdCAgLy8gSW1wbGVtZW50IE5ld3RvbidzIG1ldGhvZFxuXHQgIHZhciBuZXdSYXRlLCBlcHNSYXRlLCByZXN1bHRWYWx1ZTtcblx0ICB2YXIgY29udExvb3AgPSB0cnVlO1xuXHQgIGRvIHtcblx0ICAgIHJlc3VsdFZhbHVlID0gaXJyUmVzdWx0KHZhbHVlcywgZGF0ZXMsIHJlc3VsdFJhdGUpO1xuXHQgICAgbmV3UmF0ZSA9IHJlc3VsdFJhdGUgLSByZXN1bHRWYWx1ZSAvIGlyclJlc3VsdERlcml2KHZhbHVlcywgZGF0ZXMsIHJlc3VsdFJhdGUpO1xuXHQgICAgZXBzUmF0ZSA9IE1hdGguYWJzKG5ld1JhdGUgLSByZXN1bHRSYXRlKTtcblx0ICAgIHJlc3VsdFJhdGUgPSBuZXdSYXRlO1xuXHQgICAgY29udExvb3AgPSAoZXBzUmF0ZSA+IGVwc01heCkgJiYgKE1hdGguYWJzKHJlc3VsdFZhbHVlKSA+IGVwc01heCk7XG5cdCAgfSB3aGlsZSAoY29udExvb3ApO1xuXG5cdCAgLy8gUmV0dXJuIGludGVybmFsIHJhdGUgb2YgcmV0dXJuXG5cdCAgcmV0dXJuIHJlc3VsdFJhdGU7XG5cdH07XG5cblx0ZXhwb3J0cy5JU1BNVCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgdmFsdWUpIHtcblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgdmFsdWUgPSB1dGlscy5wYXJzZU51bWJlcih2YWx1ZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kLCBwZXJpb2RzLCB2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gaW50ZXJlc3Rcblx0ICByZXR1cm4gdmFsdWUgKiByYXRlICogKHBlcmlvZCAvIHBlcmlvZHMgLSAxKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuTURVUkFUSU9OID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ01EVVJBVElPTiBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLk1JUlIgPSBmdW5jdGlvbih2YWx1ZXMsIGZpbmFuY2VfcmF0ZSwgcmVpbnZlc3RfcmF0ZSkge1xuXHQgIHZhbHVlcyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbih2YWx1ZXMpKTtcblx0ICBmaW5hbmNlX3JhdGUgPSB1dGlscy5wYXJzZU51bWJlcihmaW5hbmNlX3JhdGUpO1xuXHQgIHJlaW52ZXN0X3JhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyZWludmVzdF9yYXRlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih2YWx1ZXMsIGZpbmFuY2VfcmF0ZSwgcmVpbnZlc3RfcmF0ZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBJbml0aWFsaXplIG51bWJlciBvZiB2YWx1ZXNcblx0ICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG5cblx0ICAvLyBMb29rdXAgcGF5bWVudHMgKG5lZ2F0aXZlIHZhbHVlcykgYW5kIGluY29tZXMgKHBvc2l0aXZlIHZhbHVlcylcblx0ICB2YXIgcGF5bWVudHMgPSBbXTtcblx0ICB2YXIgaW5jb21lcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBpZiAodmFsdWVzW2ldIDwgMCkge1xuXHQgICAgICBwYXltZW50cy5wdXNoKHZhbHVlc1tpXSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpbmNvbWVzLnB1c2godmFsdWVzW2ldKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gbW9kaWZpZWQgaW50ZXJuYWwgcmF0ZSBvZiByZXR1cm5cblx0ICB2YXIgbnVtID0gLWV4cG9ydHMuTlBWKHJlaW52ZXN0X3JhdGUsIGluY29tZXMpICogTWF0aC5wb3coMSArIHJlaW52ZXN0X3JhdGUsIG4gLSAxKTtcblx0ICB2YXIgZGVuID0gZXhwb3J0cy5OUFYoZmluYW5jZV9yYXRlLCBwYXltZW50cykgKiAoMSArIGZpbmFuY2VfcmF0ZSk7XG5cdCAgcmV0dXJuIE1hdGgucG93KG51bSAvIGRlbiwgMSAvIChuIC0gMSkpIC0gMTtcblx0fTtcblxuXHRleHBvcnRzLk5PTUlOQUwgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzKSB7XG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2RzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiByYXRlIDw9MCBvciBwZXJpb2RzIDwgMVxuXHQgIGlmIChyYXRlIDw9IDAgfHwgcGVyaW9kcyA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gVHJ1bmNhdGUgcGVyaW9kcyBpZiBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgIHBlcmlvZHMgPSBwYXJzZUludChwZXJpb2RzLCAxMCk7XG5cblx0ICAvLyBSZXR1cm4gbm9taW5hbCBhbm51YWwgaW50ZXJlc3QgcmF0ZVxuXHQgIHJldHVybiAoTWF0aC5wb3cocmF0ZSArIDEsIDEgLyBwZXJpb2RzKSAtIDEpICogcGVyaW9kcztcblx0fTtcblxuXHRleHBvcnRzLk5QRVIgPSBmdW5jdGlvbihyYXRlLCBwYXltZW50LCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpIHtcblx0ICB0eXBlID0gKHR5cGUgPT09IHVuZGVmaW5lZCkgPyAwIDogdHlwZTtcblx0ICBmdXR1cmUgPSAoZnV0dXJlID09PSB1bmRlZmluZWQpID8gMCA6IGZ1dHVyZTtcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwYXltZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocGF5bWVudCk7XG5cdCAgcHJlc2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByZXNlbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgdHlwZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHR5cGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBheW1lbnQsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gbnVtYmVyIG9mIHBlcmlvZHNcblx0ICB2YXIgbnVtID0gcGF5bWVudCAqICgxICsgcmF0ZSAqIHR5cGUpIC0gZnV0dXJlICogcmF0ZTtcblx0ICB2YXIgZGVuID0gKHByZXNlbnQgKiByYXRlICsgcGF5bWVudCAqICgxICsgcmF0ZSAqIHR5cGUpKTtcblx0ICByZXR1cm4gTWF0aC5sb2cobnVtIC8gZGVuKSAvIE1hdGgubG9nKDEgKyByYXRlKTtcblx0fTtcblxuXHRleHBvcnRzLk5QViA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChhcmdzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBhcmdzO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCByYXRlXG5cdCAgdmFyIHJhdGUgPSBhcmdzWzBdO1xuXG5cdCAgLy8gSW5pdGlhbGl6ZSBuZXQgcHJlc2VudCB2YWx1ZVxuXHQgIHZhciB2YWx1ZSA9IDA7XG5cblx0ICAvLyBMb29wIG9uIGFsbCB2YWx1ZXNcblx0ICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3MubGVuZ3RoOyBqKyspIHtcblx0ICAgIHZhbHVlICs9IGFyZ3Nbal0gLyBNYXRoLnBvdygxICsgcmF0ZSwgaik7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG5ldCBwcmVzZW50IHZhbHVlXG5cdCAgcmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5PRERGUFJJQ0UgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignT0RERlBSSUNFIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5PRERGWUlFTEQgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignT0RERllJRUxEIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5PRERMUFJJQ0UgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignT0RETFBSSUNFIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5PRERMWUlFTEQgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignT0RETFlJRUxEIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUERVUkFUSU9OID0gZnVuY3Rpb24ocmF0ZSwgcHJlc2VudCwgZnV0dXJlKSB7XG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHByZXNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwcmVzZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHByZXNlbnQsIGZ1dHVyZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcmF0ZSA8PTBcblx0ICBpZiAocmF0ZSA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBudW1iZXIgb2YgcGVyaW9kc1xuXHQgIHJldHVybiAoTWF0aC5sb2coZnV0dXJlKSAtIE1hdGgubG9nKHByZXNlbnQpKSAvIE1hdGgubG9nKDEgKyByYXRlKTtcblx0fTtcblxuXHRleHBvcnRzLlBNVCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXG5cdCAgZnV0dXJlID0gZnV0dXJlIHx8IDA7XG5cdCAgdHlwZSA9IHR5cGUgfHwgMDtcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgcHJlc2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByZXNlbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgdHlwZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHR5cGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gcGF5bWVudFxuXHQgIHZhciByZXN1bHQ7XG5cdCAgaWYgKHJhdGUgPT09IDApIHtcblx0ICAgIHJlc3VsdCA9IChwcmVzZW50ICsgZnV0dXJlKSAvIHBlcmlvZHM7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciB0ZXJtID0gTWF0aC5wb3coMSArIHJhdGUsIHBlcmlvZHMpO1xuXHQgICAgaWYgKHR5cGUgPT09IDEpIHtcblx0ICAgICAgcmVzdWx0ID0gKGZ1dHVyZSAqIHJhdGUgLyAodGVybSAtIDEpICsgcHJlc2VudCAqIHJhdGUgLyAoMSAtIDEgLyB0ZXJtKSkgLyAoMSArIHJhdGUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzdWx0ID0gZnV0dXJlICogcmF0ZSAvICh0ZXJtIC0gMSkgKyBwcmVzZW50ICogcmF0ZSAvICgxIC0gMSAvIHRlcm0pO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gLXJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlBQTVQgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkge1xuXHQgIGZ1dHVyZSA9IGZ1dHVyZSB8fCAwO1xuXHQgIHR5cGUgPSB0eXBlIHx8IDA7XG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHByZXNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwcmVzZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIHR5cGUgPSB1dGlscy5wYXJzZU51bWJlcih0eXBlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGV4cG9ydHMuUE1UKHJhdGUsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkgLSBleHBvcnRzLklQTVQocmF0ZSwgcGVyaW9kLCBwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUsIHR5cGUpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5QUklDRSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdQUklDRSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuUFJJQ0VESVNDID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1BSSUNFRElTQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuUFJJQ0VNQVQgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignUFJJQ0VNQVQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5QViA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZHMsIHBheW1lbnQsIGZ1dHVyZSwgdHlwZSkge1xuXHQgIGZ1dHVyZSA9IGZ1dHVyZSB8fCAwO1xuXHQgIHR5cGUgPSB0eXBlIHx8IDA7XG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHBheW1lbnQgPSB1dGlscy5wYXJzZU51bWJlcihwYXltZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIHR5cGUgPSB1dGlscy5wYXJzZU51bWJlcih0eXBlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2RzLCBwYXltZW50LCBmdXR1cmUsIHR5cGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHByZXNlbnQgdmFsdWVcblx0ICBpZiAocmF0ZSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIC1wYXltZW50ICogcGVyaW9kcyAtIGZ1dHVyZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuICgoKDEgLSBNYXRoLnBvdygxICsgcmF0ZSwgcGVyaW9kcykpIC8gcmF0ZSkgKiBwYXltZW50ICogKDEgKyByYXRlICogdHlwZSkgLSBmdXR1cmUpIC8gTWF0aC5wb3coMSArIHJhdGUsIHBlcmlvZHMpO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLlJBVEUgPSBmdW5jdGlvbihwZXJpb2RzLCBwYXltZW50LCBwcmVzZW50LCBmdXR1cmUsIHR5cGUsIGd1ZXNzKSB7XG5cdCAgLy8gQ3JlZGl0czogcmFidWdlbnRvXG5cblx0ICBndWVzcyA9IChndWVzcyA9PT0gdW5kZWZpbmVkKSA/IDAuMDEgOiBndWVzcztcblx0ICBmdXR1cmUgPSAoZnV0dXJlID09PSB1bmRlZmluZWQpID8gMCA6IGZ1dHVyZTtcblx0ICB0eXBlID0gKHR5cGUgPT09IHVuZGVmaW5lZCkgPyAwIDogdHlwZTtcblxuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBwYXltZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocGF5bWVudCk7XG5cdCAgcHJlc2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByZXNlbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgdHlwZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHR5cGUpO1xuXHQgIGd1ZXNzID0gdXRpbHMucGFyc2VOdW1iZXIoZ3Vlc3MpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHBlcmlvZHMsIHBheW1lbnQsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSwgZ3Vlc3MpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gU2V0IG1heGltdW0gZXBzaWxvbiBmb3IgZW5kIG9mIGl0ZXJhdGlvblxuXHQgIHZhciBlcHNNYXggPSAxZS02O1xuXG5cdCAgLy8gU2V0IG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnNcblx0ICB2YXIgaXRlck1heCA9IDEwMDtcblx0ICB2YXIgaXRlciA9IDA7XG5cdCAgdmFyIGNsb3NlID0gZmFsc2U7XG5cdCAgdmFyIHJhdGUgPSBndWVzcztcblxuXHQgIHdoaWxlIChpdGVyIDwgaXRlck1heCAmJiAhY2xvc2UpIHtcblx0ICAgIHZhciB0MSA9IE1hdGgucG93KHJhdGUgKyAxLCBwZXJpb2RzKTtcblx0ICAgIHZhciB0MiA9IE1hdGgucG93KHJhdGUgKyAxLCBwZXJpb2RzIC0gMSk7XG5cblx0ICAgIHZhciBmMSA9IGZ1dHVyZSArIHQxICogcHJlc2VudCArIHBheW1lbnQgKiAodDEgLSAxKSAqIChyYXRlICogdHlwZSArIDEpIC8gcmF0ZTtcblx0ICAgIHZhciBmMiA9IHBlcmlvZHMgKiB0MiAqIHByZXNlbnQgLSBwYXltZW50ICogKHQxIC0gMSkgKihyYXRlICogdHlwZSArIDEpIC8gTWF0aC5wb3cocmF0ZSwyKTtcblx0ICAgIHZhciBmMyA9IHBlcmlvZHMgKiBwYXltZW50ICogdDIgKiAocmF0ZSAqIHR5cGUgKyAxKSAvIHJhdGUgKyBwYXltZW50ICogKHQxIC0gMSkgKiB0eXBlIC8gcmF0ZTtcblxuXHQgICAgdmFyIG5ld1JhdGUgPSByYXRlIC0gZjEgLyAoZjIgKyBmMyk7XG5cblx0ICAgIGlmIChNYXRoLmFicyhuZXdSYXRlIC0gcmF0ZSkgPCBlcHNNYXgpIGNsb3NlID0gdHJ1ZTtcblx0ICAgIGl0ZXIrK1xuXHQgICAgcmF0ZSA9IG5ld1JhdGU7XG5cdCAgfVxuXG5cdCAgaWYgKCFjbG9zZSkgcmV0dXJuIE51bWJlci5OYU4gKyByYXRlO1xuXHQgIHJldHVybiByYXRlO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5SRUNFSVZFRCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdSRUNFSVZFRCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLlJSSSA9IGZ1bmN0aW9uKHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSkge1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwZXJpb2RzLCBwcmVzZW50LCBmdXR1cmUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHBlcmlvZHMgb3IgcHJlc2VudCBpcyBlcXVhbCB0byAwICh6ZXJvKVxuXHQgIGlmIChwZXJpb2RzID09PSAwIHx8IHByZXNlbnQgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVxdWl2YWxlbnQgaW50ZXJlc3QgcmF0ZVxuXHQgIHJldHVybiBNYXRoLnBvdyhmdXR1cmUgLyBwcmVzZW50LCAxIC8gcGVyaW9kcykgLSAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0xOID0gZnVuY3Rpb24oY29zdCwgc2FsdmFnZSwgbGlmZSkge1xuXHQgIGNvc3QgPSB1dGlscy5wYXJzZU51bWJlcihjb3N0KTtcblx0ICBzYWx2YWdlID0gdXRpbHMucGFyc2VOdW1iZXIoc2FsdmFnZSk7XG5cdCAgbGlmZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGxpZmUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGNvc3QsIHNhbHZhZ2UsIGxpZmUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGxpZmUgZXF1YWwgdG8gMCAoemVybylcblx0ICBpZiAobGlmZSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gc3RyYWlnaHQtbGluZSBkZXByZWNpYXRpb25cblx0ICByZXR1cm4gKGNvc3QgLSBzYWx2YWdlKSAvIGxpZmU7XG5cdH07XG5cblx0ZXhwb3J0cy5TWUQgPSBmdW5jdGlvbihjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGlzIG5vdCBhIG51bWJlclxuXHQgIGNvc3QgPSB1dGlscy5wYXJzZU51bWJlcihjb3N0KTtcblx0ICBzYWx2YWdlID0gdXRpbHMucGFyc2VOdW1iZXIoc2FsdmFnZSk7XG5cdCAgbGlmZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGxpZmUpO1xuXHQgIHBlcmlvZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoY29zdCwgc2FsdmFnZSwgbGlmZSwgcGVyaW9kKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBsaWZlIGVxdWFsIHRvIDAgKHplcm8pXG5cdCAgaWYgKGxpZmUgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHBlcmlvZCBpcyBsb3dlciB0aGFuIDEgb3IgZ3JlYXRlciB0aGFuIGxpZmVcblx0ICBpZiAocGVyaW9kIDwgMSB8fCBwZXJpb2QgPiBsaWZlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFRydW5jYXRlIHBlcmlvZCBpZiBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgIHBlcmlvZCA9IHBhcnNlSW50KHBlcmlvZCwgMTApO1xuXG5cdCAgLy8gUmV0dXJuIHN0cmFpZ2h0LWxpbmUgZGVwcmVjaWF0aW9uXG5cdCAgcmV0dXJuICgoY29zdCAtIHNhbHZhZ2UpICogKGxpZmUgLSBwZXJpb2QgKyAxKSAqIDIpIC8gKGxpZmUgKiAobGlmZSArIDEpKTtcblx0fTtcblxuXHRleHBvcnRzLlRCSUxMRVEgPSBmdW5jdGlvbihzZXR0bGVtZW50LCBtYXR1cml0eSwgZGlzY291bnQpIHtcblx0ICBzZXR0bGVtZW50ID0gdXRpbHMucGFyc2VEYXRlKHNldHRsZW1lbnQpO1xuXHQgIG1hdHVyaXR5ID0gdXRpbHMucGFyc2VEYXRlKG1hdHVyaXR5KTtcblx0ICBkaXNjb3VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpc2NvdW50KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihzZXR0bGVtZW50LCBtYXR1cml0eSwgZGlzY291bnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGRpc2NvdW50IGlzIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gemVyb1xuXHQgIGlmIChkaXNjb3VudCA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBzZXR0bGVtZW50IGlzIGdyZWF0ZXIgdGhhbiBtYXR1cml0eVxuXHQgIGlmIChzZXR0bGVtZW50ID4gbWF0dXJpdHkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG1hdHVyaXR5IGlzIG1vcmUgdGhhbiBvbmUgeWVhciBhZnRlciBzZXR0bGVtZW50XG5cdCAgaWYgKG1hdHVyaXR5IC0gc2V0dGxlbWVudCA+IDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGJvbmQtZXF1aXZhbGVudCB5aWVsZFxuXHQgIHJldHVybiAoMzY1ICogZGlzY291bnQpIC8gKDM2MCAtIGRpc2NvdW50ICogZGF0ZVRpbWUuREFZUzM2MChzZXR0bGVtZW50LCBtYXR1cml0eSwgZmFsc2UpKTtcblx0fTtcblxuXHRleHBvcnRzLlRCSUxMUFJJQ0UgPSBmdW5jdGlvbihzZXR0bGVtZW50LCBtYXR1cml0eSwgZGlzY291bnQpIHtcblx0ICBzZXR0bGVtZW50ID0gdXRpbHMucGFyc2VEYXRlKHNldHRsZW1lbnQpO1xuXHQgIG1hdHVyaXR5ID0gdXRpbHMucGFyc2VEYXRlKG1hdHVyaXR5KTtcblx0ICBkaXNjb3VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpc2NvdW50KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihzZXR0bGVtZW50LCBtYXR1cml0eSwgZGlzY291bnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGRpc2NvdW50IGlzIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gemVyb1xuXHQgIGlmIChkaXNjb3VudCA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBzZXR0bGVtZW50IGlzIGdyZWF0ZXIgdGhhbiBtYXR1cml0eVxuXHQgIGlmIChzZXR0bGVtZW50ID4gbWF0dXJpdHkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG1hdHVyaXR5IGlzIG1vcmUgdGhhbiBvbmUgeWVhciBhZnRlciBzZXR0bGVtZW50XG5cdCAgaWYgKG1hdHVyaXR5IC0gc2V0dGxlbWVudCA+IDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGJvbmQtZXF1aXZhbGVudCB5aWVsZFxuXHQgIHJldHVybiAxMDAgKiAoMSAtIGRpc2NvdW50ICogZGF0ZVRpbWUuREFZUzM2MChzZXR0bGVtZW50LCBtYXR1cml0eSwgZmFsc2UpIC8gMzYwKTtcblx0fTtcblxuXHRleHBvcnRzLlRCSUxMWUlFTEQgPSBmdW5jdGlvbihzZXR0bGVtZW50LCBtYXR1cml0eSwgcHJpY2UpIHtcblx0ICBzZXR0bGVtZW50ID0gdXRpbHMucGFyc2VEYXRlKHNldHRsZW1lbnQpO1xuXHQgIG1hdHVyaXR5ID0gdXRpbHMucGFyc2VEYXRlKG1hdHVyaXR5KTtcblx0ICBwcmljZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByaWNlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihzZXR0bGVtZW50LCBtYXR1cml0eSwgcHJpY2UpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHByaWNlIGlzIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gemVyb1xuXHQgIGlmIChwcmljZSA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBzZXR0bGVtZW50IGlzIGdyZWF0ZXIgdGhhbiBtYXR1cml0eVxuXHQgIGlmIChzZXR0bGVtZW50ID4gbWF0dXJpdHkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG1hdHVyaXR5IGlzIG1vcmUgdGhhbiBvbmUgeWVhciBhZnRlciBzZXR0bGVtZW50XG5cdCAgaWYgKG1hdHVyaXR5IC0gc2V0dGxlbWVudCA+IDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGJvbmQtZXF1aXZhbGVudCB5aWVsZFxuXHQgIHJldHVybiAoMTAwIC0gcHJpY2UpICogMzYwIC8gKHByaWNlICogZGF0ZVRpbWUuREFZUzM2MChzZXR0bGVtZW50LCBtYXR1cml0eSwgZmFsc2UpKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuVkRCID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1ZEQiBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXG5cdGV4cG9ydHMuWElSUiA9IGZ1bmN0aW9uKHZhbHVlcywgZGF0ZXMsIGd1ZXNzKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cblx0ICB2YWx1ZXMgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4odmFsdWVzKSk7XG5cdCAgZGF0ZXMgPSB1dGlscy5wYXJzZURhdGVBcnJheSh1dGlscy5mbGF0dGVuKGRhdGVzKSk7XG5cdCAgZ3Vlc3MgPSB1dGlscy5wYXJzZU51bWJlcihndWVzcyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IodmFsdWVzLCBkYXRlcywgZ3Vlc3MpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gQ2FsY3VsYXRlcyB0aGUgcmVzdWx0aW5nIGFtb3VudFxuXHQgIHZhciBpcnJSZXN1bHQgPSBmdW5jdGlvbih2YWx1ZXMsIGRhdGVzLCByYXRlKSB7XG5cdCAgICB2YXIgciA9IHJhdGUgKyAxO1xuXHQgICAgdmFyIHJlc3VsdCA9IHZhbHVlc1swXTtcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHJlc3VsdCArPSB2YWx1ZXNbaV0gLyBNYXRoLnBvdyhyLCBkYXRlVGltZS5EQVlTKGRhdGVzW2ldLCBkYXRlc1swXSkgLyAzNjUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgLy8gQ2FsY3VsYXRlcyB0aGUgZmlyc3QgZGVyaXZhdGlvblxuXHQgIHZhciBpcnJSZXN1bHREZXJpdiA9IGZ1bmN0aW9uKHZhbHVlcywgZGF0ZXMsIHJhdGUpIHtcblx0ICAgIHZhciByID0gcmF0ZSArIDE7XG5cdCAgICB2YXIgcmVzdWx0ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBmcmFjID0gZGF0ZVRpbWUuREFZUyhkYXRlc1tpXSwgZGF0ZXNbMF0pIC8gMzY1O1xuXHQgICAgICByZXN1bHQgLT0gZnJhYyAqIHZhbHVlc1tpXSAvIE1hdGgucG93KHIsIGZyYWMgKyAxKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblxuXHQgIC8vIENoZWNrIHRoYXQgdmFsdWVzIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBwb3NpdGl2ZSB2YWx1ZSBhbmQgb25lIG5lZ2F0aXZlIHZhbHVlXG5cdCAgdmFyIHBvc2l0aXZlID0gZmFsc2U7XG5cdCAgdmFyIG5lZ2F0aXZlID0gZmFsc2U7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmICh2YWx1ZXNbaV0gPiAwKSB7XG5cdCAgICAgIHBvc2l0aXZlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICh2YWx1ZXNbaV0gPCAwKSB7XG5cdCAgICAgIG5lZ2F0aXZlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgdmFsdWVzIGRvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHBvc2l0aXZlIHZhbHVlIGFuZCBvbmUgbmVnYXRpdmUgdmFsdWVcblx0ICBpZiAoIXBvc2l0aXZlIHx8ICFuZWdhdGl2ZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJbml0aWFsaXplIGd1ZXNzIGFuZCByZXN1bHRSYXRlXG5cdCAgZ3Vlc3MgPSBndWVzcyB8fCAwLjE7XG5cdCAgdmFyIHJlc3VsdFJhdGUgPSBndWVzcztcblxuXHQgIC8vIFNldCBtYXhpbXVtIGVwc2lsb24gZm9yIGVuZCBvZiBpdGVyYXRpb25cblx0ICB2YXIgZXBzTWF4ID0gMWUtMTA7XG5cblx0ICAvLyBJbXBsZW1lbnQgTmV3dG9uJ3MgbWV0aG9kXG5cdCAgdmFyIG5ld1JhdGUsIGVwc1JhdGUsIHJlc3VsdFZhbHVlO1xuXHQgIHZhciBjb250TG9vcCA9IHRydWU7XG5cdCAgZG8ge1xuXHQgICAgcmVzdWx0VmFsdWUgPSBpcnJSZXN1bHQodmFsdWVzLCBkYXRlcywgcmVzdWx0UmF0ZSk7XG5cdCAgICBuZXdSYXRlID0gcmVzdWx0UmF0ZSAtIHJlc3VsdFZhbHVlIC8gaXJyUmVzdWx0RGVyaXYodmFsdWVzLCBkYXRlcywgcmVzdWx0UmF0ZSk7XG5cdCAgICBlcHNSYXRlID0gTWF0aC5hYnMobmV3UmF0ZSAtIHJlc3VsdFJhdGUpO1xuXHQgICAgcmVzdWx0UmF0ZSA9IG5ld1JhdGU7XG5cdCAgICBjb250TG9vcCA9IChlcHNSYXRlID4gZXBzTWF4KSAmJiAoTWF0aC5hYnMocmVzdWx0VmFsdWUpID4gZXBzTWF4KTtcblx0ICB9IHdoaWxlIChjb250TG9vcCk7XG5cblx0ICAvLyBSZXR1cm4gaW50ZXJuYWwgcmF0ZSBvZiByZXR1cm5cblx0ICByZXR1cm4gcmVzdWx0UmF0ZTtcblx0fTtcblxuXHRleHBvcnRzLlhOUFYgPSBmdW5jdGlvbihyYXRlLCB2YWx1ZXMsIGRhdGVzKSB7XG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHZhbHVlcyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbih2YWx1ZXMpKTtcblx0ICBkYXRlcyA9IHV0aWxzLnBhcnNlRGF0ZUFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0ZXMpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCB2YWx1ZXMsIGRhdGVzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gdmFsdWVzW2ldIC8gTWF0aC5wb3coMSArIHJhdGUsIGRhdGVUaW1lLkRBWVMoZGF0ZXNbaV0sIGRhdGVzWzBdKSAvIDM2NSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLllJRUxEID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1lJRUxEIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5ZSUVMRERJU0MgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignWUlFTERESVNDIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5ZSUVMRE1BVCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdZSUVMRE1BVCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDE4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdGV4cG9ydHMuTUFUQ0ggPSBmdW5jdGlvbihsb29rdXBWYWx1ZSwgbG9va3VwQXJyYXksIG1hdGNoVHlwZSkge1xuXHQgIGlmICghbG9va3VwVmFsdWUgJiYgIWxvb2t1cEFycmF5KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcblx0ICAgIG1hdGNoVHlwZSA9IDE7XG5cdCAgfVxuXHQgIGlmICghKGxvb2t1cEFycmF5IGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKG1hdGNoVHlwZSAhPT0gLTEgJiYgbWF0Y2hUeXBlICE9PSAwICYmIG1hdGNoVHlwZSAhPT0gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblx0ICB2YXIgaW5kZXg7XG5cdCAgdmFyIGluZGV4VmFsdWU7XG5cdCAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwQXJyYXkubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgaWYgKG1hdGNoVHlwZSA9PT0gMSkge1xuXHQgICAgICBpZiAobG9va3VwQXJyYXlbaWR4XSA9PT0gbG9va3VwVmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gaWR4ICsgMTtcblx0ICAgICAgfSBlbHNlIGlmIChsb29rdXBBcnJheVtpZHhdIDwgbG9va3VwVmFsdWUpIHtcblx0ICAgICAgICBpZiAoIWluZGV4VmFsdWUpIHtcblx0ICAgICAgICAgIGluZGV4ID0gaWR4ICsgMTtcblx0ICAgICAgICAgIGluZGV4VmFsdWUgPSBsb29rdXBBcnJheVtpZHhdO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobG9va3VwQXJyYXlbaWR4XSA+IGluZGV4VmFsdWUpIHtcblx0ICAgICAgICAgIGluZGV4ID0gaWR4ICsgMTtcblx0ICAgICAgICAgIGluZGV4VmFsdWUgPSBsb29rdXBBcnJheVtpZHhdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChtYXRjaFR5cGUgPT09IDApIHtcblx0ICAgICAgaWYgKHR5cGVvZiBsb29rdXBWYWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICBsb29rdXBWYWx1ZSA9IGxvb2t1cFZhbHVlLnJlcGxhY2UoL1xcPy9nLCAnLicpO1xuXHQgICAgICAgIGlmIChsb29rdXBBcnJheVtpZHhdLnRvTG93ZXJDYXNlKCkubWF0Y2gobG9va3VwVmFsdWUudG9Mb3dlckNhc2UoKSkpIHtcblx0ICAgICAgICAgIHJldHVybiBpZHggKyAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAobG9va3VwQXJyYXlbaWR4XSA9PT0gbG9va3VwVmFsdWUpIHtcblx0ICAgICAgICAgIHJldHVybiBpZHggKyAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChtYXRjaFR5cGUgPT09IC0xKSB7XG5cdCAgICAgIGlmIChsb29rdXBBcnJheVtpZHhdID09PSBsb29rdXBWYWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBpZHggKyAxO1xuXHQgICAgICB9IGVsc2UgaWYgKGxvb2t1cEFycmF5W2lkeF0gPiBsb29rdXBWYWx1ZSkge1xuXHQgICAgICAgIGlmICghaW5kZXhWYWx1ZSkge1xuXHQgICAgICAgICAgaW5kZXggPSBpZHggKyAxO1xuXHQgICAgICAgICAgaW5kZXhWYWx1ZSA9IGxvb2t1cEFycmF5W2lkeF07XG5cdCAgICAgICAgfSBlbHNlIGlmIChsb29rdXBBcnJheVtpZHhdIDwgaW5kZXhWYWx1ZSkge1xuXHQgICAgICAgICAgaW5kZXggPSBpZHggKyAxO1xuXHQgICAgICAgICAgaW5kZXhWYWx1ZSA9IGxvb2t1cEFycmF5W2lkeF07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGluZGV4ID8gaW5kZXggOiBlcnJvci5uYTtcblx0fTtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuOyIsInRoaXMuaiQgPSB0aGlzLmpTdGF0ID0gKGZ1bmN0aW9uKE1hdGgsIHVuZGVmaW5lZCkge1xuXG4vLyBGb3IgcXVpY2sgcmVmZXJlbmNlLlxudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vLyBDYWxjdWxhdGUgY29ycmVjdGlvbiBmb3IgSUVFRSBlcnJvclxuLy8gVE9ETzogVGhpcyBjYWxjdWxhdGlvbiBjYW4gYmUgaW1wcm92ZWQuXG5mdW5jdGlvbiBjYWxjUmR4KG4sIG0pIHtcbiAgdmFyIHZhbCA9IG4gPiBtID8gbiA6IG07XG4gIHJldHVybiBNYXRoLnBvdygxMCxcbiAgICAgICAgICAgICAgICAgIDE3IC0gfn4oTWF0aC5sb2coKCh2YWwgPiAwKSA/IHZhbCA6IC12YWwpKSAqIE1hdGguTE9HMTBFKSk7XG59XG5cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyAmJiBhcmcgPT09IGFyZztcbn1cblxuXG4vLyBDb252ZXJ0cyB0aGUgalN0YXQgbWF0cml4IHRvIHZlY3Rvci5cbmZ1bmN0aW9uIHRvVmVjdG9yKGFycikge1xuICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuXG5cbi8vIFRoZSBvbmUgYW5kIG9ubHkgalN0YXQgY29uc3RydWN0b3IuXG5mdW5jdGlvbiBqU3RhdCgpIHtcbiAgcmV0dXJuIG5ldyBqU3RhdC5faW5pdChhcmd1bWVudHMpO1xufVxuXG5cbi8vIFRPRE86IFJlbW92ZSBhZnRlciBhbGwgcmVmZXJlbmNlcyBpbiBzcmMgZmlsZXMgaGF2ZSBiZWVuIHJlbW92ZWQuXG5qU3RhdC5mbiA9IGpTdGF0LnByb3RvdHlwZTtcblxuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpbml0aWFsaXplciBmcm9tIHRoZSBjb25zdHJ1Y3RvciBpdCdzIGVhc2llciB0byBoYW5kbGVcbi8vIGFsd2F5cyByZXR1cm5pbmcgYSBuZXcgaW5zdGFuY2Ugd2hldGhlciBcIm5ld1wiIHdhcyB1c2VkIG9yIG5vdC5cbmpTdGF0Ll9pbml0ID0gZnVuY3Rpb24gX2luaXQoYXJncykge1xuICB2YXIgaTtcblxuICAvLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSwgbXVzdCBiZSB2ZWN0b3Igb3IgbWF0cml4LlxuICBpZiAoaXNBcnJheShhcmdzWzBdKSkge1xuICAgIC8vIENoZWNrIGlmIG1hdHJpeC5cbiAgICBpZiAoaXNBcnJheShhcmdzWzBdWzBdKSkge1xuICAgICAgLy8gU2VlIGlmIGEgbWFwcGluZyBmdW5jdGlvbiB3YXMgYWxzbyBwYXNzZWQuXG4gICAgICBpZiAoaXNGdW5jdGlvbihhcmdzWzFdKSlcbiAgICAgICAgYXJnc1swXSA9IGpTdGF0Lm1hcChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGlzIGZhc3RlciB0aGFuIHRoaXMucHVzaC5hcHBseSh0aGlzLCBhcmdzWzBdLlxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3NbMF0ubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXNbaV0gPSBhcmdzWzBdW2ldO1xuICAgICAgdGhpcy5sZW5ndGggPSBhcmdzWzBdLmxlbmd0aDtcblxuICAgIC8vIE90aGVyd2lzZSBtdXN0IGJlIGEgdmVjdG9yLlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzWzBdID0gaXNGdW5jdGlvbihhcmdzWzFdKSA/IGpTdGF0Lm1hcChhcmdzWzBdLCBhcmdzWzFdKSA6IGFyZ3NbMF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gIC8vIElmIGZpcnN0IGFyZ3VtZW50IGlzIG51bWJlciwgYXNzdW1lIGNyZWF0aW9uIG9mIHNlcXVlbmNlLlxuICB9IGVsc2UgaWYgKGlzTnVtYmVyKGFyZ3NbMF0pKSB7XG4gICAgdGhpc1swXSA9IGpTdGF0LnNlcS5hcHBseShudWxsLCBhcmdzKTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBqU3RhdCBvYmplY3QgaXMgcGFzc2VkIHRvIGpTdGF0LlxuICB9IGVsc2UgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBqU3RhdCkge1xuICAgIC8vIER1cGxpY2F0ZSB0aGUgb2JqZWN0IGFuZCBwYXNzIGl0IGJhY2suXG4gICAgcmV0dXJuIGpTdGF0KGFyZ3NbMF0udG9BcnJheSgpKTtcblxuICAvLyBVbmV4cGVjdGVkIGFyZ3VtZW50IHZhbHVlLCByZXR1cm4gZW1wdHkgalN0YXQgb2JqZWN0LlxuICAvLyBUT0RPOiBUaGlzIGlzIHN0cmFuZ2UgYmVoYXZpb3IuIFNob3VsZG4ndCB0aGlzIHRocm93IG9yIHNvbWUgc3VjaCB0byBsZXRcbiAgLy8gdGhlIHVzZXIga25vdyB0aGV5IGhhZCBiYWQgYXJndW1lbnRzP1xuICB9IGVsc2Uge1xuICAgIHRoaXNbMF0gPSBbXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5qU3RhdC5faW5pdC5wcm90b3R5cGUgPSBqU3RhdC5wcm90b3R5cGU7XG5qU3RhdC5faW5pdC5jb25zdHJ1Y3RvciA9IGpTdGF0O1xuXG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zLlxuLy8gVE9ETzogZm9yIGludGVybmFsIHVzZSBvbmx5P1xualN0YXQudXRpbHMgPSB7XG4gIGNhbGNSZHg6IGNhbGNSZHgsXG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgdG9WZWN0b3I6IHRvVmVjdG9yXG59O1xuXG5cbi8vIEVhc2lseSBleHRlbmQgdGhlIGpTdGF0IG9iamVjdC5cbi8vIFRPRE86IGlzIHRoaXMgc2VyaW91c2x5IG5lY2Vzc2FyeT9cbmpTdGF0LmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBmb3IgKGogaW4gb2JqKVxuICAgICAgalN0YXRbal0gPSBvYmpbal07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChqIGluIGFyZ3VtZW50c1tpXSlcbiAgICAgIG9ialtqXSA9IGFyZ3VtZW50c1tpXVtqXTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBtYXRyaXguXG5qU3RhdC5yb3dzID0gZnVuY3Rpb24gcm93cyhhcnIpIHtcbiAgcmV0dXJuIGFyci5sZW5ndGggfHwgMTtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hdHJpeC5cbmpTdGF0LmNvbHMgPSBmdW5jdGlvbiBjb2xzKGFycikge1xuICByZXR1cm4gYXJyWzBdLmxlbmd0aCB8fCAxO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3QgeyByb3dzOiBpLCBjb2xzOiBqIH1cbmpTdGF0LmRpbWVuc2lvbnMgPSBmdW5jdGlvbiBkaW1lbnNpb25zKGFycikge1xuICByZXR1cm4ge1xuICAgIHJvd3M6IGpTdGF0LnJvd3MoYXJyKSxcbiAgICBjb2xzOiBqU3RhdC5jb2xzKGFycilcbiAgfTtcbn07XG5cblxuLy8gUmV0dXJucyBhIHNwZWNpZmllZCByb3cgYXMgYSB2ZWN0b3JcbmpTdGF0LnJvdyA9IGZ1bmN0aW9uIHJvdyhhcnIsIGluZGV4KSB7XG4gIHJldHVybiBhcnJbaW5kZXhdO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgY29sdW1uIGFzIGEgdmVjdG9yXG5qU3RhdC5jb2wgPSBmdW5jdGlvbiBjb2xzKGFyciwgaW5kZXgpIHtcbiAgdmFyIGNvbHVtbiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspXG4gICAgY29sdW1uW2ldID0gW2FycltpXVtpbmRleF1dO1xuICByZXR1cm4gY29sdW1uO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBkaWFnb25hbCBvZiB0aGUgbWF0cml4XG5qU3RhdC5kaWFnID0gZnVuY3Rpb24gZGlhZyhhcnIpIHtcbiAgdmFyIG5yb3cgPSBqU3RhdC5yb3dzKGFycik7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobnJvdyk7XG4gIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG5yb3c7IHJvdysrKVxuICAgIHJlc1tyb3ddID0gW2Fycltyb3ddW3Jvd11dO1xuICByZXR1cm4gcmVzO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBhbnRpLWRpYWdvbmFsIG9mIHRoZSBtYXRyaXhcbmpTdGF0LmFudGlkaWFnID0gZnVuY3Rpb24gYW50aWRpYWcoYXJyKSB7XG4gIHZhciBucm93ID0galN0YXQucm93cyhhcnIpIC0gMTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShucm93KTtcbiAgZm9yICh2YXIgaSA9IDA7IG5yb3cgPj0gMDsgbnJvdy0tLCBpKyspXG4gICAgcmVzW2ldID0gW2FycltpXVtucm93XV07XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBUcmFuc3Bvc2UgYSBtYXRyaXggb3IgYXJyYXkuXG5qU3RhdC50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoYXJyKSB7XG4gIHZhciBvYmogPSBbXTtcbiAgdmFyIG9iakFyciwgcm93cywgY29scywgaiwgaTtcblxuICAvLyBNYWtlIHN1cmUgYXJyIGlzIGluIG1hdHJpeCBmb3JtYXQuXG4gIGlmICghaXNBcnJheShhcnJbMF0pKVxuICAgIGFyciA9IFthcnJdO1xuXG4gIHJvd3MgPSBhcnIubGVuZ3RoO1xuICBjb2xzID0gYXJyWzBdLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XG4gICAgb2JqQXJyID0gbmV3IEFycmF5KHJvd3MpO1xuICAgIGZvciAoaiA9IDA7IGogPCByb3dzOyBqKyspXG4gICAgICBvYmpBcnJbal0gPSBhcnJbal1baV07XG4gICAgb2JqLnB1c2gob2JqQXJyKTtcbiAgfVxuXG4gIC8vIElmIG9iaiBpcyB2ZWN0b3IsIHJldHVybiBvbmx5IHNpbmdsZSBhcnJheS5cbiAgcmV0dXJuIG9iai5sZW5ndGggPT09IDEgPyBvYmpbMF0gOiBvYmo7XG59O1xuXG5cbi8vIE1hcCBhIGZ1bmN0aW9uIHRvIGFuIGFycmF5IG9yIGFycmF5IG9mIGFycmF5cy5cbi8vIFwidG9BbHRlclwiIGlzIGFuIGludGVybmFsIHZhcmlhYmxlLlxualN0YXQubWFwID0gZnVuY3Rpb24gbWFwKGFyciwgZnVuYywgdG9BbHRlcikge1xuICB2YXIgcm93LCBucm93LCBuY29sLCByZXMsIGNvbDtcblxuICBpZiAoIWlzQXJyYXkoYXJyWzBdKSlcbiAgICBhcnIgPSBbYXJyXTtcblxuICBucm93ID0gYXJyLmxlbmd0aDtcbiAgbmNvbCA9IGFyclswXS5sZW5ndGg7XG4gIHJlcyA9IHRvQWx0ZXIgPyBhcnIgOiBuZXcgQXJyYXkobnJvdyk7XG5cbiAgZm9yIChyb3cgPSAwOyByb3cgPCBucm93OyByb3crKykge1xuICAgIC8vIGlmIHRoZSByb3cgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKCFyZXNbcm93XSlcbiAgICAgIHJlc1tyb3ddID0gbmV3IEFycmF5KG5jb2wpO1xuICAgIGZvciAoY29sID0gMDsgY29sIDwgbmNvbDsgY29sKyspXG4gICAgICByZXNbcm93XVtjb2xdID0gZnVuYyhhcnJbcm93XVtjb2xdLCByb3csIGNvbCk7XG4gIH1cblxuICByZXR1cm4gcmVzLmxlbmd0aCA9PT0gMSA/IHJlc1swXSA6IHJlcztcbn07XG5cblxuLy8gRGVzdHJ1Y3RpdmVseSBhbHRlciBhbiBhcnJheS5cbmpTdGF0LmFsdGVyID0gZnVuY3Rpb24gYWx0ZXIoYXJyLCBmdW5jKSB7XG4gIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jLCB0cnVlKTtcbn07XG5cblxuLy8gR2VuZXJhdGUgYSByb3dzIHggY29scyBtYXRyaXggYWNjb3JkaW5nIHRvIHRoZSBzdXBwbGllZCBmdW5jdGlvbi5cbmpTdGF0LmNyZWF0ZSA9IGZ1bmN0aW9uICBjcmVhdGUocm93cywgY29scywgZnVuYykge1xuICB2YXIgcmVzID0gbmV3IEFycmF5KHJvd3MpO1xuICB2YXIgaSwgajtcblxuICBpZiAoaXNGdW5jdGlvbihjb2xzKSkge1xuICAgIGZ1bmMgPSBjb2xzO1xuICAgIGNvbHMgPSByb3dzO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgIHJlc1tpXSA9IG5ldyBBcnJheShjb2xzKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgY29sczsgaisrKVxuICAgICAgcmVzW2ldW2pdID0gZnVuYyhpLCBqKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5cbmZ1bmN0aW9uIHJldFplcm8oKSB7IHJldHVybiAwOyB9XG5cblxuLy8gR2VuZXJhdGUgYSByb3dzIHggY29scyBtYXRyaXggb2YgemVyb3MuXG5qU3RhdC56ZXJvcyA9IGZ1bmN0aW9uIHplcm9zKHJvd3MsIGNvbHMpIHtcbiAgaWYgKCFpc051bWJlcihjb2xzKSlcbiAgICBjb2xzID0gcm93cztcbiAgcmV0dXJuIGpTdGF0LmNyZWF0ZShyb3dzLCBjb2xzLCByZXRaZXJvKTtcbn07XG5cblxuZnVuY3Rpb24gcmV0T25lKCkgeyByZXR1cm4gMTsgfVxuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IG9mIG9uZXMuXG5qU3RhdC5vbmVzID0gZnVuY3Rpb24gb25lcyhyb3dzLCBjb2xzKSB7XG4gIGlmICghaXNOdW1iZXIoY29scykpXG4gICAgY29scyA9IHJvd3M7XG4gIHJldHVybiBqU3RhdC5jcmVhdGUocm93cywgY29scywgcmV0T25lKTtcbn07XG5cblxuLy8gR2VuZXJhdGUgYSByb3dzIHggY29scyBtYXRyaXggb2YgdW5pZm9ybWx5IHJhbmRvbSBudW1iZXJzLlxualN0YXQucmFuZCA9IGZ1bmN0aW9uIHJhbmQocm93cywgY29scykge1xuICBpZiAoIWlzTnVtYmVyKGNvbHMpKVxuICAgIGNvbHMgPSByb3dzO1xuICByZXR1cm4galN0YXQuY3JlYXRlKHJvd3MsIGNvbHMsIE1hdGgucmFuZG9tKTtcbn07XG5cblxuZnVuY3Rpb24gcmV0SWRlbnQoaSwgaikgeyByZXR1cm4gaSA9PT0gaiA/IDEgOiAwOyB9XG5cblxuLy8gR2VuZXJhdGUgYW4gaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgcm93IHggY29scy5cbmpTdGF0LmlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkocm93cywgY29scykge1xuICBpZiAoIWlzTnVtYmVyKGNvbHMpKVxuICAgIGNvbHMgPSByb3dzO1xuICByZXR1cm4galN0YXQuY3JlYXRlKHJvd3MsIGNvbHMsIHJldElkZW50KTtcbn07XG5cblxuLy8gVGVzdHMgd2hldGhlciBhIG1hdHJpeCBpcyBzeW1tZXRyaWNcbmpTdGF0LnN5bW1ldHJpYyA9IGZ1bmN0aW9uIHN5bW1ldHJpYyhhcnIpIHtcbiAgdmFyIGlzc3ltbWV0cmljID0gdHJ1ZTtcbiAgdmFyIHNpemUgPSBhcnIubGVuZ3RoO1xuICB2YXIgcm93LCBjb2w7XG5cbiAgaWYgKGFyci5sZW5ndGggIT09IGFyclswXS5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAocm93ID0gMDsgcm93IDwgc2l6ZTsgcm93KyspIHtcbiAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHNpemU7IGNvbCsrKVxuICAgICAgaWYgKGFycltjb2xdW3Jvd10gIT09IGFycltyb3ddW2NvbF0pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBTZXQgYWxsIHZhbHVlcyB0byB6ZXJvLlxualN0YXQuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LmFsdGVyKGFyciwgcmV0WmVybyk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIHNlcXVlbmNlLlxualN0YXQuc2VxID0gZnVuY3Rpb24gc2VxKG1pbiwgbWF4LCBsZW5ndGgsIGZ1bmMpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKVxuICAgIGZ1bmMgPSBmYWxzZTtcblxuICB2YXIgYXJyID0gW107XG4gIHZhciBoaXZhbCA9IGNhbGNSZHgobWluLCBtYXgpO1xuICB2YXIgc3RlcCA9IChtYXggKiBoaXZhbCAtIG1pbiAqIGhpdmFsKSAvICgobGVuZ3RoIC0gMSkgKiBoaXZhbCk7XG4gIHZhciBjdXJyZW50ID0gbWluO1xuICB2YXIgY250O1xuXG4gIC8vIEN1cnJlbnQgaXMgYXNzaWduZWQgdXNpbmcgYSB0ZWNobmlxdWUgdG8gY29tcGVuc2F0ZSBmb3IgSUVFRSBlcnJvci5cbiAgLy8gVE9ETzogTmVlZHMgYmV0dGVyIGltcGxlbWVudGF0aW9uLlxuICBmb3IgKGNudCA9IDA7XG4gICAgICAgY3VycmVudCA8PSBtYXg7XG4gICAgICAgY250KyssIGN1cnJlbnQgPSAobWluICogaGl2YWwgKyBzdGVwICogaGl2YWwgKiBjbnQpIC8gaGl2YWwpIHtcbiAgICBhcnIucHVzaCgoZnVuYyA/IGZ1bmMoY3VycmVudCwgY250KSA6IGN1cnJlbnQpKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59O1xuXG5cbi8vIFRPRE86IEdvIG92ZXIgdGhpcyBlbnRpcmUgaW1wbGVtZW50YXRpb24uIFNlZW1zIGEgdHJhZ2ljIHdhc3RlIG9mIHJlc291cmNlc1xuLy8gZG9pbmcgYWxsIHRoaXMgd29yay4gSW5zdGVhZCwgYW5kIHdoaWxlIHVnbHksIHVzZSBuZXcgRnVuY3Rpb24oKSB0byBnZW5lcmF0ZVxuLy8gYSBjdXN0b20gZnVuY3Rpb24gZm9yIGVhY2ggc3RhdGljIG1ldGhvZC5cblxuLy8gUXVpY2sgcmVmZXJlbmNlLlxudmFyIGpQcm90byA9IGpTdGF0LnByb3RvdHlwZTtcblxuLy8gRGVmYXVsdCBsZW5ndGguXG5qUHJvdG8ubGVuZ3RoID0gMDtcblxuLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuLy8gVE9ETzogQ2hlY2sgaWYgdGhleSdyZSBhY3R1YWxseSB1c2VkLCBhbmQgaWYgdGhleSBhcmUgdGhlbiByZW5hbWUgdGhlbVxuLy8gdG8gXypcbmpQcm90by5wdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5qUHJvdG8uc29ydCA9IEFycmF5LnByb3RvdHlwZS5zb3J0O1xualByb3RvLnNwbGljZSA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2U7XG5qUHJvdG8uc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cblxuLy8gUmV0dXJuIGEgY2xlYW4gYXJyYXkuXG5qUHJvdG8udG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKHRoaXMpIDogc2xpY2UuY2FsbCh0aGlzKVswXTtcbn07XG5cblxuLy8gTWFwIGEgZnVuY3Rpb24gdG8gYSBtYXRyaXggb3IgdmVjdG9yLlxualByb3RvLm1hcCA9IGZ1bmN0aW9uIG1hcChmdW5jLCB0b0FsdGVyKSB7XG4gIHJldHVybiBqU3RhdChqU3RhdC5tYXAodGhpcywgZnVuYywgdG9BbHRlcikpO1xufTtcblxuXG4vLyBEZXN0cnVjdGl2ZWx5IGFsdGVyIGFuIGFycmF5LlxualByb3RvLmFsdGVyID0gZnVuY3Rpb24gYWx0ZXIoZnVuYykge1xuICBqU3RhdC5hbHRlcih0aGlzLCBmdW5jKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIEV4dGVuZCBwcm90b3R5cGUgd2l0aCBtZXRob2RzIHRoYXQgaGF2ZSBubyBhcmd1bWVudC5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgcmVzdWx0cztcbiAgICAgIC8vIENoZWNrIGZvciBjYWxsYmFjay5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuYy5jYWxsKHNlbGYsIGpQcm90b1twYXNzZnVuY10uY2FsbChzZWxmKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMgPSBqU3RhdFtwYXNzZnVuY10odGhpcyk7XG4gICAgICByZXR1cm4gaXNBcnJheShyZXN1bHRzKSA/IGpTdGF0KHJlc3VsdHMpIDogcmVzdWx0cztcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgndHJhbnNwb3NlIGNsZWFyIHN5bW1ldHJpYyByb3dzIGNvbHMgZGltZW5zaW9ucyBkaWFnIGFudGlkaWFnJy5zcGxpdCgnICcpKTtcblxuXG4vLyBFeHRlbmQgcHJvdG90eXBlIHdpdGggbWV0aG9kcyB0aGF0IGhhdmUgb25lIGFyZ3VtZW50LlxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbihpbmRleCwgZnVuYykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLy8gY2hlY2sgZm9yIGNhbGxiYWNrXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmMuY2FsbChzZWxmLCBqUHJvdG9bcGFzc2Z1bmNdLmNhbGwoc2VsZiwgaW5kZXgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBpbmRleCkpO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCdyb3cgY29sJy5zcGxpdCgnICcpKTtcblxuXG4vLyBFeHRlbmQgcHJvdG90eXBlIHdpdGggc2ltcGxlIHNob3J0Y3V0IG1ldGhvZHMuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalByb3RvW3Bhc3NmdW5jXSA9IG5ldyBGdW5jdGlvbihcbiAgICAgICAgJ3JldHVybiBqU3RhdChqU3RhdC4nICsgcGFzc2Z1bmMgKyAnLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpOycpO1xuICB9KShmdW5jc1tpXSk7XG59KSgnY3JlYXRlIHplcm9zIG9uZXMgcmFuZCBpZGVudGl0eScuc3BsaXQoJyAnKSk7XG5cblxuLy8gRXhwb3NpbmcgalN0YXQuXG5yZXR1cm4galN0YXQ7XG5cbn0oTWF0aCkpO1xuKGZ1bmN0aW9uKGpTdGF0LCBNYXRoKSB7XG5cbnZhciBpc0Z1bmN0aW9uID0galN0YXQudXRpbHMuaXNGdW5jdGlvbjtcblxuLy8gQXNjZW5kaW5nIGZ1bmN0aW9ucyBmb3Igc29ydFxuZnVuY3Rpb24gYXNjTnVtKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9XG5cbmZ1bmN0aW9uIGNsaXAoYXJnLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihhcmcsIG1heCkpO1xufVxuXG5cbi8vIHN1bSBvZiBhbiBhcnJheVxualN0YXQuc3VtID0gZnVuY3Rpb24gc3VtKGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB2YXIgdG1wO1xuICB3aGlsZSAoLS1pID49IDApXG4gICAgc3VtICs9IGFycltpXTtcbiAgcmV0dXJuIHN1bTtcbn07XG5cblxuLy8gc3VtIHNxdWFyZWRcbmpTdGF0LnN1bXNxcmQgPSBmdW5jdGlvbiBzdW1zcXJkKGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApXG4gICAgc3VtICs9IGFycltpXSAqIGFycltpXTtcbiAgcmV0dXJuIHN1bTtcbn07XG5cblxuLy8gc3VtIG9mIHNxdWFyZWQgZXJyb3JzIG9mIHByZWRpY3Rpb24gKFNTRSlcbmpTdGF0LnN1bXNxZXJyID0gZnVuY3Rpb24gc3Vtc3FlcnIoYXJyKSB7XG4gIHZhciBtZWFuID0galN0YXQubWVhbihhcnIpO1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB2YXIgdG1wO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB0bXAgPSBhcnJbaV0gLSBtZWFuO1xuICAgIHN1bSArPSB0bXAgKiB0bXA7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cblxuLy8gcHJvZHVjdCBvZiBhbiBhcnJheVxualN0YXQucHJvZHVjdCA9IGZ1bmN0aW9uIHByb2R1Y3QoYXJyKSB7XG4gIHZhciBwcm9kID0gMTtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApXG4gICAgcHJvZCAqPSBhcnJbaV07XG4gIHJldHVybiBwcm9kO1xufTtcblxuXG4vLyBtaW5pbXVtIHZhbHVlIG9mIGFuIGFycmF5XG5qU3RhdC5taW4gPSBmdW5jdGlvbiBtaW4oYXJyKSB7XG4gIHZhciBsb3cgPSBhcnJbMF07XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGFyci5sZW5ndGgpXG4gICAgaWYgKGFycltpXSA8IGxvdylcbiAgICAgIGxvdyA9IGFycltpXTtcbiAgcmV0dXJuIGxvdztcbn07XG5cblxuLy8gbWF4aW11bSB2YWx1ZSBvZiBhbiBhcnJheVxualN0YXQubWF4ID0gZnVuY3Rpb24gbWF4KGFycikge1xuICB2YXIgaGlnaCA9IGFyclswXTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYXJyLmxlbmd0aClcbiAgICBpZiAoYXJyW2ldID4gaGlnaClcbiAgICAgIGhpZ2ggPSBhcnJbaV07XG4gIHJldHVybiBoaWdoO1xufTtcblxuXG4vLyBtZWFuIHZhbHVlIG9mIGFuIGFycmF5XG5qU3RhdC5tZWFuID0gZnVuY3Rpb24gbWVhbihhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LnN1bShhcnIpIC8gYXJyLmxlbmd0aDtcbn07XG5cblxuLy8gbWVhbiBzcXVhcmVkIGVycm9yIChNU0UpXG5qU3RhdC5tZWFuc3FlcnIgPSBmdW5jdGlvbiBtZWFuc3FlcnIoYXJyKSB7XG4gIHJldHVybiBqU3RhdC5zdW1zcWVycihhcnIpIC8gYXJyLmxlbmd0aDtcbn07XG5cblxuLy8gZ2VvbWV0cmljIG1lYW4gb2YgYW4gYXJyYXlcbmpTdGF0Lmdlb21lYW4gPSBmdW5jdGlvbiBnZW9tZWFuKGFycikge1xuICByZXR1cm4gTWF0aC5wb3coalN0YXQucHJvZHVjdChhcnIpLCAxIC8gYXJyLmxlbmd0aCk7XG59O1xuXG5cbi8vIG1lZGlhbiBvZiBhbiBhcnJheVxualN0YXQubWVkaWFuID0gZnVuY3Rpb24gbWVkaWFuKGFycikge1xuICB2YXIgYXJybGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIF9hcnIgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIC8vIGNoZWNrIGlmIGFycmF5IGlzIGV2ZW4gb3Igb2RkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGVcbiAgcmV0dXJuICEoYXJybGVuICYgMSlcbiAgICA/IChfYXJyWyhhcnJsZW4gLyAyKSAtIDEgXSArIF9hcnJbKGFycmxlbiAvIDIpXSkgLyAyXG4gICAgOiBfYXJyWyhhcnJsZW4gLyAyKSB8IDAgXTtcbn07XG5cblxuLy8gY3VtdWxhdGl2ZSBzdW0gb2YgYW4gYXJyYXlcbmpTdGF0LmN1bXN1bSA9IGZ1bmN0aW9uIGN1bXN1bShhcnIpIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBzdW1zID0gbmV3IEFycmF5KGxlbik7XG4gIHZhciBpO1xuICBzdW1zWzBdID0gYXJyWzBdO1xuICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgc3Vtc1tpXSA9IHN1bXNbaSAtIDFdICsgYXJyW2ldO1xuICByZXR1cm4gc3Vtcztcbn07XG5cblxuLy8gc3VjY2Vzc2l2ZSBkaWZmZXJlbmNlcyBvZiBhIHNlcXVlbmNlXG5qU3RhdC5kaWZmID0gZnVuY3Rpb24gZGlmZihhcnIpIHtcbiAgdmFyIGRpZmZzID0gW107XG4gIHZhciBhcnJMZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMTsgaSA8IGFyckxlbjsgaSsrKVxuICAgIGRpZmZzLnB1c2goYXJyW2ldIC0gYXJyW2kgLSAxXSk7XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLy8gbW9kZSBvZiBhbiBhcnJheVxuLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1vZGVzIG9mIGFuIGFycmF5LCByZXR1cm4gYWxsIG9mIHRoZW1cbi8vIGlzIHRoaXMgdGhlIGFwcHJvcHJpYXRlIHdheSBvZiBoYW5kbGluZyBpdD9cbmpTdGF0Lm1vZGUgPSBmdW5jdGlvbiBtb2RlKGFycikge1xuICB2YXIgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIF9hcnIgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIHZhciBjb3VudCA9IDE7XG4gIHZhciBtYXhDb3VudCA9IDA7XG4gIHZhciBudW1NYXhDb3VudCA9IDA7XG4gIHZhciBtb2RlX2FyciA9IFtdO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYXJyTGVuOyBpKyspIHtcbiAgICBpZiAoX2FycltpXSA9PT0gX2FycltpICsgMV0pIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgIG1vZGVfYXJyID0gW19hcnJbaV1dO1xuICAgICAgICBtYXhDb3VudCA9IGNvdW50O1xuICAgICAgICBudW1NYXhDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICAvLyBhcmUgdGhlcmUgbXVsdGlwbGUgbWF4IGNvdW50c1xuICAgICAgZWxzZSBpZiAoY291bnQgPT09IG1heENvdW50KSB7XG4gICAgICAgIG1vZGVfYXJyLnB1c2goX2FycltpXSk7XG4gICAgICAgIG51bU1heENvdW50Kys7XG4gICAgICB9XG4gICAgICAvLyByZXNldHRpbmcgY291bnQgZm9yIG5ldyB2YWx1ZSBpbiBhcnJheVxuICAgICAgY291bnQgPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudW1NYXhDb3VudCA9PT0gMCA/IG1vZGVfYXJyWzBdIDogbW9kZV9hcnI7XG59O1xuXG5cbi8vIHJhbmdlIG9mIGFuIGFycmF5XG5qU3RhdC5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGFycikge1xuICByZXR1cm4galN0YXQubWF4KGFycikgLSBqU3RhdC5taW4oYXJyKTtcbn07XG5cbi8vIHZhcmlhbmNlIG9mIGFuIGFycmF5XG4vLyBmbGFnIGluZGljYXRlcyBwb3B1bGF0aW9uIHZzIHNhbXBsZVxualN0YXQudmFyaWFuY2UgPSBmdW5jdGlvbiB2YXJpYW5jZShhcnIsIGZsYWcpIHtcbiAgcmV0dXJuIGpTdGF0LnN1bXNxZXJyKGFycikgLyAoYXJyLmxlbmd0aCAtIChmbGFnID8gMSA6IDApKTtcbn07XG5cblxuLy8gc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGFuIGFycmF5XG4vLyBmbGFnIGluZGljYXRlcyBwb3B1bGF0aW9uIHZzIHNhbXBsZVxualN0YXQuc3RkZXYgPSBmdW5jdGlvbiBzdGRldihhcnIsIGZsYWcpIHtcbiAgcmV0dXJuIE1hdGguc3FydChqU3RhdC52YXJpYW5jZShhcnIsIGZsYWcpKTtcbn07XG5cblxuLy8gbWVhbiBkZXZpYXRpb24gKG1lYW4gYWJzb2x1dGUgZGV2aWF0aW9uKSBvZiBhbiBhcnJheVxualN0YXQubWVhbmRldiA9IGZ1bmN0aW9uIG1lYW5kZXYoYXJyKSB7XG4gIHZhciBkZXZTdW0gPSAwO1xuICB2YXIgbWVhbiA9IGpTdGF0Lm1lYW4oYXJyKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICBkZXZTdW0gKz0gTWF0aC5hYnMoYXJyW2ldIC0gbWVhbik7XG4gIHJldHVybiBkZXZTdW0gLyBhcnIubGVuZ3RoO1xufTtcblxuXG4vLyBtZWRpYW4gZGV2aWF0aW9uIChtZWRpYW4gYWJzb2x1dGUgZGV2aWF0aW9uKSBvZiBhbiBhcnJheVxualN0YXQubWVkZGV2ID0gZnVuY3Rpb24gbWVkZGV2KGFycikge1xuICB2YXIgZGV2U3VtID0gMDtcbiAgdmFyIG1lZGlhbiA9IGpTdGF0Lm1lZGlhbihhcnIpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIGRldlN1bSArPSBNYXRoLmFicyhhcnJbaV0gLSBtZWRpYW4pO1xuICByZXR1cm4gZGV2U3VtIC8gYXJyLmxlbmd0aDtcbn07XG5cblxuLy8gY29lZmZpY2llbnQgb2YgdmFyaWF0aW9uXG5qU3RhdC5jb2VmZnZhciA9IGZ1bmN0aW9uIGNvZWZmdmFyKGFycikge1xuICByZXR1cm4galN0YXQuc3RkZXYoYXJyKSAvIGpTdGF0Lm1lYW4oYXJyKTtcbn07XG5cblxuLy8gcXVhcnRpbGVzIG9mIGFuIGFycmF5XG5qU3RhdC5xdWFydGlsZXMgPSBmdW5jdGlvbiBxdWFydGlsZXMoYXJyKSB7XG4gIHZhciBhcnJsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgX2FyciA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgcmV0dXJuIFtcbiAgICBfYXJyWyBNYXRoLnJvdW5kKChhcnJsZW4pIC8gNCkgLSAxIF0sXG4gICAgX2FyclsgTWF0aC5yb3VuZCgoYXJybGVuKSAvIDIpIC0gMSBdLFxuICAgIF9hcnJbIE1hdGgucm91bmQoKGFycmxlbikgKiAzIC8gNCkgLSAxIF1cbiAgXTtcbn07XG5cblxuLy8gQXJiaXRhcnkgcXVhbnRpbGVzIG9mIGFuIGFycmF5LiBEaXJlY3QgcG9ydCBvZiB0aGUgc2NpcHkuc3RhdHNcbi8vIGltcGxlbWVudGF0aW9uIGJ5IFBpZXJyZSBHRiBHZXJhcmQtTWFyY2hhbnQuXG5qU3RhdC5xdWFudGlsZXMgPSBmdW5jdGlvbiBxdWFudGlsZXMoYXJyLCBxdWFudGlsZXNBcnJheSwgYWxwaGFwLCBiZXRhcCkge1xuICB2YXIgc29ydGVkQXJyYXkgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIHZhciBxdWFudGlsZVZhbHMgPSBbcXVhbnRpbGVzQXJyYXkubGVuZ3RoXTtcbiAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaSwgcCwgbSwgYWxlcGgsIGssIGdhbW1hO1xuXG4gIGlmICh0eXBlb2YgYWxwaGFwID09PSAndW5kZWZpbmVkJylcbiAgICBhbHBoYXAgPSAzIC8gODtcbiAgaWYgKHR5cGVvZiBiZXRhcCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgYmV0YXAgPSAzIC8gODtcblxuICBmb3IgKGkgPSAwOyBpIDwgcXVhbnRpbGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBwID0gcXVhbnRpbGVzQXJyYXlbaV07XG4gICAgbSA9IGFscGhhcCArIHAgKiAoMSAtIGFscGhhcCAtIGJldGFwKTtcbiAgICBhbGVwaCA9IG4gKiBwICsgbTtcbiAgICBrID0gTWF0aC5mbG9vcihjbGlwKGFsZXBoLCAxLCBuIC0gMSkpO1xuICAgIGdhbW1hID0gY2xpcChhbGVwaCAtIGssIDAsIDEpO1xuICAgIHF1YW50aWxlVmFsc1tpXSA9ICgxIC0gZ2FtbWEpICogc29ydGVkQXJyYXlbayAtIDFdICsgZ2FtbWEgKiBzb3J0ZWRBcnJheVtrXTtcbiAgfVxuXG4gIHJldHVybiBxdWFudGlsZVZhbHM7XG59O1xuXG4vLyBUaGUgcGVyY2VudGlsZSByYW5rIG9mIHNjb3JlIGluIGEgZ2l2ZW4gYXJyYXkuIFJldHVybnMgdGhlIHBlcmNlbnRhZ2Vcbi8vIG9mIGFsbCB2YWx1ZXMgaW4gdGhlIGlucHV0IGFycmF5IHRoYXQgYXJlIGxlc3MgdGhhbiAoa2luZD0nc3RyaWN0Jykgb3Jcbi8vIGxlc3Mgb3IgZXF1YWwgdGhhbiAoa2luZD0nd2VhaycpIHNjb3JlLiBEZWZhdWx0IGlzIHdlYWsuXG5qU3RhdC5wZXJjZW50aWxlT2ZTY29yZSA9IGZ1bmN0aW9uIHBlcmNlbnRpbGVPZlNjb3JlKGFyciwgc2NvcmUsIGtpbmQpIHtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHN0cmljdCA9IGZhbHNlO1xuICB2YXIgdmFsdWUsIGk7XG5cbiAgaWYgKGtpbmQgPT09ICdzdHJpY3QnKVxuICAgIHN0cmljdCA9IHRydWU7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJbaV07XG4gICAgaWYgKChzdHJpY3QgJiYgdmFsdWUgPCBzY29yZSkgfHxcbiAgICAgICAgKCFzdHJpY3QgJiYgdmFsdWUgPD0gc2NvcmUpKSB7XG4gICAgICBjb3VudGVyKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvdW50ZXIgLyBsZW47XG59O1xuXG4vLyBjb3ZhcmlhbmNlIG9mIHR3byBhcnJheXNcbmpTdGF0LmNvdmFyaWFuY2UgPSBmdW5jdGlvbiBjb3ZhcmlhbmNlKGFycjEsIGFycjIpIHtcbiAgdmFyIHUgPSBqU3RhdC5tZWFuKGFycjEpO1xuICB2YXIgdiA9IGpTdGF0Lm1lYW4oYXJyMik7XG4gIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG4gIHZhciBzcV9kZXYgPSBuZXcgQXJyYXkoYXJyMUxlbik7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBhcnIxTGVuOyBpKyspXG4gICAgc3FfZGV2W2ldID0gKGFycjFbaV0gLSB1KSAqIChhcnIyW2ldIC0gdik7XG5cbiAgcmV0dXJuIGpTdGF0LnN1bShzcV9kZXYpIC8gKGFycjFMZW4gLSAxKTtcbn07XG5cblxuLy8gKHBlYXJzb24ncykgcG9wdWxhdGlvbiBjb3JyZWxhdGlvbiBjb2VmZmljaWVudCwgcmhvXG5qU3RhdC5jb3JyY29lZmYgPSBmdW5jdGlvbiBjb3JyY29lZmYoYXJyMSwgYXJyMikge1xuICByZXR1cm4galN0YXQuY292YXJpYW5jZShhcnIxLCBhcnIyKSAvXG4gICAgICBqU3RhdC5zdGRldihhcnIxLCAxKSAvXG4gICAgICBqU3RhdC5zdGRldihhcnIyLCAxKTtcbn07XG5cblxudmFyIGpQcm90byA9IGpTdGF0LnByb3RvdHlwZTtcblxuXG4vLyBFeHRlbmQgalByb3RvIHdpdGggbWV0aG9kIGZvciBjYWxjdWxhdGluZyBjdW11bGF0aXZlIHN1bXMsIGFzIGl0IGRvZXMgbm90XG4vLyBydW4gYWdhaW4gaW4gY2FzZSBvZiB0cnVlLlxuLy8gSWYgYSBtYXRyaXggaXMgcGFzc2VkLCBhdXRvbWF0aWNhbGx5IGFzc3VtZSBvcGVyYXRpb24gc2hvdWxkIGJlIGRvbmUgb24gdGhlXG4vLyBjb2x1bW5zLlxualByb3RvLmN1bXN1bSA9IGZ1bmN0aW9uKGZ1bGxib29sLCBmdW5jKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgdG1wdGhpcyA9IHRoaXM7XG5cbiAgLy8gQXNzaWdubWVudCByZWFzc2lnbmF0aW9uIGRlcGVuZGluZyBvbiBob3cgcGFyYW1ldGVycyB3ZXJlIHBhc3NlZCBpbi5cbiAgaWYgKGlzRnVuY3Rpb24oZnVsbGJvb2wpKSB7XG4gICAgZnVuYyA9IGZ1bGxib29sO1xuICAgIGZ1bGxib29sID0gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBpZiBhIGNhbGxiYWNrIHdhcyBwYXNzZWQgd2l0aCB0aGUgZnVuY3Rpb24uXG4gIGlmIChmdW5jKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmMuY2FsbCh0bXB0aGlzLCBqUHJvdG8uY3Vtc3VtLmNhbGwodG1wdGhpcywgZnVsbGJvb2wpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIG1hdHJpeCBhbmQgcnVuIGNhbGN1bGF0aW9ucy5cbiAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgIHRtcHRoaXMgPSBmdWxsYm9vbCA9PT0gdHJ1ZSA/IHRoaXMgOiB0aGlzLnRyYW5zcG9zZSgpO1xuICAgIGZvciAoOyBpIDwgdG1wdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgIGFycltpXSA9IGpTdGF0LmN1bXN1bSh0bXB0aGlzW2ldKTtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgcmV0dXJuIGpTdGF0LmN1bXN1bSh0aGlzWzBdLCBmdWxsYm9vbCk7XG59O1xuXG5cbi8vIEV4dGVuZCBqUHJvdG8gd2l0aCBtZXRob2RzIHdoaWNoIGRvbid0IHJlcXVpcmUgYXJndW1lbnRzIGFuZCB3b3JrIG9uIGNvbHVtbnMuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgLy8gSWYgYSBtYXRyaXggaXMgcGFzc2VkLCBhdXRvbWF0aWNhbGx5IGFzc3VtZSBvcGVyYXRpb24gc2hvdWxkIGJlIGRvbmUgb25cbiAgICAvLyB0aGUgY29sdW1ucy5cbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oZnVsbGJvb2wsIGZ1bmMpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB0bXB0aGlzID0gdGhpcztcbiAgICAgIC8vIEFzc2lnbm1lbnQgcmVhc3NpZ25hdGlvbiBkZXBlbmRpbmcgb24gaG93IHBhcmFtZXRlcnMgd2VyZSBwYXNzZWQgaW4uXG4gICAgICBpZiAoaXNGdW5jdGlvbihmdWxsYm9vbCkpIHtcbiAgICAgICAgZnVuYyA9IGZ1bGxib29sO1xuICAgICAgICBmdWxsYm9vbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgYSBjYWxsYmFjayB3YXMgcGFzc2VkIHdpdGggdGhlIGZ1bmN0aW9uLlxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jLmNhbGwodG1wdGhpcywgalByb3RvW3Bhc3NmdW5jXS5jYWxsKHRtcHRoaXMsIGZ1bGxib29sKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGlmIG1hdHJpeCBhbmQgcnVuIGNhbGN1bGF0aW9ucy5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdG1wdGhpcyA9IGZ1bGxib29sID09PSB0cnVlID8gdGhpcyA6IHRoaXMudHJhbnNwb3NlKCk7XG4gICAgICAgIGZvciAoOyBpIDwgdG1wdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhcnJbaV0gPSBqU3RhdFtwYXNzZnVuY10odG1wdGhpc1tpXSk7XG4gICAgICAgIHJldHVybiBmdWxsYm9vbCA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBqU3RhdFtwYXNzZnVuY10oalN0YXQudXRpbHMudG9WZWN0b3IoYXJyKSlcbiAgICAgICAgICAgIDogYXJyO1xuICAgICAgfVxuICAgICAgLy8gUGFzcyBmdWxsYm9vbCBpZiBvbmx5IHZlY3Rvciwgbm90IGEgbWF0cml4LiBmb3IgdmFyaWFuY2UgYW5kIHN0ZGV2LlxuICAgICAgcmV0dXJuIGpTdGF0W3Bhc3NmdW5jXSh0aGlzWzBdLCBmdWxsYm9vbCk7XG4gICAgfTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoKCdzdW0gc3Vtc3FyZCBzdW1zcWVyciBwcm9kdWN0IG1pbiBtYXggbWVhbiBtZWFuc3FlcnIgZ2VvbWVhbiBtZWRpYW4gZGlmZiAnICtcbiAgICAnbW9kZSByYW5nZSB2YXJpYW5jZSBzdGRldiBtZWFuZGV2IG1lZGRldiBjb2VmZnZhciBxdWFydGlsZXMnKS5zcGxpdCgnICcpKTtcblxuXG4vLyBFeHRlbmQgalByb3RvIHdpdGggZnVuY3Rpb25zIHRoYXQgdGFrZSBhcmd1bWVudHMuIE9wZXJhdGlvbnMgb24gbWF0cmljZXMgYXJlXG4vLyBkb25lIG9uIGNvbHVtbnMuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalByb3RvW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHRtcHRoaXMgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAvLyBJZiB0aGUgbGFzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCB3ZSBhc3N1bWUgaXQncyBhIGNhbGxiYWNrOyB3ZVxuICAgICAgLy8gc3RyaXAgdGhlIGNhbGxiYWNrIG91dCBhbmQgY2FsbCB0aGUgZnVuY3Rpb24gYWdhaW4uXG4gICAgICBpZiAoaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHZhciBjYWxsYmFja0Z1bmN0aW9uID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgYXJnc1RvUGFzcyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrRnVuY3Rpb24uY2FsbCh0bXB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUHJvdG9bcGFzc2Z1bmNdLmFwcGx5KHRtcHRoaXMsIGFyZ3NUb1Bhc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBPdGhlcndpc2Ugd2UgY3VycnkgdGhlIGZ1bmN0aW9uIGFyZ3MgYW5kIGNhbGwgbm9ybWFsbHkuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2FsbGJhY2tGdW5jdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGN1cnJpZWRGdW5jdGlvbiA9IGZ1bmN0aW9uIGN1cnJpZWRGdW5jdGlvbih2ZWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4galN0YXRbcGFzc2Z1bmNdLmFwcGx5KHRtcHRoaXMsIFt2ZWN0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIG1hdHJpeCwgcnVuIGNvbHVtbi1ieS1jb2x1bW4uXG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRtcHRoaXMgPSB0bXB0aGlzLnRyYW5zcG9zZSgpO1xuICAgICAgICBmb3IgKDsgaSA8IHRtcHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgYXJyW2ldID0gY3VycmllZEZ1bmN0aW9uKHRtcHRoaXNbaV0pO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UgcnVuIG9uIHRoZSB2ZWN0b3IuXG4gICAgICByZXR1cm4gY3VycmllZEZ1bmN0aW9uKHRoaXNbMF0pO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCdxdWFudGlsZXMgcGVyY2VudGlsZU9mU2NvcmUnLnNwbGl0KCcgJykpO1xuXG59KHRoaXMualN0YXQsIE1hdGgpKTtcbi8vIFNwZWNpYWwgZnVuY3Rpb25zIC8vXG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxuLy8gTG9nLWdhbW1hIGZ1bmN0aW9uXG5qU3RhdC5nYW1tYWxuID0gZnVuY3Rpb24gZ2FtbWFsbih4KSB7XG4gIHZhciBqID0gMDtcbiAgdmFyIGNvZiA9IFtcbiAgICA3Ni4xODAwOTE3Mjk0NzE0NiwgLTg2LjUwNTMyMDMyOTQxNjc3LCAyNC4wMTQwOTgyNDA4MzA5MSxcbiAgICAtMS4yMzE3Mzk1NzI0NTAxNTUsIDAuMTIwODY1MDk3Mzg2NjE3OWUtMiwgLTAuNTM5NTIzOTM4NDk1M2UtNVxuICBdO1xuICB2YXIgc2VyID0gMS4wMDAwMDAwMDAxOTAwMTU7XG4gIHZhciB4eCwgeSwgdG1wO1xuICB0bXAgPSAoeSA9IHh4ID0geCkgKyA1LjU7XG4gIHRtcCAtPSAoeHggKyAwLjUpICogTWF0aC5sb2codG1wKTtcbiAgZm9yICg7IGogPCA2OyBqKyspXG4gICAgc2VyICs9IGNvZltqXSAvICsreTtcbiAgcmV0dXJuIE1hdGgubG9nKDIuNTA2NjI4Mjc0NjMxMDAwNSAqIHNlciAvIHh4KSAtIHRtcDtcbn07XG5cblxuLy8gZ2FtbWEgb2YgeFxualN0YXQuZ2FtbWFmbiA9IGZ1bmN0aW9uIGdhbW1hZm4oeCkge1xuICB2YXIgcCA9IFstMS43MTYxODUxMzg4NjU0OTUsIDI0Ljc2NTY1MDgwNTU3NTkyLCAtMzc5LjgwNDI1NjQ3MDk0NTYzLFxuICAgICAgICAgICA2MjkuMzMxMTU1MzEyODE4NCwgODY2Ljk2NjIwMjc5MDQxMzMsIC0zMTQ1MS4yNzI5Njg4NDgzNjcsXG4gICAgICAgICAgIC0zNjE0NC40MTM0MTg2OTExNzYsIDY2NDU2LjE0MzgyMDI0MDU0XG4gIF07XG4gIHZhciBxID0gWy0zMC44NDAyMzAwMTE5NzM5LCAzMTUuMzUwNjI2OTc5NjA0MTYsIC0xMDE1LjE1NjM2NzQ5MDIxOTIsXG4gICAgICAgICAgIC0zMTA3Ljc3MTY3MTU3MjMxMSwgMjI1MzguMTE4NDIwOTgwMTUxLCA0NzU1Ljg0NjI3NzUyNzg4MTEsXG4gICAgICAgICAgIC0xMzQ2NTkuOTU5ODY0OTY5MywgLTExNTEzMi4yNTk2NzU1NTM1XTtcbiAgdmFyIGZhY3QgPSBmYWxzZTtcbiAgdmFyIG4gPSAwO1xuICB2YXIgeGRlbiA9IDA7XG4gIHZhciB4bnVtID0gMDtcbiAgdmFyIHkgPSB4O1xuICB2YXIgaSwgeiwgeWksIHJlcywgc3VtLCB5c3E7XG4gIGlmICh5IDw9IDApIHtcbiAgICByZXMgPSB5ICUgMSArIDMuNmUtMTY7XG4gICAgaWYgKHJlcykge1xuICAgICAgZmFjdCA9ICghKHkgJiAxKSA/IDEgOiAtMSkgKiBNYXRoLlBJIC8gTWF0aC5zaW4oTWF0aC5QSSAqIHJlcyk7XG4gICAgICB5ID0gMSAtIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gIH1cbiAgeWkgPSB5O1xuICBpZiAoeSA8IDEpIHtcbiAgICB6ID0geSsrO1xuICB9IGVsc2Uge1xuICAgIHogPSAoeSAtPSBuID0gKHkgfCAwKSAtIDEpIC0gMTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgeG51bSA9ICh4bnVtICsgcFtpXSkgKiB6O1xuICAgIHhkZW4gPSB4ZGVuICogeiArIHFbaV07XG4gIH1cbiAgcmVzID0geG51bSAvIHhkZW4gKyAxO1xuICBpZiAoeWkgPCB5KSB7XG4gICAgcmVzIC89IHlpO1xuICB9IGVsc2UgaWYgKHlpID4geSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHJlcyAqPSB5O1xuICAgICAgeSsrO1xuICAgIH1cbiAgfVxuICBpZiAoZmFjdCkge1xuICAgIHJlcyA9IGZhY3QgLyByZXM7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuLy8gbG93ZXIgaW5jb21wbGV0ZSBnYW1tYSBmdW5jdGlvbiBQKGEseClcbmpTdGF0LmdhbW1hcCA9IGZ1bmN0aW9uIGdhbW1hcChhLCB4KSB7XG4gIHZhciBhbG4gPSBqU3RhdC5nYW1tYWxuKGEpO1xuICB2YXIgYXAgPSBhO1xuICB2YXIgc3VtID0gMSAvIGE7XG4gIHZhciBkZWwgPSBzdW07XG4gIHZhciBiID0geCArIDEgLSBhO1xuICB2YXIgYyA9IDEgLyAxLjBlLTMwO1xuICB2YXIgZCA9IDEgLyBiO1xuICB2YXIgaCA9IGQ7XG4gIHZhciBpID0gMTtcbiAgLy8gY2FsY3VsYXRlIG1heGltdW0gbnVtYmVyIG9mIGl0dGVyYXRpb25zIHJlcXVpcmVkIGZvciBhXG4gIHZhciBJVE1BWCA9IC1+KE1hdGgubG9nKChhID49IDEpID8gYSA6IDEgLyBhKSAqIDguNSArIGEgKiAwLjQgKyAxNyk7XG4gIHZhciBhbiwgZW5kdmFsO1xuXG4gIGlmICh4IDwgMCB8fCBhIDw9IDApIHtcbiAgICByZXR1cm4gTmFOO1xuICB9IGVsc2UgaWYgKHggPCBhICsgMSkge1xuICAgIGZvciAoOyBpIDw9IElUTUFYOyBpKyspIHtcbiAgICAgIHN1bSArPSBkZWwgKj0geCAvICsrYXA7XG4gICAgfVxuICAgIHJldHVybiBzdW0gKiBNYXRoLmV4cCgteCArIGEgKiBNYXRoLmxvZyh4KSAtIChhbG4pKTtcbiAgfVxuXG4gIGZvciAoOyBpIDw9IElUTUFYOyBpKyspIHtcbiAgICBhbiA9IC1pICogKGkgLSBhKTtcbiAgICBiICs9IDI7XG4gICAgZCA9IGFuICogZCArIGI7XG4gICAgYyA9IGIgKyBhbiAvIGM7XG4gICAgZCA9IDEgLyBkO1xuICAgIGggKj0gZCAqIGM7XG4gIH1cblxuICByZXR1cm4gMSAtIGggKiBNYXRoLmV4cCgteCArIGEgKiBNYXRoLmxvZyh4KSAtIChhbG4pKTtcbn07XG5cblxuLy8gbmF0dXJhbCBsb2cgZmFjdG9yaWFsIG9mIG5cbmpTdGF0LmZhY3RvcmlhbGxuID0gZnVuY3Rpb24gZmFjdG9yaWFsbG4obikge1xuICByZXR1cm4gbiA8IDAgPyBOYU4gOiBqU3RhdC5nYW1tYWxuKG4gKyAxKTtcbn07XG5cbi8vIGZhY3RvcmlhbCBvZiBuXG5qU3RhdC5mYWN0b3JpYWwgPSBmdW5jdGlvbiBmYWN0b3JpYWwobikge1xuICByZXR1cm4gbiA8IDAgPyBOYU4gOiBqU3RhdC5nYW1tYWZuKG4gKyAxKTtcbn07XG5cbi8vIGNvbWJpbmF0aW9ucyBvZiBuLCBtXG5qU3RhdC5jb21iaW5hdGlvbiA9IGZ1bmN0aW9uIGNvbWJpbmF0aW9uKG4sIG0pIHtcbiAgLy8gbWFrZSBzdXJlIG4gb3IgbSBkb24ndCBleGNlZWQgdGhlIHVwcGVyIGxpbWl0IG9mIHVzYWJsZSB2YWx1ZXNcbiAgcmV0dXJuIChuID4gMTcwIHx8IG0gPiAxNzApXG4gICAgICA/IE1hdGguZXhwKGpTdGF0LmNvbWJpbmF0aW9ubG4obiwgbSkpXG4gICAgICA6IChqU3RhdC5mYWN0b3JpYWwobikgLyBqU3RhdC5mYWN0b3JpYWwobSkpIC8galN0YXQuZmFjdG9yaWFsKG4gLSBtKTtcbn07XG5cblxualN0YXQuY29tYmluYXRpb25sbiA9IGZ1bmN0aW9uIGNvbWJpbmF0aW9ubG4obiwgbSl7XG4gIHJldHVybiBqU3RhdC5mYWN0b3JpYWxsbihuKSAtIGpTdGF0LmZhY3RvcmlhbGxuKG0pIC0galN0YXQuZmFjdG9yaWFsbG4obiAtIG0pO1xufTtcblxuXG4vLyBwZXJtdXRhdGlvbnMgb2YgbiwgbVxualN0YXQucGVybXV0YXRpb24gPSBmdW5jdGlvbiBwZXJtdXRhdGlvbihuLCBtKSB7XG4gIHJldHVybiBqU3RhdC5mYWN0b3JpYWwobikgLyBqU3RhdC5mYWN0b3JpYWwobiAtIG0pO1xufTtcblxuXG4vLyBiZXRhIGZ1bmN0aW9uXG5qU3RhdC5iZXRhZm4gPSBmdW5jdGlvbiBiZXRhZm4oeCwgeSkge1xuICAvLyBlbnN1cmUgYXJndW1lbnRzIGFyZSBwb3NpdGl2ZVxuICBpZiAoeCA8PSAwIHx8IHkgPD0gMClcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAvLyBtYWtlIHN1cmUgeCArIHkgZG9lc24ndCBleGNlZWQgdGhlIHVwcGVyIGxpbWl0IG9mIHVzYWJsZSB2YWx1ZXNcbiAgcmV0dXJuICh4ICsgeSA+IDE3MClcbiAgICAgID8gTWF0aC5leHAoalN0YXQuYmV0YWxuKHgsIHkpKVxuICAgICAgOiBqU3RhdC5nYW1tYWZuKHgpICogalN0YXQuZ2FtbWFmbih5KSAvIGpTdGF0LmdhbW1hZm4oeCArIHkpO1xufTtcblxuXG4vLyBuYXR1cmFsIGxvZ2FyaXRobSBvZiBiZXRhIGZ1bmN0aW9uXG5qU3RhdC5iZXRhbG4gPSBmdW5jdGlvbiBiZXRhbG4oeCwgeSkge1xuICByZXR1cm4galN0YXQuZ2FtbWFsbih4KSArIGpTdGF0LmdhbW1hbG4oeSkgLSBqU3RhdC5nYW1tYWxuKHggKyB5KTtcbn07XG5cblxuLy8gRXZhbHVhdGVzIHRoZSBjb250aW51ZWQgZnJhY3Rpb24gZm9yIGluY29tcGxldGUgYmV0YSBmdW5jdGlvbiBieSBtb2RpZmllZFxuLy8gTGVudHoncyBtZXRob2QuXG5qU3RhdC5iZXRhY2YgPSBmdW5jdGlvbiBiZXRhY2YoeCwgYSwgYikge1xuICB2YXIgZnBtaW4gPSAxZS0zMDtcbiAgdmFyIG0gPSAxO1xuICB2YXIgcWFiID0gYSArIGI7XG4gIHZhciBxYXAgPSBhICsgMTtcbiAgdmFyIHFhbSA9IGEgLSAxO1xuICB2YXIgYyA9IDE7XG4gIHZhciBkID0gMSAtIHFhYiAqIHggLyBxYXA7XG4gIHZhciBtMiwgYWEsIGRlbCwgaDtcblxuICAvLyBUaGVzZSBxJ3Mgd2lsbCBiZSB1c2VkIGluIGZhY3RvcnMgdGhhdCBvY2N1ciBpbiB0aGUgY29lZmZpY2llbnRzXG4gIGlmIChNYXRoLmFicyhkKSA8IGZwbWluKVxuICAgIGQgPSBmcG1pbjtcbiAgZCA9IDEgLyBkO1xuICBoID0gZDtcblxuICBmb3IgKDsgbSA8PSAxMDA7IG0rKykge1xuICAgIG0yID0gMiAqIG07XG4gICAgYWEgPSBtICogKGIgLSBtKSAqIHggLyAoKHFhbSArIG0yKSAqIChhICsgbTIpKTtcbiAgICAvLyBPbmUgc3RlcCAodGhlIGV2ZW4gb25lKSBvZiB0aGUgcmVjdXJyZW5jZVxuICAgIGQgPSAxICsgYWEgKiBkO1xuICAgIGlmIChNYXRoLmFicyhkKSA8IGZwbWluKVxuICAgICAgZCA9IGZwbWluO1xuICAgIGMgPSAxICsgYWEgLyBjO1xuICAgIGlmIChNYXRoLmFicyhjKSA8IGZwbWluKVxuICAgICAgYyA9IGZwbWluO1xuICAgIGQgPSAxIC8gZDtcbiAgICBoICo9IGQgKiBjO1xuICAgIGFhID0gLShhICsgbSkgKiAocWFiICsgbSkgKiB4IC8gKChhICsgbTIpICogKHFhcCArIG0yKSk7XG4gICAgLy8gTmV4dCBzdGVwIG9mIHRoZSByZWN1cnJlbmNlICh0aGUgb2RkIG9uZSlcbiAgICBkID0gMSArIGFhICogZDtcbiAgICBpZiAoTWF0aC5hYnMoZCkgPCBmcG1pbilcbiAgICAgIGQgPSBmcG1pbjtcbiAgICBjID0gMSArIGFhIC8gYztcbiAgICBpZiAoTWF0aC5hYnMoYykgPCBmcG1pbilcbiAgICAgIGMgPSBmcG1pbjtcbiAgICBkID0gMSAvIGQ7XG4gICAgZGVsID0gZCAqIGM7XG4gICAgaCAqPSBkZWw7XG4gICAgaWYgKE1hdGguYWJzKGRlbCAtIDEuMCkgPCAzZS03KVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gaDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgaW52ZXJzZSBpbmNvbXBsdGUgZ2FtbWEgZnVuY3Rpb25cbmpTdGF0LmdhbW1hcGludiA9IGZ1bmN0aW9uIGdhbW1hcGludihwLCBhKSB7XG4gIHZhciBqID0gMDtcbiAgdmFyIGExID0gYSAtIDE7XG4gIHZhciBFUFMgPSAxZS04O1xuICB2YXIgZ2xuID0galN0YXQuZ2FtbWFsbihhKTtcbiAgdmFyIHgsIGVyciwgdCwgdSwgcHAsIGxuYTEsIGFmYWM7XG5cbiAgaWYgKHAgPj0gMSlcbiAgICByZXR1cm4gTWF0aC5tYXgoMTAwLCBhICsgMTAwICogTWF0aC5zcXJ0KGEpKTtcbiAgaWYgKHAgPD0gMClcbiAgICByZXR1cm4gMDtcbiAgaWYgKGEgPiAxKSB7XG4gICAgbG5hMSA9IE1hdGgubG9nKGExKTtcbiAgICBhZmFjID0gTWF0aC5leHAoYTEgKiAobG5hMSAtIDEpIC0gZ2xuKTtcbiAgICBwcCA9IChwIDwgMC41KSA/IHAgOiAxIC0gcDtcbiAgICB0ID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocHApKTtcbiAgICB4ID0gKDIuMzA3NTMgKyB0ICogMC4yNzA2MSkgLyAoMSArIHQgKiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0O1xuICAgIGlmIChwIDwgMC41KVxuICAgICAgeCA9IC14O1xuICAgIHggPSBNYXRoLm1heCgxZS0zLFxuICAgICAgICAgICAgICAgICBhICogTWF0aC5wb3coMSAtIDEgLyAoOSAqIGEpIC0geCAvICgzICogTWF0aC5zcXJ0KGEpKSwgMykpO1xuICB9IGVsc2Uge1xuICAgIHQgPSAxIC0gYSAqICgwLjI1MyArIGEgKiAwLjEyKTtcbiAgICBpZiAocCA8IHQpXG4gICAgICB4ID0gTWF0aC5wb3cocCAvIHQsIDEgLyBhKTtcbiAgICBlbHNlXG4gICAgICB4ID0gMSAtIE1hdGgubG9nKDEgLSAocCAtIHQpIC8gKDEgLSB0KSk7XG4gIH1cblxuICBmb3IoOyBqIDwgMTI7IGorKykge1xuICAgIGlmICh4IDw9IDApXG4gICAgICByZXR1cm4gMDtcbiAgICBlcnIgPSBqU3RhdC5nYW1tYXAoYSwgeCkgLSBwO1xuICAgIGlmIChhID4gMSlcbiAgICAgIHQgPSBhZmFjICogTWF0aC5leHAoLSh4IC0gYTEpICsgYTEgKiAoTWF0aC5sb2coeCkgLSBsbmExKSk7XG4gICAgZWxzZVxuICAgICAgdCA9IE1hdGguZXhwKC14ICsgYTEgKiBNYXRoLmxvZyh4KSAtIGdsbik7XG4gICAgdSA9IGVyciAvIHQ7XG4gICAgeCAtPSAodCA9IHUgLyAoMSAtIDAuNSAqIE1hdGgubWluKDEsIHUgKiAoKGEgLSAxKSAvIHggLSAxKSkpKTtcbiAgICBpZiAoeCA8PSAwKVxuICAgICAgeCA9IDAuNSAqICh4ICsgdCk7XG4gICAgaWYgKE1hdGguYWJzKHQpIDwgRVBTICogeClcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGVycm9yIGZ1bmN0aW9uIGVyZih4KVxualN0YXQuZXJmID0gZnVuY3Rpb24gZXJmKHgpIHtcbiAgdmFyIGNvZiA9IFstMS4zMDI2NTM3MTk3ODE3MDk0LCA2LjQxOTY5NzkyMzU2NDkwMjZlLTEsIDEuOTQ3NjQ3MzIwNDE4NTgzNmUtMixcbiAgICAgICAgICAgICAtOS41NjE1MTQ3ODY4MDg2MzFlLTMsIC05LjQ2NTk1MzQ0NDgyMDM2ZS00LCAzLjY2ODM5NDk3ODUyNzYxZS00LFxuICAgICAgICAgICAgIDQuMjUyMzMyNDgwNjkwN2UtNSwgLTIuMDI3ODU3ODExMjUzNGUtNSwgLTEuNjI0MjkwMDA0NjQ3ZS02LFxuICAgICAgICAgICAgIDEuMzAzNjU1ODM1NTgwZS02LCAxLjU2MjY0NDE3MjJlLTgsIC04LjUyMzgwOTU5MTVlLTgsXG4gICAgICAgICAgICAgNi41MjkwNTQ0MzllLTksIDUuMDU5MzQzNDk1ZS05LCAtOS45MTM2NDE1NmUtMTAsXG4gICAgICAgICAgICAgLTIuMjczNjUxMjJlLTEwLCA5LjY0Njc5MTFlLTExLCAyLjM5NDAzOGUtMTIsXG4gICAgICAgICAgICAgLTYuODg2MDI3ZS0xMiwgOC45NDQ4N2UtMTMsIDMuMTMwOTJlLTEzLFxuICAgICAgICAgICAgIC0xLjEyNzA4ZS0xMywgMy44MWUtMTYsIDcuMTA2ZS0xNSxcbiAgICAgICAgICAgICAtMS41MjNlLTE1LCAtOS40ZS0xNywgMS4yMWUtMTYsXG4gICAgICAgICAgICAgLTIuOGUtMTddO1xuICB2YXIgaiA9IGNvZi5sZW5ndGggLSAxO1xuICB2YXIgaXNuZWcgPSBmYWxzZTtcbiAgdmFyIGQgPSAwO1xuICB2YXIgZGQgPSAwO1xuICB2YXIgdCwgdHksIHRtcCwgcmVzO1xuXG4gIGlmICh4IDwgMCkge1xuICAgIHggPSAteDtcbiAgICBpc25lZyA9IHRydWU7XG4gIH1cblxuICB0ID0gMiAvICgyICsgeCk7XG4gIHR5ID0gNCAqIHQgLSAyO1xuXG4gIGZvcig7IGogPiAwOyBqLS0pIHtcbiAgICB0bXAgPSBkO1xuICAgIGQgPSB0eSAqIGQgLSBkZCArIGNvZltqXTtcbiAgICBkZCA9IHRtcDtcbiAgfVxuXG4gIHJlcyA9IHQgKiBNYXRoLmV4cCgteCAqIHggKyAwLjUgKiAoY29mWzBdICsgdHkgKiBkKSAtIGRkKTtcbiAgcmV0dXJuIGlzbmVnID8gcmVzIC0gMSA6IDEgLSByZXM7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGNvbXBsbWVudGFyeSBlcnJvciBmdW5jdGlvbiBlcmZjKHgpXG5qU3RhdC5lcmZjID0gZnVuY3Rpb24gZXJmYyh4KSB7XG4gIHJldHVybiAxIC0galN0YXQuZXJmKHgpO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wbGVtZW50YXJ5IGVycm9yIGZ1bmN0aW9uXG5qU3RhdC5lcmZjaW52ID0gZnVuY3Rpb24gZXJmY2ludihwKSB7XG4gIHZhciBqID0gMDtcbiAgdmFyIHgsIGVyciwgdCwgcHA7XG4gIGlmIChwID49IDIpXG4gICAgcmV0dXJuIC0xMDA7XG4gIGlmIChwIDw9IDApXG4gICAgcmV0dXJuIDEwMDtcbiAgcHAgPSAocCA8IDEpID8gcCA6IDIgLSBwO1xuICB0ID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocHAgLyAyKSk7XG4gIHggPSAtMC43MDcxMSAqICgoMi4zMDc1MyArIHQgKiAwLjI3MDYxKSAvXG4gICAgICAgICAgICAgICAgICAoMSArIHQgKiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0KTtcbiAgZm9yICg7IGogPCAyOyBqKyspIHtcbiAgICBlcnIgPSBqU3RhdC5lcmZjKHgpIC0gcHA7XG4gICAgeCArPSBlcnIgLyAoMS4xMjgzNzkxNjcwOTU1MTI1NyAqIE1hdGguZXhwKC14ICogeCkgLSB4ICogZXJyKTtcbiAgfVxuICByZXR1cm4gKHAgPCAxKSA/IHggOiAteDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgaW5jb21wbGV0ZSBiZXRhIGZ1bmN0aW9uXG5qU3RhdC5pYmV0YWludiA9IGZ1bmN0aW9uIGliZXRhaW52KHAsIGEsIGIpIHtcbiAgdmFyIEVQUyA9IDFlLTg7XG4gIHZhciBhMSA9IGEgLSAxO1xuICB2YXIgYjEgPSBiIC0gMTtcbiAgdmFyIGogPSAwO1xuICB2YXIgbG5hLCBsbmIsIHBwLCB0LCB1LCBlcnIsIHgsIGFsLCBoLCB3LCBhZmFjO1xuICBpZiAocCA8PSAwKVxuICAgIHJldHVybiAwO1xuICBpZiAocCA+PSAxKVxuICAgIHJldHVybiAxO1xuICBpZiAoYSA+PSAxICYmIGIgPj0gMSkge1xuICAgIHBwID0gKHAgPCAwLjUpID8gcCA6IDEgLSBwO1xuICAgIHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhwcCkpO1xuICAgIHggPSAoMi4zMDc1MyArIHQgKiAwLjI3MDYxKSAvICgxICsgdCogKDAuOTkyMjkgKyB0ICogMC4wNDQ4MSkpIC0gdDtcbiAgICBpZiAocCA8IDAuNSlcbiAgICAgIHggPSAteDtcbiAgICBhbCA9ICh4ICogeCAtIDMpIC8gNjtcbiAgICBoID0gMiAvICgxIC8gKDIgKiBhIC0gMSkgICsgMSAvICgyICogYiAtIDEpKTtcbiAgICB3ID0gKHggKiBNYXRoLnNxcnQoYWwgKyBoKSAvIGgpIC0gKDEgLyAoMiAqIGIgLSAxKSAtIDEgLyAoMiAqIGEgLSAxKSkgKlxuICAgICAgICAoYWwgKyA1IC8gNiAtIDIgLyAoMyAqIGgpKTtcbiAgICB4ID0gYSAvIChhICsgYiAqIE1hdGguZXhwKDIgKiB3KSk7XG4gIH0gZWxzZSB7XG4gICAgbG5hID0gTWF0aC5sb2coYSAvIChhICsgYikpO1xuICAgIGxuYiA9IE1hdGgubG9nKGIgLyAoYSArIGIpKTtcbiAgICB0ID0gTWF0aC5leHAoYSAqIGxuYSkgLyBhO1xuICAgIHUgPSBNYXRoLmV4cChiICogbG5iKSAvIGI7XG4gICAgdyA9IHQgKyB1O1xuICAgIGlmIChwIDwgdCAvIHcpXG4gICAgICB4ID0gTWF0aC5wb3coYSAqIHcgKiBwLCAxIC8gYSk7XG4gICAgZWxzZVxuICAgICAgeCA9IDEgLSBNYXRoLnBvdyhiICogdyAqICgxIC0gcCksIDEgLyBiKTtcbiAgfVxuICBhZmFjID0gLWpTdGF0LmdhbW1hbG4oYSkgLSBqU3RhdC5nYW1tYWxuKGIpICsgalN0YXQuZ2FtbWFsbihhICsgYik7XG4gIGZvcig7IGogPCAxMDsgaisrKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gMSlcbiAgICAgIHJldHVybiB4O1xuICAgIGVyciA9IGpTdGF0LmliZXRhKHgsIGEsIGIpIC0gcDtcbiAgICB0ID0gTWF0aC5leHAoYTEgKiBNYXRoLmxvZyh4KSArIGIxICogTWF0aC5sb2coMSAtIHgpICsgYWZhYyk7XG4gICAgdSA9IGVyciAvIHQ7XG4gICAgeCAtPSAodCA9IHUgLyAoMSAtIDAuNSAqIE1hdGgubWluKDEsIHUgKiAoYTEgLyB4IC0gYjEgLyAoMSAtIHgpKSkpKTtcbiAgICBpZiAoeCA8PSAwKVxuICAgICAgeCA9IDAuNSAqICh4ICsgdCk7XG4gICAgaWYgKHggPj0gMSlcbiAgICAgIHggPSAwLjUgKiAoeCArIHQgKyAxKTtcbiAgICBpZiAoTWF0aC5hYnModCkgPCBFUFMgKiB4ICYmIGogPiAwKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGluY29tcGxldGUgYmV0YSBmdW5jdGlvbiBJX3goYSxiKVxualN0YXQuaWJldGEgPSBmdW5jdGlvbiBpYmV0YSh4LCBhLCBiKSB7XG4gIC8vIEZhY3RvcnMgaW4gZnJvbnQgb2YgdGhlIGNvbnRpbnVlZCBmcmFjdGlvbi5cbiAgdmFyIGJ0ID0gKHggPT09IDAgfHwgeCA9PT0gMSkgPyAgMCA6XG4gICAgTWF0aC5leHAoalN0YXQuZ2FtbWFsbihhICsgYikgLSBqU3RhdC5nYW1tYWxuKGEpIC1cbiAgICAgICAgICAgICBqU3RhdC5nYW1tYWxuKGIpICsgYSAqIE1hdGgubG9nKHgpICsgYiAqXG4gICAgICAgICAgICAgTWF0aC5sb2coMSAtIHgpKTtcbiAgaWYgKHggPCAwIHx8IHggPiAxKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHggPCAoYSArIDEpIC8gKGEgKyBiICsgMikpXG4gICAgLy8gVXNlIGNvbnRpbnVlZCBmcmFjdGlvbiBkaXJlY3RseS5cbiAgICByZXR1cm4gYnQgKiBqU3RhdC5iZXRhY2YoeCwgYSwgYikgLyBhO1xuICAvLyBlbHNlIHVzZSBjb250aW51ZWQgZnJhY3Rpb24gYWZ0ZXIgbWFraW5nIHRoZSBzeW1tZXRyeSB0cmFuc2Zvcm1hdGlvbi5cbiAgcmV0dXJuIDEgLSBidCAqIGpTdGF0LmJldGFjZigxIC0geCwgYiwgYSkgLyBiO1xufTtcblxuXG4vLyBSZXR1cm5zIGEgbm9ybWFsIGRldmlhdGUgKG11PTAsIHNpZ21hPTEpLlxuLy8gSWYgbiBhbmQgbSBhcmUgc3BlY2lmaWVkIGl0IHJldHVybnMgYSBvYmplY3Qgb2Ygbm9ybWFsIGRldmlhdGVzLlxualN0YXQucmFuZG4gPSBmdW5jdGlvbiByYW5kbihuLCBtKSB7XG4gIHZhciB1LCB2LCB4LCB5LCBxLCBtYXQ7XG4gIGlmICghbSlcbiAgICBtID0gbjtcbiAgaWYgKG4pXG4gICAgcmV0dXJuIGpTdGF0LmNyZWF0ZShuLCBtLCBmdW5jdGlvbigpIHsgcmV0dXJuIGpTdGF0LnJhbmRuKCk7IH0pO1xuICBkbyB7XG4gICAgdSA9IE1hdGgucmFuZG9tKCk7XG4gICAgdiA9IDEuNzE1NiAqIChNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICB4ID0gdSAtIDAuNDQ5ODcxO1xuICAgIHkgPSBNYXRoLmFicyh2KSArIDAuMzg2NTk1O1xuICAgIHEgPSB4ICogeCArIHkgKiAoMC4xOTYwMCAqIHkgLSAwLjI1NDcyICogeCk7XG4gIH0gd2hpbGUgKHEgPiAwLjI3NTk3ICYmIChxID4gMC4yNzg0NiB8fCB2ICogdiA+IC00ICogTWF0aC5sb2codSkgKiB1ICogdSkpO1xuICByZXR1cm4gdiAvIHU7XG59O1xuXG5cbi8vIFJldHVybnMgYSBnYW1tYSBkZXZpYXRlIGJ5IHRoZSBtZXRob2Qgb2YgTWFyc2FnbGlhIGFuZCBUc2FuZy5cbmpTdGF0LnJhbmRnID0gZnVuY3Rpb24gcmFuZGcoc2hhcGUsIG4sIG0pIHtcbiAgdmFyIG9hbHBoID0gc2hhcGU7XG4gIHZhciBhMSwgYTIsIHUsIHYsIHgsIG1hdDtcbiAgaWYgKCFtKVxuICAgIG0gPSBuO1xuICBpZiAoIXNoYXBlKVxuICAgIHNoYXBlID0gMTtcbiAgaWYgKG4pIHtcbiAgICBtYXQgPSBqU3RhdC56ZXJvcyhuLG0pO1xuICAgIG1hdC5hbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIGpTdGF0LnJhbmRnKHNoYXBlKTsgfSk7XG4gICAgcmV0dXJuIG1hdDtcbiAgfVxuICBpZiAoc2hhcGUgPCAxKVxuICAgIHNoYXBlICs9IDE7XG4gIGExID0gc2hhcGUgLSAxIC8gMztcbiAgYTIgPSAxIC8gTWF0aC5zcXJ0KDkgKiBhMSk7XG4gIGRvIHtcbiAgICBkbyB7XG4gICAgICB4ID0galN0YXQucmFuZG4oKTtcbiAgICAgIHYgPSAxICsgYTIgKiB4O1xuICAgIH0gd2hpbGUodiA8PSAwKTtcbiAgICB2ID0gdiAqIHYgKiB2O1xuICAgIHUgPSBNYXRoLnJhbmRvbSgpO1xuICB9IHdoaWxlKHUgPiAxIC0gMC4zMzEgKiBNYXRoLnBvdyh4LCA0KSAmJlxuICAgICAgICAgIE1hdGgubG9nKHUpID4gMC41ICogeCp4ICsgYTEgKiAoMSAtIHYgKyBNYXRoLmxvZyh2KSkpO1xuICAvLyBhbHBoYSA+IDFcbiAgaWYgKHNoYXBlID09IG9hbHBoKVxuICAgIHJldHVybiBhMSAqIHY7XG4gIC8vIGFscGhhIDwgMVxuICBkbyB7XG4gICAgdSA9IE1hdGgucmFuZG9tKCk7XG4gIH0gd2hpbGUodSA9PT0gMCk7XG4gIHJldHVybiBNYXRoLnBvdyh1LCAxIC8gb2FscGgpICogYTEgKiB2O1xufTtcblxuXG4vLyBtYWtpbmcgdXNlIG9mIHN0YXRpYyBtZXRob2RzIG9uIHRoZSBpbnN0YW5jZVxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpTdGF0LmZuW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGpTdGF0KFxuICAgICAgICAgIGpTdGF0Lm1hcCh0aGlzLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4galN0YXRbcGFzc2Z1bmNdKHZhbHVlKTsgfSkpO1xuICAgIH1cbiAgfSkoZnVuY3NbaV0pO1xufSkoJ2dhbW1hbG4gZ2FtbWFmbiBmYWN0b3JpYWwgZmFjdG9yaWFsbG4nLnNwbGl0KCcgJykpO1xuXG5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqU3RhdC5mbltwYXNzZnVuY10gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBqU3RhdChqU3RhdFtwYXNzZnVuY10uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoJ3JhbmRuJy5zcGxpdCgnICcpKTtcblxufSh0aGlzLmpTdGF0LCBNYXRoKSk7XG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxuLy8gZ2VuZXJhdGUgYWxsIGRpc3RyaWJ1dGlvbiBpbnN0YW5jZSBtZXRob2RzXG4oZnVuY3Rpb24obGlzdCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIChmdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gZGlzdHJpYnV0aW9uIGluc3RhbmNlIG1ldGhvZFxuICAgIGpTdGF0W2Z1bmNdID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGFyZ3VtZW50cy5jYWxsZWUpKVxuICAgICAgICByZXR1cm4gbmV3IGFyZ3VtZW50cy5jYWxsZWUoYSwgYiwgYyk7XG4gICAgICB0aGlzLl9hID0gYTtcbiAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIGRpc3RyaWJ1dGlvbiBtZXRob2QgdG8gYmUgdXNlZCBvbiBhIGpTdGF0IGluc3RhbmNlXG4gICAgalN0YXQuZm5bZnVuY10gPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICB2YXIgbmV3dGhpcyA9IGpTdGF0W2Z1bmNdKGEsIGIsIGMpO1xuICAgICAgbmV3dGhpcy5kYXRhID0gdGhpcztcbiAgICAgIHJldHVybiBuZXd0aGlzO1xuICAgIH07XG4gICAgLy8gc2FtcGxlIGluc3RhbmNlIG1ldGhvZFxuICAgIGpTdGF0W2Z1bmNdLnByb3RvdHlwZS5zYW1wbGUgPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHZhciBhID0gdGhpcy5fYTtcbiAgICAgIHZhciBiID0gdGhpcy5fYjtcbiAgICAgIHZhciBjID0gdGhpcy5fYztcbiAgICAgIGlmIChhcnIpXG4gICAgICAgIHJldHVybiBqU3RhdC5hbHRlcihhcnIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBqU3RhdFtmdW5jXS5zYW1wbGUoYSwgYiwgYyk7XG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4galN0YXRbZnVuY10uc2FtcGxlKGEsIGIsIGMpO1xuICAgIH07XG4gICAgLy8gZ2VuZXJhdGUgdGhlIHBkZiwgY2RmIGFuZCBpbnYgaW5zdGFuY2UgbWV0aG9kc1xuICAgIChmdW5jdGlvbih2YWxzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIChmdW5jdGlvbihmbmZ1bmMpIHtcbiAgICAgICAgalN0YXRbZnVuY10ucHJvdG90eXBlW2ZuZnVuY10gPSBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLl9hO1xuICAgICAgICAgIHZhciBiID0gdGhpcy5fYjtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMuX2M7XG4gICAgICAgICAgaWYgKCF4ICYmIHggIT09IDApXG4gICAgICAgICAgICB4ID0gdGhpcy5kYXRhO1xuICAgICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBqU3RhdC5mbi5tYXAuY2FsbCh4LCBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBqU3RhdFtmdW5jXVtmbmZ1bmNdKHgsIGEsIGIsIGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBqU3RhdFtmdW5jXVtmbmZ1bmNdKHgsIGEsIGIsIGMpO1xuICAgICAgICB9O1xuICAgICAgfSkodmFsc1tpXSk7XG4gICAgfSkoJ3BkZiBjZGYgaW52Jy5zcGxpdCgnICcpKTtcbiAgICAvLyBnZW5lcmF0ZSB0aGUgbWVhbiwgbWVkaWFuLCBtb2RlIGFuZCB2YXJpYW5jZSBpbnN0YW5jZSBtZXRob2RzXG4gICAgKGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKGZuZnVuYykge1xuICAgICAgICBqU3RhdFtmdW5jXS5wcm90b3R5cGVbZm5mdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBqU3RhdFtmdW5jXVtmbmZ1bmNdKHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MpO1xuICAgICAgICB9O1xuICAgICAgfSkodmFsc1tpXSk7XG4gICAgfSkoJ21lYW4gbWVkaWFuIG1vZGUgdmFyaWFuY2UnLnNwbGl0KCcgJykpO1xuICB9KShsaXN0W2ldKTtcbn0pKChcbiAgJ2JldGEgY2VudHJhbEYgY2F1Y2h5IGNoaXNxdWFyZSBleHBvbmVudGlhbCBnYW1tYSBpbnZnYW1tYSBrdW1hcmFzd2FteSAnICtcbiAgJ2xvZ25vcm1hbCBub3JtYWwgcGFyZXRvIHN0dWRlbnR0IHdlaWJ1bGwgdW5pZm9ybSAgYmlub21pYWwgbmVnYmluIGh5cGdlb20gJyArXG4gICdwb2lzc29uIHRyaWFuZ3VsYXInXG4pLnNwbGl0KCcgJykpO1xuXG5cblxuLy8gZXh0ZW5kIGJldGEgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmJldGEsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICAvLyBQREYgaXMgemVybyBvdXRzaWRlIHRoZSBzdXBwb3J0XG4gICAgaWYgKHggPiAxIHx8IHggPCAwKVxuICAgICAgcmV0dXJuIDA7XG4gICAgLy8gUERGIGlzIG9uZSBmb3IgdGhlIHVuaWZvcm0gY2FzZVxuICAgIGlmIChhbHBoYSA9PSAxICYmIGJldGEgPT0gMSlcbiAgICAgIHJldHVybiAxO1xuXG4gICAgaWYgKGFscGhhIDwgNTEyIHx8IGJldGEgPCA1MTIpIHtcbiAgICAgIHJldHVybiAoTWF0aC5wb3coeCwgYWxwaGEgLSAxKSAqIE1hdGgucG93KDEgLSB4LCBiZXRhIC0gMSkpIC9cbiAgICAgICAgICBqU3RhdC5iZXRhZm4oYWxwaGEsIGJldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5leHAoKGFscGhhIC0gMSkgKiBNYXRoLmxvZyh4KSArXG4gICAgICAgICAgICAgICAgICAgICAgKGJldGEgLSAxKSAqIE1hdGgubG9nKDEgLSB4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgalN0YXQuYmV0YWxuKGFscGhhLCBiZXRhKSk7XG4gICAgfVxuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuICh4ID4gMSB8fCB4IDwgMCkgPyAoeCA+IDEpICogMSA6IGpTdGF0LmliZXRhKHgsIGFscGhhLCBiZXRhKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uIGludih4LCBhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiBqU3RhdC5pYmV0YWludih4LCBhbHBoYSwgYmV0YSk7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiBhbHBoYSAvIChhbHBoYSArIGJldGEpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGFscGhhLCBiZXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZWRpYW4gbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKGFscGhhICogYmV0YSkgLyAoTWF0aC5wb3coYWxwaGEgKyBiZXRhLCAyKSAqIChhbHBoYSArIGJldGEgKyAxKSk7XG4gIH0sXG5cbiAgLy8gcmV0dXJuIGEgcmFuZG9tIHNhbXBsZVxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShhbHBoYSwgYmV0YSkge1xuICAgIHZhciB1ID0galN0YXQucmFuZGcoYWxwaGEpO1xuICAgIHJldHVybiB1IC8gKHUgKyBqU3RhdC5yYW5kZyhiZXRhKSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIChhbHBoYSAqIGJldGEpIC8gKE1hdGgucG93KGFscGhhICsgYmV0YSwgMikgKiAoYWxwaGEgKyBiZXRhICsgMSkpO1xuICB9XG59KTtcblxuLy8gZXh0ZW5kIEYgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmNlbnRyYWxGLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGRmMSwgZGYyKSB7XG4gICAgaWYgKHggPCAwKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChNYXRoLnBvdyhkZjEgKiB4LCBkZjEpICogTWF0aC5wb3coZGYyLCBkZjIpKSAvXG4gICAgICAgICAgICAgICAgICAgICAoTWF0aC5wb3coZGYxICogeCArIGRmMiwgZGYxICsgZGYyKSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICh4ICogalN0YXQuYmV0YWZuKGRmMS8yLCBkZjIvMikpO1xuXG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgZGYxLCBkZjIpIHtcbiAgICByZXR1cm4galN0YXQuaWJldGEoKGRmMSAqIHgpIC8gKGRmMSAqIHggKyBkZjIpLCBkZjEgLyAyLCBkZjIgLyAyKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uIGludih4LCBkZjEsIGRmMikge1xuICAgIHJldHVybiBkZjIgLyAoZGYxICogKDEgLyBqU3RhdC5pYmV0YWludih4LCBkZjEgLyAyLCBkZjIgLyAyKSAtIDEpKTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGRmMSwgZGYyKSB7XG4gICAgcmV0dXJuIChkZjIgPiAyKSA/IGRmMiAvIChkZjIgLSAyKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGRmMSwgZGYyKSB7XG4gICAgcmV0dXJuIChkZjEgPiAyKSA/IChkZjIgKiAoZGYxIC0gMikpIC8gKGRmMSAqIChkZjIgKyAyKSkgOiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgLy8gcmV0dXJuIGEgcmFuZG9tIHNhbXBsZVxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShkZjEsIGRmMikge1xuICAgIHZhciB4MSA9IGpTdGF0LnJhbmRnKGRmMSAvIDIpICogMjtcbiAgICB2YXIgeDIgPSBqU3RhdC5yYW5kZyhkZjIgLyAyKSAqIDI7XG4gICAgcmV0dXJuICh4MSAvIGRmMSkgLyAoeDIgLyBkZjIpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShkZjEsIGRmMikge1xuICAgIGlmIChkZjIgPD0gNClcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIDIgKiBkZjIgKiBkZjIgKiAoZGYxICsgZGYyIC0gMikgL1xuICAgICAgICAoZGYxICogKGRmMiAtIDIpICogKGRmMiAtIDIpICogKGRmMiAtIDQpKTtcbiAgfVxufSk7XG5cblxuLy8gZXh0ZW5kIGNhdWNoeSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuY2F1Y2h5LCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGxvY2FsLCBzY2FsZSkge1xuICAgIHJldHVybiAoc2NhbGUgLyAoTWF0aC5wb3coeCAtIGxvY2FsLCAyKSArIE1hdGgucG93KHNjYWxlLCAyKSkpIC8gTWF0aC5QSTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4gTWF0aC5hdGFuKCh4IC0gbG9jYWwpIC8gc2NhbGUpIC8gTWF0aC5QSSArIDAuNTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIGxvY2FsLCBzY2FsZSkge1xuICAgIHJldHVybiBsb2NhbCArIHNjYWxlICogTWF0aC50YW4oTWF0aC5QSSAqIChwIC0gMC41KSk7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4obG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUobG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGxvY2FsLCBzY2FsZSkge1xuICAgIHJldHVybiBqU3RhdC5yYW5kbigpICpcbiAgICAgICAgTWF0aC5zcXJ0KDEgLyAoMiAqIGpTdGF0LnJhbmRnKDAuNSkpKSAqIHNjYWxlICsgbG9jYWw7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIGNoaXNxdWFyZSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuY2hpc3F1YXJlLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGRvZikge1xuICAgIHJldHVybiBNYXRoLmV4cCgoZG9mIC8gMiAtIDEpICogTWF0aC5sb2coeCkgLSB4IC8gMiAtIChkb2YgLyAyKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKDIpIC0galN0YXQuZ2FtbWFsbihkb2YgLyAyKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgZG9mKSB7XG4gICAgcmV0dXJuIGpTdGF0LmdhbW1hcChkb2YgLyAyLCB4IC8gMik7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBkb2YpIHtcbiAgICByZXR1cm4gMiAqIGpTdGF0LmdhbW1hcGludihwLCAwLjUgKiBkb2YpO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihkb2YpIHtcbiAgICByZXR1cm4gZG9mO1xuICB9LFxuXG4gIC8vIFRPRE86IHRoaXMgaXMgYW4gYXBwcm94aW1hdGlvbiAoaXMgdGhlcmUgYSBiZXR0ZXIgd2F5PylcbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oZG9mKSB7XG4gICAgcmV0dXJuIGRvZiAqIE1hdGgucG93KDEgLSAoMiAvICg5ICogZG9mKSksIDMpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoZG9mKSB7XG4gICAgcmV0dXJuIChkb2YgLSAyID4gMCkgPyBkb2YgLSAyIDogMDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShkb2YpIHtcbiAgICByZXR1cm4galN0YXQucmFuZGcoZG9mIC8gMikgKiAyO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShkb2YpIHtcbiAgICByZXR1cm4gMiAqIGRvZjtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgZXhwb25lbnRpYWwgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmV4cG9uZW50aWFsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHJhdGUpIHtcbiAgICByZXR1cm4geCA8IDAgPyAwIDogcmF0ZSAqIE1hdGguZXhwKC1yYXRlICogeCk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgcmF0ZSkge1xuICAgIHJldHVybiB4IDwgMCA/IDAgOiAxIC0gTWF0aC5leHAoLXJhdGUgKiB4KTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIHJhdGUpIHtcbiAgICByZXR1cm4gLU1hdGgubG9nKDEgLSBwKSAvIHJhdGU7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKHJhdGUpIHtcbiAgICByZXR1cm4gMSAvIHJhdGU7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiAocmF0ZSkge1xuICAgIHJldHVybiAoMSAvIHJhdGUpICogTWF0aC5sb2coMik7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShyYXRlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUocmF0ZSkge1xuICAgIHJldHVybiAtMSAvIHJhdGUgKiBNYXRoLmxvZyhNYXRoLnJhbmRvbSgpKTtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKHJhdGUpIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocmF0ZSwgLTIpO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBnYW1tYSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuZ2FtbWEsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKChzaGFwZSAtIDEpICogTWF0aC5sb2coeCkgLSB4IC8gc2NhbGUgLVxuICAgICAgICAgICAgICAgICAgICBqU3RhdC5nYW1tYWxuKHNoYXBlKSAtIHNoYXBlICogTWF0aC5sb2coc2NhbGUpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4galN0YXQuZ2FtbWFwKHNoYXBlLCB4IC8gc2NhbGUpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGpTdGF0LmdhbW1hcGludihwLCBzaGFwZSkgKiBzY2FsZTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIHNoYXBlICogc2NhbGU7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShzaGFwZSwgc2NhbGUpIHtcbiAgICBpZihzaGFwZSA+IDEpIHJldHVybiAoc2hhcGUgLSAxKSAqIHNjYWxlO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGpTdGF0LnJhbmRnKHNoYXBlKSAqIHNjYWxlO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gc2hhcGUgKiBzY2FsZSAqIHNjYWxlO1xuICB9XG59KTtcblxuLy8gZXh0ZW5kIGludmVyc2UgZ2FtbWEgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmludmdhbW1hLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBNYXRoLmV4cCgtKHNoYXBlICsgMSkgKiBNYXRoLmxvZyh4KSAtIHNjYWxlIC8geCAtXG4gICAgICAgICAgICAgICAgICAgIGpTdGF0LmdhbW1hbG4oc2hhcGUpICsgc2hhcGUgKiBNYXRoLmxvZyhzY2FsZSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiAxIC0galN0YXQuZ2FtbWFwKHNoYXBlLCBzY2FsZSAvIHgpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlIC8galN0YXQuZ2FtbWFwaW52KDEgLSBwLCBzaGFwZSk7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiAoc2hhcGUgPiAxKSA/IHNjYWxlIC8gKHNoYXBlIC0gMSkgOiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgLyAoc2hhcGUgKyAxKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgLyBqU3RhdC5yYW5kZyhzaGFwZSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKHNoYXBlLCBzY2FsZSkge1xuICAgIGlmIChzaGFwZSA8PSAyKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc2NhbGUgKiBzY2FsZSAvICgoc2hhcGUgLSAxKSAqIChzaGFwZSAtIDEpICogKHNoYXBlIC0gMikpO1xuICB9XG59KTtcblxuXG4vLyBleHRlbmQga3VtYXJhc3dhbXkgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0Lmt1bWFyYXN3YW15LCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKE1hdGgubG9nKGFscGhhKSArIE1hdGgubG9nKGJldGEpICsgKGFscGhhIC0gMSkgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLmxvZyh4KSArIChiZXRhIC0gMSkgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLmxvZygxIC0gTWF0aC5wb3coeCwgYWxwaGEpKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKDEgLSBNYXRoLnBvdygxIC0gTWF0aC5wb3coeCwgYWxwaGEpLCBiZXRhKSk7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIChiZXRhICogalN0YXQuZ2FtbWFmbigxICsgMSAvIGFscGhhKSAqXG4gICAgICAgICAgICBqU3RhdC5nYW1tYWZuKGJldGEpKSAvIChqU3RhdC5nYW1tYWZuKDEgKyAxIC8gYWxwaGEgKyBiZXRhKSk7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMSAtIE1hdGgucG93KDIsIC0xIC8gYmV0YSksIDEgLyBhbHBoYSk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShhbHBoYSwgYmV0YSkge1xuICAgIGlmICghKGFscGhhID49IDEgJiYgYmV0YSA+PSAxICYmIChhbHBoYSAhPT0gMSAmJiBiZXRhICE9PSAxKSkpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBNYXRoLnBvdygoYWxwaGEgLSAxKSAvIChhbHBoYSAqIGJldGEgLSAxKSwgMSAvIGFscGhhKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoYWxwaGEsIGJldGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbmNlIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgICAvLyBUT0RPOiBjb21wbGV0ZSB0aGlzXG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIGxvZ25vcm1hbCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQubG9nbm9ybWFsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIG11LCBzaWdtYSkge1xuICAgIHJldHVybiBNYXRoLmV4cCgtTWF0aC5sb2coeCkgLSAwLjUgKiBNYXRoLmxvZygyICogTWF0aC5QSSkgLVxuICAgICAgICAgICAgICAgICAgICBNYXRoLmxvZyhzaWdtYSkgLSBNYXRoLnBvdyhNYXRoLmxvZyh4KSAtIG11LCAyKSAvXG4gICAgICAgICAgICAgICAgICAgICgyICogc2lnbWEgKiBzaWdtYSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIG11LCBzaWdtYSkge1xuICAgIHJldHVybiAwLjUgK1xuICAgICAgICAoMC41ICogalN0YXQuZXJmKChNYXRoLmxvZyh4KSAtIG11KSAvIE1hdGguc3FydCgyICogc2lnbWEgKiBzaWdtYSkpKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIG11LCBzaWdtYSkge1xuICAgIHJldHVybiBNYXRoLmV4cCgtMS40MTQyMTM1NjIzNzMwOTUwNSAqIHNpZ21hICogalN0YXQuZXJmY2ludigyICogcCkgKyBtdSk7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAobXUgKyBzaWdtYSAqIHNpZ21hIC8gMik7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4obXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKG11KTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKG11LCBzaWdtYSkge1xuICAgIHJldHVybiBNYXRoLmV4cChtdSAtIHNpZ21hICogc2lnbWEpO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKG11LCBzaWdtYSkge1xuICAgIHJldHVybiBNYXRoLmV4cChqU3RhdC5yYW5kbigpICogc2lnbWEgKyBtdSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKG11LCBzaWdtYSkge1xuICAgIHJldHVybiAoTWF0aC5leHAoc2lnbWEgKiBzaWdtYSkgLSAxKSAqIE1hdGguZXhwKDIgKiBtdSArIHNpZ21hICogc2lnbWEpO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBub3JtYWwgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0Lm5vcm1hbCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBtZWFuLCBzdGQpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoLTAuNSAqIE1hdGgubG9nKDIgKiBNYXRoLlBJKSAtXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKHN0ZCkgLSBNYXRoLnBvdyh4IC0gbWVhbiwgMikgLyAoMiAqIHN0ZCAqIHN0ZCkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiAwLjUgKiAoMSArIGpTdGF0LmVyZigoeCAtIG1lYW4pIC8gTWF0aC5zcXJ0KDIgKiBzdGQgKiBzdGQpKSk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBtZWFuLCBzdGQpIHtcbiAgICByZXR1cm4gLTEuNDE0MjEzNTYyMzczMDk1MDUgKiBzdGQgKiBqU3RhdC5lcmZjaW52KDIgKiBwKSArIG1lYW47XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBtZWFuO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBtZWFuO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIChtZWFuLCBzdGQpIHtcbiAgICByZXR1cm4gbWVhbjtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShtZWFuLCBzdGQpIHtcbiAgICByZXR1cm4galN0YXQucmFuZG4oKSAqIHN0ZCArIG1lYW47XG4gIH0sXG5cbiAgdmFyaWFuY2UgOiBmdW5jdGlvbihtZWFuLCBzdGQpIHtcbiAgICByZXR1cm4gc3RkICogc3RkO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBwYXJldG8gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LnBhcmV0bywge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBzY2FsZSwgc2hhcGUpIHtcbiAgICBpZiAoeCA8PSBzY2FsZSlcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIChzaGFwZSAqIE1hdGgucG93KHNjYWxlLCBzaGFwZSkpIC8gTWF0aC5wb3coeCwgc2hhcGUgKyAxKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KHNjYWxlIC8geCwgc2hhcGUpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDEpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiAoc2hhcGUgKiBNYXRoLnBvdyhzY2FsZSwgc2hhcGUpKSAvIChzaGFwZSAtIDEpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAqIChzaGFwZSAqIE1hdGguU1FSVDIpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9LFxuXG4gIHZhcmlhbmNlIDogZnVuY3Rpb24oc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDIpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiAoc2NhbGUqc2NhbGUgKiBzaGFwZSkgLyAoTWF0aC5wb3coc2hhcGUgLSAxLCAyKSAqIChzaGFwZSAtIDIpKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgc3R1ZGVudHQgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LnN0dWRlbnR0LCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGRvZikge1xuICAgIHJldHVybiAoalN0YXQuZ2FtbWFmbigoZG9mICsgMSkgLyAyKSAvIChNYXRoLnNxcnQoZG9mICogTWF0aC5QSSkgKlxuICAgICAgICBqU3RhdC5nYW1tYWZuKGRvZiAvIDIpKSkgKlxuICAgICAgICBNYXRoLnBvdygxICsgKCh4ICogeCkgLyBkb2YpLCAtKChkb2YgKyAxKSAvIDIpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkb2YpIHtcbiAgICB2YXIgZG9mMiA9IGRvZiAvIDI7XG4gICAgcmV0dXJuIGpTdGF0LmliZXRhKCh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgZG9mKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAoMiAqIE1hdGguc3FydCh4ICogeCArIGRvZikpLCBkb2YyLCBkb2YyKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIGRvZikge1xuICAgIHZhciB4ID0galN0YXQuaWJldGFpbnYoMiAqIE1hdGgubWluKHAsIDEgLSBwKSwgMC41ICogZG9mLCAwLjUpO1xuICAgIHggPSBNYXRoLnNxcnQoZG9mICogKDEgLSB4KSAvIHgpO1xuICAgIHJldHVybiAocCA+IDAuNSkgPyB4IDogLXg7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihkb2YpIHtcbiAgICByZXR1cm4gKGRvZiA+IDEpID8gMCA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihkb2YpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGRvZikge1xuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGRvZikge1xuICAgIHJldHVybiBqU3RhdC5yYW5kbigpICogTWF0aC5zcXJ0KGRvZiAvICgyICogalN0YXQucmFuZGcoZG9mIC8gMikpKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoZG9mKSB7XG4gICAgcmV0dXJuIChkb2YgID4gMikgPyBkb2YgLyAoZG9mIC0gMikgOiAoZG9mID4gMSkgPyBJbmZpbml0eSA6IHVuZGVmaW5lZDtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgd2VpYnVsbCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQud2VpYnVsbCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBzY2FsZSwgc2hhcGUpIHtcbiAgICBpZiAoeCA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKHNoYXBlIC8gc2NhbGUpICogTWF0aC5wb3coKHggLyBzY2FsZSksIChzaGFwZSAtIDEpKSAqXG4gICAgICAgIE1hdGguZXhwKC0oTWF0aC5wb3coKHggLyBzY2FsZSksIHNoYXBlKSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiB4IDwgMCA/IDAgOiAxIC0gTWF0aC5leHAoLU1hdGgucG93KCh4IC8gc2NhbGUpLCBzaGFwZSkpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogTWF0aC5wb3coLU1hdGgubG9nKDEgLSBwKSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogalN0YXQuZ2FtbWFmbigxICsgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBNYXRoLnBvdyhNYXRoLmxvZygyKSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNjYWxlLCBzaGFwZSkge1xuICAgIGlmIChzaGFwZSA8PSAxKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc2NhbGUgKiBNYXRoLnBvdygoc2hhcGUgLSAxKSAvIHNoYXBlLCAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAqIE1hdGgucG93KC1NYXRoLmxvZyhNYXRoLnJhbmRvbSgpKSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogc2NhbGUgKiBqU3RhdC5nYW1tYWZuKDEgKyAyIC8gc2hhcGUpIC1cbiAgICAgICAgTWF0aC5wb3codGhpcy5tZWFuKHNjYWxlLCBzaGFwZSksIDIpO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC51bmlmb3JtLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGEsIGIpIHtcbiAgICByZXR1cm4gKHggPCBhIHx8IHggPiBiKSA/IDAgOiAxIC8gKGIgLSBhKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhLCBiKSB7XG4gICAgaWYgKHggPCBhKVxuICAgICAgcmV0dXJuIDA7XG4gICAgZWxzZSBpZiAoeCA8IGIpXG4gICAgICByZXR1cm4gKHggLSBhKSAvIChiIC0gYSk7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihhLCBiKSB7XG4gICAgcmV0dXJuIDAuNSAqIChhICsgYik7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oYSwgYikge1xuICAgIHJldHVybiBqU3RhdC5tZWFuKGEsIGIpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoYSwgYikge1xuICAgIHRocm93IG5ldyBFcnJvcignbW9kZSBpcyBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoYSwgYikge1xuICAgIHJldHVybiAoYSAvIDIgKyBiIC8gMikgKyAoYiAvIDIgLSBhIC8gMikgKiAoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoYSwgYikge1xuICAgIHJldHVybiBNYXRoLnBvdyhiIC0gYSwgMikgLyAxMjtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgdW5pZm9ybSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuYmlub21pYWwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoaywgbiwgcCkge1xuICAgIHJldHVybiAocCA9PT0gMCB8fCBwID09PSAxKSA/XG4gICAgICAoKG4gKiBwKSA9PT0gayA/IDEgOiAwKSA6XG4gICAgICBqU3RhdC5jb21iaW5hdGlvbihuLCBrKSAqIE1hdGgucG93KHAsIGspICogTWF0aC5wb3coMSAtIHAsIG4gLSBrKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBuLCBwKSB7XG4gICAgdmFyIGJpbm9tYXJyID0gW10sXG4gICAgayA9IDA7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHggPCBuKSB7XG4gICAgICBmb3IgKDsgayA8PSB4OyBrKyspIHtcbiAgICAgICAgYmlub21hcnJbIGsgXSA9IGpTdGF0LmJpbm9taWFsLnBkZihrLCBuLCBwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqU3RhdC5zdW0oYmlub21hcnIpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgdW5pZm9ybSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQubmVnYmluLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIHIsIHApIHtcbiAgICByZXR1cm4gayAhPT0gayB8IDBcbiAgICAgID8gZmFsc2VcbiAgICAgIDogayA8IDBcbiAgICAgICAgPyAwXG4gICAgICAgIDogalN0YXQuY29tYmluYXRpb24oayArIHIgLSAxLCByIC0gMSkgKiBNYXRoLnBvdygxIC0gcCwgaykgKiBNYXRoLnBvdyhwLCByKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCByLCBwKSB7XG4gICAgdmFyIHN1bSA9IDAsXG4gICAgayA9IDA7XG4gICAgaWYgKHggPCAwKSByZXR1cm4gMDtcbiAgICBmb3IgKDsgayA8PSB4OyBrKyspIHtcbiAgICAgIHN1bSArPSBqU3RhdC5uZWdiaW4ucGRmKGssIHIsIHApO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5oeXBnZW9tLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIE4sIG0sIG4pIHtcbiAgICAvLyBIeXBlcmdlb21ldHJpYyBQREYuXG5cbiAgICAvLyBBIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSBDREYgYWxnb3JpdGhtIGJlbG93LlxuXG4gICAgLy8gayA9IG51bWJlciBvZiBzdWNjZXNzZXMgZHJhd25cbiAgICAvLyBOID0gcG9wdWxhdGlvbiBzaXplXG4gICAgLy8gbSA9IG51bWJlciBvZiBzdWNjZXNzZXMgaW4gcG9wdWxhdGlvblxuICAgIC8vIG4gPSBudW1iZXIgb2YgaXRlbXMgZHJhd24gZnJvbSBwb3B1bGF0aW9uXG5cbiAgICBpZihrICE9PSBrIHwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZihrIDwgMCB8fCBrIDwgbSAtIChOIC0gbikpIHtcbiAgICAgIC8vIEl0J3MgaW1wb3NzaWJsZSB0byBoYXZlIHRoaXMgZmV3IHN1Y2Nlc3NlcyBkcmF3bi5cbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZihrID4gbiB8fCBrID4gbSkge1xuICAgICAgLy8gSXQncyBpbXBvc3NpYmxlIHRvIGhhdmUgdGhpcyBtYW55IHN1Y2Nlc3NlcyBkcmF3bi5cbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAobSAqIDIgPiBOKSB7XG4gICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzdWNjZXNzZXMuXG5cbiAgICAgIGlmKG4gKiAyID4gTikge1xuICAgICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuXG4gICAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLnBkZihOIC0gbSAtIG4gKyBrLCBOLCBOIC0gbSwgTiAtIG4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gaXMgc2FtcGxlZC5cblxuICAgICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5wZGYobiAtIGssIE4sIE4gLSBtLCBuKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZihuICogMiA+IE4pIHtcbiAgICAgIC8vIEhhbGYgb3IgbGVzcyBpcyBzdWNjZXNzZXMuXG5cbiAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLnBkZihtIC0gaywgTiwgbSwgTiAtIG4pO1xuXG4gICAgfSBlbHNlIGlmKG0gPCBuKSB7XG4gICAgICAvLyBXZSB3YW50IHRvIGhhdmUgdGhlIG51bWJlciBvZiB0aGluZ3Mgc2FtcGxlZCB0byBiZSBsZXNzIHRoYW4gdGhlXG4gICAgICAvLyBzdWNjZXNzZXMgYXZhaWxhYmxlLiBTbyBzd2FwIHRoZSBkZWZpbml0aW9ucyBvZiBzdWNjZXNzZnVsIGFuZCBzYW1wbGVkLlxuICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20ucGRmKGssIE4sIG4sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgaGFsZiBvciBsZXNzIG9mIHRoZSBwb3B1bGF0aW9uIHdhcyBzYW1wbGVkLCBoYWxmIG9yXG4gICAgICAvLyBsZXNzIG9mIGl0IHdhcyBzdWNjZXNzZXMsIGFuZCB3ZSBoYWQgZmV3ZXIgc2FtcGxlZCB0aGluZ3MgdGhhblxuICAgICAgLy8gc3VjY2Vzc2VzLiBOb3cgd2UgY2FuIGRvIHRoaXMgY29tcGxpY2F0ZWQgaXRlcmF0aXZlIGFsZ29yaXRobSBpbiBhblxuICAgICAgLy8gZWZmaWNpZW50IHdheS5cblxuICAgICAgLy8gVGhlIGJhc2ljIHByZW1pc2Ugb2YgdGhlIGFsZ29yaXRobSBpcyB0aGF0IHdlIHBhcnRpYWxseSBub3JtYWxpemUgb3VyXG4gICAgICAvLyBpbnRlcm1lZGlhdGUgcHJvZHVjdCB0byBrZWVwIGl0IGluIGEgbnVtZXJpY2FsbHkgZ29vZCByZWdpb24sIGFuZCB0aGVuXG4gICAgICAvLyBmaW5pc2ggdGhlIG5vcm1hbGl6YXRpb24gYXQgdGhlIGVuZC5cblxuICAgICAgLy8gVGhpcyB2YXJpYWJsZSBob2xkcyB0aGUgc2NhbGVkIHByb2JhYmlsaXR5IG9mIHRoZSBjdXJyZW50IG51bWJlciBvZlxuICAgICAgLy8gc3VjY2Vzc2VzLlxuICAgICAgdmFyIHNjYWxlZFBERiA9IDE7XG5cbiAgICAgIC8vIFRoaXMga2VlcHMgdHJhY2sgb2YgaG93IG11Y2ggd2UgaGF2ZSBub3JtYWxpemVkLlxuICAgICAgdmFyIHNhbXBsZXNEb25lID0gMDtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICAvLyBGb3IgZXZlcnkgcG9zc2libGUgbnVtYmVyIG9mIHN1Y2Nlc3NlcyB1cCB0byB0aGF0IG9ic2VydmVkLi4uXG5cbiAgICAgICAgd2hpbGUoc2NhbGVkUERGID4gMSAmJiBzYW1wbGVzRG9uZSA8IG4pIHtcbiAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgcmVzdWx0IGlzIGdyb3dpbmcgdG9vIGJpZy4gQXBwbHkgc29tZSBvZiB0aGVcbiAgICAgICAgICAvLyBub3JtYWxpemF0aW9uIHRvIHNocmluayBldmVyeXRoaW5nLlxuXG4gICAgICAgICAgc2NhbGVkUERGICo9IDEgLSAobSAvIChOIC0gc2FtcGxlc0RvbmUpKTtcblxuICAgICAgICAgIC8vIFNheSB3ZSd2ZSBub3JtYWxpemVkIGJ5IHRoaXMgc2FtcGxlIGFscmVhZHkuXG4gICAgICAgICAgc2FtcGxlc0RvbmUrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBwYXJ0aWFsbHktbm9ybWFsaXplZCBoeXBlcmdlb21ldHJpYyBQREYgZm9yIHRoZSBuZXh0XG4gICAgICAgIC8vIG51bWJlciBvZiBzdWNjZXNzZXNcbiAgICAgICAgc2NhbGVkUERGICo9IChuIC0gaSkgKiAobSAtIGkpIC8gKChpICsgMSkgKiAoTiAtIG0gLSBuICsgaSArIDEpKTtcbiAgICAgIH1cblxuICAgICAgZm9yKDsgc2FtcGxlc0RvbmUgPCBuOyBzYW1wbGVzRG9uZSsrKSB7XG4gICAgICAgIC8vIEFwcGx5IGFsbCB0aGUgcmVzdCBvZiB0aGUgbm9ybWFsaXphdGlvblxuICAgICAgICBzY2FsZWRQREYgKj0gMSAtIChtIC8gKE4gLSBzYW1wbGVzRG9uZSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBCb3VuZCBhbnN3ZXIgc2FuZWx5IGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgc2NhbGVkUERGKSk7XG4gICAgfVxuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIE4sIG0sIG4pIHtcbiAgICAvLyBIeXBlcmdlb21ldHJpYyBDREYuXG5cbiAgICAvLyBUaGlzIGFsZ29yaXRobSBpcyBkdWUgdG8gUHJvZi4gVGhvbWFzIFMuIEZlcmd1c29uLCA8dG9tQG1hdGgudWNsYS5lZHU+LFxuICAgIC8vIGFuZCBjb21lcyBmcm9tIGhpcyBoeXBlcmdlb21ldHJpYyB0ZXN0IGNhbGN1bGF0b3IgYXRcbiAgICAvLyA8aHR0cDovL3d3dy5tYXRoLnVjbGEuZWR1L350b20vZGlzdHJpYnV0aW9ucy9IeXBlcmdlb21ldHJpYy5odG1sPi5cblxuICAgIC8vIHggPSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGRyYXduXG4gICAgLy8gTiA9IHBvcHVsYXRpb24gc2l6ZVxuICAgIC8vIG0gPSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGluIHBvcHVsYXRpb25cbiAgICAvLyBuID0gbnVtYmVyIG9mIGl0ZW1zIGRyYXduIGZyb20gcG9wdWxhdGlvblxuXG4gICAgaWYoeCA8IDAgfHwgeCA8IG0gLSAoTiAtIG4pKSB7XG4gICAgICAvLyBJdCdzIGltcG9zc2libGUgdG8gaGF2ZSB0aGlzIGZldyBzdWNjZXNzZXMgZHJhd24gb3IgZmV3ZXIuXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYoeCA+PSBuIHx8IHggPj0gbSkge1xuICAgICAgLy8gV2Ugd2lsbCBhbHdheXMgaGF2ZSB0aGlzIG1hbnkgc3VjY2Vzc2VzIG9yIGZld2VyLlxuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChtICogMiA+IE4pIHtcbiAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHN1Y2Nlc3Nlcy5cblxuICAgICAgaWYobiAqIDIgPiBOKSB7XG4gICAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHNhbXBsZWQuXG5cbiAgICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20uY2RmKE4gLSBtIC0gbiArIHgsIE4sIE4gLSBtLCBOIC0gbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbGYgb3IgbGVzcyBvZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuXG4gICAgICAgIHJldHVybiAxIC0galN0YXQuaHlwZ2VvbS5jZGYobiAtIHggLSAxLCBOLCBOIC0gbSwgbik7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYobiAqIDIgPiBOKSB7XG4gICAgICAvLyBIYWxmIG9yIGxlc3MgaXMgc3VjY2Vzc2VzLlxuXG4gICAgICByZXR1cm4gMSAtIGpTdGF0Lmh5cGdlb20uY2RmKG0gLSB4IC0gMSwgTiwgbSwgTiAtIG4pO1xuXG4gICAgfSBlbHNlIGlmKG0gPCBuKSB7XG4gICAgICAvLyBXZSB3YW50IHRvIGhhdmUgdGhlIG51bWJlciBvZiB0aGluZ3Mgc2FtcGxlZCB0byBiZSBsZXNzIHRoYW4gdGhlXG4gICAgICAvLyBzdWNjZXNzZXMgYXZhaWxhYmxlLiBTbyBzd2FwIHRoZSBkZWZpbml0aW9ucyBvZiBzdWNjZXNzZnVsIGFuZCBzYW1wbGVkLlxuICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20uY2RmKHgsIE4sIG4sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgaGFsZiBvciBsZXNzIG9mIHRoZSBwb3B1bGF0aW9uIHdhcyBzYW1wbGVkLCBoYWxmIG9yXG4gICAgICAvLyBsZXNzIG9mIGl0IHdhcyBzdWNjZXNzZXMsIGFuZCB3ZSBoYWQgZmV3ZXIgc2FtcGxlZCB0aGluZ3MgdGhhblxuICAgICAgLy8gc3VjY2Vzc2VzLiBOb3cgd2UgY2FuIGRvIHRoaXMgY29tcGxpY2F0ZWQgaXRlcmF0aXZlIGFsZ29yaXRobSBpbiBhblxuICAgICAgLy8gZWZmaWNpZW50IHdheS5cblxuICAgICAgLy8gVGhlIGJhc2ljIHByZW1pc2Ugb2YgdGhlIGFsZ29yaXRobSBpcyB0aGF0IHdlIHBhcnRpYWxseSBub3JtYWxpemUgb3VyXG4gICAgICAvLyBpbnRlcm1lZGlhdGUgc3VtIHRvIGtlZXAgaXQgaW4gYSBudW1lcmljYWxseSBnb29kIHJlZ2lvbiwgYW5kIHRoZW5cbiAgICAgIC8vIGZpbmlzaCB0aGUgbm9ybWFsaXphdGlvbiBhdCB0aGUgZW5kLlxuXG4gICAgICAvLyBIb2xkcyB0aGUgaW50ZXJtZWRpYXRlLCBzY2FsZWQgdG90YWwgQ0RGLlxuICAgICAgdmFyIHNjYWxlZENERiA9IDE7XG5cbiAgICAgIC8vIFRoaXMgdmFyaWFibGUgaG9sZHMgdGhlIHNjYWxlZCBwcm9iYWJpbGl0eSBvZiB0aGUgY3VycmVudCBudW1iZXIgb2ZcbiAgICAgIC8vIHN1Y2Nlc3Nlcy5cbiAgICAgIHZhciBzY2FsZWRQREYgPSAxO1xuXG4gICAgICAvLyBUaGlzIGtlZXBzIHRyYWNrIG9mIGhvdyBtdWNoIHdlIGhhdmUgbm9ybWFsaXplZC5cbiAgICAgIHZhciBzYW1wbGVzRG9uZSA9IDA7XG5cbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4OyBpKyspIHtcbiAgICAgICAgLy8gRm9yIGV2ZXJ5IHBvc3NpYmxlIG51bWJlciBvZiBzdWNjZXNzZXMgdXAgdG8gdGhhdCBvYnNlcnZlZC4uLlxuXG4gICAgICAgIHdoaWxlKHNjYWxlZENERiA+IDEgJiYgc2FtcGxlc0RvbmUgPCBuKSB7XG4gICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIHJlc3VsdCBpcyBncm93aW5nIHRvbyBiaWcuIEFwcGx5IHNvbWUgb2YgdGhlXG4gICAgICAgICAgLy8gbm9ybWFsaXphdGlvbiB0byBzaHJpbmsgZXZlcnl0aGluZy5cblxuICAgICAgICAgIHZhciBmYWN0b3IgPSAxIC0gKG0gLyAoTiAtIHNhbXBsZXNEb25lKSk7XG5cbiAgICAgICAgICBzY2FsZWRQREYgKj0gZmFjdG9yO1xuICAgICAgICAgIHNjYWxlZENERiAqPSBmYWN0b3I7XG5cbiAgICAgICAgICAvLyBTYXkgd2UndmUgbm9ybWFsaXplZCBieSB0aGlzIHNhbXBsZSBhbHJlYWR5LlxuICAgICAgICAgIHNhbXBsZXNEb25lKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXb3JrIG91dCB0aGUgcGFydGlhbGx5LW5vcm1hbGl6ZWQgaHlwZXJnZW9tZXRyaWMgUERGIGZvciB0aGUgbmV4dFxuICAgICAgICAvLyBudW1iZXIgb2Ygc3VjY2Vzc2VzXG4gICAgICAgIHNjYWxlZFBERiAqPSAobiAtIGkpICogKG0gLSBpKSAvICgoaSArIDEpICogKE4gLSBtIC0gbiArIGkgKyAxKSk7XG5cbiAgICAgICAgLy8gQWRkIHRvIHRoZSBDREYgYW5zd2VyLlxuICAgICAgICBzY2FsZWRDREYgKz0gc2NhbGVkUERGO1xuICAgICAgfVxuXG4gICAgICBmb3IoOyBzYW1wbGVzRG9uZSA8IG47IHNhbXBsZXNEb25lKyspIHtcbiAgICAgICAgLy8gQXBwbHkgYWxsIHRoZSByZXN0IG9mIHRoZSBub3JtYWxpemF0aW9uXG4gICAgICAgIHNjYWxlZENERiAqPSAxIC0gKG0gLyAoTiAtIHNhbXBsZXNEb25lKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJvdW5kIGFuc3dlciBzYW5lbHkgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBzY2FsZWRDREYpKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LnBvaXNzb24sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoaywgbCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhsLCBrKSAqIE1hdGguZXhwKC1sKSAvIGpTdGF0LmZhY3RvcmlhbChrKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBsKSB7XG4gICAgdmFyIHN1bWFyciA9IFtdLFxuICAgIGsgPSAwO1xuICAgIGlmICh4IDwgMCkgcmV0dXJuIDA7XG4gICAgZm9yICg7IGsgPD0geDsgaysrKSB7XG4gICAgICBzdW1hcnIucHVzaChqU3RhdC5wb2lzc29uLnBkZihrLCBsKSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5zdW0oc3VtYXJyKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBsO1xuICB9LFxuXG4gIHZhcmlhbmNlIDogZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBsO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGwpIHtcbiAgICB2YXIgcCA9IDEsIGsgPSAwLCBMID0gTWF0aC5leHAoLWwpO1xuICAgIGRvIHtcbiAgICAgIGsrKztcbiAgICAgIHAgKj0gTWF0aC5yYW5kb20oKTtcbiAgICB9IHdoaWxlIChwID4gTCk7XG4gICAgcmV0dXJuIGsgLSAxO1xuICB9XG59KTtcblxuLy8gZXh0ZW5kIHRyaWFuZ3VsYXIgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LnRyaWFuZ3VsYXIsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgYSwgYiwgYykge1xuICAgIHJldHVybiAoYiA8PSBhIHx8IGMgPCBhIHx8IGMgPiBiKVxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogKHggPCBhIHx8IHggPiBiKVxuICAgICAgICA/IDBcbiAgICAgICAgOiAoeCA8PSBjKVxuICAgICAgICAgID8gKDIgKiAoeCAtIGEpKSAvICgoYiAtIGEpICogKGMgLSBhKSlcbiAgICAgICAgICA6ICgyICogKGIgLSB4KSkgLyAoKGIgLSBhKSAqIChiIC0gYykpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGEsIGIsIGMpIHtcbiAgICBpZiAoYiA8PSBhIHx8IGMgPCBhIHx8IGMgPiBiKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoeCA8IGEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeCA8PSBjKVxuICAgICAgICByZXR1cm4gTWF0aC5wb3coeCAtIGEsIDIpIC8gKChiIC0gYSkgKiAoYyAtIGEpKTtcbiAgICAgIHJldHVybiAxIC0gTWF0aC5wb3coYiAtIHgsIDIpIC8gKChiIC0gYSkgKiAoYiAtIGMpKTtcbiAgICB9XG4gICAgLy8gbmV2ZXIgcmVhY2ggdGhpc1xuICAgIHJldHVybiAxO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oYSwgYiwgYykge1xuICAgIHJldHVybiAoYSArIGIgKyBjKSAvIDM7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oYSwgYiwgYykge1xuICAgIGlmIChjIDw9IChhICsgYikgLyAyKSB7XG4gICAgICByZXR1cm4gYiAtIE1hdGguc3FydCgoYiAtIGEpICogKGIgLSBjKSkgLyBNYXRoLnNxcnQoMik7XG4gICAgfSBlbHNlIGlmIChjID4gKGEgKyBiKSAvIDIpIHtcbiAgICAgIHJldHVybiBhICsgTWF0aC5zcXJ0KChiIC0gYSkgKiAoYyAtIGEpKSAvIE1hdGguc3FydCgyKTtcbiAgICB9XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGM7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoYSwgYiwgYykge1xuICAgIHZhciB1ID0gTWF0aC5yYW5kb20oKTtcbiAgICBpZiAodSA8ICgoYyAtIGEpIC8gKGIgLSBhKSkpXG4gICAgICByZXR1cm4gYSArIE1hdGguc3FydCh1ICogKGIgLSBhKSAqIChjIC0gYSkpXG4gICAgcmV0dXJuIGIgLSBNYXRoLnNxcnQoKDEgLSB1KSAqIChiIC0gYSkgKiAoYiAtIGMpKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAqIGEgKyBiICogYiArIGMgKiBjIC0gYSAqIGIgLSBhICogYyAtIGIgKiBjKSAvIDE4O1xuICB9XG59KTtcblxufSh0aGlzLmpTdGF0LCBNYXRoKSk7XG4vKiBQcm92aWRlcyBmdW5jdGlvbnMgZm9yIHRoZSBzb2x1dGlvbiBvZiBsaW5lYXIgc3lzdGVtIG9mIGVxdWF0aW9ucywgaW50ZWdyYXRpb24sIGV4dHJhcG9sYXRpb24sXG4gKiBpbnRlcnBvbGF0aW9uLCBlaWdlbnZhbHVlIHByb2JsZW1zLCBkaWZmZXJlbnRpYWwgZXF1YXRpb25zIGFuZCBQQ0EgYW5hbHlzaXMuICovXG5cbihmdW5jdGlvbihqU3RhdCwgTWF0aCkge1xuXG52YXIgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xudmFyIGlzQXJyYXkgPSBqU3RhdC51dGlscy5pc0FycmF5O1xuXG5qU3RhdC5leHRlbmQoe1xuXG4gIC8vIGFkZCBhIHZlY3Rvci9tYXRyaXggdG8gYSB2ZWN0b3IvbWF0cml4IG9yIHNjYWxhclxuICBhZGQ6IGZ1bmN0aW9uIGFkZChhcnIsIGFyZykge1xuICAgIC8vIGNoZWNrIGlmIGFyZyBpcyBhIHZlY3RvciBvciBzY2FsYXJcbiAgICBpZiAoaXNBcnJheShhcmcpKSB7XG4gICAgICBpZiAoIWlzQXJyYXkoYXJnWzBdKSkgYXJnID0gWyBhcmcgXTtcbiAgICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSwgcm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICsgYXJnW3Jvd11bY29sXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlICsgYXJnOyB9KTtcbiAgfSxcblxuICAvLyBzdWJ0cmFjdCBhIHZlY3RvciBvciBzY2FsYXIgZnJvbSB0aGUgdmVjdG9yXG4gIHN1YnRyYWN0OiBmdW5jdGlvbiBzdWJ0cmFjdChhcnIsIGFyZykge1xuICAgIC8vIGNoZWNrIGlmIGFyZyBpcyBhIHZlY3RvciBvciBzY2FsYXJcbiAgICBpZiAoaXNBcnJheShhcmcpKSB7XG4gICAgICBpZiAoIWlzQXJyYXkoYXJnWzBdKSkgYXJnID0gWyBhcmcgXTtcbiAgICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSwgcm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC0gYXJnW3Jvd11bY29sXSB8fCAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgLSBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIG1hdHJpeCBkaXZpc2lvblxuICBkaXZpZGU6IGZ1bmN0aW9uIGRpdmlkZShhcnIsIGFyZykge1xuICAgIGlmIChpc0FycmF5KGFyZykpIHtcbiAgICAgIGlmICghaXNBcnJheShhcmdbMF0pKSBhcmcgPSBbIGFyZyBdO1xuICAgICAgcmV0dXJuIGpTdGF0Lm11bHRpcGx5KGFyciwgalN0YXQuaW52KGFyZykpO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlIC8gYXJnOyB9KTtcbiAgfSxcblxuICAvLyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uIG11bHRpcGx5KGFyciwgYXJnKSB7XG4gICAgdmFyIHJvdywgY29sLCBucmVzY29scywgc3VtLFxuICAgIG5yb3cgPSBhcnIubGVuZ3RoLFxuICAgIG5jb2wgPSBhcnJbMF0ubGVuZ3RoLFxuICAgIHJlcyA9IGpTdGF0Lnplcm9zKG5yb3csIG5yZXNjb2xzID0gKGlzQXJyYXkoYXJnKSkgPyBhcmdbMF0ubGVuZ3RoIDogbmNvbCksXG4gICAgcmVzY29scyA9IDA7XG4gICAgaWYgKGlzQXJyYXkoYXJnKSkge1xuICAgICAgZm9yICg7IHJlc2NvbHMgPCBucmVzY29sczsgcmVzY29scysrKSB7XG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgbnJvdzsgcm93KyspIHtcbiAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgbmNvbDsgY29sKyspXG4gICAgICAgICAgc3VtICs9IGFycltyb3ddW2NvbF0gKiBhcmdbY29sXVtyZXNjb2xzXTtcbiAgICAgICAgICByZXNbcm93XVtyZXNjb2xzXSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIChucm93ID09PSAxICYmIHJlc2NvbHMgPT09IDEpID8gcmVzWzBdWzBdIDogcmVzO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlICogYXJnOyB9KTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gbWF0cmljaWVzXG4gIGRvdDogZnVuY3Rpb24gZG90KGFyciwgYXJnKSB7XG4gICAgaWYgKCFpc0FycmF5KGFyclswXSkpIGFyciA9IFsgYXJyIF07XG4gICAgaWYgKCFpc0FycmF5KGFyZ1swXSkpIGFyZyA9IFsgYXJnIF07XG4gICAgLy8gY29udmVydCBjb2x1bW4gdG8gcm93IHZlY3RvclxuICAgIHZhciBsZWZ0ID0gKGFyclswXS5sZW5ndGggPT09IDEgJiYgYXJyLmxlbmd0aCAhPT0gMSkgPyBqU3RhdC50cmFuc3Bvc2UoYXJyKSA6IGFycixcbiAgICByaWdodCA9IChhcmdbMF0ubGVuZ3RoID09PSAxICYmIGFyZy5sZW5ndGggIT09IDEpID8galN0YXQudHJhbnNwb3NlKGFyZykgOiBhcmcsXG4gICAgcmVzID0gW10sXG4gICAgcm93ID0gMCxcbiAgICBucm93ID0gbGVmdC5sZW5ndGgsXG4gICAgbmNvbCA9IGxlZnRbMF0ubGVuZ3RoLFxuICAgIHN1bSwgY29sO1xuICAgIGZvciAoOyByb3cgPCBucm93OyByb3crKykge1xuICAgICAgcmVzW3Jvd10gPSBbXTtcbiAgICAgIHN1bSA9IDA7XG4gICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IG5jb2w7IGNvbCsrKVxuICAgICAgc3VtICs9IGxlZnRbcm93XVtjb2xdICogcmlnaHRbcm93XVtjb2xdO1xuICAgICAgcmVzW3Jvd10gPSBzdW07XG4gICAgfVxuICAgIHJldHVybiAocmVzLmxlbmd0aCA9PT0gMSkgPyByZXNbMF0gOiByZXM7XG4gIH0sXG5cbiAgLy8gcmFpc2UgZXZlcnkgZWxlbWVudCBieSBhIHNjYWxhclxuICBwb3c6IGZ1bmN0aW9uIHBvdyhhcnIsIGFyZykge1xuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gTWF0aC5wb3codmFsdWUsIGFyZyk7IH0pO1xuICB9LFxuXG4gIC8vIGdlbmVyYXRlIHRoZSBhYnNvbHV0ZSB2YWx1ZXMgb2YgdGhlIHZlY3RvclxuICBhYnM6IGZ1bmN0aW9uIGFicyhhcnIpIHtcbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIE1hdGguYWJzKHZhbHVlKTsgfSk7XG4gIH0sXG5cbiAgLy8gY29tcHV0ZXMgdGhlIHAtbm9ybSBvZiB0aGUgdmVjdG9yXG4gIC8vIEluIHRoZSBjYXNlIHRoYXQgYSBtYXRyaXggaXMgcGFzc2VkLCB1c2VzIHRoZSBmaXJzdCByb3cgYXMgdGhlIHZlY3RvclxuICBub3JtOiBmdW5jdGlvbiBub3JtKGFyciwgcCkge1xuICAgIHZhciBubm9ybSA9IDAsXG4gICAgaSA9IDA7XG4gICAgLy8gY2hlY2sgdGhlIHAtdmFsdWUgb2YgdGhlIG5vcm0sIGFuZCBzZXQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgICBpZiAoaXNOYU4ocCkpIHAgPSAyO1xuICAgIC8vIGNoZWNrIGlmIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5LCBhbmQgbWFrZSB2ZWN0b3IgY29ycmVjdGlvblxuICAgIGlmIChpc0FycmF5KGFyclswXSkpIGFyciA9IGFyclswXTtcbiAgICAvLyB2ZWN0b3Igbm9ybVxuICAgIGZvciAoOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBubm9ybSArPSBNYXRoLnBvdyhNYXRoLmFicyhhcnJbaV0pLCBwKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucG93KG5ub3JtLCAxIC8gcCk7XG4gIH0sXG5cbiAgLy8gVE9ETzogbWFrZSBjb21wYXRpYmxlIHdpdGggbWF0cmljZXNcbiAgLy8gY29tcHV0ZXMgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvcnMgaW4gcmFkc1xuICBhbmdsZTogZnVuY3Rpb24gYW5nbGUoYXJyLCBhcmcpIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKGpTdGF0LmRvdChhcnIsIGFyZykgLyAoalN0YXQubm9ybShhcnIpICogalN0YXQubm9ybShhcmcpKSk7XG4gIH0sXG5cbiAgLy8gYXVnbWVudCBvbmUgbWF0cml4IGJ5IGFub3RoZXJcbiAgYXVnOiBmdW5jdGlvbiBhdWcoYSwgYikge1xuICAgIHZhciBuZXdhcnIgPSBhLnNsaWNlKCksXG4gICAgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBuZXdhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHB1c2guYXBwbHkobmV3YXJyW2ldLCBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld2FycjtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uIGludihhKSB7XG4gICAgdmFyIHJvd3MgPSBhLmxlbmd0aCxcbiAgICBjb2xzID0gYVswXS5sZW5ndGgsXG4gICAgYiA9IGpTdGF0LmlkZW50aXR5KHJvd3MsIGNvbHMpLFxuICAgIGMgPSBqU3RhdC5nYXVzc19qb3JkYW4oYSwgYiksXG4gICAgb2JqID0gW10sXG4gICAgaSA9IDAsXG4gICAgajtcbiAgICBmb3IgKDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgb2JqW2ldID0gW107XG4gICAgICBmb3IgKGogPSBjb2xzIC0gMTsgaiA8IGNbMF0ubGVuZ3RoOyBqKyspXG4gICAgICBvYmpbaV1baiAtIGNvbHNdID0gY1tpXVtqXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICAvLyBjYWxjdWxhdGUgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4XG4gIGRldDogZnVuY3Rpb24gZGV0KGEpIHtcbiAgICB2YXIgYWxlbiA9IGEubGVuZ3RoLFxuICAgIGFsZW5kID0gYWxlbiAqIDIsXG4gICAgdmFscyA9IG5ldyBBcnJheShhbGVuZCksXG4gICAgcm93c2hpZnQgPSBhbGVuIC0gMSxcbiAgICBjb2xzaGlmdCA9IGFsZW5kIC0gMSxcbiAgICBtcm93ID0gcm93c2hpZnQgLSBhbGVuICsgMSxcbiAgICBtY29sID0gY29sc2hpZnQsXG4gICAgaSA9IDAsXG4gICAgcmVzdWx0ID0gMCxcbiAgICBqO1xuICAgIC8vIGNoZWNrIGZvciBzcGVjaWFsIDJ4MiBjYXNlXG4gICAgaWYgKGFsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBhWzBdWzBdICogYVsxXVsxXSAtIGFbMF1bMV0gKiBhWzFdWzBdO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGFsZW5kOyBpKyspIHtcbiAgICAgIHZhbHNbaV0gPSAxO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWxlbjsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgYWxlbjsgaisrKSB7XG4gICAgICAgIHZhbHNbKG1yb3cgPCAwKSA/IG1yb3cgKyBhbGVuIDogbXJvdyBdICo9IGFbaV1bal07XG4gICAgICAgIHZhbHNbKG1jb2wgPCBhbGVuKSA/IG1jb2wgKyBhbGVuIDogbWNvbCBdICo9IGFbaV1bal07XG4gICAgICAgIG1yb3crKztcbiAgICAgICAgbWNvbC0tO1xuICAgICAgfVxuICAgICAgbXJvdyA9IC0tcm93c2hpZnQgLSBhbGVuICsgMTtcbiAgICAgIG1jb2wgPSAtLWNvbHNoaWZ0O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWxlbjsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gdmFsc1tpXTtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBhbGVuZDsgaSsrKSB7XG4gICAgICByZXN1bHQgLT0gdmFsc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBnYXVzc19lbGltaW5hdGlvbjogZnVuY3Rpb24gZ2F1c3NfZWxpbWluYXRpb24oYSwgYikge1xuICAgIHZhciBpID0gMCxcbiAgICBqID0gMCxcbiAgICBuID0gYS5sZW5ndGgsXG4gICAgbSA9IGFbMF0ubGVuZ3RoLFxuICAgIGZhY3RvciA9IDEsXG4gICAgc3VtID0gMCxcbiAgICB4ID0gW10sXG4gICAgbWF1ZywgcGl2b3QsIHRlbXAsIGs7XG4gICAgYSA9IGpTdGF0LmF1ZyhhLCBiKTtcbiAgICBtYXVnID0gYVswXS5sZW5ndGg7XG4gICAgZm9yKDsgaSA8IG47IGkrKykge1xuICAgICAgcGl2b3QgPSBhW2ldW2ldO1xuICAgICAgaiA9IGk7XG4gICAgICBmb3IgKGsgPSBpICsgMTsgayA8IG07IGsrKykge1xuICAgICAgICBpZiAocGl2b3QgPCBNYXRoLmFicyhhW2tdW2ldKSkge1xuICAgICAgICAgIHBpdm90ID0gYVtrXVtpXTtcbiAgICAgICAgICBqID0gaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGogIT0gaSkge1xuICAgICAgICBmb3IoayA9IDA7IGsgPCBtYXVnOyBrKyspIHtcbiAgICAgICAgICB0ZW1wID0gYVtpXVtrXTtcbiAgICAgICAgICBhW2ldW2tdID0gYVtqXVtrXTtcbiAgICAgICAgICBhW2pdW2tdID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChqID0gaSArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgZmFjdG9yID0gYVtqXVtpXSAvIGFbaV1baV07XG4gICAgICAgIGZvcihrID0gaTsgayA8IG1hdWc7IGsrKykge1xuICAgICAgICAgIGFbal1ba10gPSBhW2pdW2tdIC0gZmFjdG9yICogYVtpXVtrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHN1bSA9IDA7XG4gICAgICBmb3IgKGogPSBpICsgMTsgajw9IG4gLSAxOyBqKyspIHtcbiAgICAgICAgc3VtID0geFtqXSAqIGFbaV1bal07XG4gICAgICB9XG4gICAgICB4W2ldID0oYVtpXVttYXVnIC0gMV0gLSBzdW0pIC8gYVtpXVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG4gIH0sXG5cbiAgZ2F1c3Nfam9yZGFuOiBmdW5jdGlvbiBnYXVzc19qb3JkYW4oYSwgYikge1xuICAgIHZhciBtID0galN0YXQuYXVnKGEsIGIpLFxuICAgIGggPSBtLmxlbmd0aCxcbiAgICB3ID0gbVswXS5sZW5ndGg7XG4gICAgLy8gZmluZCBtYXggcGl2b3RcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGg7IHkrKykge1xuICAgICAgdmFyIG1heHJvdyA9IHk7XG4gICAgICBmb3IgKHZhciB5MiA9IHkrMTsgeTIgPCBoOyB5MisrKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhtW3kyXVt5XSkgPiBNYXRoLmFicyhtW21heHJvd11beV0pKVxuICAgICAgICAgIG1heHJvdyA9IHkyO1xuICAgICAgfVxuICAgICAgdmFyIHRtcCA9IG1beV07XG4gICAgICBtW3ldID0gbVttYXhyb3ddO1xuICAgICAgbVttYXhyb3ddID0gdG1wXG4gICAgICBmb3IgKHZhciB5MiA9IHkrMTsgeTIgPCBoOyB5MisrKSB7XG4gICAgICAgIGMgPSBtW3kyXVt5XSAvIG1beV1beV07XG4gICAgICAgIGZvciAodmFyIHggPSB5OyB4IDwgdzsgeCsrKSB7XG4gICAgICAgICAgbVt5Ml1beF0gLT0gbVt5XVt4XSAqIGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYmFja3N1YnN0aXR1dGVcbiAgICBmb3IgKHZhciB5ID0gaC0xOyB5ID49IDA7IHktLSkge1xuICAgICAgYyA9IG1beV1beV07XG4gICAgICBmb3IgKHZhciB5MiA9IDA7IHkyIDwgeTsgeTIrKykge1xuICAgICAgICBmb3IgKHZhciB4ID0gdy0xOyB4ID4geS0xOyB4LS0pIHtcbiAgICAgICAgICBtW3kyXVt4XSAtPSBtW3ldW3hdICogbVt5Ml1beV0gLyBjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtW3ldW3ldIC89IGM7XG4gICAgICBmb3IgKHZhciB4ID0gaDsgeCA8IHc7IHgrKykge1xuICAgICAgICBtW3ldW3hdIC89IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9LFxuXG4gIGx1OiBmdW5jdGlvbiBsdShhLCBiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsdSBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG5cbiAgY2hvbGVza3k6IGZ1bmN0aW9uIGNob2xlc2t5KGEsIGIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nob2xlc2t5IG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcblxuICBnYXVzc19qYWNvYmk6IGZ1bmN0aW9uIGdhdXNzX2phY29iaShhLCBiLCB4LCByKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIgbiA9IGEubGVuZ3RoO1xuICAgIHZhciBsID0gW107XG4gICAgdmFyIHUgPSBbXTtcbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciB4diwgYywgaCwgeGs7XG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxbaV0gPSBbXTtcbiAgICAgIHVbaV0gPSBbXTtcbiAgICAgIGRbaV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGkgPiBqKSB7XG4gICAgICAgICAgbFtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgdVtpXVtqXSA9IGRbaV1bal0gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPCBqKSB7XG4gICAgICAgICAgdVtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgbFtpXVtqXSA9IGRbaV1bal0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSB1W2ldW2pdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBoID0galN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkoalN0YXQuaW52KGQpLCBqU3RhdC5hZGQobCwgdSkpLCAtMSk7XG4gICAgYyA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihkKSwgYik7XG4gICAgeHYgPSB4O1xuICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHgpLCBjKTtcbiAgICBpID0gMjtcbiAgICB3aGlsZSAoTWF0aC5hYnMoalN0YXQubm9ybShqU3RhdC5zdWJ0cmFjdCh4ayx4dikpKSA+IHIpIHtcbiAgICAgIHh2ID0geGs7XG4gICAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4diksIGMpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4geGs7XG4gIH0sXG5cbiAgZ2F1c3Nfc2VpZGVsOiBmdW5jdGlvbiBnYXVzc19zZWlkZWwoYSwgYiwgeCwgcikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbiA9IGEubGVuZ3RoO1xuICAgIHZhciBsID0gW107XG4gICAgdmFyIHUgPSBbXTtcbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBqLCB4diwgYywgaCwgeGs7XG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxbaV0gPSBbXTtcbiAgICAgIHVbaV0gPSBbXTtcbiAgICAgIGRbaV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGkgPiBqKSB7XG4gICAgICAgICAgbFtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgdVtpXVtqXSA9IGRbaV1bal0gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPCBqKSB7XG4gICAgICAgICAgdVtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgbFtpXVtqXSA9IGRbaV1bal0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSB1W2ldW2pdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBoID0galN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkoalN0YXQuaW52KGpTdGF0LmFkZChkLCBsKSksIHUpLCAtMSk7XG4gICAgYyA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihqU3RhdC5hZGQoZCwgbCkpLCBiKTtcbiAgICB4diA9IHg7XG4gICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeCksIGMpO1xuICAgIGkgPSAyO1xuICAgIHdoaWxlIChNYXRoLmFicyhqU3RhdC5ub3JtKGpTdGF0LnN1YnRyYWN0KHhrLCB4dikpKSA+IHIpIHtcbiAgICAgIHh2ID0geGs7XG4gICAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4diksIGMpO1xuICAgICAgaSA9IGkgKyAxO1xuICAgIH1cbiAgICByZXR1cm4geGs7XG4gIH0sXG5cbiAgU09SOiBmdW5jdGlvbiBTT1IoYSwgYiwgeCwgciwgdykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbiA9IGEubGVuZ3RoO1xuICAgIHZhciBsID0gW107XG4gICAgdmFyIHUgPSBbXTtcbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBqLCB4diwgYywgaCwgeGs7XG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxbaV0gPSBbXTtcbiAgICAgIHVbaV0gPSBbXTtcbiAgICAgIGRbaV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGkgPiBqKSB7XG4gICAgICAgICAgbFtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgdVtpXVtqXSA9IGRbaV1bal0gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPCBqKSB7XG4gICAgICAgICAgdVtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgbFtpXVtqXSA9IGRbaV1bal0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSB1W2ldW2pdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBoID0galN0YXQubXVsdGlwbHkoalN0YXQuaW52KGpTdGF0LmFkZChkLCBqU3RhdC5tdWx0aXBseShsLCB3KSkpLFxuICAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5zdWJ0cmFjdChqU3RhdC5tdWx0aXBseShkLCAxIC0gdyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpTdGF0Lm11bHRpcGx5KHUsIHcpKSk7XG4gICAgYyA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihqU3RhdC5hZGQoZCxcbiAgICAgICAgalN0YXQubXVsdGlwbHkobCwgdykpKSwgYiksIHcpO1xuICAgIHh2ID0geDtcbiAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4KSwgYyk7XG4gICAgaSA9IDI7XG4gICAgd2hpbGUgKE1hdGguYWJzKGpTdGF0Lm5vcm0oalN0YXQuc3VidHJhY3QoeGssIHh2KSkpID4gcikge1xuICAgICAgeHYgPSB4aztcbiAgICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHh2KSwgYyk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB4aztcbiAgfSxcblxuICBob3VzZWhvbGRlcjogZnVuY3Rpb24gaG91c2Vob2xkZXIoYSkge1xuICAgIHZhciBtID0gYS5sZW5ndGg7XG4gICAgdmFyIG4gPSBhWzBdLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHcgPSBbXTtcbiAgICB2YXIgcCA9IFtdO1xuICAgIHZhciBhbHBoYSwgciwgaywgaiwgZmFjdG9yO1xuICAgIGZvciAoOyBpIDwgbSAtIDE7IGkrKykge1xuICAgICAgYWxwaGEgPSAwO1xuICAgICAgZm9yIChqID0gaSArIDE7IGogPCBuOyBqKyspXG4gICAgICBhbHBoYSArPSAoYVtqXVtpXSAqIGFbal1baV0pO1xuICAgICAgZmFjdG9yID0gKGFbaSArIDFdW2ldID4gMCkgPyAtMSA6IDE7XG4gICAgICBhbHBoYSA9IGZhY3RvciAqIE1hdGguc3FydChhbHBoYSk7XG4gICAgICByID0gTWF0aC5zcXJ0KCgoKGFscGhhICogYWxwaGEpIC0gYVtpICsgMV1baV0gKiBhbHBoYSkgLyAyKSk7XG4gICAgICB3ID0galN0YXQuemVyb3MobSwgMSk7XG4gICAgICB3W2kgKyAxXVswXSA9IChhW2kgKyAxXVtpXSAtIGFscGhhKSAvICgyICogcik7XG4gICAgICBmb3IgKGsgPSBpICsgMjsgayA8IG07IGsrKykgd1trXVswXSA9IGFba11baV0gLyAoMiAqIHIpO1xuICAgICAgcCA9IGpTdGF0LnN1YnRyYWN0KGpTdGF0LmlkZW50aXR5KG0sIG4pLFxuICAgICAgICAgIGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KHcsIGpTdGF0LnRyYW5zcG9zZSh3KSksIDIpKTtcbiAgICAgIGEgPSBqU3RhdC5tdWx0aXBseShwLCBqU3RhdC5tdWx0aXBseShhLCBwKSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9LFxuXG4gIC8vIFRPRE86IG5vdCB3b3JraW5nIHByb3Blcmx5LlxuICBRUjogZnVuY3Rpb24gUVIoYSwgYikge1xuICAgIHZhciBtID0gYS5sZW5ndGg7XG4gICAgdmFyIG4gPSBhWzBdLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHcgPSBbXTtcbiAgICB2YXIgcCA9IFtdO1xuICAgIHZhciB4ID0gW107XG4gICAgdmFyIGosIGFscGhhLCByLCBrLCBmYWN0b3IsIHN1bTtcbiAgICBmb3IgKDsgaSA8IG0gLSAxOyBpKyspIHtcbiAgICAgIGFscGhhID0gMDtcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgaisrKVxuICAgICAgICBhbHBoYSArPSAoYVtqXVtpXSAqIGFbal1baV0pO1xuICAgICAgZmFjdG9yID0gKGFbaSArIDFdW2ldID4gMCkgPyAtMSA6IDE7XG4gICAgICBhbHBoYSA9IGZhY3RvciAqIE1hdGguc3FydChhbHBoYSk7XG4gICAgICByID0gTWF0aC5zcXJ0KCgoKGFscGhhICogYWxwaGEpIC0gYVtpICsgMV1baV0gKiBhbHBoYSkgLyAyKSk7XG4gICAgICB3ID0galN0YXQuemVyb3MobSwgMSk7XG4gICAgICB3W2kgKyAxXVswXSA9IChhW2kgKyAxXVtpXSAtIGFscGhhKSAvICgyICogcik7XG4gICAgICBmb3IgKGsgPSBpICsgMjsgayA8IG07IGsrKylcbiAgICAgICAgd1trXVswXSA9IGFba11baV0gLyAoMiAqIHIpO1xuICAgICAgcCA9IGpTdGF0LnN1YnRyYWN0KGpTdGF0LmlkZW50aXR5KG0sIG4pLFxuICAgICAgICAgIGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KHcsIGpTdGF0LnRyYW5zcG9zZSh3KSksIDIpKTtcbiAgICAgIGEgPSBqU3RhdC5tdWx0aXBseShwLCBhKTtcbiAgICAgIGIgPSBqU3RhdC5tdWx0aXBseShwLCBiKTtcbiAgICB9XG4gICAgZm9yIChpID0gbSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBzdW0gPSAwO1xuICAgICAgZm9yIChqID0gaSArIDE7IGogPD0gbiAtIDE7IGorKylcbiAgICAgIHN1bSA9IHhbal0gKiBhW2ldW2pdO1xuICAgICAgeFtpXSA9IGJbaV1bMF0gLyBhW2ldW2ldO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfSxcblxuICBqYWNvYmk6IGZ1bmN0aW9uIGphY29iaShhKSB7XG4gICAgdmFyIGNvbmRpdGlvbiA9IDE7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgbiA9IGEubGVuZ3RoO1xuICAgIHZhciBlID0galN0YXQuaWRlbnRpdHkobiwgbik7XG4gICAgdmFyIGV2ID0gW107XG4gICAgdmFyIGIsIGksIGosIHAsIHEsIG1heGltLCB0aGV0YSwgcztcbiAgICAvLyBjb25kaXRpb24gPT09IDEgb25seSBpZiB0b2xlcmFuY2UgaXMgbm90IHJlYWNoZWRcbiAgICB3aGlsZSAoY29uZGl0aW9uID09PSAxKSB7XG4gICAgICBjb3VudCsrO1xuICAgICAgbWF4aW0gPSBhWzBdWzFdO1xuICAgICAgcCA9IDA7XG4gICAgICBxID0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgIGlmIChpICE9IGopIHtcbiAgICAgICAgICAgIGlmIChtYXhpbSA8IE1hdGguYWJzKGFbaV1bal0pKSB7XG4gICAgICAgICAgICAgIG1heGltID0gTWF0aC5hYnMoYVtpXVtqXSk7XG4gICAgICAgICAgICAgIHAgPSBpO1xuICAgICAgICAgICAgICBxID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhW3BdW3BdID09PSBhW3FdW3FdKVxuICAgICAgICB0aGV0YSA9IChhW3BdW3FdID4gMCkgPyBNYXRoLlBJIC8gNCA6IC1NYXRoLlBJIC8gNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhldGEgPSBNYXRoLmF0YW4oMiAqIGFbcF1bcV0gLyAoYVtwXVtwXSAtIGFbcV1bcV0pKSAvIDI7XG4gICAgICBzID0galN0YXQuaWRlbnRpdHkobiwgbik7XG4gICAgICBzW3BdW3BdID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgc1twXVtxXSA9IC1NYXRoLnNpbih0aGV0YSk7XG4gICAgICBzW3FdW3BdID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgc1txXVtxXSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIC8vIGVpZ2VuIHZlY3RvciBtYXRyaXhcbiAgICAgIGUgPSBqU3RhdC5tdWx0aXBseShlLCBzKTtcbiAgICAgIGIgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYocyksIGEpLCBzKTtcbiAgICAgIGEgPSBiO1xuICAgICAgY29uZGl0aW9uID0gMDtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IG47IGorKykge1xuICAgICAgICAgIGlmIChpICE9IGogJiYgTWF0aC5hYnMoYVtpXVtqXSkgPiAwLjAwMSkge1xuICAgICAgICAgICAgY29uZGl0aW9uID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZXYucHVzaChhW2ldW2ldKTtcbiAgICAvL3JldHVybnMgYm90aCB0aGUgZWlnZW52YWx1ZSBhbmQgZWlnZW5tYXRyaXhcbiAgICByZXR1cm4gW2UsIGV2XTtcbiAgfSxcblxuICBydW5nZWt1dHRhOiBmdW5jdGlvbiBydW5nZWt1dHRhKGYsIGgsIHAsIHRfaiwgdV9qLCBvcmRlcikge1xuICAgIHZhciBrMSwgazIsIHVfajEsIGszLCBrNDtcbiAgICBpZiAob3JkZXIgPT09IDIpIHtcbiAgICAgIHdoaWxlICh0X2ogPD0gcCkge1xuICAgICAgICBrMSA9IGggKiBmKHRfaiwgdV9qKTtcbiAgICAgICAgazIgPSBoICogZih0X2ogKyBoLCB1X2ogKyBrMSk7XG4gICAgICAgIHVfajEgPSB1X2ogKyAoazEgKyBrMikgLyAyO1xuICAgICAgICB1X2ogPSB1X2oxO1xuICAgICAgICB0X2ogPSB0X2ogKyBoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JkZXIgPT09IDQpIHtcbiAgICAgIHdoaWxlICh0X2ogPD0gcCkge1xuICAgICAgICBrMSA9IGggKiBmKHRfaiwgdV9qKTtcbiAgICAgICAgazIgPSBoICogZih0X2ogKyBoIC8gMiwgdV9qICsgazEgLyAyKTtcbiAgICAgICAgazMgPSBoICogZih0X2ogKyBoIC8gMiwgdV9qICsgazIgLyAyKTtcbiAgICAgICAgazQgPSBoICogZih0X2ogK2gsIHVfaiArIGszKTtcbiAgICAgICAgdV9qMSA9IHVfaiArIChrMSArIDIgKiBrMiArIDIgKiBrMyArIGs0KSAvIDY7XG4gICAgICAgIHVfaiA9IHVfajE7XG4gICAgICAgIHRfaiA9IHRfaiArIGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1X2o7XG4gIH0sXG5cbiAgcm9tYmVyZzogZnVuY3Rpb24gcm9tYmVyZyhmLCBhLCBiLCBvcmRlcikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaCA9IChiIC0gYSkgLyAyO1xuICAgIHZhciB4ID0gW107XG4gICAgdmFyIGgxID0gW107XG4gICAgdmFyIGcgPSBbXTtcbiAgICB2YXIgbSwgYTEsIGosIGssIEksIGQ7XG4gICAgd2hpbGUgKGkgPCBvcmRlciAvIDIpIHtcbiAgICAgIEkgPSBmKGEpO1xuICAgICAgZm9yIChqID0gYSwgayA9IDA7IGogPD0gYjsgaiA9IGogKyBoLCBrKyspIHhba10gPSBqO1xuICAgICAgbSA9IHgubGVuZ3RoO1xuICAgICAgZm9yIChqID0gMTsgaiA8IG0gLSAxOyBqKyspIHtcbiAgICAgICAgSSArPSAoKChqICUgMikgIT09IDApID8gNCA6IDIpICogZih4W2pdKTtcbiAgICAgIH1cbiAgICAgIEkgPSAoaCAvIDMpICogKEkgKyBmKGIpKTtcbiAgICAgIGdbaV0gPSBJO1xuICAgICAgaCAvPSAyO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBhMSA9IGcubGVuZ3RoO1xuICAgIG0gPSAxO1xuICAgIHdoaWxlIChhMSAhPT0gMSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGExIC0gMTsgaisrKVxuICAgICAgaDFbal0gPSAoKE1hdGgucG93KDQsIG0pKSAqIGdbaiArIDFdIC0gZ1tqXSkgLyAoTWF0aC5wb3coNCwgbSkgLSAxKTtcbiAgICAgIGExID0gaDEubGVuZ3RoO1xuICAgICAgZyA9IGgxO1xuICAgICAgaDEgPSBbXTtcbiAgICAgIG0rKztcbiAgICB9XG4gICAgcmV0dXJuIGc7XG4gIH0sXG5cbiAgcmljaGFyZHNvbjogZnVuY3Rpb24gcmljaGFyZHNvbihYLCBmLCB4LCBoKSB7XG4gICAgZnVuY3Rpb24gcG9zKFgsIHgpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBuID0gWC5sZW5ndGg7XG4gICAgICB2YXIgcDtcbiAgICAgIGZvciAoOyBpIDwgbjsgaSsrKVxuICAgICAgICBpZiAoWFtpXSA9PT0geCkgcCA9IGk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgdmFyIG4gPSBYLmxlbmd0aCxcbiAgICBoX21pbiA9IE1hdGguYWJzKHggLSBYW3BvcyhYLCB4KSArIDFdKSxcbiAgICBpID0gMCxcbiAgICBnID0gW10sXG4gICAgaDEgPSBbXSxcbiAgICB5MSwgeTIsIG0sIGEsIGo7XG4gICAgd2hpbGUgKGggPj0gaF9taW4pIHtcbiAgICAgIHkxID0gcG9zKFgsIHggKyBoKTtcbiAgICAgIHkyID0gcG9zKFgsIHgpO1xuICAgICAgZ1tpXSA9IChmW3kxXSAtIDIgKiBmW3kyXSArIGZbMiAqIHkyIC0geTFdKSAvIChoICogaCk7XG4gICAgICBoIC89IDI7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGEgPSBnLmxlbmd0aDtcbiAgICBtID0gMTtcbiAgICB3aGlsZSAoYSAhPSAxKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgYSAtIDE7IGorKylcbiAgICAgIGgxW2pdID0gKChNYXRoLnBvdyg0LCBtKSkgKiBnW2ogKyAxXSAtIGdbal0pIC8gKE1hdGgucG93KDQsIG0pIC0gMSk7XG4gICAgICBhID0gaDEubGVuZ3RoO1xuICAgICAgZyA9IGgxO1xuICAgICAgaDEgPSBbXTtcbiAgICAgIG0rKztcbiAgICB9XG4gICAgcmV0dXJuIGc7XG4gIH0sXG5cbiAgc2ltcHNvbjogZnVuY3Rpb24gc2ltcHNvbihmLCBhLCBiLCBuKSB7XG4gICAgdmFyIGggPSAoYiAtIGEpIC8gbjtcbiAgICB2YXIgSSA9IGYoYSk7XG4gICAgdmFyIHggPSBbXTtcbiAgICB2YXIgaiA9IGE7XG4gICAgdmFyIGsgPSAwO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgbTtcbiAgICBmb3IgKDsgaiA8PSBiOyBqID0gaiArIGgsIGsrKylcbiAgICAgIHhba10gPSBqO1xuICAgIG0gPSB4Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IG0gLSAxOyBpKyspIHtcbiAgICAgIEkgKz0gKChpICUgMiAhPT0gMCkgPyA0IDogMikgKiBmKHhbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gKGggLyAzKSAqIChJICsgZihiKSk7XG4gIH0sXG5cbiAgaGVybWl0ZTogZnVuY3Rpb24gaGVybWl0ZShYLCBGLCBkRiwgdmFsdWUpIHtcbiAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGwgPSBbXTtcbiAgICB2YXIgZGwgPSBbXTtcbiAgICB2YXIgQSA9IFtdO1xuICAgIHZhciBCID0gW107XG4gICAgdmFyIGo7XG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxbaV0gPSAxO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSAhPSBqKSBsW2ldICo9ICh2YWx1ZSAtIFhbal0pIC8gKFhbaV0gLSBYW2pdKTtcbiAgICAgIH1cbiAgICAgIGRsW2ldID0gMDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGkgIT0gaikgZGxbaV0gKz0gMSAvIChYIFtpXSAtIFhbal0pO1xuICAgICAgfVxuICAgICAgQVtpXSA9ICgxIC0gMiAqICh2YWx1ZSAtIFhbaV0pICogZGxbaV0pICogKGxbaV0gKiBsW2ldKTtcbiAgICAgIEJbaV0gPSAodmFsdWUgLSBYW2ldKSAqIChsW2ldICogbFtpXSk7XG4gICAgICBwICs9IChBW2ldICogRltpXSArIEJbaV0gKiBkRltpXSk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIGxhZ3JhbmdlOiBmdW5jdGlvbiBsYWdyYW5nZShYLCBGLCB2YWx1ZSkge1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGosIGw7XG4gICAgdmFyIG4gPSBYLmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbCA9IEZbaV07XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0aW5nIHRoZSBsYWdyYW5nZSBwb2x5bm9taWFsIExfaVxuICAgICAgICBpZiAoaSAhPSBqKSBsICo9ICh2YWx1ZSAtIFhbal0pIC8gKFhbaV0gLSBYW2pdKTtcbiAgICAgIH1cbiAgICAgIC8vIGFkZGluZyB0aGUgbGFncmFuZ2UgcG9seW5vbWlhbHMgZm91bmQgYWJvdmVcbiAgICAgIHAgKz0gbDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgY3ViaWNfc3BsaW5lOiBmdW5jdGlvbiBjdWJpY19zcGxpbmUoWCwgRiwgdmFsdWUpIHtcbiAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgIHZhciBpID0gMCwgajtcbiAgICB2YXIgQSA9IFtdO1xuICAgIHZhciBCID0gW107XG4gICAgdmFyIGFscGhhID0gW107XG4gICAgdmFyIGMgPSBbXTtcbiAgICB2YXIgaCA9IFtdO1xuICAgIHZhciBiID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICBmb3IgKDsgaSA8IG4gLSAxOyBpKyspXG4gICAgICBoW2ldID0gWFtpICsgMV0gLSBYW2ldO1xuICAgIGFscGhhWzBdID0gMDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgYWxwaGFbaV0gPSAoMyAvIGhbaV0pICogKEZbaSArIDFdIC0gRltpXSkgLVxuICAgICAgICAgICgzIC8gaFtpLTFdKSAqIChGW2ldIC0gRltpLTFdKTtcbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIEFbaV0gPSBbXTtcbiAgICAgIEJbaV0gPSBbXTtcbiAgICAgIEFbaV1baS0xXSA9IGhbaS0xXTtcbiAgICAgIEFbaV1baV0gPSAyICogKGhbaSAtIDFdICsgaFtpXSk7XG4gICAgICBBW2ldW2krMV0gPSBoW2ldO1xuICAgICAgQltpXVswXSA9IGFscGhhW2ldO1xuICAgIH1cbiAgICBjID0galN0YXQubXVsdGlwbHkoalN0YXQuaW52KEEpLCBCKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbiAtIDE7IGorKykge1xuICAgICAgYltqXSA9IChGW2ogKyAxXSAtIEZbal0pIC8gaFtqXSAtIGhbal0gKiAoY1tqICsgMV1bMF0gKyAyICogY1tqXVswXSkgLyAzO1xuICAgICAgZFtqXSA9IChjW2ogKyAxXVswXSAtIGNbal1bMF0pIC8gKDMgKiBoW2pdKTtcbiAgICB9XG4gICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKFhbal0gPiB2YWx1ZSkgYnJlYWs7XG4gICAgfVxuICAgIGogLT0gMTtcbiAgICByZXR1cm4gRltqXSArICh2YWx1ZSAtIFhbal0pICogYltqXSArIGpTdGF0LnNxKHZhbHVlLVhbal0pICpcbiAgICAgICAgY1tqXSArICh2YWx1ZSAtIFhbal0pICogalN0YXQuc3EodmFsdWUgLSBYW2pdKSAqIGRbal07XG4gIH0sXG5cbiAgZ2F1c3NfcXVhZHJhdHVyZTogZnVuY3Rpb24gZ2F1c3NfcXVhZHJhdHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dhdXNzX3F1YWRyYXR1cmUgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9LFxuXG4gIFBDQTogZnVuY3Rpb24gUENBKFgpIHtcbiAgICB2YXIgbSA9IFgubGVuZ3RoO1xuICAgIHZhciBuID0gWFswXS5sZW5ndGg7XG4gICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGosIHRlbXAxO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIEQgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHRlbXAyID0gW107XG4gICAgdmFyIFkgPSBbXTtcbiAgICB2YXIgQnQgPSBbXTtcbiAgICB2YXIgQiA9IFtdO1xuICAgIHZhciBDID0gW107XG4gICAgdmFyIFYgPSBbXTtcbiAgICB2YXIgVnQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICB1W2ldID0galN0YXQuc3VtKFhbaV0pIC8gbjtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgQltpXSA9IFtdO1xuICAgICAgZm9yKGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgIEJbaV1bal0gPSBYW2pdW2ldIC0gdVtqXTtcbiAgICAgIH1cbiAgICB9XG4gICAgQiA9IGpTdGF0LnRyYW5zcG9zZShCKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICBDW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgIENbaV1bal0gPSAoalN0YXQuZG90KFtCW2ldXSwgW0Jbal1dKSkgLyAobiAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgPSBqU3RhdC5qYWNvYmkoQyk7XG4gICAgViA9IHJlc3VsdFswXTtcbiAgICBEID0gcmVzdWx0WzFdO1xuICAgIFZ0ID0galN0YXQudHJhbnNwb3NlKFYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBELmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGogPSBpOyBqIDwgRC5sZW5ndGg7IGorKykge1xuICAgICAgICBpZihEW2ldIDwgRFtqXSkgIHtcbiAgICAgICAgICB0ZW1wMSA9IERbaV07XG4gICAgICAgICAgRFtpXSA9IERbal07XG4gICAgICAgICAgRFtqXSA9IHRlbXAxO1xuICAgICAgICAgIHRlbXAyID0gVnRbaV07XG4gICAgICAgICAgVnRbaV0gPSBWdFtqXTtcbiAgICAgICAgICBWdFtqXSA9IHRlbXAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIEJ0ID0galN0YXQudHJhbnNwb3NlKEIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgIFlbaV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBCdC5sZW5ndGg7IGorKykge1xuICAgICAgICBZW2ldW2pdID0galN0YXQuZG90KFtWdFtpXV0sIFtCdFtqXV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1gsIEQsIFZ0LCBZXTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCBqU3RhdC5mbiB3aXRoIG1ldGhvZHMgdGhhdCByZXF1aXJlIG9uZSBhcmd1bWVudFxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpTdGF0LmZuW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKGFyZywgZnVuYykge1xuICAgICAgdmFyIHRtcHRoaXMgPSB0aGlzO1xuICAgICAgLy8gY2hlY2sgZm9yIGNhbGxiYWNrXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmMuY2FsbCh0bXB0aGlzLCBqU3RhdC5mbltwYXNzZnVuY10uY2FsbCh0bXB0aGlzLCBhcmcpKTtcbiAgICAgICAgfSwgMTUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgalN0YXRbcGFzc2Z1bmNdKHRoaXMsIGFyZykgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4galN0YXRbcGFzc2Z1bmNdKHRoaXMsIGFyZyk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBqU3RhdChqU3RhdFtwYXNzZnVuY10odGhpcywgYXJnKSk7XG4gICAgfTtcbiAgfShmdW5jc1tpXSkpO1xufSgnYWRkIGRpdmlkZSBtdWx0aXBseSBzdWJ0cmFjdCBkb3QgcG93IGFicyBub3JtIGFuZ2xlJy5zcGxpdCgnICcpKSk7XG5cbn0odGhpcy5qU3RhdCwgTWF0aCkpO1xuKGZ1bmN0aW9uKGpTdGF0LCBNYXRoKSB7XG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIGlzTnVtYmVyID0galN0YXQudXRpbHMuaXNOdW1iZXI7XG5cbi8vIGZsYWc9PXRydWUgZGVub3RlcyB1c2Ugb2Ygc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvblxuLy8gWiBTdGF0aXN0aWNzXG5qU3RhdC5leHRlbmQoe1xuICAvLyAyIGRpZmZlcmVudCBwYXJhbWV0ZXIgbGlzdHM6XG4gIC8vICh2YWx1ZSwgbWVhbiwgc2QpXG4gIC8vICh2YWx1ZSwgYXJyYXksIGZsYWcpXG4gIHpzY29yZTogZnVuY3Rpb24genNjb3JlKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmIChpc051bWJlcihhcmdzWzFdKSkge1xuICAgICAgcmV0dXJuIChhcmdzWzBdIC0gYXJnc1sxXSkgLyBhcmdzWzJdO1xuICAgIH1cbiAgICByZXR1cm4gKGFyZ3NbMF0gLSBqU3RhdC5tZWFuKGFyZ3NbMV0pKSAvIGpTdGF0LnN0ZGV2KGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9LFxuXG4gIC8vIDMgZGlmZmVyZW50IHBhcmFtdGVyIGxpc3RzOlxuICAvLyAodmFsdWUsIG1lYW4sIHNkLCBzaWRlcylcbiAgLy8gKHpzY29yZSwgc2lkZXMpXG4gIC8vICh2YWx1ZSwgYXJyYXksIHNpZGVzLCBmbGFnKVxuICB6dGVzdDogZnVuY3Rpb24genRlc3QoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICBpZihpc051bWJlcihhcmdzWzFdKSkge1xuICAgICAgICB2YXIgeiA9IGpTdGF0LnpzY29yZShhcmdzWzBdLGFyZ3NbMV0sYXJnc1syXSlcbiAgICAgICAgcmV0dXJuIChhcmdzWzNdID09PSAxKSA/XG4gICAgICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLDAsMSkpIDpcbiAgICAgICAgICAoalN0YXQubm9ybWFsLmNkZigtTWF0aC5hYnMoeiksMCwxKSogMik7XG4gICAgICB9XG4gICAgICB2YXIgeiA9IGFyZ3NbMF1cbiAgICAgIHJldHVybiAoYXJnc1syXSA9PT0gMSkgP1xuICAgICAgICAoalN0YXQubm9ybWFsLmNkZigtTWF0aC5hYnMoeiksMCwxKSkgOlxuICAgICAgICAoalN0YXQubm9ybWFsLmNkZigtTWF0aC5hYnMoeiksMCwxKSoyKTtcbiAgICB9XG4gICAgdmFyIHogPSBqU3RhdC56c2NvcmUoYXJnc1swXSxhcmdzWzFdLGFyZ3NbM10pXG4gICAgcmV0dXJuIChhcmdzWzFdID09PSAxKSA/XG4gICAgICAoalN0YXQubm9ybWFsLmNkZigtTWF0aC5hYnMoeiksIDAsIDEpKSA6XG4gICAgICAoalN0YXQubm9ybWFsLmNkZigtTWF0aC5hYnMoeiksIDAsIDEpKjIpO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIHpzY29yZTogZnVuY3Rpb24genNjb3JlKHZhbHVlLCBmbGFnKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWVhbigpKSAvIHRoaXMuc3RkZXYoZmxhZyk7XG4gIH0sXG5cbiAgenRlc3Q6IGZ1bmN0aW9uIHp0ZXN0KHZhbHVlLCBzaWRlcywgZmxhZykge1xuICAgIHZhciB6c2NvcmUgPSBNYXRoLmFicyh0aGlzLnpzY29yZSh2YWx1ZSwgZmxhZykpO1xuICAgIHJldHVybiAoc2lkZXMgPT09IDEpID9cbiAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC16c2NvcmUsIDAsIDEpKSA6XG4gICAgICAoalN0YXQubm9ybWFsLmNkZigtenNjb3JlLCAwLCAxKSAqIDIpO1xuICB9XG59KTtcblxuLy8gVCBTdGF0aXN0aWNzXG5qU3RhdC5leHRlbmQoe1xuICAvLyAyIHBhcmFtZXRlciBsaXN0c1xuICAvLyAodmFsdWUsIG1lYW4sIHNkLCBuKVxuICAvLyAodmFsdWUsIGFycmF5KVxuICB0c2NvcmU6IGZ1bmN0aW9uIHRzY29yZSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gKGFyZ3MubGVuZ3RoID09PSA0KSA/XG4gICAgICAoKGFyZ3NbMF0gLSBhcmdzWzFdKSAvIChhcmdzWzJdIC8gTWF0aC5zcXJ0KGFyZ3NbM10pKSkgOlxuICAgICAgKChhcmdzWzBdIC0galN0YXQubWVhbihhcmdzWzFdKSkgL1xuICAgICAgIChqU3RhdC5zdGRldihhcmdzWzFdLCB0cnVlKSAvIE1hdGguc3FydChhcmdzWzFdLmxlbmd0aCkpKTtcbiAgfSxcblxuICAvLyAzIGRpZmZlcmVudCBwYXJhbXRlciBsaXN0czpcbiAgLy8gKHZhbHVlLCBtZWFuLCBzZCwgbiwgc2lkZXMpXG4gIC8vICh0c2NvcmUsIG4sIHNpZGVzKVxuICAvLyAodmFsdWUsIGFycmF5LCBzaWRlcylcbiAgdHRlc3Q6IGZ1bmN0aW9uIHR0ZXN0KCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciB0c2NvcmU7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA1KSB7XG4gICAgICB0c2NvcmUgPSBNYXRoLmFicyhqU3RhdC50c2NvcmUoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSkpO1xuICAgICAgcmV0dXJuIChhcmdzWzRdID09PSAxKSA/XG4gICAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1szXS0xKSkgOlxuICAgICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbM10tMSkqMik7XG4gICAgfVxuICAgIGlmIChpc051bWJlcihhcmdzWzFdKSkge1xuICAgICAgdHNjb3JlID0gTWF0aC5hYnMoYXJnc1swXSlcbiAgICAgIHJldHVybiAoYXJnc1syXSA9PSAxKSA/XG4gICAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1sxXS0xKSkgOlxuICAgICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbMV0tMSkgKiAyKTtcbiAgICB9XG4gICAgdHNjb3JlID0gTWF0aC5hYnMoalN0YXQudHNjb3JlKGFyZ3NbMF0sIGFyZ3NbMV0pKVxuICAgIHJldHVybiAoYXJnc1syXSA9PSAxKSA/XG4gICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbMV0ubGVuZ3RoLTEpKSA6XG4gICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbMV0ubGVuZ3RoLTEpICogMik7XG4gIH1cbn0pO1xuXG5qU3RhdC5leHRlbmQoalN0YXQuZm4sIHtcbiAgdHNjb3JlOiBmdW5jdGlvbiB0c2NvcmUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5tZWFuKCkpIC8gKHRoaXMuc3RkZXYodHJ1ZSkgLyBNYXRoLnNxcnQodGhpcy5jb2xzKCkpKTtcbiAgfSxcblxuICB0dGVzdDogZnVuY3Rpb24gdHRlc3QodmFsdWUsIHNpZGVzKSB7XG4gICAgcmV0dXJuIChzaWRlcyA9PT0gMSkgP1xuICAgICAgKDEgLSBqU3RhdC5zdHVkZW50dC5jZGYoTWF0aC5hYnModGhpcy50c2NvcmUodmFsdWUpKSwgdGhpcy5jb2xzKCktMSkpIDpcbiAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLU1hdGguYWJzKHRoaXMudHNjb3JlKHZhbHVlKSksIHRoaXMuY29scygpLTEpKjIpO1xuICB9XG59KTtcblxuLy8gRiBTdGF0aXN0aWNzXG5qU3RhdC5leHRlbmQoe1xuICAvLyBQYXJhbXRlciBsaXN0IGlzIGFzIGZvbGxvd3M6XG4gIC8vIChhcnJheTEsIGFycmF5MiwgYXJyYXkzLCAuLi4pXG4gIC8vIG9yIGl0IGlzIGFuIGFycmF5IG9mIGFycmF5c1xuICAvLyBhcnJheSBvZiBhcnJheXMgY29udmVyc2lvblxuICBhbm92YWZzY29yZTogZnVuY3Rpb24gYW5vdmFmc2NvcmUoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgZXhwVmFyLCBzYW1wbGUsIHNhbXBNZWFuLCBzYW1wU2FtcE1lYW4sIHRtcGFyZ3MsIHVuZXhwVmFyLCBpLCBqO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdG1wYXJncyA9IG5ldyBBcnJheShhcmdzWzBdLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0bXBhcmdzW2ldID0gYXJnc1swXVtpXTtcbiAgICAgIH1cbiAgICAgIGFyZ3MgPSB0bXBhcmdzO1xuICAgIH1cbiAgICAvLyAyIHNhbXBsZSBjYXNlXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4galN0YXQudmFyaWFuY2UoYXJnc1swXSkgLyBqU3RhdC52YXJpYW5jZShhcmdzWzFdKTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIHNhbXBsZSBhcnJheVxuICAgIHNhbXBsZSA9IG5ldyBBcnJheSgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGUuY29uY2F0KGFyZ3NbaV0pO1xuICAgIH1cbiAgICBzYW1wTWVhbiA9IGpTdGF0Lm1lYW4oc2FtcGxlKTtcbiAgICAvLyBDb21wdXRlcyB0aGUgZXhwbGFpbmVkIHZhcmlhbmNlXG4gICAgZXhwVmFyID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwVmFyID0gZXhwVmFyICsgYXJnc1tpXS5sZW5ndGggKiBNYXRoLnBvdyhqU3RhdC5tZWFuKGFyZ3NbaV0pIC0gc2FtcE1lYW4sIDIpO1xuICAgIH1cbiAgICBleHBWYXIgLz0gKGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgLy8gQ29tcHV0ZXMgdW5leHBsYWluZWQgdmFyaWFuY2VcbiAgICB1bmV4cFZhciA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNhbXBTYW1wTWVhbiA9IGpTdGF0Lm1lYW4oYXJnc1tpXSk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgYXJnc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICB1bmV4cFZhciArPSBNYXRoLnBvdyhhcmdzW2ldW2pdIC0gc2FtcFNhbXBNZWFuLCAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5leHBWYXIgLz0gKHNhbXBsZS5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgcmV0dXJuIGV4cFZhciAvIHVuZXhwVmFyO1xuICB9LFxuXG4gIC8vIDIgZGlmZmVyZW50IHBhcmFtdGVyIHNldHVwc1xuICAvLyAoYXJyYXkxLCBhcnJheTIsIGFycmF5MywgLi4uKVxuICAvLyAoYW5vdmFmc2NvcmUsIGRmMSwgZGYyKVxuICBhbm92YWZ0ZXN0OiBmdW5jdGlvbiBhbm92YWZ0ZXN0KCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGRmMSwgZGYyLCBuLCBpO1xuICAgIGlmIChpc051bWJlcihhcmdzWzBdKSkge1xuICAgICAgcmV0dXJuIDEgLSBqU3RhdC5jZW50cmFsRi5jZGYoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIGFub3ZhZnNjb3JlID0galN0YXQuYW5vdmFmc2NvcmUoYXJncyk7XG4gICAgZGYxID0gYXJncy5sZW5ndGggLSAxO1xuICAgIG4gPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuID0gbiArIGFyZ3NbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICBkZjIgPSBuIC0gZGYxIC0gMTtcbiAgICByZXR1cm4gMSAtIGpTdGF0LmNlbnRyYWxGLmNkZihhbm92YWZzY29yZSwgZGYxLCBkZjIpO1xuICB9LFxuXG4gIGZ0ZXN0OiBmdW5jdGlvbiBmdGVzdChmc2NvcmUsIGRmMSwgZGYyKSB7XG4gICAgcmV0dXJuIDEgLSBqU3RhdC5jZW50cmFsRi5jZGYoZnNjb3JlLCBkZjEsIGRmMik7XG4gIH1cbn0pO1xuXG5qU3RhdC5leHRlbmQoalN0YXQuZm4sIHtcbiAgYW5vdmFmc2NvcmU6IGZ1bmN0aW9uIGFub3ZhZnNjb3JlKCkge1xuICAgIHJldHVybiBqU3RhdC5hbm92YWZzY29yZSh0aGlzLnRvQXJyYXkoKSk7XG4gIH0sXG5cbiAgYW5vdmFmdGVzOiBmdW5jdGlvbiBhbm92YWZ0ZXMoKSB7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuID0gbiArIHRoaXNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQuZnRlc3QodGhpcy5hbm92YWZzY29yZSgpLCB0aGlzLmxlbmd0aCAtIDEsIG4gLSB0aGlzLmxlbmd0aCk7XG4gIH1cbn0pO1xuXG4vLyBFcnJvciBCb3VuZHNcbmpTdGF0LmV4dGVuZCh7XG4gIC8vIDIgZGlmZmVyZW50IHBhcmFtZXRlciBzZXR1cHNcbiAgLy8gKHZhbHVlLCBhbHBoYSwgc2QsIG4pXG4gIC8vICh2YWx1ZSwgYWxwaGEsIGFycmF5KVxuICBub3JtYWxjaTogZnVuY3Rpb24gbm9ybWFsY2koKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgYW5zID0gbmV3IEFycmF5KDIpLFxuICAgIGNoYW5nZTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNoYW5nZSA9IE1hdGguYWJzKGpTdGF0Lm5vcm1hbC5pbnYoYXJnc1sxXSAvIDIsIDAsIDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMl0gLyBNYXRoLnNxcnQoYXJnc1szXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFuZ2UgPSBNYXRoLmFicyhqU3RhdC5ub3JtYWwuaW52KGFyZ3NbMV0gLyAyLCAwLCAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5zdGRldihhcmdzWzJdKSAvIE1hdGguc3FydChhcmdzWzJdLmxlbmd0aCkpO1xuICAgIH1cbiAgICBhbnNbMF0gPSBhcmdzWzBdIC0gY2hhbmdlO1xuICAgIGFuc1sxXSA9IGFyZ3NbMF0gKyBjaGFuZ2U7XG4gICAgcmV0dXJuIGFucztcbiAgfSxcblxuICAvLyAyIGRpZmZlcmVudCBwYXJhbWV0ZXIgc2V0dXBzXG4gIC8vICh2YWx1ZSwgYWxwaGEsIHNkLCBuKVxuICAvLyAodmFsdWUsIGFscGhhLCBhcnJheSlcbiAgdGNpOiBmdW5jdGlvbiB0Y2koKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgYW5zID0gbmV3IEFycmF5KDIpLFxuICAgIGNoYW5nZTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNoYW5nZSA9IE1hdGguYWJzKGpTdGF0LnN0dWRlbnR0LmludihhcmdzWzFdIC8gMiwgYXJnc1szXSAtIDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMl0gLyBNYXRoLnNxcnQoYXJnc1szXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFuZ2UgPSBNYXRoLmFicyhqU3RhdC5zdHVkZW50dC5pbnYoYXJnc1sxXSAvIDIsIGFyZ3NbMl0ubGVuZ3RoIC0gMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgalN0YXQuc3RkZXYoYXJnc1syXSwgdHJ1ZSkgLyBNYXRoLnNxcnQoYXJnc1syXS5sZW5ndGgpKTtcbiAgICB9XG4gICAgYW5zWzBdID0gYXJnc1swXSAtIGNoYW5nZTtcbiAgICBhbnNbMV0gPSBhcmdzWzBdICsgY2hhbmdlO1xuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgc2lnbmlmaWNhbnQ6IGZ1bmN0aW9uIHNpZ25pZmljYW50KHB2YWx1ZSwgYWxwaGEpIHtcbiAgICByZXR1cm4gcHZhbHVlIDwgYWxwaGE7XG4gIH1cbn0pO1xuXG5qU3RhdC5leHRlbmQoalN0YXQuZm4sIHtcbiAgbm9ybWFsY2k6IGZ1bmN0aW9uIG5vcm1hbGNpKHZhbHVlLCBhbHBoYSkge1xuICAgIHJldHVybiBqU3RhdC5ub3JtYWxjaSh2YWx1ZSwgYWxwaGEsIHRoaXMudG9BcnJheSgpKTtcbiAgfSxcblxuICB0Y2k6IGZ1bmN0aW9uIHRjaSh2YWx1ZSwgYWxwaGEpIHtcbiAgICByZXR1cm4galN0YXQudGNpKHZhbHVlLCBhbHBoYSwgdGhpcy50b0FycmF5KCkpO1xuICB9XG59KTtcblxufSh0aGlzLmpTdGF0LCBNYXRoKSk7XG4iLCIvKiFcbiAqIG51bWVyYWwuanNcbiAqIHZlcnNpb24gOiAxLjUuM1xuICogYXV0aG9yIDogQWRhbSBEcmFwZXJcbiAqIGxpY2Vuc2UgOiBNSVRcbiAqIGh0dHA6Ly9hZGFtd2RyYXBlci5naXRodWIuY29tL051bWVyYWwtanMvXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RhbnRzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIG51bWVyYWwsXG4gICAgICAgIFZFUlNJT04gPSAnMS41LjMnLFxuICAgICAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsYW5ndWFnZSBjb25maWcgZmlsZXNcbiAgICAgICAgbGFuZ3VhZ2VzID0ge30sXG4gICAgICAgIGN1cnJlbnRMYW5ndWFnZSA9ICdlbicsXG4gICAgICAgIHplcm9Gb3JtYXQgPSBudWxsLFxuICAgICAgICBkZWZhdWx0Rm9ybWF0ID0gJzAsMCcsXG4gICAgICAgIC8vIGNoZWNrIGZvciBub2RlSlNcbiAgICAgICAgaGFzTW9kdWxlID0gKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdHJ1Y3RvcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIE51bWVyYWwgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE51bWVyYWwgKG51bWJlcikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0b0ZpeGVkKCkgdGhhdCB0cmVhdHMgZmxvYXRzIG1vcmUgbGlrZSBkZWNpbWFsc1xuICAgICAqXG4gICAgICogRml4ZXMgYmluYXJ5IHJvdW5kaW5nIGlzc3VlcyAoZWcuICgwLjYxNSkudG9GaXhlZCgyKSA9PT0gJzAuNjEnKSB0aGF0IHByZXNlbnRcbiAgICAgKiBwcm9ibGVtcyBmb3IgYWNjb3VudGluZy0gYW5kIGZpbmFuY2UtcmVsYXRlZCBzb2Z0d2FyZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ZpeGVkICh2YWx1ZSwgcHJlY2lzaW9uLCByb3VuZGluZ0Z1bmN0aW9uLCBvcHRpb25hbHMpIHtcbiAgICAgICAgdmFyIHBvd2VyID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiksXG4gICAgICAgICAgICBvcHRpb25hbHNSZWdFeHAsXG4gICAgICAgICAgICBvdXRwdXQ7XG4gICAgICAgICAgICBcbiAgICAgICAgLy9yb3VuZGluZ0Z1bmN0aW9uID0gKHJvdW5kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCA/IHJvdW5kaW5nRnVuY3Rpb24gOiBNYXRoLnJvdW5kKTtcbiAgICAgICAgLy8gTXVsdGlwbHkgdXAgYnkgcHJlY2lzaW9uLCByb3VuZCBhY2N1cmF0ZWx5LCB0aGVuIGRpdmlkZSBhbmQgdXNlIG5hdGl2ZSB0b0ZpeGVkKCk6XG4gICAgICAgIG91dHB1dCA9IChyb3VuZGluZ0Z1bmN0aW9uKHZhbHVlICogcG93ZXIpIC8gcG93ZXIpLnRvRml4ZWQocHJlY2lzaW9uKTtcblxuICAgICAgICBpZiAob3B0aW9uYWxzKSB7XG4gICAgICAgICAgICBvcHRpb25hbHNSZWdFeHAgPSBuZXcgUmVnRXhwKCcwezEsJyArIG9wdGlvbmFscyArICd9JCcpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2Uob3B0aW9uYWxzUmVnRXhwLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRm9ybWF0dGluZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8vIGRldGVybWluZSB3aGF0IHR5cGUgb2YgZm9ybWF0dGluZyB3ZSBuZWVkIHRvIGRvXG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtZXJhbCAobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBvdXRwdXQ7XG5cbiAgICAgICAgLy8gZmlndXJlIG91dCB3aGF0IGtpbmQgb2YgZm9ybWF0IHdlIGFyZSBkZWFsaW5nIHdpdGhcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCckJykgPiAtMSkgeyAvLyBjdXJyZW5jeSEhISEhXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXRDdXJyZW5jeShuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCclJykgPiAtMSkgeyAvLyBwZXJjZW50YWdlXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXRQZXJjZW50YWdlKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJzonKSA+IC0xKSB7IC8vIHRpbWVcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdFRpbWUobiwgZm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHsgLy8gcGxhaW4gb2wnIG51bWJlcnMgb3IgYnl0ZXNcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcihuLl92YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBzdHJpbmdcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICAvLyByZXZlcnQgdG8gbnVtYmVyXG4gICAgZnVuY3Rpb24gdW5mb3JtYXROdW1lcmFsIChuLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIHN0cmluZ09yaWdpbmFsID0gc3RyaW5nLFxuICAgICAgICAgICAgdGhvdXNhbmRSZWdFeHAsXG4gICAgICAgICAgICBtaWxsaW9uUmVnRXhwLFxuICAgICAgICAgICAgYmlsbGlvblJlZ0V4cCxcbiAgICAgICAgICAgIHRyaWxsaW9uUmVnRXhwLFxuICAgICAgICAgICAgc3VmZml4ZXMgPSBbJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ10sXG4gICAgICAgICAgICBieXRlc011bHRpcGxpZXIgPSBmYWxzZSxcbiAgICAgICAgICAgIHBvd2VyO1xuXG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignOicpID4gLTEpIHtcbiAgICAgICAgICAgIG4uX3ZhbHVlID0gdW5mb3JtYXRUaW1lKHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5nID09PSB6ZXJvRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcLi9nLCcnKS5yZXBsYWNlKGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMuZGVjaW1hbCwgJy4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWUgaWYgYWJicmV2aWF0aW9ucyBhcmUgdGhlcmUgc28gdGhhdCB3ZSBjYW4gbXVsdGlwbHkgdG8gdGhlIGNvcnJlY3QgbnVtYmVyXG4gICAgICAgICAgICAgICAgdGhvdXNhbmRSZWdFeHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy50aG91c2FuZCArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG4gICAgICAgICAgICAgICAgbWlsbGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLm1pbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuICAgICAgICAgICAgICAgIGJpbGxpb25SZWdFeHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy5iaWxsaW9uICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcbiAgICAgICAgICAgICAgICB0cmlsbGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRyaWxsaW9uICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcblxuICAgICAgICAgICAgICAgIC8vIHNlZSBpZiBieXRlcyBhcmUgdGhlcmUgc28gdGhhdCB3ZSBjYW4gbXVsdGlwbHkgdG8gdGhlIGNvcnJlY3QgbnVtYmVyXG4gICAgICAgICAgICAgICAgZm9yIChwb3dlciA9IDA7IHBvd2VyIDw9IHN1ZmZpeGVzLmxlbmd0aDsgcG93ZXIrKykge1xuICAgICAgICAgICAgICAgICAgICBieXRlc011bHRpcGxpZXIgPSAoc3RyaW5nLmluZGV4T2Yoc3VmZml4ZXNbcG93ZXJdKSA+IC0xKSA/IE1hdGgucG93KDEwMjQsIHBvd2VyICsgMSkgOiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXNNdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRvIHNvbWUgbWF0aCB0byBjcmVhdGUgb3VyIG51bWJlclxuICAgICAgICAgICAgICAgIG4uX3ZhbHVlID0gKChieXRlc011bHRpcGxpZXIpID8gYnl0ZXNNdWx0aXBsaWVyIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKHRob3VzYW5kUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgMykgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2gobWlsbGlvblJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDYpIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKGJpbGxpb25SZWdFeHApKSA/IE1hdGgucG93KDEwLCA5KSA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaCh0cmlsbGlvblJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDEyKSA6IDEpICogKChzdHJpbmcuaW5kZXhPZignJScpID4gLTEpID8gMC4wMSA6IDEpICogKCgoc3RyaW5nLnNwbGl0KCctJykubGVuZ3RoICsgTWF0aC5taW4oc3RyaW5nLnNwbGl0KCcoJykubGVuZ3RoLTEsIHN0cmluZy5zcGxpdCgnKScpLmxlbmd0aC0xKSkgJSAyKT8gMTogLTEpICogTnVtYmVyKHN0cmluZy5yZXBsYWNlKC9bXjAtOVxcLl0rL2csICcnKSk7XG5cbiAgICAgICAgICAgICAgICAvLyByb3VuZCBpZiB3ZSBhcmUgdGFsa2luZyBhYm91dCBieXRlc1xuICAgICAgICAgICAgICAgIG4uX3ZhbHVlID0gKGJ5dGVzTXVsdGlwbGllcikgPyBNYXRoLmNlaWwobi5fdmFsdWUpIDogbi5fdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uX3ZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdEN1cnJlbmN5IChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHN5bWJvbEluZGV4ID0gZm9ybWF0LmluZGV4T2YoJyQnKSxcbiAgICAgICAgICAgIG9wZW5QYXJlbkluZGV4ID0gZm9ybWF0LmluZGV4T2YoJygnKSxcbiAgICAgICAgICAgIG1pbnVzU2lnbkluZGV4ID0gZm9ybWF0LmluZGV4T2YoJy0nKSxcbiAgICAgICAgICAgIHNwYWNlID0gJycsXG4gICAgICAgICAgICBzcGxpY2VJbmRleCxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlIG9yIGFmdGVyIGN1cnJlbmN5XG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignICQnKSA+IC0xKSB7XG4gICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgJCcsICcnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignJCAnKSA+IC0xKSB7XG4gICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCckICcsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCckJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9ybWF0IHRoZSBudW1iZXJcbiAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKG4uX3ZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIHRoZSBzeW1ib2xcbiAgICAgICAgaWYgKHN5bWJvbEluZGV4IDw9IDEpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKCcpID4gLTEgfHwgb3V0cHV0LmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBzcGxpY2VJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbEluZGV4IDwgb3BlblBhcmVuSW5kZXggfHwgc3ltYm9sSW5kZXggPCBtaW51c1NpZ25JbmRleCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzeW1ib2wgYXBwZWFycyBiZWZvcmUgdGhlIFwiKFwiIG9yIFwiLVwiXG4gICAgICAgICAgICAgICAgICAgIHNwbGljZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZShzcGxpY2VJbmRleCwgMCwgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgc3BhY2UgKyBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJyknKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKC0xLCAwLCBzcGFjZSArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UGVyY2VudGFnZSAobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBzcGFjZSA9ICcnLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgdmFsdWUgPSBuLl92YWx1ZSAqIDEwMDtcblxuICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlICVcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgJScpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyAlJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyUnLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIFxuICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJyknKSA+IC0xICkge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgJyUnKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgJyUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRUaW1lIChuKSB7XG4gICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3Iobi5fdmFsdWUvNjAvNjApLFxuICAgICAgICAgICAgbWludXRlcyA9IE1hdGguZmxvb3IoKG4uX3ZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkpLzYwKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLnJvdW5kKG4uX3ZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkgLSAobWludXRlcyAqIDYwKSk7XG4gICAgICAgIHJldHVybiBob3VycyArICc6JyArICgobWludXRlcyA8IDEwKSA/ICcwJyArIG1pbnV0ZXMgOiBtaW51dGVzKSArICc6JyArICgoc2Vjb25kcyA8IDEwKSA/ICcwJyArIHNlY29uZHMgOiBzZWNvbmRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmZvcm1hdFRpbWUgKHN0cmluZykge1xuICAgICAgICB2YXIgdGltZUFycmF5ID0gc3RyaW5nLnNwbGl0KCc6JyksXG4gICAgICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgICAgLy8gdHVybiBob3VycyBhbmQgbWludXRlcyBpbnRvIHNlY29uZHMgYW5kIGFkZCB0aGVtIGFsbCB1cFxuICAgICAgICBpZiAodGltZUFycmF5Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMF0pICogNjAgKiA2MCk7XG4gICAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzFdKSAqIDYwKTtcbiAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgTnVtYmVyKHRpbWVBcnJheVsyXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZUFycmF5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyAoTnVtYmVyKHRpbWVBcnJheVswXSkgKiA2MCk7XG4gICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIE51bWJlcih0aW1lQXJyYXlbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIoc2Vjb25kcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyICh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBuZWdQID0gZmFsc2UsXG4gICAgICAgICAgICBzaWduZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIG9wdERlYyA9IGZhbHNlLFxuICAgICAgICAgICAgYWJiciA9ICcnLFxuICAgICAgICAgICAgYWJicksgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIHRob3VzYW5kc1xuICAgICAgICAgICAgYWJick0gPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIG1pbGxpb25zXG4gICAgICAgICAgICBhYmJyQiA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gYmlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJUID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byB0cmlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJGb3JjZSA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgIGJ5dGVzID0gJycsXG4gICAgICAgICAgICBvcmQgPSAnJyxcbiAgICAgICAgICAgIGFicyA9IE1hdGguYWJzKHZhbHVlKSxcbiAgICAgICAgICAgIHN1ZmZpeGVzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ10sXG4gICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICBwb3dlcixcbiAgICAgICAgICAgIHcsXG4gICAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgICB0aG91c2FuZHMsXG4gICAgICAgICAgICBkID0gJycsXG4gICAgICAgICAgICBuZWcgPSBmYWxzZTtcblxuICAgICAgICAvLyBjaGVjayBpZiBudW1iZXIgaXMgemVybyBhbmQgYSBjdXN0b20gemVybyBmb3JtYXQgaGFzIGJlZW4gc2V0XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiB6ZXJvRm9ybWF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb0Zvcm1hdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNlZSBpZiB3ZSBzaG91bGQgdXNlIHBhcmVudGhlc2VzIGZvciBuZWdhdGl2ZSBudW1iZXIgb3IgaWYgd2Ugc2hvdWxkIHByZWZpeCB3aXRoIGEgc2lnblxuICAgICAgICAgICAgLy8gaWYgYm90aCBhcmUgcHJlc2VudCB3ZSBkZWZhdWx0IHRvIHBhcmVudGhlc2VzXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJygnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbmVnUCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJysnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFwrL2csICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIGFiYnJldmlhdGlvbiBpcyB3YW50ZWRcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignYScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhYmJyZXZpYXRpb24gaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgYWJicksgPSBmb3JtYXQuaW5kZXhPZignYUsnKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJNID0gZm9ybWF0LmluZGV4T2YoJ2FNJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyQiA9IGZvcm1hdC5pbmRleE9mKCdhQicpID49IDA7XG4gICAgICAgICAgICAgICAgYWJiclQgPSBmb3JtYXQuaW5kZXhPZignYVQnKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSA9IGFiYnJLIHx8IGFiYnJNIHx8IGFiYnJCIHx8IGFiYnJUO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBhJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhYmJyID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIGEnLCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2EnLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFicyA+PSBNYXRoLnBvdygxMCwgMTIpICYmICFhYmJyRm9yY2UgfHwgYWJiclQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRyaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDEyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCAxMikgJiYgYWJzID49IE1hdGgucG93KDEwLCA5KSAmJiAhYWJickZvcmNlIHx8IGFiYnJCKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLmJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgOSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgOSkgJiYgYWJzID49IE1hdGgucG93KDEwLCA2KSAmJiAhYWJickZvcmNlIHx8IGFiYnJNKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLm1pbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgNik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgNikgJiYgYWJzID49IE1hdGgucG93KDEwLCAzKSAmJiAhYWJickZvcmNlIHx8IGFiYnJLKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRob3VzYW5kXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy50aG91c2FuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiB3ZSBhcmUgZm9ybWF0dGluZyBieXRlc1xuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdiJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBiJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcyA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBiJywgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdiJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAocG93ZXIgPSAwOyBwb3dlciA8PSBzdWZmaXhlcy5sZW5ndGg7IHBvd2VyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gTWF0aC5wb3coMTAyNCwgcG93ZXIpO1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLnBvdygxMDI0LCBwb3dlcisxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gbWluICYmIHZhbHVlIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGVzICsgc3VmZml4ZXNbcG93ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiBvcmRpbmFsIGlzIHdhbnRlZFxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdvJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBvJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvcmQgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgbycsICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnbycsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcmQgPSBvcmQgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5vcmRpbmFsKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdbLl0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0RGVjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnWy5dJywgJy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdyA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGZvcm1hdC5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgdGhvdXNhbmRzID0gZm9ybWF0LmluZGV4T2YoJywnKTtcblxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNpb24uaW5kZXhPZignWycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnJlcGxhY2UoJ10nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbi5zcGxpdCgnWycpO1xuICAgICAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgKHByZWNpc2lvblswXS5sZW5ndGggKyBwcmVjaXNpb25bMV0ubGVuZ3RoKSwgcm91bmRpbmdGdW5jdGlvbiwgcHJlY2lzaW9uWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHRvRml4ZWQodmFsdWUsIHByZWNpc2lvbi5sZW5ndGgsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHcgPSBkLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZC5zcGxpdCgnLicpWzFdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsICsgZC5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0RGVjICYmIE51bWJlcihkLnNsaWNlKDEpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gdG9GaXhlZCh2YWx1ZSwgbnVsbCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCBudW1iZXJcbiAgICAgICAgICAgIGlmICh3LmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdyA9IHcuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbmVnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRob3VzYW5kcyA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdyA9IHcudG9TdHJpbmcoKS5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pKyg/IVxcZCkpL2csICckMScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLnRob3VzYW5kcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdyA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKChuZWdQICYmIG5lZykgPyAnKCcgOiAnJykgKyAoKCFuZWdQICYmIG5lZykgPyAnLScgOiAnJykgKyAoKCFuZWcgJiYgc2lnbmVkKSA/ICcrJyA6ICcnKSArIHcgKyBkICsgKChvcmQpID8gb3JkIDogJycpICsgKChhYmJyKSA/IGFiYnIgOiAnJykgKyAoKGJ5dGVzKSA/IGJ5dGVzIDogJycpICsgKChuZWdQICYmIG5lZykgPyAnKScgOiAnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFRvcCBMZXZlbCBGdW5jdGlvbnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBudW1lcmFsID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmIChudW1lcmFsLmlzTnVtZXJhbChpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gMCB8fCB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIU51bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gbnVtZXJhbC5mbi51bmZvcm1hdChpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE51bWVyYWwoTnVtYmVyKGlucHV0KSk7XG4gICAgfTtcblxuICAgIC8vIHZlcnNpb24gbnVtYmVyXG4gICAgbnVtZXJhbC52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIC8vIGNvbXBhcmUgbnVtZXJhbCBvYmplY3RcbiAgICBudW1lcmFsLmlzTnVtZXJhbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bWVyYWw7XG4gICAgfTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxhbmd1YWdlcyBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsYW5ndWFnZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsYW5ndWFnZSBrZXkuXG4gICAgbnVtZXJhbC5sYW5ndWFnZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRMYW5ndWFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgJiYgIXZhbHVlcykge1xuICAgICAgICAgICAgaWYoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlIDogJyArIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGFuZ3VhZ2UgPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzIHx8ICFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgbG9hZExhbmd1YWdlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1lcmFsO1xuICAgIH07XG4gICAgXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGxvYWRlZCBsYW5ndWFnZSBkYXRhLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50XG4gICAgLy8gZ2xvYmFsIGxhbmd1YWdlIG9iamVjdC5cbiAgICBudW1lcmFsLmxhbmd1YWdlRGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlIDogJyArIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBsYW5ndWFnZXNba2V5XTtcbiAgICB9O1xuXG4gICAgbnVtZXJhbC5sYW5ndWFnZSgnZW4nLCB7XG4gICAgICAgIGRlbGltaXRlcnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kczogJywnLFxuICAgICAgICAgICAgZGVjaW1hbDogJy4nXG4gICAgICAgIH0sXG4gICAgICAgIGFiYnJldmlhdGlvbnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kOiAnaycsXG4gICAgICAgICAgICBtaWxsaW9uOiAnbScsXG4gICAgICAgICAgICBiaWxsaW9uOiAnYicsXG4gICAgICAgICAgICB0cmlsbGlvbjogJ3QnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTA7XG4gICAgICAgICAgICByZXR1cm4gKH5+IChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbmN5OiB7XG4gICAgICAgICAgICBzeW1ib2w6ICckJ1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBudW1lcmFsLnplcm9Gb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHplcm9Gb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiBudWxsO1xuICAgIH07XG5cbiAgICBudW1lcmFsLmRlZmF1bHRGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIGRlZmF1bHRGb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiAnMC4wJztcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBIZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gbG9hZExhbmd1YWdlKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGxhbmd1YWdlc1trZXldID0gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRmxvYXRpbmctcG9pbnQgaGVscGVyc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8vIFRoZSBmbG9hdGluZy1wb2ludCBoZWxwZXIgZnVuY3Rpb25zIGFuZCBpbXBsZW1lbnRhdGlvblxuICAgIC8vIGJvcnJvd3MgaGVhdmlseSBmcm9tIHNpbmZ1bC5qczogaHR0cDovL2d1aXBuLmdpdGh1Yi5pby9zaW5mdWwuanMvXG5cbiAgICAvKipcbiAgICAgKiBBcnJheS5wcm90b3R5cGUucmVkdWNlIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXRcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9SZWR1Y2UjQ29tcGF0aWJpbGl0eVxuICAgICAqL1xuICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChudWxsID09PSB0aGlzIHx8ICd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcykge1xuICAgICAgICAgICAgICAgIC8vIEF0IHRoZSBtb21lbnQgYWxsIG1vZGVybiBicm93c2VycywgdGhhdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuIEZvciBpbnN0YW5jZSwgSUU4XG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3Qgc3VwcG9ydCBzdHJpY3QgbW9kZSwgc28gdGhpcyBjaGVjayBpcyBhY3R1YWxseSB1c2VsZXNzLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2UgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICAgICAgaXNWYWx1ZVNldCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoMSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9wdF9pbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgaXNWYWx1ZVNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBsZW5ndGggPiBpbmRleDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZVNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgdGhpc1tpbmRleF0sIGluZGV4LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc1ZhbHVlU2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG11bHRpcGxpZXIgbmVjZXNzYXJ5IHRvIG1ha2UgeCA+PSAxLFxuICAgICAqIGVmZmVjdGl2ZWx5IGVsaW1pbmF0aW5nIG1pc2NhbGN1bGF0aW9ucyBjYXVzZWQgYnlcbiAgICAgKiBmaW5pdGUgcHJlY2lzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bHRpcGxpZXIoeCkge1xuICAgICAgICB2YXIgcGFydHMgPSB4LnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgcGFydHNbMV0ubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMsIHJldHVybnMgdGhlIG1heGltdW1cbiAgICAgKiBtdWx0aXBsaWVyIHRoYXQgbXVzdCBiZSB1c2VkIHRvIG5vcm1hbGl6ZSBhbiBvcGVyYXRpb24gaW52b2x2aW5nXG4gICAgICogYWxsIG9mIHRoZW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29ycmVjdGlvbkZhY3RvcigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgICAgICAgIHZhciBtcCA9IG11bHRpcGxpZXIocHJldiksXG4gICAgICAgICAgICAgICAgbW4gPSBtdWx0aXBsaWVyKG5leHQpO1xuICAgICAgICByZXR1cm4gbXAgPiBtbiA/IG1wIDogbW47XG4gICAgICAgIH0sIC1JbmZpbml0eSk7XG4gICAgfSAgICAgICAgXG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgTnVtZXJhbCBQcm90b3R5cGVcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIG51bWVyYWwuZm4gPSBOdW1lcmFsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjbG9uZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1lcmFsKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdCA6IGZ1bmN0aW9uIChpbnB1dFN0cmluZywgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWVyYWwodGhpcywgXG4gICAgICAgICAgICAgICAgICBpbnB1dFN0cmluZyA/IGlucHV0U3RyaW5nIDogZGVmYXVsdEZvcm1hdCwgXG4gICAgICAgICAgICAgICAgICAocm91bmRpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSA/IHJvdW5kaW5nRnVuY3Rpb24gOiBNYXRoLnJvdW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5mb3JtYXQgOiBmdW5jdGlvbiAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXRTdHJpbmcpID09PSAnW29iamVjdCBOdW1iZXJdJykgeyBcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRTdHJpbmc7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZm9ybWF0TnVtZXJhbCh0aGlzLCBpbnB1dFN0cmluZyA/IGlucHV0U3RyaW5nIDogZGVmYXVsdEZvcm1hdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWVPZiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBjb3JyZWN0aW9uRmFjdG9yLmNhbGwobnVsbCwgdGhpcy5fdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIGNvcnJGYWN0b3IgKiBjdXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbdGhpcy5fdmFsdWUsIHZhbHVlXS5yZWR1Y2UoY2JhY2ssIDApIC8gY29yckZhY3RvcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1YnRyYWN0IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtIC0gY29yckZhY3RvciAqIGN1cnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt2YWx1ZV0ucmVkdWNlKGNiYWNrLCB0aGlzLl92YWx1ZSAqIGNvcnJGYWN0b3IpIC8gY29yckZhY3RvcjsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIG11bHRpcGx5IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IoYWNjdW0sIGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoYWNjdW0gKiBjb3JyRmFjdG9yKSAqIChjdXJyICogY29yckZhY3RvcikgL1xuICAgICAgICAgICAgICAgICAgICAoY29yckZhY3RvciAqIGNvcnJGYWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbdGhpcy5fdmFsdWUsIHZhbHVlXS5yZWR1Y2UoY2JhY2ssIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGl2aWRlIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IoYWNjdW0sIGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoYWNjdW0gKiBjb3JyRmFjdG9yKSAvIChjdXJyICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjayk7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaWZmZXJlbmNlIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobnVtZXJhbCh0aGlzLl92YWx1ZSkuc3VidHJhY3QodmFsdWUpLnZhbHVlKCkpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBFeHBvc2luZyBOdW1lcmFsXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gQ29tbW9uSlMgbW9kdWxlIGlzIGRlZmluZWRcbiAgICBpZiAoaGFzTW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbnVtZXJhbDtcbiAgICB9XG5cbiAgICAvKmdsb2JhbCBlbmRlcjpmYWxzZSAqL1xuICAgIGlmICh0eXBlb2YgZW5kZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGhlcmUsIGB0aGlzYCBtZWFucyBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlclxuICAgICAgICAvLyBhZGQgYG51bWVyYWxgIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcbiAgICAgICAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgJ2FkdmFuY2VkJyBtb2RlXG4gICAgICAgIHRoaXNbJ251bWVyYWwnXSA9IG51bWVyYWw7XG4gICAgfVxuXG4gICAgLypnbG9iYWwgZGVmaW5lOmZhbHNlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1lcmFsO1xuICAgICAgICB9KTtcbiAgICB9XG59KS5jYWxsKHRoaXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBudW1lcmljID0gKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiKT8oZnVuY3Rpb24gbnVtZXJpYygpIHt9KTooZXhwb3J0cyk7XG5pZih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7IGdsb2JhbC5udW1lcmljID0gbnVtZXJpYzsgfVxuXG5udW1lcmljLnZlcnNpb24gPSBcIjEuMi42XCI7XG5cbi8vIDEuIFV0aWxpdHkgZnVuY3Rpb25zXG5udW1lcmljLmJlbmNoID0gZnVuY3Rpb24gYmVuY2ggKGYsaW50ZXJ2YWwpIHtcbiAgICB2YXIgdDEsdDIsbixpO1xuICAgIGlmKHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJ1bmRlZmluZWRcIikgeyBpbnRlcnZhbCA9IDE1OyB9XG4gICAgbiA9IDAuNTtcbiAgICB0MSA9IG5ldyBEYXRlKCk7XG4gICAgd2hpbGUoMSkge1xuICAgICAgICBuKj0yO1xuICAgICAgICBmb3IoaT1uO2k+MztpLT00KSB7IGYoKTsgZigpOyBmKCk7IGYoKTsgfVxuICAgICAgICB3aGlsZShpPjApIHsgZigpOyBpLS07IH1cbiAgICAgICAgdDIgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZih0Mi10MSA+IGludGVydmFsKSBicmVhaztcbiAgICB9XG4gICAgZm9yKGk9bjtpPjM7aS09NCkgeyBmKCk7IGYoKTsgZigpOyBmKCk7IH1cbiAgICB3aGlsZShpPjApIHsgZigpOyBpLS07IH1cbiAgICB0MiA9IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIDEwMDAqKDMqbi0xKS8odDItdDEpO1xufVxuXG5udW1lcmljLl9teUluZGV4T2YgPSAoZnVuY3Rpb24gX215SW5kZXhPZih3KSB7XG4gICAgdmFyIG4gPSB0aGlzLmxlbmd0aCxrO1xuICAgIGZvcihrPTA7azxuOysraykgaWYodGhpc1trXT09PXcpIHJldHVybiBrO1xuICAgIHJldHVybiAtMTtcbn0pO1xubnVtZXJpYy5teUluZGV4T2YgPSAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpP0FycmF5LnByb3RvdHlwZS5pbmRleE9mOm51bWVyaWMuX215SW5kZXhPZjtcblxubnVtZXJpYy5GdW5jdGlvbiA9IEZ1bmN0aW9uO1xubnVtZXJpYy5wcmVjaXNpb24gPSA0O1xubnVtZXJpYy5sYXJnZUFycmF5ID0gNTA7XG5cbm51bWVyaWMucHJldHR5UHJpbnQgPSBmdW5jdGlvbiBwcmV0dHlQcmludCh4KSB7XG4gICAgZnVuY3Rpb24gZm10bnVtKHgpIHtcbiAgICAgICAgaWYoeCA9PT0gMCkgeyByZXR1cm4gJzAnOyB9XG4gICAgICAgIGlmKGlzTmFOKHgpKSB7IHJldHVybiAnTmFOJzsgfVxuICAgICAgICBpZih4PDApIHsgcmV0dXJuICctJytmbXRudW0oLXgpOyB9XG4gICAgICAgIGlmKGlzRmluaXRlKHgpKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHgpIC8gTWF0aC5sb2coMTApKTtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0geCAvIE1hdGgucG93KDEwLHNjYWxlKTtcbiAgICAgICAgICAgIHZhciBiYXNpYyA9IG5vcm1hbGl6ZWQudG9QcmVjaXNpb24obnVtZXJpYy5wcmVjaXNpb24pO1xuICAgICAgICAgICAgaWYocGFyc2VGbG9hdChiYXNpYykgPT09IDEwKSB7IHNjYWxlKys7IG5vcm1hbGl6ZWQgPSAxOyBiYXNpYyA9IG5vcm1hbGl6ZWQudG9QcmVjaXNpb24obnVtZXJpYy5wcmVjaXNpb24pOyB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChiYXNpYykudG9TdHJpbmcoKSsnZScrc2NhbGUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0luZmluaXR5JztcbiAgICB9XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZ1bmN0aW9uIGZvbyh4KSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJ1bmRlZmluZWRcIikgeyByZXQucHVzaChBcnJheShudW1lcmljLnByZWNpc2lvbis4KS5qb2luKCcgJykpOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgaWYodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHsgcmV0LnB1c2goJ1wiJyt4KydcIicpOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgaWYodHlwZW9mIHggPT09IFwiYm9vbGVhblwiKSB7IHJldC5wdXNoKHgudG9TdHJpbmcoKSk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFyIGEgPSBmbXRudW0oeCk7XG4gICAgICAgICAgICB2YXIgYiA9IHgudG9QcmVjaXNpb24obnVtZXJpYy5wcmVjaXNpb24pO1xuICAgICAgICAgICAgdmFyIGMgPSBwYXJzZUZsb2F0KHgudG9TdHJpbmcoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBkID0gW2EsYixjLHBhcnNlRmxvYXQoYikudG9TdHJpbmcoKSxwYXJzZUZsb2F0KGMpLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgZm9yKGs9MTtrPGQubGVuZ3RoO2srKykgeyBpZihkW2tdLmxlbmd0aCA8IGEubGVuZ3RoKSBhID0gZFtrXTsgfVxuICAgICAgICAgICAgcmV0LnB1c2goQXJyYXkobnVtZXJpYy5wcmVjaXNpb24rOC1hLmxlbmd0aCkuam9pbignICcpK2EpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHggPT09IG51bGwpIHsgcmV0LnB1c2goXCJudWxsXCIpOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgaWYodHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIikgeyBcbiAgICAgICAgICAgIHJldC5wdXNoKHgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKGsgaW4geCkgeyBpZih4Lmhhc093blByb3BlcnR5KGspKSB7IFxuICAgICAgICAgICAgICAgIGlmKGZsYWcpIHJldC5wdXNoKCcsXFxuJyk7XG4gICAgICAgICAgICAgICAgZWxzZSByZXQucHVzaCgnXFxueycpO1xuICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlOyBcbiAgICAgICAgICAgICAgICByZXQucHVzaChrKTsgXG4gICAgICAgICAgICAgICAgcmV0LnB1c2goJzogXFxuJyk7IFxuICAgICAgICAgICAgICAgIGZvbyh4W2tdKTsgXG4gICAgICAgICAgICB9IH1cbiAgICAgICAgICAgIGlmKGZsYWcpIHJldC5wdXNoKCd9XFxuJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih4IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmKHgubGVuZ3RoID4gbnVtZXJpYy5sYXJnZUFycmF5KSB7IHJldC5wdXNoKCcuLi5MYXJnZSBBcnJheS4uLicpOyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldC5wdXNoKCdbJyk7XG4gICAgICAgICAgICBmb3Ioaz0wO2s8eC5sZW5ndGg7aysrKSB7IGlmKGs+MCkgeyByZXQucHVzaCgnLCcpOyBpZihmbGFnKSByZXQucHVzaCgnXFxuICcpOyB9IGZsYWcgPSBmb28oeFtrXSk7IH1cbiAgICAgICAgICAgIHJldC5wdXNoKCddJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXQucHVzaCgneycpO1xuICAgICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgICBmb3IoayBpbiB4KSB7IGlmKHguaGFzT3duUHJvcGVydHkoaykpIHsgaWYoZmxhZykgcmV0LnB1c2goJyxcXG4nKTsgZmxhZyA9IHRydWU7IHJldC5wdXNoKGspOyByZXQucHVzaCgnOiBcXG4nKTsgZm9vKHhba10pOyB9IH1cbiAgICAgICAgcmV0LnB1c2goJ30nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvbyh4KTtcbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xufVxuXG5udW1lcmljLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uIHBhcnNlRGF0ZShkKSB7XG4gICAgZnVuY3Rpb24gZm9vKGQpIHtcbiAgICAgICAgaWYodHlwZW9mIGQgPT09ICdzdHJpbmcnKSB7IHJldHVybiBEYXRlLnBhcnNlKGQucmVwbGFjZSgvLS9nLCcvJykpOyB9XG4gICAgICAgIGlmKCEoZCBpbnN0YW5jZW9mIEFycmF5KSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJwYXJzZURhdGU6IHBhcmFtZXRlciBtdXN0IGJlIGFycmF5cyBvZiBzdHJpbmdzXCIpOyB9XG4gICAgICAgIHZhciByZXQgPSBbXSxrO1xuICAgICAgICBmb3Ioaz0wO2s8ZC5sZW5ndGg7aysrKSB7IHJldFtrXSA9IGZvbyhkW2tdKTsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gZm9vKGQpO1xufVxuXG5udW1lcmljLnBhcnNlRmxvYXQgPSBmdW5jdGlvbiBwYXJzZUZsb2F0XyhkKSB7XG4gICAgZnVuY3Rpb24gZm9vKGQpIHtcbiAgICAgICAgaWYodHlwZW9mIGQgPT09ICdzdHJpbmcnKSB7IHJldHVybiBwYXJzZUZsb2F0KGQpOyB9XG4gICAgICAgIGlmKCEoZCBpbnN0YW5jZW9mIEFycmF5KSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJwYXJzZUZsb2F0OiBwYXJhbWV0ZXIgbXVzdCBiZSBhcnJheXMgb2Ygc3RyaW5nc1wiKTsgfVxuICAgICAgICB2YXIgcmV0ID0gW10saztcbiAgICAgICAgZm9yKGs9MDtrPGQubGVuZ3RoO2srKykgeyByZXRba10gPSBmb28oZFtrXSk7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIGZvbyhkKTtcbn1cblxubnVtZXJpYy5wYXJzZUNTViA9IGZ1bmN0aW9uIHBhcnNlQ1NWKHQpIHtcbiAgICB2YXIgZm9vID0gdC5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIGosaztcbiAgICB2YXIgcmV0ID0gW107XG4gICAgdmFyIHBhdCA9IC8oKFteJ1wiLF0qKXwoJ1teJ10qJyl8KFwiW15cIl0qXCIpKSwvZztcbiAgICB2YXIgcGF0bnVtID0gL15cXHMqKChbKy1dP1swLTldKyhcXC5bMC05XSopPyhlWystXT9bMC05XSspPyl8KFsrLV0/WzAtOV0qKFxcLlswLTldKyk/KGVbKy1dP1swLTldKyk/KSlcXHMqJC87XG4gICAgdmFyIHN0cmlwcGVyID0gZnVuY3Rpb24obikgeyByZXR1cm4gbi5zdWJzdHIoMCxuLmxlbmd0aC0xKTsgfVxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZm9yKGs9MDtrPGZvby5sZW5ndGg7aysrKSB7XG4gICAgICB2YXIgYmFyID0gKGZvb1trXStcIixcIikubWF0Y2gocGF0KSxiYXo7XG4gICAgICBpZihiYXIubGVuZ3RoPjApIHtcbiAgICAgICAgICByZXRbY291bnRdID0gW107XG4gICAgICAgICAgZm9yKGo9MDtqPGJhci5sZW5ndGg7aisrKSB7XG4gICAgICAgICAgICAgIGJheiA9IHN0cmlwcGVyKGJhcltqXSk7XG4gICAgICAgICAgICAgIGlmKHBhdG51bS50ZXN0KGJheikpIHsgcmV0W2NvdW50XVtqXSA9IHBhcnNlRmxvYXQoYmF6KTsgfVxuICAgICAgICAgICAgICBlbHNlIHJldFtjb3VudF1bal0gPSBiYXo7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMudG9DU1YgPSBmdW5jdGlvbiB0b0NTVihBKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbShBKTtcbiAgICB2YXIgaSxqLG0sbixyb3cscmV0O1xuICAgIG0gPSBzWzBdO1xuICAgIG4gPSBzWzFdO1xuICAgIHJldCA9IFtdO1xuICAgIGZvcihpPTA7aTxtO2krKykge1xuICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgZm9yKGo9MDtqPG07aisrKSB7IHJvd1tqXSA9IEFbaV1bal0udG9TdHJpbmcoKTsgfVxuICAgICAgICByZXRbaV0gPSByb3cuam9pbignLCAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCdcXG4nKSsnXFxuJztcbn1cblxubnVtZXJpYy5nZXRVUkwgPSBmdW5jdGlvbiBnZXRVUkwodXJsKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNsaWVudC5vcGVuKFwiR0VUXCIsdXJsLGZhbHNlKTtcbiAgICBjbGllbnQuc2VuZCgpO1xuICAgIHJldHVybiBjbGllbnQ7XG59XG5cbm51bWVyaWMuaW1hZ2VVUkwgPSBmdW5jdGlvbiBpbWFnZVVSTChpbWcpIHtcbiAgICBmdW5jdGlvbiBiYXNlNjQoQSkge1xuICAgICAgICB2YXIgbiA9IEEubGVuZ3RoLCBpLHgseSx6LHAscSxyLHM7XG4gICAgICAgIHZhciBrZXkgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICAgIHZhciByZXQgPSBcIlwiO1xuICAgICAgICBmb3IoaT0wO2k8bjtpKz0zKSB7XG4gICAgICAgICAgICB4ID0gQVtpXTtcbiAgICAgICAgICAgIHkgPSBBW2krMV07XG4gICAgICAgICAgICB6ID0gQVtpKzJdO1xuICAgICAgICAgICAgcCA9IHggPj4gMjtcbiAgICAgICAgICAgIHEgPSAoKHggJiAzKSA8PCA0KSArICh5ID4+IDQpO1xuICAgICAgICAgICAgciA9ICgoeSAmIDE1KSA8PCAyKSArICh6ID4+IDYpO1xuICAgICAgICAgICAgcyA9IHogJiA2MztcbiAgICAgICAgICAgIGlmKGkrMT49bikgeyByID0gcyA9IDY0OyB9XG4gICAgICAgICAgICBlbHNlIGlmKGkrMj49bikgeyBzID0gNjQ7IH1cbiAgICAgICAgICAgIHJldCArPSBrZXkuY2hhckF0KHApICsga2V5LmNoYXJBdChxKSArIGtleS5jaGFyQXQocikgKyBrZXkuY2hhckF0KHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmMzMkFycmF5IChhLGZyb20sdG8pIHtcbiAgICAgICAgaWYodHlwZW9mIGZyb20gPT09IFwidW5kZWZpbmVkXCIpIHsgZnJvbSA9IDA7IH1cbiAgICAgICAgaWYodHlwZW9mIHRvID09PSBcInVuZGVmaW5lZFwiKSB7IHRvID0gYS5sZW5ndGg7IH1cbiAgICAgICAgdmFyIHRhYmxlID0gWzB4MDAwMDAwMDAsIDB4NzcwNzMwOTYsIDB4RUUwRTYxMkMsIDB4OTkwOTUxQkEsIDB4MDc2REM0MTksIDB4NzA2QUY0OEYsIDB4RTk2M0E1MzUsIDB4OUU2NDk1QTMsXG4gICAgICAgICAgICAgICAgICAgICAweDBFREI4ODMyLCAweDc5RENCOEE0LCAweEUwRDVFOTFFLCAweDk3RDJEOTg4LCAweDA5QjY0QzJCLCAweDdFQjE3Q0JELCAweEU3QjgyRDA3LCAweDkwQkYxRDkxLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4MURCNzEwNjQsIDB4NkFCMDIwRjIsIDB4RjNCOTcxNDgsIDB4ODRCRTQxREUsIDB4MUFEQUQ0N0QsIDB4NkREREU0RUIsIDB4RjRENEI1NTEsIDB4ODNEMzg1QzcsXG4gICAgICAgICAgICAgICAgICAgICAweDEzNkM5ODU2LCAweDY0NkJBOEMwLCAweEZENjJGOTdBLCAweDhBNjVDOUVDLCAweDE0MDE1QzRGLCAweDYzMDY2Q0Q5LCAweEZBMEYzRDYzLCAweDhEMDgwREY1LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4M0I2RTIwQzgsIDB4NEM2OTEwNUUsIDB4RDU2MDQxRTQsIDB4QTI2NzcxNzIsIDB4M0MwM0U0RDEsIDB4NEIwNEQ0NDcsIDB4RDIwRDg1RkQsIDB4QTUwQUI1NkIsIFxuICAgICAgICAgICAgICAgICAgICAgMHgzNUI1QThGQSwgMHg0MkIyOTg2QywgMHhEQkJCQzlENiwgMHhBQ0JDRjk0MCwgMHgzMkQ4NkNFMywgMHg0NURGNUM3NSwgMHhEQ0Q2MERDRiwgMHhBQkQxM0Q1OSwgXG4gICAgICAgICAgICAgICAgICAgICAweDI2RDkzMEFDLCAweDUxREUwMDNBLCAweEM4RDc1MTgwLCAweEJGRDA2MTE2LCAweDIxQjRGNEI1LCAweDU2QjNDNDIzLCAweENGQkE5NTk5LCAweEI4QkRBNTBGLFxuICAgICAgICAgICAgICAgICAgICAgMHgyODAyQjg5RSwgMHg1RjA1ODgwOCwgMHhDNjBDRDlCMiwgMHhCMTBCRTkyNCwgMHgyRjZGN0M4NywgMHg1ODY4NEMxMSwgMHhDMTYxMURBQiwgMHhCNjY2MkQzRCxcbiAgICAgICAgICAgICAgICAgICAgIDB4NzZEQzQxOTAsIDB4MDFEQjcxMDYsIDB4OThEMjIwQkMsIDB4RUZENTEwMkEsIDB4NzFCMTg1ODksIDB4MDZCNkI1MUYsIDB4OUZCRkU0QTUsIDB4RThCOEQ0MzMsXG4gICAgICAgICAgICAgICAgICAgICAweDc4MDdDOUEyLCAweDBGMDBGOTM0LCAweDk2MDlBODhFLCAweEUxMEU5ODE4LCAweDdGNkEwREJCLCAweDA4NkQzRDJELCAweDkxNjQ2Qzk3LCAweEU2NjM1QzAxLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NkI2QjUxRjQsIDB4MUM2QzYxNjIsIDB4ODU2NTMwRDgsIDB4RjI2MjAwNEUsIDB4NkMwNjk1RUQsIDB4MUIwMUE1N0IsIDB4ODIwOEY0QzEsIDB4RjUwRkM0NTcsIFxuICAgICAgICAgICAgICAgICAgICAgMHg2NUIwRDlDNiwgMHgxMkI3RTk1MCwgMHg4QkJFQjhFQSwgMHhGQ0I5ODg3QywgMHg2MkREMURERiwgMHgxNURBMkQ0OSwgMHg4Q0QzN0NGMywgMHhGQkQ0NEM2NSwgXG4gICAgICAgICAgICAgICAgICAgICAweDREQjI2MTU4LCAweDNBQjU1MUNFLCAweEEzQkMwMDc0LCAweEQ0QkIzMEUyLCAweDRBREZBNTQxLCAweDNERDg5NUQ3LCAweEE0RDFDNDZELCAweEQzRDZGNEZCLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NDM2OUU5NkEsIDB4MzQ2RUQ5RkMsIDB4QUQ2Nzg4NDYsIDB4REE2MEI4RDAsIDB4NDQwNDJENzMsIDB4MzMwMzFERTUsIDB4QUEwQTRDNUYsIDB4REQwRDdDQzksIFxuICAgICAgICAgICAgICAgICAgICAgMHg1MDA1NzEzQywgMHgyNzAyNDFBQSwgMHhCRTBCMTAxMCwgMHhDOTBDMjA4NiwgMHg1NzY4QjUyNSwgMHgyMDZGODVCMywgMHhCOTY2RDQwOSwgMHhDRTYxRTQ5RiwgXG4gICAgICAgICAgICAgICAgICAgICAweDVFREVGOTBFLCAweDI5RDlDOTk4LCAweEIwRDA5ODIyLCAweEM3RDdBOEI0LCAweDU5QjMzRDE3LCAweDJFQjQwRDgxLCAweEI3QkQ1QzNCLCAweEMwQkE2Q0FELCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RURCODgzMjAsIDB4OUFCRkIzQjYsIDB4MDNCNkUyMEMsIDB4NzRCMUQyOUEsIDB4RUFENTQ3MzksIDB4OUREMjc3QUYsIDB4MDREQjI2MTUsIDB4NzNEQzE2ODMsIFxuICAgICAgICAgICAgICAgICAgICAgMHhFMzYzMEIxMiwgMHg5NDY0M0I4NCwgMHgwRDZENkEzRSwgMHg3QTZBNUFBOCwgMHhFNDBFQ0YwQiwgMHg5MzA5RkY5RCwgMHgwQTAwQUUyNywgMHg3RDA3OUVCMSwgXG4gICAgICAgICAgICAgICAgICAgICAweEYwMEY5MzQ0LCAweDg3MDhBM0QyLCAweDFFMDFGMjY4LCAweDY5MDZDMkZFLCAweEY3NjI1NzVELCAweDgwNjU2N0NCLCAweDE5NkMzNjcxLCAweDZFNkIwNkU3LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RkVENDFCNzYsIDB4ODlEMzJCRTAsIDB4MTBEQTdBNUEsIDB4NjdERDRBQ0MsIDB4RjlCOURGNkYsIDB4OEVCRUVGRjksIDB4MTdCN0JFNDMsIDB4NjBCMDhFRDUsIFxuICAgICAgICAgICAgICAgICAgICAgMHhENkQ2QTNFOCwgMHhBMUQxOTM3RSwgMHgzOEQ4QzJDNCwgMHg0RkRGRjI1MiwgMHhEMUJCNjdGMSwgMHhBNkJDNTc2NywgMHgzRkI1MDZERCwgMHg0OEIyMzY0QiwgXG4gICAgICAgICAgICAgICAgICAgICAweEQ4MEQyQkRBLCAweEFGMEExQjRDLCAweDM2MDM0QUY2LCAweDQxMDQ3QTYwLCAweERGNjBFRkMzLCAweEE4NjdERjU1LCAweDMxNkU4RUVGLCAweDQ2NjlCRTc5LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4Q0I2MUIzOEMsIDB4QkM2NjgzMUEsIDB4MjU2RkQyQTAsIDB4NTI2OEUyMzYsIDB4Q0MwQzc3OTUsIDB4QkIwQjQ3MDMsIDB4MjIwMjE2QjksIDB4NTUwNTI2MkYsIFxuICAgICAgICAgICAgICAgICAgICAgMHhDNUJBM0JCRSwgMHhCMkJEMEIyOCwgMHgyQkI0NUE5MiwgMHg1Q0IzNkEwNCwgMHhDMkQ3RkZBNywgMHhCNUQwQ0YzMSwgMHgyQ0Q5OUU4QiwgMHg1QkRFQUUxRCwgXG4gICAgICAgICAgICAgICAgICAgICAweDlCNjRDMkIwLCAweEVDNjNGMjI2LCAweDc1NkFBMzlDLCAweDAyNkQ5MzBBLCAweDlDMDkwNkE5LCAweEVCMEUzNjNGLCAweDcyMDc2Nzg1LCAweDA1MDA1NzEzLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4OTVCRjRBODIsIDB4RTJCODdBMTQsIDB4N0JCMTJCQUUsIDB4MENCNjFCMzgsIDB4OTJEMjhFOUIsIDB4RTVENUJFMEQsIDB4N0NEQ0VGQjcsIDB4MEJEQkRGMjEsIFxuICAgICAgICAgICAgICAgICAgICAgMHg4NkQzRDJENCwgMHhGMUQ0RTI0MiwgMHg2OEREQjNGOCwgMHgxRkRBODM2RSwgMHg4MUJFMTZDRCwgMHhGNkI5MjY1QiwgMHg2RkIwNzdFMSwgMHgxOEI3NDc3NywgXG4gICAgICAgICAgICAgICAgICAgICAweDg4MDg1QUU2LCAweEZGMEY2QTcwLCAweDY2MDYzQkNBLCAweDExMDEwQjVDLCAweDhGNjU5RUZGLCAweEY4NjJBRTY5LCAweDYxNkJGRkQzLCAweDE2NkNDRjQ1LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4QTAwQUUyNzgsIDB4RDcwREQyRUUsIDB4NEUwNDgzNTQsIDB4MzkwM0IzQzIsIDB4QTc2NzI2NjEsIDB4RDA2MDE2RjcsIDB4NDk2OTQ3NEQsIDB4M0U2RTc3REIsIFxuICAgICAgICAgICAgICAgICAgICAgMHhBRUQxNkE0QSwgMHhEOUQ2NUFEQywgMHg0MERGMEI2NiwgMHgzN0Q4M0JGMCwgMHhBOUJDQUU1MywgMHhERUJCOUVDNSwgMHg0N0IyQ0Y3RiwgMHgzMEI1RkZFOSwgXG4gICAgICAgICAgICAgICAgICAgICAweEJEQkRGMjFDLCAweENBQkFDMjhBLCAweDUzQjM5MzMwLCAweDI0QjRBM0E2LCAweEJBRDAzNjA1LCAweENERDcwNjkzLCAweDU0REU1NzI5LCAweDIzRDk2N0JGLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4QjM2NjdBMkUsIDB4QzQ2MTRBQjgsIDB4NUQ2ODFCMDIsIDB4MkE2RjJCOTQsIDB4QjQwQkJFMzcsIDB4QzMwQzhFQTEsIDB4NUEwNURGMUIsIDB4MkQwMkVGOERdO1xuICAgICBcbiAgICAgICAgdmFyIGNyYyA9IC0xLCB5ID0gMCwgbiA9IGEubGVuZ3RoLGk7XG5cbiAgICAgICAgZm9yIChpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIHkgPSAoY3JjIF4gYVtpXSkgJiAweEZGO1xuICAgICAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVt5XTtcbiAgICAgICAgfVxuICAgICBcbiAgICAgICAgcmV0dXJuIGNyYyBeICgtMSk7XG4gICAgfVxuXG4gICAgdmFyIGggPSBpbWdbMF0ubGVuZ3RoLCB3ID0gaW1nWzBdWzBdLmxlbmd0aCwgczEsIHMyLCBuZXh0LGssbGVuZ3RoLGEsYixpLGosYWRsZXIzMixjcmMzMjtcbiAgICB2YXIgc3RyZWFtID0gW1xuICAgICAgICAgICAgICAgICAgMTM3LCA4MCwgNzgsIDcxLCAxMywgMTAsIDI2LCAxMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMDogUE5HIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgMCwwLDAsMTMsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgODogSUhEUiBDaHVuayBsZW5ndGhcbiAgICAgICAgICAgICAgICAgIDczLCA3MiwgNjgsIDgyLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTI6IFwiSUhEUlwiIFxuICAgICAgICAgICAgICAgICAgKHcgPj4gMjQpICYgMjU1LCAodyA+PiAxNikgJiAyNTUsICh3ID4+IDgpICYgMjU1LCB3JjI1NSwgICAvLyAxNjogV2lkdGhcbiAgICAgICAgICAgICAgICAgIChoID4+IDI0KSAmIDI1NSwgKGggPj4gMTYpICYgMjU1LCAoaCA+PiA4KSAmIDI1NSwgaCYyNTUsICAgLy8gMjA6IEhlaWdodFxuICAgICAgICAgICAgICAgICAgOCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNDogYml0IGRlcHRoXG4gICAgICAgICAgICAgICAgICAyLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI1OiBSR0JcbiAgICAgICAgICAgICAgICAgIDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjY6IGRlZmxhdGVcbiAgICAgICAgICAgICAgICAgIDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjc6IG5vIGZpbHRlclxuICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyODogbm8gaW50ZXJsYWNlXG4gICAgICAgICAgICAgICAgICAtMSwtMiwtMywtNCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI5OiBDUkNcbiAgICAgICAgICAgICAgICAgIC01LC02LC03LC04LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzM6IElEQVQgQ2h1bmsgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICA3MywgNjgsIDY1LCA4NCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDM3OiBcIklEQVRcIlxuICAgICAgICAgICAgICAgICAgLy8gUkZDIDE5NTAgaGVhZGVyIHN0YXJ0cyBoZXJlXG4gICAgICAgICAgICAgICAgICA4LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQxOiBSRkMxOTUwIENNRlxuICAgICAgICAgICAgICAgICAgMjkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA0MjogUkZDMTk1MCBGTEdcbiAgICAgICAgICAgICAgICAgIF07XG4gICAgY3JjMzIgPSBjcmMzMkFycmF5KHN0cmVhbSwxMiwyOSk7XG4gICAgc3RyZWFtWzI5XSA9IChjcmMzMj4+MjQpJjI1NTtcbiAgICBzdHJlYW1bMzBdID0gKGNyYzMyPj4xNikmMjU1O1xuICAgIHN0cmVhbVszMV0gPSAoY3JjMzI+PjgpJjI1NTtcbiAgICBzdHJlYW1bMzJdID0gKGNyYzMyKSYyNTU7XG4gICAgczEgPSAxO1xuICAgIHMyID0gMDtcbiAgICBmb3IoaT0wO2k8aDtpKyspIHtcbiAgICAgICAgaWYoaTxoLTEpIHsgc3RyZWFtLnB1c2goMCk7IH1cbiAgICAgICAgZWxzZSB7IHN0cmVhbS5wdXNoKDEpOyB9XG4gICAgICAgIGEgPSAoMyp3KzErKGk9PT0wKSkmMjU1OyBiID0gKCgzKncrMSsoaT09PTApKT4+OCkmMjU1O1xuICAgICAgICBzdHJlYW0ucHVzaChhKTsgc3RyZWFtLnB1c2goYik7XG4gICAgICAgIHN0cmVhbS5wdXNoKCh+YSkmMjU1KTsgc3RyZWFtLnB1c2goKH5iKSYyNTUpO1xuICAgICAgICBpZihpPT09MCkgc3RyZWFtLnB1c2goMCk7XG4gICAgICAgIGZvcihqPTA7ajx3O2orKykge1xuICAgICAgICAgICAgZm9yKGs9MDtrPDM7aysrKSB7XG4gICAgICAgICAgICAgICAgYSA9IGltZ1trXVtpXVtqXTtcbiAgICAgICAgICAgICAgICBpZihhPjI1NSkgYSA9IDI1NTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGE8MCkgYT0wO1xuICAgICAgICAgICAgICAgIGVsc2UgYSA9IE1hdGgucm91bmQoYSk7XG4gICAgICAgICAgICAgICAgczEgPSAoczEgKyBhICklNjU1MjE7XG4gICAgICAgICAgICAgICAgczIgPSAoczIgKyBzMSklNjU1MjE7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2goYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnB1c2goMCk7XG4gICAgfVxuICAgIGFkbGVyMzIgPSAoczI8PDE2KStzMTtcbiAgICBzdHJlYW0ucHVzaCgoYWRsZXIzMj4+MjQpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGFkbGVyMzI+PjE2KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChhZGxlcjMyPj44KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChhZGxlcjMyKSYyNTUpO1xuICAgIGxlbmd0aCA9IHN0cmVhbS5sZW5ndGggLSA0MTtcbiAgICBzdHJlYW1bMzNdID0gKGxlbmd0aD4+MjQpJjI1NTtcbiAgICBzdHJlYW1bMzRdID0gKGxlbmd0aD4+MTYpJjI1NTtcbiAgICBzdHJlYW1bMzVdID0gKGxlbmd0aD4+OCkmMjU1O1xuICAgIHN0cmVhbVszNl0gPSAobGVuZ3RoKSYyNTU7XG4gICAgY3JjMzIgPSBjcmMzMkFycmF5KHN0cmVhbSwzNyk7XG4gICAgc3RyZWFtLnB1c2goKGNyYzMyPj4yNCkmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoY3JjMzI+PjE2KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChjcmMzMj4+OCkmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoY3JjMzIpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goMCk7XG4gICAgc3RyZWFtLnB1c2goMCk7XG4gICAgc3RyZWFtLnB1c2goMCk7XG4gICAgc3RyZWFtLnB1c2goMCk7XG4vLyAgICBhID0gc3RyZWFtLmxlbmd0aDtcbiAgICBzdHJlYW0ucHVzaCg3Myk7ICAvLyBJXG4gICAgc3RyZWFtLnB1c2goNjkpOyAgLy8gRVxuICAgIHN0cmVhbS5wdXNoKDc4KTsgIC8vIE5cbiAgICBzdHJlYW0ucHVzaCg2OCk7ICAvLyBEXG4gICAgc3RyZWFtLnB1c2goMTc0KTsgLy8gQ1JDMVxuICAgIHN0cmVhbS5wdXNoKDY2KTsgIC8vIENSQzJcbiAgICBzdHJlYW0ucHVzaCg5Nik7ICAvLyBDUkMzXG4gICAgc3RyZWFtLnB1c2goMTMwKTsgLy8gQ1JDNFxuICAgIHJldHVybiAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LCcrYmFzZTY0KHN0cmVhbSk7XG59XG5cbi8vIDIuIExpbmVhciBhbGdlYnJhIHdpdGggQXJyYXlzLlxubnVtZXJpYy5fZGltID0gZnVuY3Rpb24gX2RpbSh4KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHdoaWxlKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7IHJldC5wdXNoKHgubGVuZ3RoKTsgeCA9IHhbMF07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRpbSA9IGZ1bmN0aW9uIGRpbSh4KSB7XG4gICAgdmFyIHksejtcbiAgICBpZih0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB5ID0geFswXTtcbiAgICAgICAgaWYodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHogPSB5WzBdO1xuICAgICAgICAgICAgaWYodHlwZW9mIHogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtZXJpYy5fZGltKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt4Lmxlbmd0aCx5Lmxlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4Lmxlbmd0aF07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxubnVtZXJpYy5tYXByZWR1Y2UgPSBmdW5jdGlvbiBtYXByZWR1Y2UoYm9keSxpbml0KSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKCd4JywnYWNjdW0nLCdfcycsJ19rJyxcbiAgICAgICAgICAgICdpZih0eXBlb2YgYWNjdW0gPT09IFwidW5kZWZpbmVkXCIpIGFjY3VtID0gJytpbml0Kyc7XFxuJytcbiAgICAgICAgICAgICdpZih0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikgeyB2YXIgeGkgPSB4OyAnK2JvZHkrJzsgcmV0dXJuIGFjY3VtOyB9XFxuJytcbiAgICAgICAgICAgICdpZih0eXBlb2YgX3MgPT09IFwidW5kZWZpbmVkXCIpIF9zID0gbnVtZXJpYy5kaW0oeCk7XFxuJytcbiAgICAgICAgICAgICdpZih0eXBlb2YgX2sgPT09IFwidW5kZWZpbmVkXCIpIF9rID0gMDtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBfbiA9IF9zW19rXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBpLHhpO1xcbicrXG4gICAgICAgICAgICAnaWYoX2sgPCBfcy5sZW5ndGgtMSkge1xcbicrXG4gICAgICAgICAgICAnICAgIGZvcihpPV9uLTE7aT49MDtpLS0pIHtcXG4nK1xuICAgICAgICAgICAgJyAgICAgICAgYWNjdW0gPSBhcmd1bWVudHMuY2FsbGVlKHhbaV0sYWNjdW0sX3MsX2srMSk7XFxuJytcbiAgICAgICAgICAgICcgICAgfScrXG4gICAgICAgICAgICAnICAgIHJldHVybiBhY2N1bTtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ2ZvcihpPV9uLTE7aT49MTtpLT0yKSB7IFxcbicrXG4gICAgICAgICAgICAnICAgIHhpID0geFtpXTtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJztcXG4nK1xuICAgICAgICAgICAgJyAgICB4aSA9IHhbaS0xXTtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJztcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ2lmKGkgPT09IDApIHtcXG4nK1xuICAgICAgICAgICAgJyAgICB4aSA9IHhbaV07XFxuJytcbiAgICAgICAgICAgICcgICAgJytib2R5KydcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiBhY2N1bTsnXG4gICAgICAgICAgICApO1xufVxubnVtZXJpYy5tYXByZWR1Y2UyID0gZnVuY3Rpb24gbWFwcmVkdWNlMihib2R5LHNldHVwKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKCd4JyxcbiAgICAgICAgICAgICd2YXIgbiA9IHgubGVuZ3RoO1xcbicrXG4gICAgICAgICAgICAndmFyIGkseGk7XFxuJytzZXR1cCsnO1xcbicrXG4gICAgICAgICAgICAnZm9yKGk9bi0xO2khPT0tMTstLWkpIHsgXFxuJytcbiAgICAgICAgICAgICcgICAgeGkgPSB4W2ldO1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIGFjY3VtOydcbiAgICAgICAgICAgICk7XG59XG5cblxubnVtZXJpYy5zYW1lID0gZnVuY3Rpb24gc2FtZSh4LHkpIHtcbiAgICB2YXIgaSxuO1xuICAgIGlmKCEoeCBpbnN0YW5jZW9mIEFycmF5KSB8fCAhKHkgaW5zdGFuY2VvZiBBcnJheSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbiA9IHgubGVuZ3RoO1xuICAgIGlmKG4gIT09IHkubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvcihpPTA7aTxuO2krKykge1xuICAgICAgICBpZih4W2ldID09PSB5W2ldKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmKHR5cGVvZiB4W2ldID09PSBcIm9iamVjdFwiKSB7IGlmKCFzYW1lKHhbaV0seVtpXSkpIHJldHVybiBmYWxzZTsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5udW1lcmljLnJlcCA9IGZ1bmN0aW9uIHJlcChzLHYsaykge1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSB7IGs9MDsgfVxuICAgIHZhciBuID0gc1trXSwgcmV0ID0gQXJyYXkobiksIGk7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkge1xuICAgICAgICBmb3IoaT1uLTI7aT49MDtpLT0yKSB7IHJldFtpKzFdID0gdjsgcmV0W2ldID0gdjsgfVxuICAgICAgICBpZihpPT09LTEpIHsgcmV0WzBdID0gdjsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHsgcmV0W2ldID0gbnVtZXJpYy5yZXAocyx2LGsrMSk7IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5cbm51bWVyaWMuZG90TU1zbWFsbCA9IGZ1bmN0aW9uIGRvdE1Nc21hbGwoeCx5KSB7XG4gICAgdmFyIGksaixrLHAscSxyLHJldCxmb28sYmFyLHdvbyxpMCxrMCxwMCxyMDtcbiAgICBwID0geC5sZW5ndGg7IHEgPSB5Lmxlbmd0aDsgciA9IHlbMF0ubGVuZ3RoO1xuICAgIHJldCA9IEFycmF5KHApO1xuICAgIGZvcihpPXAtMTtpPj0wO2ktLSkge1xuICAgICAgICBmb28gPSBBcnJheShyKTtcbiAgICAgICAgYmFyID0geFtpXTtcbiAgICAgICAgZm9yKGs9ci0xO2s+PTA7ay0tKSB7XG4gICAgICAgICAgICB3b28gPSBiYXJbcS0xXSp5W3EtMV1ba107XG4gICAgICAgICAgICBmb3Ioaj1xLTI7aj49MTtqLT0yKSB7XG4gICAgICAgICAgICAgICAgaTAgPSBqLTE7XG4gICAgICAgICAgICAgICAgd29vICs9IGJhcltqXSp5W2pdW2tdICsgYmFyW2kwXSp5W2kwXVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGo9PT0wKSB7IHdvbyArPSBiYXJbMF0qeVswXVtrXTsgfVxuICAgICAgICAgICAgZm9vW2tdID0gd29vO1xuICAgICAgICB9XG4gICAgICAgIHJldFtpXSA9IGZvbztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMuX2dldENvbCA9IGZ1bmN0aW9uIF9nZXRDb2woQSxqLHgpIHtcbiAgICB2YXIgbiA9IEEubGVuZ3RoLCBpO1xuICAgIGZvcihpPW4tMTtpPjA7LS1pKSB7XG4gICAgICAgIHhbaV0gPSBBW2ldW2pdO1xuICAgICAgICAtLWk7XG4gICAgICAgIHhbaV0gPSBBW2ldW2pdO1xuICAgIH1cbiAgICBpZihpPT09MCkgeFswXSA9IEFbMF1bal07XG59XG5udW1lcmljLmRvdE1NYmlnID0gZnVuY3Rpb24gZG90TU1iaWcoeCx5KXtcbiAgICB2YXIgZ2MgPSBudW1lcmljLl9nZXRDb2wsIHAgPSB5Lmxlbmd0aCwgdiA9IEFycmF5KHApO1xuICAgIHZhciBtID0geC5sZW5ndGgsIG4gPSB5WzBdLmxlbmd0aCwgQSA9IG5ldyBBcnJheShtKSwgeGo7XG4gICAgdmFyIFZWID0gbnVtZXJpYy5kb3RWVjtcbiAgICB2YXIgaSxqLGssejtcbiAgICAtLXA7XG4gICAgLS1tO1xuICAgIGZvcihpPW07aSE9PS0xOy0taSkgQVtpXSA9IEFycmF5KG4pO1xuICAgIC0tbjtcbiAgICBmb3IoaT1uO2khPT0tMTstLWkpIHtcbiAgICAgICAgZ2MoeSxpLHYpO1xuICAgICAgICBmb3Ioaj1tO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIHo9MDtcbiAgICAgICAgICAgIHhqID0geFtqXTtcbiAgICAgICAgICAgIEFbal1baV0gPSBWVih4aix2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cblxubnVtZXJpYy5kb3RNViA9IGZ1bmN0aW9uIGRvdE1WKHgseSkge1xuICAgIHZhciBwID0geC5sZW5ndGgsIHEgPSB5Lmxlbmd0aCxpO1xuICAgIHZhciByZXQgPSBBcnJheShwKSwgZG90VlYgPSBudW1lcmljLmRvdFZWO1xuICAgIGZvcihpPXAtMTtpPj0wO2ktLSkgeyByZXRbaV0gPSBkb3RWVih4W2ldLHkpOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5kb3RWTSA9IGZ1bmN0aW9uIGRvdFZNKHgseSkge1xuICAgIHZhciBpLGosayxwLHEscixyZXQsZm9vLGJhcix3b28saTAsazAscDAscjAsczEsczIsczMsYmF6LGFjY3VtO1xuICAgIHAgPSB4Lmxlbmd0aDsgcSA9IHlbMF0ubGVuZ3RoO1xuICAgIHJldCA9IEFycmF5KHEpO1xuICAgIGZvcihrPXEtMTtrPj0wO2stLSkge1xuICAgICAgICB3b28gPSB4W3AtMV0qeVtwLTFdW2tdO1xuICAgICAgICBmb3Ioaj1wLTI7aj49MTtqLT0yKSB7XG4gICAgICAgICAgICBpMCA9IGotMTtcbiAgICAgICAgICAgIHdvbyArPSB4W2pdKnlbal1ba10gKyB4W2kwXSp5W2kwXVtrXTtcbiAgICAgICAgfVxuICAgICAgICBpZihqPT09MCkgeyB3b28gKz0geFswXSp5WzBdW2tdOyB9XG4gICAgICAgIHJldFtrXSA9IHdvbztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5kb3RWViA9IGZ1bmN0aW9uIGRvdFZWKHgseSkge1xuICAgIHZhciBpLG49eC5sZW5ndGgsaTEscmV0ID0geFtuLTFdKnlbbi0xXTtcbiAgICBmb3IoaT1uLTI7aT49MTtpLT0yKSB7XG4gICAgICAgIGkxID0gaS0xO1xuICAgICAgICByZXQgKz0geFtpXSp5W2ldICsgeFtpMV0qeVtpMV07XG4gICAgfVxuICAgIGlmKGk9PT0wKSB7IHJldCArPSB4WzBdKnlbMF07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRvdCA9IGZ1bmN0aW9uIGRvdCh4LHkpIHtcbiAgICB2YXIgZCA9IG51bWVyaWMuZGltO1xuICAgIHN3aXRjaChkKHgpLmxlbmd0aCoxMDAwK2QoeSkubGVuZ3RoKSB7XG4gICAgY2FzZSAyMDAyOlxuICAgICAgICBpZih5Lmxlbmd0aCA8IDEwKSByZXR1cm4gbnVtZXJpYy5kb3RNTXNtYWxsKHgseSk7XG4gICAgICAgIGVsc2UgcmV0dXJuIG51bWVyaWMuZG90TU1iaWcoeCx5KTtcbiAgICBjYXNlIDIwMDE6IHJldHVybiBudW1lcmljLmRvdE1WKHgseSk7XG4gICAgY2FzZSAxMDAyOiByZXR1cm4gbnVtZXJpYy5kb3RWTSh4LHkpO1xuICAgIGNhc2UgMTAwMTogcmV0dXJuIG51bWVyaWMuZG90VlYoeCx5KTtcbiAgICBjYXNlIDEwMDA6IHJldHVybiBudW1lcmljLm11bFZTKHgseSk7XG4gICAgY2FzZSAxOiByZXR1cm4gbnVtZXJpYy5tdWxTVih4LHkpO1xuICAgIGNhc2UgMDogcmV0dXJuIHgqeTtcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWMuZG90IG9ubHkgd29ya3Mgb24gdmVjdG9ycyBhbmQgbWF0cmljZXMnKTtcbiAgICB9XG59XG5cbm51bWVyaWMuZGlhZyA9IGZ1bmN0aW9uIGRpYWcoZCkge1xuICAgIHZhciBpLGkxLGosbiA9IGQubGVuZ3RoLCBBID0gQXJyYXkobiksIEFpO1xuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkge1xuICAgICAgICBBaSA9IEFycmF5KG4pO1xuICAgICAgICBpMSA9IGkrMjtcbiAgICAgICAgZm9yKGo9bi0xO2o+PWkxO2otPTIpIHtcbiAgICAgICAgICAgIEFpW2pdID0gMDtcbiAgICAgICAgICAgIEFpW2otMV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo+aSkgeyBBaVtqXSA9IDA7IH1cbiAgICAgICAgQWlbaV0gPSBkW2ldO1xuICAgICAgICBmb3Ioaj1pLTE7aj49MTtqLT0yKSB7XG4gICAgICAgICAgICBBaVtqXSA9IDA7XG4gICAgICAgICAgICBBaVtqLTFdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZihqPT09MCkgeyBBaVswXSA9IDA7IH1cbiAgICAgICAgQVtpXSA9IEFpO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cbm51bWVyaWMuZ2V0RGlhZyA9IGZ1bmN0aW9uKEEpIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKEEubGVuZ3RoLEFbMF0ubGVuZ3RoKSxpLHJldCA9IEFycmF5KG4pO1xuICAgIGZvcihpPW4tMTtpPj0xOy0taSkge1xuICAgICAgICByZXRbaV0gPSBBW2ldW2ldO1xuICAgICAgICAtLWk7XG4gICAgICAgIHJldFtpXSA9IEFbaV1baV07XG4gICAgfVxuICAgIGlmKGk9PT0wKSB7XG4gICAgICAgIHJldFswXSA9IEFbMF1bMF07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eShuKSB7IHJldHVybiBudW1lcmljLmRpYWcobnVtZXJpYy5yZXAoW25dLDEpKTsgfVxubnVtZXJpYy5wb2ludHdpc2UgPSBmdW5jdGlvbiBwb2ludHdpc2UocGFyYW1zLGJvZHksc2V0dXApIHtcbiAgICBpZih0eXBlb2Ygc2V0dXAgPT09IFwidW5kZWZpbmVkXCIpIHsgc2V0dXAgPSBcIlwiOyB9XG4gICAgdmFyIGZ1biA9IFtdO1xuICAgIHZhciBrO1xuICAgIHZhciBhdmVjID0gL1xcW2lcXF0kLyxwLHRoZXZlYyA9ICcnO1xuICAgIHZhciBoYXZlcmV0ID0gZmFsc2U7XG4gICAgZm9yKGs9MDtrPHBhcmFtcy5sZW5ndGg7aysrKSB7XG4gICAgICAgIGlmKGF2ZWMudGVzdChwYXJhbXNba10pKSB7XG4gICAgICAgICAgICBwID0gcGFyYW1zW2tdLnN1YnN0cmluZygwLHBhcmFtc1trXS5sZW5ndGgtMyk7XG4gICAgICAgICAgICB0aGV2ZWMgPSBwO1xuICAgICAgICB9IGVsc2UgeyBwID0gcGFyYW1zW2tdOyB9XG4gICAgICAgIGlmKHA9PT0ncmV0JykgaGF2ZXJldCA9IHRydWU7XG4gICAgICAgIGZ1bi5wdXNoKHApO1xuICAgIH1cbiAgICBmdW5bcGFyYW1zLmxlbmd0aF0gPSAnX3MnO1xuICAgIGZ1bltwYXJhbXMubGVuZ3RoKzFdID0gJ19rJztcbiAgICBmdW5bcGFyYW1zLmxlbmd0aCsyXSA9IChcbiAgICAgICAgICAgICdpZih0eXBlb2YgX3MgPT09IFwidW5kZWZpbmVkXCIpIF9zID0gbnVtZXJpYy5kaW0oJyt0aGV2ZWMrJyk7XFxuJytcbiAgICAgICAgICAgICdpZih0eXBlb2YgX2sgPT09IFwidW5kZWZpbmVkXCIpIF9rID0gMDtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBfbiA9IF9zW19rXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBpJysoaGF2ZXJldD8nJzonLCByZXQgPSBBcnJheShfbiknKSsnO1xcbicrXG4gICAgICAgICAgICAnaWYoX2sgPCBfcy5sZW5ndGgtMSkge1xcbicrXG4gICAgICAgICAgICAnICAgIGZvcihpPV9uLTE7aT49MDtpLS0pIHJldFtpXSA9IGFyZ3VtZW50cy5jYWxsZWUoJytwYXJhbXMuam9pbignLCcpKycsX3MsX2srMSk7XFxuJytcbiAgICAgICAgICAgICcgICAgcmV0dXJuIHJldDtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgc2V0dXArJ1xcbicrXG4gICAgICAgICAgICAnZm9yKGk9X24tMTtpIT09LTE7LS1pKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgJytib2R5KydcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiByZXQ7J1xuICAgICAgICAgICAgKTtcbiAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkobnVsbCxmdW4pO1xufVxubnVtZXJpYy5wb2ludHdpc2UyID0gZnVuY3Rpb24gcG9pbnR3aXNlMihwYXJhbXMsYm9keSxzZXR1cCkge1xuICAgIGlmKHR5cGVvZiBzZXR1cCA9PT0gXCJ1bmRlZmluZWRcIikgeyBzZXR1cCA9IFwiXCI7IH1cbiAgICB2YXIgZnVuID0gW107XG4gICAgdmFyIGs7XG4gICAgdmFyIGF2ZWMgPSAvXFxbaVxcXSQvLHAsdGhldmVjID0gJyc7XG4gICAgdmFyIGhhdmVyZXQgPSBmYWxzZTtcbiAgICBmb3Ioaz0wO2s8cGFyYW1zLmxlbmd0aDtrKyspIHtcbiAgICAgICAgaWYoYXZlYy50ZXN0KHBhcmFtc1trXSkpIHtcbiAgICAgICAgICAgIHAgPSBwYXJhbXNba10uc3Vic3RyaW5nKDAscGFyYW1zW2tdLmxlbmd0aC0zKTtcbiAgICAgICAgICAgIHRoZXZlYyA9IHA7XG4gICAgICAgIH0gZWxzZSB7IHAgPSBwYXJhbXNba107IH1cbiAgICAgICAgaWYocD09PSdyZXQnKSBoYXZlcmV0ID0gdHJ1ZTtcbiAgICAgICAgZnVuLnB1c2gocCk7XG4gICAgfVxuICAgIGZ1bltwYXJhbXMubGVuZ3RoXSA9IChcbiAgICAgICAgICAgICd2YXIgX24gPSAnK3RoZXZlYysnLmxlbmd0aDtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBpJysoaGF2ZXJldD8nJzonLCByZXQgPSBBcnJheShfbiknKSsnO1xcbicrXG4gICAgICAgICAgICBzZXR1cCsnXFxuJytcbiAgICAgICAgICAgICdmb3IoaT1fbi0xO2khPT0tMTstLWkpIHtcXG4nK1xuICAgICAgICAgICAgYm9keSsnXFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gcmV0OydcbiAgICAgICAgICAgICk7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KG51bGwsZnVuKTtcbn1cbm51bWVyaWMuX2JpZm9yZWFjaCA9IChmdW5jdGlvbiBfYmlmb3JlYWNoKHgseSxzLGssZikge1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgZih4LHkpOyByZXR1cm47IH1cbiAgICB2YXIgaSxuPXNba107XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7IF9iaWZvcmVhY2godHlwZW9mIHg9PT1cIm9iamVjdFwiP3hbaV06eCx0eXBlb2YgeT09PVwib2JqZWN0XCI/eVtpXTp5LHMsaysxLGYpOyB9XG59KTtcbm51bWVyaWMuX2JpZm9yZWFjaDIgPSAoZnVuY3Rpb24gX2JpZm9yZWFjaDIoeCx5LHMsayxmKSB7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyByZXR1cm4gZih4LHkpOyB9XG4gICAgdmFyIGksbj1zW2tdLHJldCA9IEFycmF5KG4pO1xuICAgIGZvcihpPW4tMTtpPj0wOy0taSkgeyByZXRbaV0gPSBfYmlmb3JlYWNoMih0eXBlb2YgeD09PVwib2JqZWN0XCI/eFtpXTp4LHR5cGVvZiB5PT09XCJvYmplY3RcIj95W2ldOnkscyxrKzEsZik7IH1cbiAgICByZXR1cm4gcmV0O1xufSk7XG5udW1lcmljLl9mb3JlYWNoID0gKGZ1bmN0aW9uIF9mb3JlYWNoKHgscyxrLGYpIHtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7IGYoeCk7IHJldHVybjsgfVxuICAgIHZhciBpLG49c1trXTtcbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHsgX2ZvcmVhY2goeFtpXSxzLGsrMSxmKTsgfVxufSk7XG5udW1lcmljLl9mb3JlYWNoMiA9IChmdW5jdGlvbiBfZm9yZWFjaDIoeCxzLGssZikge1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgcmV0dXJuIGYoeCk7IH1cbiAgICB2YXIgaSxuPXNba10sIHJldCA9IEFycmF5KG4pO1xuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgeyByZXRbaV0gPSBfZm9yZWFjaDIoeFtpXSxzLGsrMSxmKTsgfVxuICAgIHJldHVybiByZXQ7XG59KTtcblxuLypudW1lcmljLmFueVYgPSBudW1lcmljLm1hcHJlZHVjZSgnaWYoeGkpIHJldHVybiB0cnVlOycsJ2ZhbHNlJyk7XG5udW1lcmljLmFsbFYgPSBudW1lcmljLm1hcHJlZHVjZSgnaWYoIXhpKSByZXR1cm4gZmFsc2U7JywndHJ1ZScpO1xubnVtZXJpYy5hbnkgPSBmdW5jdGlvbih4KSB7IGlmKHR5cGVvZiB4Lmxlbmd0aCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHg7IHJldHVybiBudW1lcmljLmFueVYoeCk7IH1cbm51bWVyaWMuYWxsID0gZnVuY3Rpb24oeCkgeyBpZih0eXBlb2YgeC5sZW5ndGggPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB4OyByZXR1cm4gbnVtZXJpYy5hbGxWKHgpOyB9Ki9cblxubnVtZXJpYy5vcHMyID0ge1xuICAgICAgICBhZGQ6ICcrJyxcbiAgICAgICAgc3ViOiAnLScsXG4gICAgICAgIG11bDogJyonLFxuICAgICAgICBkaXY6ICcvJyxcbiAgICAgICAgbW9kOiAnJScsXG4gICAgICAgIGFuZDogJyYmJyxcbiAgICAgICAgb3I6ICAnfHwnLFxuICAgICAgICBlcTogICc9PT0nLFxuICAgICAgICBuZXE6ICchPT0nLFxuICAgICAgICBsdDogICc8JyxcbiAgICAgICAgZ3Q6ICAnPicsXG4gICAgICAgIGxlcTogJzw9JyxcbiAgICAgICAgZ2VxOiAnPj0nLFxuICAgICAgICBiYW5kOiAnJicsXG4gICAgICAgIGJvcjogJ3wnLFxuICAgICAgICBieG9yOiAnXicsXG4gICAgICAgIGxzaGlmdDogJzw8JyxcbiAgICAgICAgcnNoaWZ0OiAnPj4nLFxuICAgICAgICBycnNoaWZ0OiAnPj4+J1xufTtcbm51bWVyaWMub3BzZXEgPSB7XG4gICAgICAgIGFkZGVxOiAnKz0nLFxuICAgICAgICBzdWJlcTogJy09JyxcbiAgICAgICAgbXVsZXE6ICcqPScsXG4gICAgICAgIGRpdmVxOiAnLz0nLFxuICAgICAgICBtb2RlcTogJyU9JyxcbiAgICAgICAgbHNoaWZ0ZXE6ICc8PD0nLFxuICAgICAgICByc2hpZnRlcTogJz4+PScsXG4gICAgICAgIHJyc2hpZnRlcTogJz4+Pj0nLFxuICAgICAgICBiYW5kZXE6ICcmPScsXG4gICAgICAgIGJvcmVxOiAnfD0nLFxuICAgICAgICBieG9yZXE6ICdePSdcbn07XG5udW1lcmljLm1hdGhmdW5zID0gWydhYnMnLCdhY29zJywnYXNpbicsJ2F0YW4nLCdjZWlsJywnY29zJyxcbiAgICAgICAgICAgICAgICAgICAgJ2V4cCcsJ2Zsb29yJywnbG9nJywncm91bmQnLCdzaW4nLCdzcXJ0JywndGFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzTmFOJywnaXNGaW5pdGUnXTtcbm51bWVyaWMubWF0aGZ1bnMyID0gWydhdGFuMicsJ3BvdycsJ21heCcsJ21pbiddO1xubnVtZXJpYy5vcHMxID0ge1xuICAgICAgICBuZWc6ICctJyxcbiAgICAgICAgbm90OiAnIScsXG4gICAgICAgIGJub3Q6ICd+JyxcbiAgICAgICAgY2xvbmU6ICcnXG59O1xubnVtZXJpYy5tYXByZWR1Y2VycyA9IHtcbiAgICAgICAgYW55OiBbJ2lmKHhpKSByZXR1cm4gdHJ1ZTsnLCd2YXIgYWNjdW0gPSBmYWxzZTsnXSxcbiAgICAgICAgYWxsOiBbJ2lmKCF4aSkgcmV0dXJuIGZhbHNlOycsJ3ZhciBhY2N1bSA9IHRydWU7J10sXG4gICAgICAgIHN1bTogWydhY2N1bSArPSB4aTsnLCd2YXIgYWNjdW0gPSAwOyddLFxuICAgICAgICBwcm9kOiBbJ2FjY3VtICo9IHhpOycsJ3ZhciBhY2N1bSA9IDE7J10sXG4gICAgICAgIG5vcm0yU3F1YXJlZDogWydhY2N1bSArPSB4aSp4aTsnLCd2YXIgYWNjdW0gPSAwOyddLFxuICAgICAgICBub3JtaW5mOiBbJ2FjY3VtID0gbWF4KGFjY3VtLGFicyh4aSkpOycsJ3ZhciBhY2N1bSA9IDAsIG1heCA9IE1hdGgubWF4LCBhYnMgPSBNYXRoLmFiczsnXSxcbiAgICAgICAgbm9ybTE6IFsnYWNjdW0gKz0gYWJzKHhpKScsJ3ZhciBhY2N1bSA9IDAsIGFicyA9IE1hdGguYWJzOyddLFxuICAgICAgICBzdXA6IFsnYWNjdW0gPSBtYXgoYWNjdW0seGkpOycsJ3ZhciBhY2N1bSA9IC1JbmZpbml0eSwgbWF4ID0gTWF0aC5tYXg7J10sXG4gICAgICAgIGluZjogWydhY2N1bSA9IG1pbihhY2N1bSx4aSk7JywndmFyIGFjY3VtID0gSW5maW5pdHksIG1pbiA9IE1hdGgubWluOyddXG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLG87XG4gICAgZm9yKGk9MDtpPG51bWVyaWMubWF0aGZ1bnMyLmxlbmd0aDsrK2kpIHtcbiAgICAgICAgbyA9IG51bWVyaWMubWF0aGZ1bnMyW2ldO1xuICAgICAgICBudW1lcmljLm9wczJbb10gPSBvO1xuICAgIH1cbiAgICBmb3IoaSBpbiBudW1lcmljLm9wczIpIHtcbiAgICAgICAgaWYobnVtZXJpYy5vcHMyLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBvID0gbnVtZXJpYy5vcHMyW2ldO1xuICAgICAgICAgICAgdmFyIGNvZGUsIGNvZGVlcSwgc2V0dXAgPSAnJztcbiAgICAgICAgICAgIGlmKG51bWVyaWMubXlJbmRleE9mLmNhbGwobnVtZXJpYy5tYXRoZnVuczIsaSkhPT0tMSkge1xuICAgICAgICAgICAgICAgIHNldHVwID0gJ3ZhciAnK28rJyA9IE1hdGguJytvKyc7XFxuJztcbiAgICAgICAgICAgICAgICBjb2RlID0gZnVuY3Rpb24ocix4LHkpIHsgcmV0dXJuIHIrJyA9ICcrbysnKCcreCsnLCcreSsnKSc7IH07XG4gICAgICAgICAgICAgICAgY29kZWVxID0gZnVuY3Rpb24oeCx5KSB7IHJldHVybiB4KycgPSAnK28rJygnK3grJywnK3krJyknOyB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gZnVuY3Rpb24ocix4LHkpIHsgcmV0dXJuIHIrJyA9ICcreCsnICcrbysnICcreTsgfTtcbiAgICAgICAgICAgICAgICBpZihudW1lcmljLm9wc2VxLmhhc093blByb3BlcnR5KGkrJ2VxJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZWVxID0gZnVuY3Rpb24oeCx5KSB7IHJldHVybiB4KycgJytvKyc9ICcreTsgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlZXEgPSBmdW5jdGlvbih4LHkpIHsgcmV0dXJuIHgrJyA9ICcreCsnICcrbysnICcreTsgfTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWVyaWNbaSsnVlYnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3hbaV0nLCd5W2ldJ10sY29kZSgncmV0W2ldJywneFtpXScsJ3lbaV0nKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ1NWJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWyd4JywneVtpXSddLGNvZGUoJ3JldFtpXScsJ3gnLCd5W2ldJyksc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydWUyddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsneFtpXScsJ3knXSxjb2RlKCdyZXRbaV0nLCd4W2ldJywneScpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaV0gPSBGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgaSwgeCA9IGFyZ3VtZW50c1swXSwgeTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIFZWID0gbnVtZXJpYy4nK2krJ1ZWLCBWUyA9IG51bWVyaWMuJytpKydWUywgU1YgPSBudW1lcmljLicraSsnU1Y7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBkaW0gPSBudW1lcmljLmRpbTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnZm9yKGk9MTtpIT09bjsrK2kpIHsgXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgeSA9IGFyZ3VtZW50c1tpXTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICBpZih0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgICAgICBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgeCA9IG51bWVyaWMuX2JpZm9yZWFjaDIoeCx5LGRpbSh4KSwwLFZWKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICAgICAgZWxzZSB4ID0gbnVtZXJpYy5fYmlmb3JlYWNoMih4LHksZGltKHgpLDAsVlMpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIH0gZWxzZSBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgeCA9IG51bWVyaWMuX2JpZm9yZWFjaDIoeCx5LGRpbSh5KSwwLFNWKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICBlbHNlICcrY29kZWVxKCd4JywneScpKydcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnfVxcbnJldHVybiB4O1xcbicpO1xuICAgICAgICAgICAgbnVtZXJpY1tvXSA9IG51bWVyaWNbaV07XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsncmV0W2ldJywneFtpXSddLCBjb2RlZXEoJ3JldFtpXScsJ3hbaV0nKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxUyddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsncmV0W2ldJywneCddLCBjb2RlZXEoJ3JldFtpXScsJ3gnKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxJ10gPSBGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgaSwgeCA9IGFyZ3VtZW50c1swXSwgeTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIFYgPSBudW1lcmljLicraSsnZXFWLCBTID0gbnVtZXJpYy4nK2krJ2VxU1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdmb3IoaT0xO2khPT1uOysraSkgeyBcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICB5ID0gYXJndW1lbnRzW2ldO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSBudW1lcmljLl9iaWZvcmVhY2goeCx5LHMsMCxWKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICBlbHNlIG51bWVyaWMuX2JpZm9yZWFjaCh4LHkscywwLFMpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd9XFxucmV0dXJuIHg7XFxuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGk9MDtpPG51bWVyaWMubWF0aGZ1bnMyLmxlbmd0aDsrK2kpIHtcbiAgICAgICAgbyA9IG51bWVyaWMubWF0aGZ1bnMyW2ldO1xuICAgICAgICBkZWxldGUgbnVtZXJpYy5vcHMyW29dO1xuICAgIH1cbiAgICBmb3IoaT0wO2k8bnVtZXJpYy5tYXRoZnVucy5sZW5ndGg7KytpKSB7XG4gICAgICAgIG8gPSBudW1lcmljLm1hdGhmdW5zW2ldO1xuICAgICAgICBudW1lcmljLm9wczFbb10gPSBvO1xuICAgIH1cbiAgICBmb3IoaSBpbiBudW1lcmljLm9wczEpIHtcbiAgICAgICAgaWYobnVtZXJpYy5vcHMxLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBzZXR1cCA9ICcnO1xuICAgICAgICAgICAgbyA9IG51bWVyaWMub3BzMVtpXTtcbiAgICAgICAgICAgIGlmKG51bWVyaWMubXlJbmRleE9mLmNhbGwobnVtZXJpYy5tYXRoZnVucyxpKSE9PS0xKSB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5oYXNPd25Qcm9wZXJ0eShvKSkgc2V0dXAgPSAndmFyICcrbysnID0gTWF0aC4nK28rJztcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtZXJpY1tpKydlcVYnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3JldFtpXSddLCdyZXRbaV0gPSAnK28rJyhyZXRbaV0pOycsc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydlcSddID0gRnVuY3Rpb24oJ3gnLFxuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIHggIT09IFwib2JqZWN0XCIpIHJldHVybiAnK28rJ3hcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIGk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBWID0gbnVtZXJpYy4nK2krJ2VxVjtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIHMgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnbnVtZXJpYy5fZm9yZWFjaCh4LHMsMCxWKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAncmV0dXJuIHg7XFxuJyk7XG4gICAgICAgICAgICBudW1lcmljW2krJ1YnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3hbaV0nXSwncmV0W2ldID0gJytvKycoeFtpXSk7JyxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2ldID0gRnVuY3Rpb24oJ3gnLFxuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIHggIT09IFwib2JqZWN0XCIpIHJldHVybiAnK28rJyh4KVxcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgaTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIFYgPSBudW1lcmljLicraSsnVjtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIHMgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAncmV0dXJuIG51bWVyaWMuX2ZvcmVhY2gyKHgscywwLFYpO1xcbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihpPTA7aTxudW1lcmljLm1hdGhmdW5zLmxlbmd0aDsrK2kpIHtcbiAgICAgICAgbyA9IG51bWVyaWMubWF0aGZ1bnNbaV07XG4gICAgICAgIGRlbGV0ZSBudW1lcmljLm9wczFbb107XG4gICAgfVxuICAgIGZvcihpIGluIG51bWVyaWMubWFwcmVkdWNlcnMpIHtcbiAgICAgICAgaWYobnVtZXJpYy5tYXByZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgbyA9IG51bWVyaWMubWFwcmVkdWNlcnNbaV07XG4gICAgICAgICAgICBudW1lcmljW2krJ1YnXSA9IG51bWVyaWMubWFwcmVkdWNlMihvWzBdLG9bMV0pO1xuICAgICAgICAgICAgbnVtZXJpY1tpXSA9IEZ1bmN0aW9uKCd4JywncycsJ2snLFxuICAgICAgICAgICAgICAgICAgICBvWzFdK1xuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIHggIT09IFwib2JqZWN0XCIpIHsnK1xuICAgICAgICAgICAgICAgICAgICAnICAgIHhpID0geDtcXG4nK1xuICAgICAgICAgICAgICAgICAgICBvWzBdKyc7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgICByZXR1cm4gYWNjdW07XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ30nK1xuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIHMgPT09IFwidW5kZWZpbmVkXCIpIHMgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIGsgPSAwO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdpZihrID09PSBzLmxlbmd0aC0xKSByZXR1cm4gbnVtZXJpYy4nK2krJ1YoeCk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciB4aTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIG4gPSB4Lmxlbmd0aCwgaTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICAgeGkgPSBhcmd1bWVudHMuY2FsbGVlKHhbaV0pO1xcbicrXG4gICAgICAgICAgICAgICAgICAgIG9bMF0rJztcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4gYWNjdW07XFxuJyk7XG4gICAgICAgIH1cbiAgICB9XG59KCkpO1xuXG5udW1lcmljLnRydW5jVlYgPSBudW1lcmljLnBvaW50d2lzZShbJ3hbaV0nLCd5W2ldJ10sJ3JldFtpXSA9IHJvdW5kKHhbaV0veVtpXSkqeVtpXTsnLCd2YXIgcm91bmQgPSBNYXRoLnJvdW5kOycpO1xubnVtZXJpYy50cnVuY1ZTID0gbnVtZXJpYy5wb2ludHdpc2UoWyd4W2ldJywneSddLCdyZXRbaV0gPSByb3VuZCh4W2ldL3kpKnk7JywndmFyIHJvdW5kID0gTWF0aC5yb3VuZDsnKTtcbm51bWVyaWMudHJ1bmNTViA9IG51bWVyaWMucG9pbnR3aXNlKFsneCcsJ3lbaV0nXSwncmV0W2ldID0gcm91bmQoeC95W2ldKSp5W2ldOycsJ3ZhciByb3VuZCA9IE1hdGgucm91bmQ7Jyk7XG5udW1lcmljLnRydW5jID0gZnVuY3Rpb24gdHJ1bmMoeCx5KSB7XG4gICAgaWYodHlwZW9mIHggPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIHJldHVybiBudW1lcmljLnRydW5jVlYoeCx5KTtcbiAgICAgICAgcmV0dXJuIG51bWVyaWMudHJ1bmNWUyh4LHkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIHJldHVybiBudW1lcmljLnRydW5jU1YoeCx5KTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4L3kpKnk7XG59XG5cbm51bWVyaWMuaW52ID0gZnVuY3Rpb24gaW52KHgpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpLCBhYnMgPSBNYXRoLmFicywgbSA9IHNbMF0sIG4gPSBzWzFdO1xuICAgIHZhciBBID0gbnVtZXJpYy5jbG9uZSh4KSwgQWksIEFqO1xuICAgIHZhciBJID0gbnVtZXJpYy5pZGVudGl0eShtKSwgSWksIElqO1xuICAgIHZhciBpLGosayx4O1xuICAgIGZvcihqPTA7ajxuOysraikge1xuICAgICAgICB2YXIgaTAgPSAtMTtcbiAgICAgICAgdmFyIHYwID0gLTE7XG4gICAgICAgIGZvcihpPWo7aSE9PW07KytpKSB7IGsgPSBhYnMoQVtpXVtqXSk7IGlmKGs+djApIHsgaTAgPSBpOyB2MCA9IGs7IH0gfVxuICAgICAgICBBaiA9IEFbaTBdOyBBW2kwXSA9IEFbal07IEFbal0gPSBBajtcbiAgICAgICAgSWogPSBJW2kwXTsgSVtpMF0gPSBJW2pdOyBJW2pdID0gSWo7XG4gICAgICAgIHggPSBBaltqXTtcbiAgICAgICAgZm9yKGs9ajtrIT09bjsrK2spICAgIEFqW2tdIC89IHg7IFxuICAgICAgICBmb3Ioaz1uLTE7ayE9PS0xOy0taykgSWpba10gLz0geDtcbiAgICAgICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgICAgIGlmKGkhPT1qKSB7XG4gICAgICAgICAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICAgICAgICAgIElpID0gSVtpXTtcbiAgICAgICAgICAgICAgICB4ID0gQWlbal07XG4gICAgICAgICAgICAgICAgZm9yKGs9aisxO2shPT1uOysraykgIEFpW2tdIC09IEFqW2tdKng7XG4gICAgICAgICAgICAgICAgZm9yKGs9bi0xO2s+MDstLWspIHsgSWlba10gLT0gSWpba10qeDsgLS1rOyBJaVtrXSAtPSBJaltrXSp4OyB9XG4gICAgICAgICAgICAgICAgaWYoaz09PTApIElpWzBdIC09IElqWzBdKng7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEk7XG59XG5cbm51bWVyaWMuZGV0ID0gZnVuY3Rpb24gZGV0KHgpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xuICAgIGlmKHMubGVuZ3RoICE9PSAyIHx8IHNbMF0gIT09IHNbMV0pIHsgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiBkZXQoKSBvbmx5IHdvcmtzIG9uIHNxdWFyZSBtYXRyaWNlcycpOyB9XG4gICAgdmFyIG4gPSBzWzBdLCByZXQgPSAxLGksaixrLEEgPSBudW1lcmljLmNsb25lKHgpLEFqLEFpLGFscGhhLHRlbXAsazEsazIsazM7XG4gICAgZm9yKGo9MDtqPG4tMTtqKyspIHtcbiAgICAgICAgaz1qO1xuICAgICAgICBmb3IoaT1qKzE7aTxuO2krKykgeyBpZihNYXRoLmFicyhBW2ldW2pdKSA+IE1hdGguYWJzKEFba11bal0pKSB7IGsgPSBpOyB9IH1cbiAgICAgICAgaWYoayAhPT0gaikge1xuICAgICAgICAgICAgdGVtcCA9IEFba107IEFba10gPSBBW2pdOyBBW2pdID0gdGVtcDtcbiAgICAgICAgICAgIHJldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBBaiA9IEFbal07XG4gICAgICAgIGZvcihpPWorMTtpPG47aSsrKSB7XG4gICAgICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgICAgICBhbHBoYSA9IEFpW2pdL0FqW2pdO1xuICAgICAgICAgICAgZm9yKGs9aisxO2s8bi0xO2srPTIpIHtcbiAgICAgICAgICAgICAgICBrMSA9IGsrMTtcbiAgICAgICAgICAgICAgICBBaVtrXSAtPSBBaltrXSphbHBoYTtcbiAgICAgICAgICAgICAgICBBaVtrMV0gLT0gQWpbazFdKmFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoayE9PW4pIHsgQWlba10gLT0gQWpba10qYWxwaGE7IH1cbiAgICAgICAgfVxuICAgICAgICBpZihBaltqXSA9PT0gMCkgeyByZXR1cm4gMDsgfVxuICAgICAgICByZXQgKj0gQWpbal07XG4gICAgfVxuICAgIHJldHVybiByZXQqQVtqXVtqXTtcbn1cblxubnVtZXJpYy50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoeCkge1xuICAgIHZhciBpLGosbSA9IHgubGVuZ3RoLG4gPSB4WzBdLmxlbmd0aCwgcmV0PUFycmF5KG4pLEEwLEExLEJqO1xuICAgIGZvcihqPTA7ajxuO2orKykgcmV0W2pdID0gQXJyYXkobSk7XG4gICAgZm9yKGk9bS0xO2k+PTE7aS09Mikge1xuICAgICAgICBBMSA9IHhbaV07XG4gICAgICAgIEEwID0geFtpLTFdO1xuICAgICAgICBmb3Ioaj1uLTE7aj49MTstLWopIHtcbiAgICAgICAgICAgIEJqID0gcmV0W2pdOyBCaltpXSA9IEExW2pdOyBCaltpLTFdID0gQTBbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBCaiA9IHJldFtqXTsgQmpbaV0gPSBBMVtqXTsgQmpbaS0xXSA9IEEwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7XG4gICAgICAgICAgICBCaiA9IHJldFswXTsgQmpbaV0gPSBBMVswXTsgQmpbaS0xXSA9IEEwWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmKGk9PT0wKSB7XG4gICAgICAgIEEwID0geFswXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTE7LS1qKSB7XG4gICAgICAgICAgICByZXRbal1bMF0gPSBBMFtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIHJldFtqXVswXSA9IEEwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IHJldFswXVswXSA9IEEwWzBdOyB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5udW1lcmljLm5lZ3RyYW5zcG9zZSA9IGZ1bmN0aW9uIG5lZ3RyYW5zcG9zZSh4KSB7XG4gICAgdmFyIGksaixtID0geC5sZW5ndGgsbiA9IHhbMF0ubGVuZ3RoLCByZXQ9QXJyYXkobiksQTAsQTEsQmo7XG4gICAgZm9yKGo9MDtqPG47aisrKSByZXRbal0gPSBBcnJheShtKTtcbiAgICBmb3IoaT1tLTE7aT49MTtpLT0yKSB7XG4gICAgICAgIEExID0geFtpXTtcbiAgICAgICAgQTAgPSB4W2ktMV07XG4gICAgICAgIGZvcihqPW4tMTtqPj0xOy0taikge1xuICAgICAgICAgICAgQmogPSByZXRbal07IEJqW2ldID0gLUExW2pdOyBCaltpLTFdID0gLUEwW2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgQmogPSByZXRbal07IEJqW2ldID0gLUExW2pdOyBCaltpLTFdID0gLUEwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7XG4gICAgICAgICAgICBCaiA9IHJldFswXTsgQmpbaV0gPSAtQTFbMF07IEJqW2ktMV0gPSAtQTBbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoaT09PTApIHtcbiAgICAgICAgQTAgPSB4WzBdO1xuICAgICAgICBmb3Ioaj1uLTE7aj49MTstLWopIHtcbiAgICAgICAgICAgIHJldFtqXVswXSA9IC1BMFtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIHJldFtqXVswXSA9IC1BMFtqXTtcbiAgICAgICAgfVxuICAgICAgICBpZihqPT09MCkgeyByZXRbMF1bMF0gPSAtQTBbMF07IH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5fcmFuZG9tID0gZnVuY3Rpb24gX3JhbmRvbShzLGspIHtcbiAgICB2YXIgaSxuPXNba10scmV0PUFycmF5KG4pLCBybmQ7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkge1xuICAgICAgICBybmQgPSBNYXRoLnJhbmRvbTtcbiAgICAgICAgZm9yKGk9bi0xO2k+PTE7aS09Mikge1xuICAgICAgICAgICAgcmV0W2ldID0gcm5kKCk7XG4gICAgICAgICAgICByZXRbaS0xXSA9IHJuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGk9PT0wKSB7IHJldFswXSA9IHJuZCgpOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgcmV0W2ldID0gX3JhbmRvbShzLGsrMSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMucmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKHMpIHsgcmV0dXJuIG51bWVyaWMuX3JhbmRvbShzLDApOyB9XG5cbm51bWVyaWMubm9ybTIgPSBmdW5jdGlvbiBub3JtMih4KSB7IHJldHVybiBNYXRoLnNxcnQobnVtZXJpYy5ub3JtMlNxdWFyZWQoeCkpOyB9XG5cbm51bWVyaWMubGluc3BhY2UgPSBmdW5jdGlvbiBsaW5zcGFjZShhLGIsbikge1xuICAgIGlmKHR5cGVvZiBuID09PSBcInVuZGVmaW5lZFwiKSBuID0gTWF0aC5tYXgoTWF0aC5yb3VuZChiLWEpKzEsMSk7XG4gICAgaWYobjwyKSB7IHJldHVybiBuPT09MT9bYV06W107IH1cbiAgICB2YXIgaSxyZXQgPSBBcnJheShuKTtcbiAgICBuLS07XG4gICAgZm9yKGk9bjtpPj0wO2ktLSkgeyByZXRbaV0gPSAoaSpiKyhuLWkpKmEpL247IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmdldEJsb2NrID0gZnVuY3Rpb24gZ2V0QmxvY2soeCxmcm9tLHRvKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbSh4KTtcbiAgICBmdW5jdGlvbiBmb28oeCxrKSB7XG4gICAgICAgIHZhciBpLGEgPSBmcm9tW2tdLCBuID0gdG9ba10tYSwgcmV0ID0gQXJyYXkobik7XG4gICAgICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgIGZvcihpPW47aT49MDtpLS0pIHsgcmV0W2ldID0geFtpK2FdOyB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGZvcihpPW47aT49MDtpLS0pIHsgcmV0W2ldID0gZm9vKHhbaSthXSxrKzEpOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBmb28oeCwwKTtcbn1cblxubnVtZXJpYy5zZXRCbG9jayA9IGZ1bmN0aW9uIHNldEJsb2NrKHgsZnJvbSx0byxCKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbSh4KTtcbiAgICBmdW5jdGlvbiBmb28oeCx5LGspIHtcbiAgICAgICAgdmFyIGksYSA9IGZyb21ba10sIG4gPSB0b1trXS1hO1xuICAgICAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7IGZvcihpPW47aT49MDtpLS0pIHsgeFtpK2FdID0geVtpXTsgfSB9XG4gICAgICAgIGZvcihpPW47aT49MDtpLS0pIHsgZm9vKHhbaSthXSx5W2ldLGsrMSk7IH1cbiAgICB9XG4gICAgZm9vKHgsQiwwKTtcbiAgICByZXR1cm4geDtcbn1cblxubnVtZXJpYy5nZXRSYW5nZSA9IGZ1bmN0aW9uIGdldFJhbmdlKEEsSSxKKSB7XG4gICAgdmFyIG0gPSBJLmxlbmd0aCwgbiA9IEoubGVuZ3RoO1xuICAgIHZhciBpLGo7XG4gICAgdmFyIEIgPSBBcnJheShtKSwgQmksIEFJO1xuICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIEJbaV0gPSBBcnJheShuKTtcbiAgICAgICAgQmkgPSBCW2ldO1xuICAgICAgICBBSSA9IEFbSVtpXV07XG4gICAgICAgIGZvcihqPW4tMTtqIT09LTE7LS1qKSBCaVtqXSA9IEFJW0pbal1dO1xuICAgIH1cbiAgICByZXR1cm4gQjtcbn1cblxubnVtZXJpYy5ibG9ja01hdHJpeCA9IGZ1bmN0aW9uIGJsb2NrTWF0cml4KFgpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKFgpO1xuICAgIGlmKHMubGVuZ3RoPDQpIHJldHVybiBudW1lcmljLmJsb2NrTWF0cml4KFtYXSk7XG4gICAgdmFyIG09c1swXSxuPXNbMV0sTSxOLGksaixYaWo7XG4gICAgTSA9IDA7IE4gPSAwO1xuICAgIGZvcihpPTA7aTxtOysraSkgTSs9WFtpXVswXS5sZW5ndGg7XG4gICAgZm9yKGo9MDtqPG47KytqKSBOKz1YWzBdW2pdWzBdLmxlbmd0aDtcbiAgICB2YXIgWiA9IEFycmF5KE0pO1xuICAgIGZvcihpPTA7aTxNOysraSkgWltpXSA9IEFycmF5KE4pO1xuICAgIHZhciBJPTAsSixaSSxrLGwsWGlqaztcbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgSj1OO1xuICAgICAgICBmb3Ioaj1uLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgWGlqID0gWFtpXVtqXTtcbiAgICAgICAgICAgIEogLT0gWGlqWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihrPVhpai5sZW5ndGgtMTtrIT09LTE7LS1rKSB7XG4gICAgICAgICAgICAgICAgWGlqayA9IFhpaltrXTtcbiAgICAgICAgICAgICAgICBaSSA9IFpbSStrXTtcbiAgICAgICAgICAgICAgICBmb3IobCA9IFhpamsubGVuZ3RoLTE7bCE9PS0xOy0tbCkgWklbSitsXSA9IFhpamtbbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSSArPSBYW2ldWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIFo7XG59XG5cbm51bWVyaWMudGVuc29yID0gZnVuY3Rpb24gdGVuc29yKHgseSkge1xuICAgIGlmKHR5cGVvZiB4ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSByZXR1cm4gbnVtZXJpYy5tdWwoeCx5KTtcbiAgICB2YXIgczEgPSBudW1lcmljLmRpbSh4KSwgczIgPSBudW1lcmljLmRpbSh5KTtcbiAgICBpZihzMS5sZW5ndGggIT09IDEgfHwgczIubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtZXJpYzogdGVuc29yIHByb2R1Y3QgaXMgb25seSBkZWZpbmVkIGZvciB2ZWN0b3JzJyk7XG4gICAgfVxuICAgIHZhciBtID0gczFbMF0sIG4gPSBzMlswXSwgQSA9IEFycmF5KG0pLCBBaSwgaSxqLHhpO1xuICAgIGZvcihpPW0tMTtpPj0wO2ktLSkge1xuICAgICAgICBBaSA9IEFycmF5KG4pO1xuICAgICAgICB4aSA9IHhbaV07XG4gICAgICAgIGZvcihqPW4tMTtqPj0zOy0taikge1xuICAgICAgICAgICAgQWlbal0gPSB4aSAqIHlbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBBaVtqXSA9IHhpICogeVtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEFpW2pdID0geGkgKiB5W2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgQWlbal0gPSB4aSAqIHlbal07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoaj49MCkgeyBBaVtqXSA9IHhpICogeVtqXTsgLS1qOyB9XG4gICAgICAgIEFbaV0gPSBBaTtcbiAgICB9XG4gICAgcmV0dXJuIEE7XG59XG5cbi8vIDMuIFRoZSBUZW5zb3IgdHlwZSBUXG5udW1lcmljLlQgPSBmdW5jdGlvbiBUKHgseSkgeyB0aGlzLnggPSB4OyB0aGlzLnkgPSB5OyB9XG5udW1lcmljLnQgPSBmdW5jdGlvbiB0KHgseSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVCh4LHkpOyB9XG5cbm51bWVyaWMuVGJpbm9wID0gZnVuY3Rpb24gVGJpbm9wKHJyLHJjLGNyLGNjLHNldHVwKSB7XG4gICAgdmFyIGlvID0gbnVtZXJpYy5pbmRleE9mO1xuICAgIGlmKHR5cGVvZiBzZXR1cCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgc2V0dXAgPSAnJztcbiAgICAgICAgZm9yKGsgaW4gbnVtZXJpYykge1xuICAgICAgICAgICAgaWYobnVtZXJpYy5oYXNPd25Qcm9wZXJ0eShrKSAmJiAocnIuaW5kZXhPZihrKT49MCB8fCByYy5pbmRleE9mKGspPj0wIHx8IGNyLmluZGV4T2Yoayk+PTAgfHwgY2MuaW5kZXhPZihrKT49MCkgJiYgay5sZW5ndGg+MSkge1xuICAgICAgICAgICAgICAgIHNldHVwICs9ICd2YXIgJytrKycgPSBudW1lcmljLicraysnO1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZ1bmN0aW9uKFsneSddLFxuICAgICAgICAgICAgJ3ZhciB4ID0gdGhpcztcXG4nK1xuICAgICAgICAgICAgJ2lmKCEoeSBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIHsgeSA9IG5ldyBudW1lcmljLlQoeSk7IH1cXG4nK1xuICAgICAgICAgICAgc2V0dXArJ1xcbicrXG4gICAgICAgICAgICAnaWYoeC55KSB7JytcbiAgICAgICAgICAgICcgIGlmKHkueSkgeycrXG4gICAgICAgICAgICAnICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKCcrY2MrJyk7XFxuJytcbiAgICAgICAgICAgICcgIH1cXG4nK1xuICAgICAgICAgICAgJyAgcmV0dXJuIG5ldyBudW1lcmljLlQoJytjcisnKTtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ2lmKHkueSkge1xcbicrXG4gICAgICAgICAgICAnICByZXR1cm4gbmV3IG51bWVyaWMuVCgnK3JjKycpO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQoJytycisnKTtcXG4nXG4gICAgKTtcbn1cblxubnVtZXJpYy5ULnByb3RvdHlwZS5hZGQgPSBudW1lcmljLlRiaW5vcChcbiAgICAgICAgJ2FkZCh4LngseS54KScsXG4gICAgICAgICdhZGQoeC54LHkueCkseS55JyxcbiAgICAgICAgJ2FkZCh4LngseS54KSx4LnknLFxuICAgICAgICAnYWRkKHgueCx5LngpLGFkZCh4LnkseS55KScpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5zdWIgPSBudW1lcmljLlRiaW5vcChcbiAgICAgICAgJ3N1Yih4LngseS54KScsXG4gICAgICAgICdzdWIoeC54LHkueCksbmVnKHkueSknLFxuICAgICAgICAnc3ViKHgueCx5LngpLHgueScsXG4gICAgICAgICdzdWIoeC54LHkueCksc3ViKHgueSx5LnkpJyk7XG5udW1lcmljLlQucHJvdG90eXBlLm11bCA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnbXVsKHgueCx5LngpJyxcbiAgICAgICAgJ211bCh4LngseS54KSxtdWwoeC54LHkueSknLFxuICAgICAgICAnbXVsKHgueCx5LngpLG11bCh4LnkseS54KScsXG4gICAgICAgICdzdWIobXVsKHgueCx5LngpLG11bCh4LnkseS55KSksYWRkKG11bCh4LngseS55KSxtdWwoeC55LHkueCkpJyk7XG5cbm51bWVyaWMuVC5wcm90b3R5cGUucmVjaXByb2NhbCA9IGZ1bmN0aW9uIHJlY2lwcm9jYWwoKSB7XG4gICAgdmFyIG11bCA9IG51bWVyaWMubXVsLCBkaXYgPSBudW1lcmljLmRpdjtcbiAgICBpZih0aGlzLnkpIHtcbiAgICAgICAgdmFyIGQgPSBudW1lcmljLmFkZChtdWwodGhpcy54LHRoaXMueCksbXVsKHRoaXMueSx0aGlzLnkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBudW1lcmljLlQoZGl2KHRoaXMueCxkKSxkaXYobnVtZXJpYy5uZWcodGhpcy55KSxkKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVChkaXYoMSx0aGlzLngpKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2KHkpIHtcbiAgICBpZighKHkgaW5zdGFuY2VvZiBudW1lcmljLlQpKSB5ID0gbmV3IG51bWVyaWMuVCh5KTtcbiAgICBpZih5LnkpIHsgcmV0dXJuIHRoaXMubXVsKHkucmVjaXByb2NhbCgpKTsgfVxuICAgIHZhciBkaXYgPSBudW1lcmljLmRpdjtcbiAgICBpZih0aGlzLnkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQoZGl2KHRoaXMueCx5LngpLGRpdih0aGlzLnkseS54KSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVChkaXYodGhpcy54LHkueCkpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5kb3QgPSBudW1lcmljLlRiaW5vcChcbiAgICAgICAgJ2RvdCh4LngseS54KScsXG4gICAgICAgICdkb3QoeC54LHkueCksZG90KHgueCx5LnkpJyxcbiAgICAgICAgJ2RvdCh4LngseS54KSxkb3QoeC55LHkueCknLFxuICAgICAgICAnc3ViKGRvdCh4LngseS54KSxkb3QoeC55LHkueSkpLGFkZChkb3QoeC54LHkueSksZG90KHgueSx5LngpKSdcbiAgICAgICAgKTtcbm51bWVyaWMuVC5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gdHJhbnNwb3NlKCkge1xuICAgIHZhciB0ID0gbnVtZXJpYy50cmFuc3Bvc2UsIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgaWYoeSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVCh0KHgpLHQoeSkpOyB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQodCh4KSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLnRyYW5zanVnYXRlID0gZnVuY3Rpb24gdHJhbnNqdWdhdGUoKSB7XG4gICAgdmFyIHQgPSBudW1lcmljLnRyYW5zcG9zZSwgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHQoeCksbnVtZXJpYy5uZWd0cmFuc3Bvc2UoeSkpOyB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQodCh4KSk7XG59XG5udW1lcmljLlR1bm9wID0gZnVuY3Rpb24gVHVub3AocixjLHMpIHtcbiAgICBpZih0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikgeyBzID0gJyc7IH1cbiAgICByZXR1cm4gRnVuY3Rpb24oXG4gICAgICAgICAgICAndmFyIHggPSB0aGlzO1xcbicrXG4gICAgICAgICAgICBzKydcXG4nK1xuICAgICAgICAgICAgJ2lmKHgueSkgeycrXG4gICAgICAgICAgICAnICAnK2MrJztcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgcisnO1xcbidcbiAgICApO1xufVxuXG5udW1lcmljLlQucHJvdG90eXBlLmV4cCA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChleCknLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobXVsKGNvcyh4LnkpLGV4KSxtdWwoc2luKHgueSksZXgpKScsXG4gICAgICAgICd2YXIgZXggPSBudW1lcmljLmV4cCh4LngpLCBjb3MgPSBudW1lcmljLmNvcywgc2luID0gbnVtZXJpYy5zaW4sIG11bCA9IG51bWVyaWMubXVsOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5jb25qID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKHgueCk7JyxcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKHgueCxudW1lcmljLm5lZyh4LnkpKTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubmVnID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG5lZyh4LngpKTsnLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobmVnKHgueCksbmVnKHgueSkpOycsXG4gICAgICAgICd2YXIgbmVnID0gbnVtZXJpYy5uZWc7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLnNpbiA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLnNpbih4LngpKScsXG4gICAgICAgICdyZXR1cm4geC5leHAoKS5zdWIoeC5uZWcoKS5leHAoKSkuZGl2KG5ldyBudW1lcmljLlQoMCwyKSk7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmNvcyA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmNvcyh4LngpKScsXG4gICAgICAgICdyZXR1cm4geC5leHAoKS5hZGQoeC5uZWcoKS5leHAoKSkuZGl2KDIpOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5hYnMgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5hYnMoeC54KSk7JyxcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuc3FydChudW1lcmljLmFkZChtdWwoeC54LHgueCksbXVsKHgueSx4LnkpKSkpOycsXG4gICAgICAgICd2YXIgbXVsID0gbnVtZXJpYy5tdWw7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmxvZyA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmxvZyh4LngpKTsnLFxuICAgICAgICAndmFyIHRoZXRhID0gbmV3IG51bWVyaWMuVChudW1lcmljLmF0YW4yKHgueSx4LngpKSwgciA9IHguYWJzKCk7XFxuJytcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMubG9nKHIueCksdGhldGEueCk7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLm5vcm0yID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBudW1lcmljLm5vcm0yKHgueCk7JyxcbiAgICAgICAgJ3ZhciBmID0gbnVtZXJpYy5ub3JtMlNxdWFyZWQ7XFxuJytcbiAgICAgICAgJ3JldHVybiBNYXRoLnNxcnQoZih4LngpK2YoeC55KSk7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmludiA9IGZ1bmN0aW9uIGludigpIHtcbiAgICB2YXIgQSA9IHRoaXM7XG4gICAgaWYodHlwZW9mIEEueSA9PT0gXCJ1bmRlZmluZWRcIikgeyByZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmludihBLngpKTsgfVxuICAgIHZhciBuID0gQS54Lmxlbmd0aCwgaSwgaiwgaztcbiAgICB2YXIgUnggPSBudW1lcmljLmlkZW50aXR5KG4pLFJ5ID0gbnVtZXJpYy5yZXAoW24sbl0sMCk7XG4gICAgdmFyIEF4ID0gbnVtZXJpYy5jbG9uZShBLngpLCBBeSA9IG51bWVyaWMuY2xvbmUoQS55KTtcbiAgICB2YXIgQWl4LCBBaXksIEFqeCwgQWp5LCBSaXgsIFJpeSwgUmp4LCBSank7XG4gICAgdmFyIGksaixrLGQsZDEsYXgsYXksYngsYnksdGVtcDtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHtcbiAgICAgICAgYXggPSBBeFtpXVtpXTsgYXkgPSBBeVtpXVtpXTtcbiAgICAgICAgZCA9IGF4KmF4K2F5KmF5O1xuICAgICAgICBrID0gaTtcbiAgICAgICAgZm9yKGo9aSsxO2o8bjtqKyspIHtcbiAgICAgICAgICAgIGF4ID0gQXhbal1baV07IGF5ID0gQXlbal1baV07XG4gICAgICAgICAgICBkMSA9IGF4KmF4K2F5KmF5O1xuICAgICAgICAgICAgaWYoZDEgPiBkKSB7IGs9ajsgZCA9IGQxOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoayE9PWkpIHtcbiAgICAgICAgICAgIHRlbXAgPSBBeFtpXTsgQXhbaV0gPSBBeFtrXTsgQXhba10gPSB0ZW1wO1xuICAgICAgICAgICAgdGVtcCA9IEF5W2ldOyBBeVtpXSA9IEF5W2tdOyBBeVtrXSA9IHRlbXA7XG4gICAgICAgICAgICB0ZW1wID0gUnhbaV07IFJ4W2ldID0gUnhba107IFJ4W2tdID0gdGVtcDtcbiAgICAgICAgICAgIHRlbXAgPSBSeVtpXTsgUnlbaV0gPSBSeVtrXTsgUnlba10gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIEFpeCA9IEF4W2ldOyBBaXkgPSBBeVtpXTtcbiAgICAgICAgUml4ID0gUnhbaV07IFJpeSA9IFJ5W2ldO1xuICAgICAgICBheCA9IEFpeFtpXTsgYXkgPSBBaXlbaV07XG4gICAgICAgIGZvcihqPWkrMTtqPG47aisrKSB7XG4gICAgICAgICAgICBieCA9IEFpeFtqXTsgYnkgPSBBaXlbal07XG4gICAgICAgICAgICBBaXhbal0gPSAoYngqYXgrYnkqYXkpL2Q7XG4gICAgICAgICAgICBBaXlbal0gPSAoYnkqYXgtYngqYXkpL2Q7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGo9MDtqPG47aisrKSB7XG4gICAgICAgICAgICBieCA9IFJpeFtqXTsgYnkgPSBSaXlbal07XG4gICAgICAgICAgICBSaXhbal0gPSAoYngqYXgrYnkqYXkpL2Q7XG4gICAgICAgICAgICBSaXlbal0gPSAoYnkqYXgtYngqYXkpL2Q7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGo9aSsxO2o8bjtqKyspIHtcbiAgICAgICAgICAgIEFqeCA9IEF4W2pdOyBBankgPSBBeVtqXTtcbiAgICAgICAgICAgIFJqeCA9IFJ4W2pdOyBSankgPSBSeVtqXTtcbiAgICAgICAgICAgIGF4ID0gQWp4W2ldOyBheSA9IEFqeVtpXTtcbiAgICAgICAgICAgIGZvcihrPWkrMTtrPG47aysrKSB7XG4gICAgICAgICAgICAgICAgYnggPSBBaXhba107IGJ5ID0gQWl5W2tdO1xuICAgICAgICAgICAgICAgIEFqeFtrXSAtPSBieCpheC1ieSpheTtcbiAgICAgICAgICAgICAgICBBanlba10gLT0gYnkqYXgrYngqYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3Ioaz0wO2s8bjtrKyspIHtcbiAgICAgICAgICAgICAgICBieCA9IFJpeFtrXTsgYnkgPSBSaXlba107XG4gICAgICAgICAgICAgICAgUmp4W2tdIC09IGJ4KmF4LWJ5KmF5O1xuICAgICAgICAgICAgICAgIFJqeVtrXSAtPSBieSpheCtieCpheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IoaT1uLTE7aT4wO2ktLSkge1xuICAgICAgICBSaXggPSBSeFtpXTsgUml5ID0gUnlbaV07XG4gICAgICAgIGZvcihqPWktMTtqPj0wO2otLSkge1xuICAgICAgICAgICAgUmp4ID0gUnhbal07IFJqeSA9IFJ5W2pdO1xuICAgICAgICAgICAgYXggPSBBeFtqXVtpXTsgYXkgPSBBeVtqXVtpXTtcbiAgICAgICAgICAgIGZvcihrPW4tMTtrPj0wO2stLSkge1xuICAgICAgICAgICAgICAgIGJ4ID0gUml4W2tdOyBieSA9IFJpeVtrXTtcbiAgICAgICAgICAgICAgICBSanhba10gLT0gYXgqYnggLSBheSpieTtcbiAgICAgICAgICAgICAgICBSanlba10gLT0gYXgqYnkgKyBheSpieDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVChSeCxSeSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIGsgPSAwLCBpaywgbiA9IGkubGVuZ3RoO1xuICAgIGlmKHkpIHtcbiAgICAgICAgd2hpbGUoazxuKSB7XG4gICAgICAgICAgICBpayA9IGlba107XG4gICAgICAgICAgICB4ID0geFtpa107XG4gICAgICAgICAgICB5ID0geVtpa107XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBudW1lcmljLlQoeCx5KTtcbiAgICB9XG4gICAgd2hpbGUoazxuKSB7XG4gICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICBrKys7XG4gICAgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHgpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSx2KSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIGsgPSAwLCBpaywgbiA9IGkubGVuZ3RoLCB2eCA9IHYueCwgdnkgPSB2Lnk7XG4gICAgaWYobj09PTApIHtcbiAgICAgICAgaWYodnkpIHsgdGhpcy55ID0gdnk7IH1cbiAgICAgICAgZWxzZSBpZih5KSB7IHRoaXMueSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYodnkpIHtcbiAgICAgICAgaWYoeSkgeyAvKiBvayAqLyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeSA9IG51bWVyaWMucmVwKG51bWVyaWMuZGltKHgpLDApO1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShrPG4tMSkge1xuICAgICAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICAgICAgeSA9IHlbaWtdO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgeFtpa10gPSB2eDtcbiAgICAgICAgeVtpa10gPSB2eTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmKHkpIHtcbiAgICAgICAgd2hpbGUoazxuLTEpIHtcbiAgICAgICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgICAgIHggPSB4W2lrXTtcbiAgICAgICAgICAgIHkgPSB5W2lrXTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICBpayA9IGlba107XG4gICAgICAgIHhbaWtdID0gdng7XG4gICAgICAgIGlmKHZ4IGluc3RhbmNlb2YgQXJyYXkpIHlbaWtdID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0odngpLDApO1xuICAgICAgICBlbHNlIHlbaWtdID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdoaWxlKGs8bi0xKSB7XG4gICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICBrKys7XG4gICAgfVxuICAgIGlrID0gaVtrXTtcbiAgICB4W2lrXSA9IHZ4O1xuICAgIHJldHVybiB0aGlzO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5nZXRSb3dzID0gZnVuY3Rpb24gZ2V0Um93cyhpMCxpMSkge1xuICAgIHZhciBuID0gaTEtaTArMSwgajtcbiAgICB2YXIgcnggPSBBcnJheShuKSwgcnksIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ4W2otaTBdID0geFtqXTsgfVxuICAgIGlmKHkpIHtcbiAgICAgICAgcnkgPSBBcnJheShuKTtcbiAgICAgICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ5W2otaTBdID0geVtqXTsgfVxuICAgICAgICByZXR1cm4gbmV3IG51bWVyaWMuVChyeCxyeSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHJ4KTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuc2V0Um93cyA9IGZ1bmN0aW9uIHNldFJvd3MoaTAsaTEsQSkge1xuICAgIHZhciBqO1xuICAgIHZhciByeCA9IHRoaXMueCwgcnkgPSB0aGlzLnksIHggPSBBLngsIHkgPSBBLnk7XG4gICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ4W2pdID0geFtqLWkwXTsgfVxuICAgIGlmKHkpIHtcbiAgICAgICAgaWYoIXJ5KSB7IHJ5ID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0ocngpLDApOyB0aGlzLnkgPSByeTsgfVxuICAgICAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnlbal0gPSB5W2otaTBdOyB9XG4gICAgfSBlbHNlIGlmKHJ5KSB7XG4gICAgICAgIGZvcihqPWkwO2o8PWkxO2orKykgeyByeVtqXSA9IG51bWVyaWMucmVwKFt4W2otaTBdLmxlbmd0aF0sMCk7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmdldFJvdyA9IGZ1bmN0aW9uIGdldFJvdyhrKSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgaWYoeSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVCh4W2tdLHlba10pOyB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoeFtrXSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLnNldFJvdyA9IGZ1bmN0aW9uIHNldFJvdyhpLHYpIHtcbiAgICB2YXIgcnggPSB0aGlzLngsIHJ5ID0gdGhpcy55LCB4ID0gdi54LCB5ID0gdi55O1xuICAgIHJ4W2ldID0geDtcbiAgICBpZih5KSB7XG4gICAgICAgIGlmKCFyeSkgeyByeSA9IG51bWVyaWMucmVwKG51bWVyaWMuZGltKHJ4KSwwKTsgdGhpcy55ID0gcnk7IH1cbiAgICAgICAgcnlbaV0gPSB5O1xuICAgIH0gZWxzZSBpZihyeSkge1xuICAgICAgICByeSA9IG51bWVyaWMucmVwKFt4Lmxlbmd0aF0sMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5udW1lcmljLlQucHJvdG90eXBlLmdldEJsb2NrID0gZnVuY3Rpb24gZ2V0QmxvY2soZnJvbSx0bykge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCBiID0gbnVtZXJpYy5nZXRCbG9jaztcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKGIoeCxmcm9tLHRvKSxiKHksZnJvbSx0bykpOyB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoYih4LGZyb20sdG8pKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuc2V0QmxvY2sgPSBmdW5jdGlvbiBzZXRCbG9jayhmcm9tLHRvLEEpIHtcbiAgICBpZighKEEgaW5zdGFuY2VvZiBudW1lcmljLlQpKSBBID0gbmV3IG51bWVyaWMuVChBKTtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgYiA9IG51bWVyaWMuc2V0QmxvY2ssIEF4ID0gQS54LCBBeSA9IEEueTtcbiAgICBpZihBeSkge1xuICAgICAgICBpZigheSkgeyB0aGlzLnkgPSBudW1lcmljLnJlcChudW1lcmljLmRpbSh0aGlzKSwwKTsgeSA9IHRoaXMueTsgfVxuICAgICAgICBiKHgsZnJvbSx0byxBeCk7XG4gICAgICAgIGIoeSxmcm9tLHRvLEF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGIoeCxmcm9tLHRvLEF4KTtcbiAgICBpZih5KSBiKHksZnJvbSx0byxudW1lcmljLnJlcChudW1lcmljLmRpbShBeCksMCkpO1xufVxubnVtZXJpYy5ULnJlcCA9IGZ1bmN0aW9uIHJlcChzLHYpIHtcbiAgICB2YXIgVCA9IG51bWVyaWMuVDtcbiAgICBpZighKHYgaW5zdGFuY2VvZiBUKSkgdiA9IG5ldyBUKHYpO1xuICAgIHZhciB4ID0gdi54LCB5ID0gdi55LCByID0gbnVtZXJpYy5yZXA7XG4gICAgaWYoeSkgcmV0dXJuIG5ldyBUKHIocyx4KSxyKHMseSkpO1xuICAgIHJldHVybiBuZXcgVChyKHMseCkpO1xufVxubnVtZXJpYy5ULmRpYWcgPSBmdW5jdGlvbiBkaWFnKGQpIHtcbiAgICBpZighKGQgaW5zdGFuY2VvZiBudW1lcmljLlQpKSBkID0gbmV3IG51bWVyaWMuVChkKTtcbiAgICB2YXIgeCA9IGQueCwgeSA9IGQueSwgZGlhZyA9IG51bWVyaWMuZGlhZztcbiAgICBpZih5KSByZXR1cm4gbmV3IG51bWVyaWMuVChkaWFnKHgpLGRpYWcoeSkpO1xuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKGRpYWcoeCkpO1xufVxubnVtZXJpYy5ULmVpZyA9IGZ1bmN0aW9uIGVpZygpIHtcbiAgICBpZih0aGlzLnkpIHsgdGhyb3cgbmV3IEVycm9yKCdlaWc6IG5vdCBpbXBsZW1lbnRlZCBmb3IgY29tcGxleCBtYXRyaWNlcy4nKTsgfVxuICAgIHJldHVybiBudW1lcmljLmVpZyh0aGlzLngpO1xufVxubnVtZXJpYy5ULmlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkobikgeyByZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmlkZW50aXR5KG4pKTsgfVxubnVtZXJpYy5ULnByb3RvdHlwZS5nZXREaWFnID0gZnVuY3Rpb24gZ2V0RGlhZygpIHtcbiAgICB2YXIgbiA9IG51bWVyaWM7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgaWYoeSkgeyByZXR1cm4gbmV3IG4uVChuLmdldERpYWcoeCksbi5nZXREaWFnKHkpKTsgfVxuICAgIHJldHVybiBuZXcgbi5UKG4uZ2V0RGlhZyh4KSk7XG59XG5cbi8vIDQuIEVpZ2VudmFsdWVzIG9mIHJlYWwgbWF0cmljZXNcblxubnVtZXJpYy5ob3VzZSA9IGZ1bmN0aW9uIGhvdXNlKHgpIHtcbiAgICB2YXIgdiA9IG51bWVyaWMuY2xvbmUoeCk7XG4gICAgdmFyIHMgPSB4WzBdID49IDAgPyAxIDogLTE7XG4gICAgdmFyIGFscGhhID0gcypudW1lcmljLm5vcm0yKHgpO1xuICAgIHZbMF0gKz0gYWxwaGE7XG4gICAgdmFyIGZvbyA9IG51bWVyaWMubm9ybTIodik7XG4gICAgaWYoZm9vID09PSAwKSB7IC8qIHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gKi8gdGhyb3cgbmV3IEVycm9yKCdlaWc6IGludGVybmFsIGVycm9yJyk7IH1cbiAgICByZXR1cm4gbnVtZXJpYy5kaXYodixmb28pO1xufVxuXG5udW1lcmljLnRvVXBwZXJIZXNzZW5iZXJnID0gZnVuY3Rpb24gdG9VcHBlckhlc3NlbmJlcmcobWUpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKG1lKTtcbiAgICBpZihzLmxlbmd0aCAhPT0gMiB8fCBzWzBdICE9PSBzWzFdKSB7IHRocm93IG5ldyBFcnJvcignbnVtZXJpYzogdG9VcHBlckhlc3NlbmJlcmcoKSBvbmx5IHdvcmtzIG9uIHNxdWFyZSBtYXRyaWNlcycpOyB9XG4gICAgdmFyIG0gPSBzWzBdLCBpLGosayx4LHYsQSA9IG51bWVyaWMuY2xvbmUobWUpLEIsQyxBaSxDaSxRID0gbnVtZXJpYy5pZGVudGl0eShtKSxRaTtcbiAgICBmb3Ioaj0wO2o8bS0yO2orKykge1xuICAgICAgICB4ID0gQXJyYXkobS1qLTEpO1xuICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyB4W2ktai0xXSA9IEFbaV1bal07IH1cbiAgICAgICAgaWYobnVtZXJpYy5ub3JtMih4KT4wKSB7XG4gICAgICAgICAgICB2ID0gbnVtZXJpYy5ob3VzZSh4KTtcbiAgICAgICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEEsW2orMSxqXSxbbS0xLG0tMV0pO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyBBaSA9IEFbaV07IENpID0gQ1tpLWotMV07IGZvcihrPWo7azxtO2srKykgQWlba10gLT0gMipDaVtrLWpdOyB9XG4gICAgICAgICAgICBCID0gbnVtZXJpYy5nZXRCbG9jayhBLFswLGorMV0sW20tMSxtLTFdKTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcihudW1lcmljLmRvdChCLHYpLHYpO1xuICAgICAgICAgICAgZm9yKGk9MDtpPG07aSsrKSB7IEFpID0gQVtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz1qKzE7azxtO2srKykgQWlba10gLT0gMipDaVtrLWotMV07IH1cbiAgICAgICAgICAgIEIgPSBBcnJheShtLWotMSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgQltpLWotMV0gPSBRW2ldO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyBRaSA9IFFbaV07IENpID0gQ1tpLWotMV07IGZvcihrPTA7azxtO2srKykgUWlba10gLT0gMipDaVtrXTsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7SDpBLCBROlF9O1xufVxuXG5udW1lcmljLmVwc2lsb24gPSAyLjIyMDQ0NjA0OTI1MDMxM2UtMTY7XG5cbm51bWVyaWMuUVJGcmFuY2lzID0gZnVuY3Rpb24oSCxtYXhpdGVyKSB7XG4gICAgaWYodHlwZW9mIG1heGl0ZXIgPT09IFwidW5kZWZpbmVkXCIpIHsgbWF4aXRlciA9IDEwMDAwOyB9XG4gICAgSCA9IG51bWVyaWMuY2xvbmUoSCk7XG4gICAgdmFyIEgwID0gbnVtZXJpYy5jbG9uZShIKTtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKEgpLG09c1swXSx4LHYsYSxiLGMsZCxkZXQsdHIsIEhsb2MsIFEgPSBudW1lcmljLmlkZW50aXR5KG0pLCBRaSwgSGksIEIsIEMsIENpLGksaixrLGl0ZXI7XG4gICAgaWYobTwzKSB7IHJldHVybiB7UTpRLCBCOlsgWzAsbS0xXSBdfTsgfVxuICAgIHZhciBlcHNpbG9uID0gbnVtZXJpYy5lcHNpbG9uO1xuICAgIGZvcihpdGVyPTA7aXRlcjxtYXhpdGVyO2l0ZXIrKykge1xuICAgICAgICBmb3Ioaj0wO2o8bS0xO2orKykge1xuICAgICAgICAgICAgaWYoTWF0aC5hYnMoSFtqKzFdW2pdKSA8IGVwc2lsb24qKE1hdGguYWJzKEhbal1bal0pK01hdGguYWJzKEhbaisxXVtqKzFdKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgUUgxID0gbnVtZXJpYy5RUkZyYW5jaXMobnVtZXJpYy5nZXRCbG9jayhILFswLDBdLFtqLGpdKSxtYXhpdGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgUUgyID0gbnVtZXJpYy5RUkZyYW5jaXMobnVtZXJpYy5nZXRCbG9jayhILFtqKzEsaisxXSxbbS0xLG0tMV0pLG1heGl0ZXIpO1xuICAgICAgICAgICAgICAgIEIgPSBBcnJheShqKzEpO1xuICAgICAgICAgICAgICAgIGZvcihpPTA7aTw9ajtpKyspIHsgQltpXSA9IFFbaV07IH1cbiAgICAgICAgICAgICAgICBDID0gbnVtZXJpYy5kb3QoUUgxLlEsQik7XG4gICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1qO2krKykgeyBRW2ldID0gQ1tpXTsgfVxuICAgICAgICAgICAgICAgIEIgPSBBcnJheShtLWotMSk7XG4gICAgICAgICAgICAgICAgZm9yKGk9aisxO2k8bTtpKyspIHsgQltpLWotMV0gPSBRW2ldOyB9XG4gICAgICAgICAgICAgICAgQyA9IG51bWVyaWMuZG90KFFIMi5RLEIpO1xuICAgICAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IFFbaV0gPSBDW2ktai0xXTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7UTpRLEI6UUgxLkIuY29uY2F0KG51bWVyaWMuYWRkKFFIMi5CLGorMSkpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhID0gSFttLTJdW20tMl07IGIgPSBIW20tMl1bbS0xXTtcbiAgICAgICAgYyA9IEhbbS0xXVttLTJdOyBkID0gSFttLTFdW20tMV07XG4gICAgICAgIHRyID0gYStkO1xuICAgICAgICBkZXQgPSAoYSpkLWIqYyk7XG4gICAgICAgIEhsb2MgPSBudW1lcmljLmdldEJsb2NrKEgsIFswLDBdLCBbMiwyXSk7XG4gICAgICAgIGlmKHRyKnRyPj00KmRldCkge1xuICAgICAgICAgICAgdmFyIHMxLHMyO1xuICAgICAgICAgICAgczEgPSAwLjUqKHRyK01hdGguc3FydCh0cip0ci00KmRldCkpO1xuICAgICAgICAgICAgczIgPSAwLjUqKHRyLU1hdGguc3FydCh0cip0ci00KmRldCkpO1xuICAgICAgICAgICAgSGxvYyA9IG51bWVyaWMuYWRkKG51bWVyaWMuc3ViKG51bWVyaWMuZG90KEhsb2MsSGxvYyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYy5tdWwoSGxvYyxzMStzMikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMuZGlhZyhudW1lcmljLnJlcChbM10sczEqczIpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBIbG9jID0gbnVtZXJpYy5hZGQobnVtZXJpYy5zdWIobnVtZXJpYy5kb3QoSGxvYyxIbG9jKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljLm11bChIbG9jLHRyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYy5kaWFnKG51bWVyaWMucmVwKFszXSxkZXQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IFtIbG9jWzBdWzBdLEhsb2NbMV1bMF0sSGxvY1syXVswXV07XG4gICAgICAgIHYgPSBudW1lcmljLmhvdXNlKHgpO1xuICAgICAgICBCID0gW0hbMF0sSFsxXSxIWzJdXTtcbiAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgIGZvcihpPTA7aTwzO2krKykgeyBIaSA9IEhbaV07IENpID0gQ1tpXTsgZm9yKGs9MDtrPG07aysrKSBIaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEgsIFswLDBdLFttLTEsMl0pO1xuICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IobnVtZXJpYy5kb3QoQix2KSx2KTtcbiAgICAgICAgZm9yKGk9MDtpPG07aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz0wO2s8MztrKyspIEhpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgQiA9IFtRWzBdLFFbMV0sUVsyXV07XG4gICAgICAgIEMgPSBudW1lcmljLnRlbnNvcih2LG51bWVyaWMuZG90KHYsQikpO1xuICAgICAgICBmb3IoaT0wO2k8MztpKyspIHsgUWkgPSBRW2ldOyBDaSA9IENbaV07IGZvcihrPTA7azxtO2srKykgUWlba10gLT0gMipDaVtrXTsgfVxuICAgICAgICB2YXIgSjtcbiAgICAgICAgZm9yKGo9MDtqPG0tMjtqKyspIHtcbiAgICAgICAgICAgIGZvcihrPWo7azw9aisxO2srKykge1xuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKEhbaysxXVtrXSkgPCBlcHNpbG9uKihNYXRoLmFicyhIW2tdW2tdKStNYXRoLmFicyhIW2srMV1baysxXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBRSDEgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsWzAsMF0sW2ssa10pLG1heGl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgUUgyID0gbnVtZXJpYy5RUkZyYW5jaXMobnVtZXJpYy5nZXRCbG9jayhILFtrKzEsaysxXSxbbS0xLG0tMV0pLG1heGl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBCID0gQXJyYXkoaysxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1rO2krKykgeyBCW2ldID0gUVtpXTsgfVxuICAgICAgICAgICAgICAgICAgICBDID0gbnVtZXJpYy5kb3QoUUgxLlEsQik7XG4gICAgICAgICAgICAgICAgICAgIGZvcihpPTA7aTw9aztpKyspIHsgUVtpXSA9IENbaV07IH1cbiAgICAgICAgICAgICAgICAgICAgQiA9IEFycmF5KG0tay0xKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9aysxO2k8bTtpKyspIHsgQltpLWstMV0gPSBRW2ldOyB9XG4gICAgICAgICAgICAgICAgICAgIEMgPSBudW1lcmljLmRvdChRSDIuUSxCKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9aysxO2k8bTtpKyspIHsgUVtpXSA9IENbaS1rLTFdOyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7UTpRLEI6UUgxLkIuY29uY2F0KG51bWVyaWMuYWRkKFFIMi5CLGsrMSkpfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBKID0gTWF0aC5taW4obS0xLGorMyk7XG4gICAgICAgICAgICB4ID0gQXJyYXkoSi1qKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPD1KO2krKykgeyB4W2ktai0xXSA9IEhbaV1bal07IH1cbiAgICAgICAgICAgIHYgPSBudW1lcmljLmhvdXNlKHgpO1xuICAgICAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soSCwgW2orMSxqXSxbSixtLTFdKTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcih2LG51bWVyaWMuZG90KHYsQikpO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8PUo7aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9ajtrPG07aysrKSBIaVtrXSAtPSAyKkNpW2stal07IH1cbiAgICAgICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEgsIFswLGorMV0sW20tMSxKXSk7XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IobnVtZXJpYy5kb3QoQix2KSx2KTtcbiAgICAgICAgICAgIGZvcihpPTA7aTxtO2krKykgeyBIaSA9IEhbaV07IENpID0gQ1tpXTsgZm9yKGs9aisxO2s8PUo7aysrKSBIaVtrXSAtPSAyKkNpW2stai0xXTsgfVxuICAgICAgICAgICAgQiA9IEFycmF5KEotaik7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTw9SjtpKyspIEJbaS1qLTFdID0gUVtpXTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcih2LG51bWVyaWMuZG90KHYsQikpO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8PUo7aSsrKSB7IFFpID0gUVtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9MDtrPG07aysrKSBRaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiBlaWdlbnZhbHVlIGl0ZXJhdGlvbiBkb2VzIG5vdCBjb252ZXJnZSAtLSBpbmNyZWFzZSBtYXhpdGVyPycpO1xufVxuXG5udW1lcmljLmVpZyA9IGZ1bmN0aW9uIGVpZyhBLG1heGl0ZXIpIHtcbiAgICB2YXIgUUggPSBudW1lcmljLnRvVXBwZXJIZXNzZW5iZXJnKEEpO1xuICAgIHZhciBRQiA9IG51bWVyaWMuUVJGcmFuY2lzKFFILkgsbWF4aXRlcik7XG4gICAgdmFyIFQgPSBudW1lcmljLlQ7XG4gICAgdmFyIG4gPSBBLmxlbmd0aCxpLGssZmxhZyA9IGZhbHNlLEIgPSBRQi5CLEggPSBudW1lcmljLmRvdChRQi5RLG51bWVyaWMuZG90KFFILkgsbnVtZXJpYy50cmFuc3Bvc2UoUUIuUSkpKTtcbiAgICB2YXIgUSA9IG5ldyBUKG51bWVyaWMuZG90KFFCLlEsUUguUSkpLFEwO1xuICAgIHZhciBtID0gQi5sZW5ndGgsajtcbiAgICB2YXIgYSxiLGMsZCxwMSxwMixkaXNjLHgseSxwLHEsbjEsbjI7XG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgZm9yKGs9MDtrPG07aysrKSB7XG4gICAgICAgIGkgPSBCW2tdWzBdO1xuICAgICAgICBpZihpID09PSBCW2tdWzFdKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqID0gaSsxO1xuICAgICAgICAgICAgYSA9IEhbaV1baV07XG4gICAgICAgICAgICBiID0gSFtpXVtqXTtcbiAgICAgICAgICAgIGMgPSBIW2pdW2ldO1xuICAgICAgICAgICAgZCA9IEhbal1bal07XG4gICAgICAgICAgICBpZihiID09PSAwICYmIGMgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgcDEgPSAtYS1kO1xuICAgICAgICAgICAgcDIgPSBhKmQtYipjO1xuICAgICAgICAgICAgZGlzYyA9IHAxKnAxLTQqcDI7XG4gICAgICAgICAgICBpZihkaXNjPj0wKSB7XG4gICAgICAgICAgICAgICAgaWYocDE8MCkgeCA9IC0wLjUqKHAxLXNxcnQoZGlzYykpO1xuICAgICAgICAgICAgICAgIGVsc2UgICAgIHggPSAtMC41KihwMStzcXJ0KGRpc2MpKTtcbiAgICAgICAgICAgICAgICBuMSA9IChhLXgpKihhLXgpK2IqYjtcbiAgICAgICAgICAgICAgICBuMiA9IGMqYysoZC14KSooZC14KTtcbiAgICAgICAgICAgICAgICBpZihuMT5uMikge1xuICAgICAgICAgICAgICAgICAgICBuMSA9IHNxcnQobjEpO1xuICAgICAgICAgICAgICAgICAgICBwID0gKGEteCkvbjE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBiL24xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4yID0gc3FydChuMik7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBjL24yO1xuICAgICAgICAgICAgICAgICAgICBxID0gKGQteCkvbjI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFEwID0gbmV3IFQoW1txLC1wXSxbcCxxXV0pO1xuICAgICAgICAgICAgICAgIFEuc2V0Um93cyhpLGosUTAuZG90KFEuZ2V0Um93cyhpLGopKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSAtMC41KnAxO1xuICAgICAgICAgICAgICAgIHkgPSAwLjUqc3FydCgtZGlzYyk7XG4gICAgICAgICAgICAgICAgbjEgPSAoYS14KSooYS14KStiKmI7XG4gICAgICAgICAgICAgICAgbjIgPSBjKmMrKGQteCkqKGQteCk7XG4gICAgICAgICAgICAgICAgaWYobjE+bjIpIHtcbiAgICAgICAgICAgICAgICAgICAgbjEgPSBzcXJ0KG4xK3kqeSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSAoYS14KS9uMTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IGIvbjE7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB5IC89IG4xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4yID0gc3FydChuMit5KnkpO1xuICAgICAgICAgICAgICAgICAgICBwID0gYy9uMjtcbiAgICAgICAgICAgICAgICAgICAgcSA9IChkLXgpL24yO1xuICAgICAgICAgICAgICAgICAgICB4ID0geS9uMjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFEwID0gbmV3IFQoW1txLC1wXSxbcCxxXV0sW1t4LHldLFt5LC14XV0pO1xuICAgICAgICAgICAgICAgIFEuc2V0Um93cyhpLGosUTAuZG90KFEuZ2V0Um93cyhpLGopKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIFIgPSBRLmRvdChBKS5kb3QoUS50cmFuc2p1Z2F0ZSgpKSwgbiA9IEEubGVuZ3RoLCBFID0gbnVtZXJpYy5ULmlkZW50aXR5KG4pO1xuICAgIGZvcihqPTA7ajxuO2orKykge1xuICAgICAgICBpZihqPjApIHtcbiAgICAgICAgICAgIGZvcihrPWotMTtrPj0wO2stLSkge1xuICAgICAgICAgICAgICAgIHZhciBSayA9IFIuZ2V0KFtrLGtdKSwgUmogPSBSLmdldChbaixqXSk7XG4gICAgICAgICAgICAgICAgaWYobnVtZXJpYy5uZXEoUmsueCxSai54KSB8fCBudW1lcmljLm5lcShSay55LFJqLnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBSLmdldFJvdyhrKS5nZXRCbG9jayhba10sW2otMV0pO1xuICAgICAgICAgICAgICAgICAgICB5ID0gRS5nZXRSb3coaikuZ2V0QmxvY2soW2tdLFtqLTFdKTtcbiAgICAgICAgICAgICAgICAgICAgRS5zZXQoW2osa10sKFIuZ2V0KFtrLGpdKS5uZWcoKS5zdWIoeC5kb3QoeSkpKS5kaXYoUmsuc3ViKFJqKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEUuc2V0Um93KGosRS5nZXRSb3coaykpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGo9MDtqPG47aisrKSB7XG4gICAgICAgIHggPSBFLmdldFJvdyhqKTtcbiAgICAgICAgRS5zZXRSb3coaix4LmRpdih4Lm5vcm0yKCkpKTtcbiAgICB9XG4gICAgRSA9IEUudHJhbnNwb3NlKCk7XG4gICAgRSA9IFEudHJhbnNqdWdhdGUoKS5kb3QoRSk7XG4gICAgcmV0dXJuIHsgbGFtYmRhOlIuZ2V0RGlhZygpLCBFOkUgfTtcbn07XG5cbi8vIDUuIENvbXByZXNzZWQgQ29sdW1uIFN0b3JhZ2UgbWF0cmljZXNcbm51bWVyaWMuY2NzU3BhcnNlID0gZnVuY3Rpb24gY2NzU3BhcnNlKEEpIHtcbiAgICB2YXIgbSA9IEEubGVuZ3RoLG4sZm9vLCBpLGosIGNvdW50cyA9IFtdO1xuICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGZvbyA9IEFbaV07XG4gICAgICAgIGZvcihqIGluIGZvbykge1xuICAgICAgICAgICAgaiA9IHBhcnNlSW50KGopO1xuICAgICAgICAgICAgd2hpbGUoaj49Y291bnRzLmxlbmd0aCkgY291bnRzW2NvdW50cy5sZW5ndGhdID0gMDtcbiAgICAgICAgICAgIGlmKGZvb1tqXSE9PTApIGNvdW50c1tqXSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBuID0gY291bnRzLmxlbmd0aDtcbiAgICB2YXIgQWkgPSBBcnJheShuKzEpO1xuICAgIEFpWzBdID0gMDtcbiAgICBmb3IoaT0wO2k8bjsrK2kpIEFpW2krMV0gPSBBaVtpXSArIGNvdW50c1tpXTtcbiAgICB2YXIgQWogPSBBcnJheShBaVtuXSksIEF2ID0gQXJyYXkoQWlbbl0pO1xuICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGZvbyA9IEFbaV07XG4gICAgICAgIGZvcihqIGluIGZvbykge1xuICAgICAgICAgICAgaWYoZm9vW2pdIT09MCkge1xuICAgICAgICAgICAgICAgIGNvdW50c1tqXS0tO1xuICAgICAgICAgICAgICAgIEFqW0FpW2pdK2NvdW50c1tqXV0gPSBpO1xuICAgICAgICAgICAgICAgIEF2W0FpW2pdK2NvdW50c1tqXV0gPSBmb29bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtBaSxBaixBdl07XG59XG5udW1lcmljLmNjc0Z1bGwgPSBmdW5jdGlvbiBjY3NGdWxsKEEpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSwgcyA9IG51bWVyaWMuY2NzRGltKEEpLCBtID0gc1swXSwgbiA9IHNbMV0sIGksaixqMCxqMSxrO1xuICAgIHZhciBCID0gbnVtZXJpYy5yZXAoW20sbl0sMCk7XG4gICAgZm9yKGk9MDtpPG47aSsrKSB7XG4gICAgICAgIGowID0gQWlbaV07XG4gICAgICAgIGoxID0gQWlbaSsxXTtcbiAgICAgICAgZm9yKGo9ajA7ajxqMTsrK2opIHsgQltBaltqXV1baV0gPSBBdltqXTsgfVxuICAgIH1cbiAgICByZXR1cm4gQjtcbn1cbm51bWVyaWMuY2NzVFNvbHZlID0gZnVuY3Rpb24gY2NzVFNvbHZlKEEsYix4LGJqLHhqKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl0sbSA9IEFpLmxlbmd0aC0xLCBtYXggPSBNYXRoLm1heCxuPTA7XG4gICAgaWYodHlwZW9mIGJqID09PSBcInVuZGVmaW5lZFwiKSB4ID0gbnVtZXJpYy5yZXAoW21dLDApO1xuICAgIGlmKHR5cGVvZiBiaiA9PT0gXCJ1bmRlZmluZWRcIikgYmogPSBudW1lcmljLmxpbnNwYWNlKDAseC5sZW5ndGgtMSk7XG4gICAgaWYodHlwZW9mIHhqID09PSBcInVuZGVmaW5lZFwiKSB4aiA9IFtdO1xuICAgIGZ1bmN0aW9uIGRmcyhqKSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBpZih4W2pdICE9PSAwKSByZXR1cm47XG4gICAgICAgIHhbal0gPSAxO1xuICAgICAgICBmb3Ioaz1BaVtqXTtrPEFpW2orMV07KytrKSBkZnMoQWpba10pO1xuICAgICAgICB4altuXSA9IGo7XG4gICAgICAgICsrbjtcbiAgICB9XG4gICAgdmFyIGksaixqMCxqMSxrLGwsbDAsbDEsYTtcbiAgICBmb3IoaT1iai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IGRmcyhialtpXSk7IH1cbiAgICB4ai5sZW5ndGggPSBuO1xuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgeFt4altpXV0gPSAwOyB9XG4gICAgZm9yKGk9YmoubGVuZ3RoLTE7aSE9PS0xOy0taSkgeyBqID0gYmpbaV07IHhbal0gPSBiW2pdOyB9XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBqID0geGpbaV07XG4gICAgICAgIGowID0gQWlbal07XG4gICAgICAgIGoxID0gbWF4KEFpW2orMV0sajApO1xuICAgICAgICBmb3Ioaz1qMDtrIT09ajE7KytrKSB7IGlmKEFqW2tdID09PSBqKSB7IHhbal0gLz0gQXZba107IGJyZWFrOyB9IH1cbiAgICAgICAgYSA9IHhbal07XG4gICAgICAgIGZvcihrPWowO2shPT1qMTsrK2spIHtcbiAgICAgICAgICAgIGwgPSBBaltrXTtcbiAgICAgICAgICAgIGlmKGwgIT09IGopIHhbbF0gLT0gYSpBdltrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbm51bWVyaWMuY2NzREZTID0gZnVuY3Rpb24gY2NzREZTKG4pIHtcbiAgICB0aGlzLmsgPSBBcnJheShuKTtcbiAgICB0aGlzLmsxID0gQXJyYXkobik7XG4gICAgdGhpcy5qID0gQXJyYXkobik7XG59XG5udW1lcmljLmNjc0RGUy5wcm90b3R5cGUuZGZzID0gZnVuY3Rpb24gZGZzKEosQWksQWoseCx4aixQaW52KSB7XG4gICAgdmFyIG0gPSAwLGZvbyxuPXhqLmxlbmd0aDtcbiAgICB2YXIgayA9IHRoaXMuaywgazEgPSB0aGlzLmsxLCBqID0gdGhpcy5qLGttLGsxMTtcbiAgICBpZih4W0pdIT09MCkgcmV0dXJuO1xuICAgIHhbSl0gPSAxO1xuICAgIGpbMF0gPSBKO1xuICAgIGtbMF0gPSBrbSA9IEFpW0pdO1xuICAgIGsxWzBdID0gazExID0gQWlbSisxXTtcbiAgICB3aGlsZSgxKSB7XG4gICAgICAgIGlmKGttID49IGsxMSkge1xuICAgICAgICAgICAgeGpbbl0gPSBqW21dO1xuICAgICAgICAgICAgaWYobT09PTApIHJldHVybjtcbiAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgIC0tbTtcbiAgICAgICAgICAgIGttID0ga1ttXTtcbiAgICAgICAgICAgIGsxMSA9IGsxW21dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9vID0gUGludltBaltrbV1dO1xuICAgICAgICAgICAgaWYoeFtmb29dID09PSAwKSB7XG4gICAgICAgICAgICAgICAgeFtmb29dID0gMTtcbiAgICAgICAgICAgICAgICBrW21dID0ga207XG4gICAgICAgICAgICAgICAgKyttO1xuICAgICAgICAgICAgICAgIGpbbV0gPSBmb287XG4gICAgICAgICAgICAgICAga20gPSBBaVtmb29dO1xuICAgICAgICAgICAgICAgIGsxW21dID0gazExID0gQWlbZm9vKzFdO1xuICAgICAgICAgICAgfSBlbHNlICsra207XG4gICAgICAgIH1cbiAgICB9XG59XG5udW1lcmljLmNjc0xQU29sdmUgPSBmdW5jdGlvbiBjY3NMUFNvbHZlKEEsQix4LHhqLEksUGludixkZnMpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxtID0gQWkubGVuZ3RoLTEsIG49MDtcbiAgICB2YXIgQmkgPSBCWzBdLCBCaiA9IEJbMV0sIEJ2ID0gQlsyXTtcbiAgICBcbiAgICB2YXIgaSxpMCxpMSxqLEosajAsajEsayxsLGwwLGwxLGE7XG4gICAgaTAgPSBCaVtJXTtcbiAgICBpMSA9IEJpW0krMV07XG4gICAgeGoubGVuZ3RoID0gMDtcbiAgICBmb3IoaT1pMDtpPGkxOysraSkgeyBkZnMuZGZzKFBpbnZbQmpbaV1dLEFpLEFqLHgseGosUGludik7IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IHhbeGpbaV1dID0gMDsgfVxuICAgIGZvcihpPWkwO2khPT1pMTsrK2kpIHsgaiA9IFBpbnZbQmpbaV1dOyB4W2pdID0gQnZbaV07IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGogPSB4altpXTtcbiAgICAgICAgajAgPSBBaVtqXTtcbiAgICAgICAgajEgPSBBaVtqKzFdO1xuICAgICAgICBmb3Ioaz1qMDtrPGoxOysraykgeyBpZihQaW52W0FqW2tdXSA9PT0gaikgeyB4W2pdIC89IEF2W2tdOyBicmVhazsgfSB9XG4gICAgICAgIGEgPSB4W2pdO1xuICAgICAgICBmb3Ioaz1qMDtrPGoxOysraykge1xuICAgICAgICAgICAgbCA9IFBpbnZbQWpba11dO1xuICAgICAgICAgICAgaWYobCAhPT0gaikgeFtsXSAtPSBhKkF2W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxubnVtZXJpYy5jY3NMVVAxID0gZnVuY3Rpb24gY2NzTFVQMShBLHRocmVzaG9sZCkge1xuICAgIHZhciBtID0gQVswXS5sZW5ndGgtMTtcbiAgICB2YXIgTCA9IFtudW1lcmljLnJlcChbbSsxXSwwKSxbXSxbXV0sIFUgPSBbbnVtZXJpYy5yZXAoW20rMV0sIDApLFtdLFtdXTtcbiAgICB2YXIgTGkgPSBMWzBdLCBMaiA9IExbMV0sIEx2ID0gTFsyXSwgVWkgPSBVWzBdLCBVaiA9IFVbMV0sIFV2ID0gVVsyXTtcbiAgICB2YXIgeCA9IG51bWVyaWMucmVwKFttXSwwKSwgeGogPSBudW1lcmljLnJlcChbbV0sMCk7XG4gICAgdmFyIGksaixrLGowLGoxLGEsZSxjLGQsSztcbiAgICB2YXIgc29sID0gbnVtZXJpYy5jY3NMUFNvbHZlLCBtYXggPSBNYXRoLm1heCwgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIFAgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKSxQaW52ID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSk7XG4gICAgdmFyIGRmcyA9IG5ldyBudW1lcmljLmNjc0RGUyhtKTtcbiAgICBpZih0eXBlb2YgdGhyZXNob2xkID09PSBcInVuZGVmaW5lZFwiKSB7IHRocmVzaG9sZCA9IDE7IH1cbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgc29sKEwsQSx4LHhqLGksUGludixkZnMpO1xuICAgICAgICBhID0gLTE7XG4gICAgICAgIGUgPSAtMTtcbiAgICAgICAgZm9yKGo9eGoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgayA9IHhqW2pdO1xuICAgICAgICAgICAgaWYoayA8PSBpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGMgPSBhYnMoeFtrXSk7XG4gICAgICAgICAgICBpZihjID4gYSkgeyBlID0gazsgYSA9IGM7IH1cbiAgICAgICAgfVxuICAgICAgICBpZihhYnMoeFtpXSk8dGhyZXNob2xkKmEpIHtcbiAgICAgICAgICAgIGogPSBQW2ldO1xuICAgICAgICAgICAgYSA9IFBbZV07XG4gICAgICAgICAgICBQW2ldID0gYTsgUGludlthXSA9IGk7XG4gICAgICAgICAgICBQW2VdID0gajsgUGludltqXSA9IGU7XG4gICAgICAgICAgICBhID0geFtpXTsgeFtpXSA9IHhbZV07IHhbZV0gPSBhO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBMaVtpXTtcbiAgICAgICAgZSA9IFVpW2ldO1xuICAgICAgICBkID0geFtpXTtcbiAgICAgICAgTGpbYV0gPSBQW2ldO1xuICAgICAgICBMdlthXSA9IDE7XG4gICAgICAgICsrYTtcbiAgICAgICAgZm9yKGo9eGoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgayA9IHhqW2pdO1xuICAgICAgICAgICAgYyA9IHhba107XG4gICAgICAgICAgICB4altqXSA9IDA7XG4gICAgICAgICAgICB4W2tdID0gMDtcbiAgICAgICAgICAgIGlmKGs8PWkpIHsgVWpbZV0gPSBrOyBVdltlXSA9IGM7ICAgKytlOyB9XG4gICAgICAgICAgICBlbHNlICAgICB7IExqW2FdID0gUFtrXTsgTHZbYV0gPSBjL2Q7ICsrYTsgfVxuICAgICAgICB9XG4gICAgICAgIExpW2krMV0gPSBhO1xuICAgICAgICBVaVtpKzFdID0gZTtcbiAgICB9XG4gICAgZm9yKGo9TGoubGVuZ3RoLTE7aiE9PS0xOy0taikgeyBMaltqXSA9IFBpbnZbTGpbal1dOyB9XG4gICAgcmV0dXJuIHtMOkwsIFU6VSwgUDpQLCBQaW52OlBpbnZ9O1xufVxubnVtZXJpYy5jY3NERlMwID0gZnVuY3Rpb24gY2NzREZTMChuKSB7XG4gICAgdGhpcy5rID0gQXJyYXkobik7XG4gICAgdGhpcy5rMSA9IEFycmF5KG4pO1xuICAgIHRoaXMuaiA9IEFycmF5KG4pO1xufVxubnVtZXJpYy5jY3NERlMwLnByb3RvdHlwZS5kZnMgPSBmdW5jdGlvbiBkZnMoSixBaSxBaix4LHhqLFBpbnYsUCkge1xuICAgIHZhciBtID0gMCxmb28sbj14ai5sZW5ndGg7XG4gICAgdmFyIGsgPSB0aGlzLmssIGsxID0gdGhpcy5rMSwgaiA9IHRoaXMuaixrbSxrMTE7XG4gICAgaWYoeFtKXSE9PTApIHJldHVybjtcbiAgICB4W0pdID0gMTtcbiAgICBqWzBdID0gSjtcbiAgICBrWzBdID0ga20gPSBBaVtQaW52W0pdXTtcbiAgICBrMVswXSA9IGsxMSA9IEFpW1BpbnZbSl0rMV07XG4gICAgd2hpbGUoMSkge1xuICAgICAgICBpZihpc05hTihrbSkpIHRocm93IG5ldyBFcnJvcihcIk93IVwiKTtcbiAgICAgICAgaWYoa20gPj0gazExKSB7XG4gICAgICAgICAgICB4altuXSA9IFBpbnZbalttXV07XG4gICAgICAgICAgICBpZihtPT09MCkgcmV0dXJuO1xuICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgLS1tO1xuICAgICAgICAgICAga20gPSBrW21dO1xuICAgICAgICAgICAgazExID0gazFbbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb28gPSBBaltrbV07XG4gICAgICAgICAgICBpZih4W2Zvb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICB4W2Zvb10gPSAxO1xuICAgICAgICAgICAgICAgIGtbbV0gPSBrbTtcbiAgICAgICAgICAgICAgICArK207XG4gICAgICAgICAgICAgICAgalttXSA9IGZvbztcbiAgICAgICAgICAgICAgICBmb28gPSBQaW52W2Zvb107XG4gICAgICAgICAgICAgICAga20gPSBBaVtmb29dO1xuICAgICAgICAgICAgICAgIGsxW21dID0gazExID0gQWlbZm9vKzFdO1xuICAgICAgICAgICAgfSBlbHNlICsra207XG4gICAgICAgIH1cbiAgICB9XG59XG5udW1lcmljLmNjc0xQU29sdmUwID0gZnVuY3Rpb24gY2NzTFBTb2x2ZTAoQSxCLHkseGosSSxQaW52LFAsZGZzKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl0sbSA9IEFpLmxlbmd0aC0xLCBuPTA7XG4gICAgdmFyIEJpID0gQlswXSwgQmogPSBCWzFdLCBCdiA9IEJbMl07XG4gICAgXG4gICAgdmFyIGksaTAsaTEsaixKLGowLGoxLGssbCxsMCxsMSxhO1xuICAgIGkwID0gQmlbSV07XG4gICAgaTEgPSBCaVtJKzFdO1xuICAgIHhqLmxlbmd0aCA9IDA7XG4gICAgZm9yKGk9aTA7aTxpMTsrK2kpIHsgZGZzLmRmcyhCaltpXSxBaSxBaix5LHhqLFBpbnYsUCk7IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IGogPSB4altpXTsgeVtQW2pdXSA9IDA7IH1cbiAgICBmb3IoaT1pMDtpIT09aTE7KytpKSB7IGogPSBCaltpXTsgeVtqXSA9IEJ2W2ldOyB9XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBqID0geGpbaV07XG4gICAgICAgIGwgPSBQW2pdO1xuICAgICAgICBqMCA9IEFpW2pdO1xuICAgICAgICBqMSA9IEFpW2orMV07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB7IGlmKEFqW2tdID09PSBsKSB7IHlbbF0gLz0gQXZba107IGJyZWFrOyB9IH1cbiAgICAgICAgYSA9IHlbbF07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB5W0FqW2tdXSAtPSBhKkF2W2tdO1xuICAgICAgICB5W2xdID0gYTtcbiAgICB9XG59XG5udW1lcmljLmNjc0xVUDAgPSBmdW5jdGlvbiBjY3NMVVAwKEEsdGhyZXNob2xkKSB7XG4gICAgdmFyIG0gPSBBWzBdLmxlbmd0aC0xO1xuICAgIHZhciBMID0gW251bWVyaWMucmVwKFttKzFdLDApLFtdLFtdXSwgVSA9IFtudW1lcmljLnJlcChbbSsxXSwgMCksW10sW11dO1xuICAgIHZhciBMaSA9IExbMF0sIExqID0gTFsxXSwgTHYgPSBMWzJdLCBVaSA9IFVbMF0sIFVqID0gVVsxXSwgVXYgPSBVWzJdO1xuICAgIHZhciB5ID0gbnVtZXJpYy5yZXAoW21dLDApLCB4aiA9IG51bWVyaWMucmVwKFttXSwwKTtcbiAgICB2YXIgaSxqLGssajAsajEsYSxlLGMsZCxLO1xuICAgIHZhciBzb2wgPSBudW1lcmljLmNjc0xQU29sdmUwLCBtYXggPSBNYXRoLm1heCwgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIFAgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKSxQaW52ID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSk7XG4gICAgdmFyIGRmcyA9IG5ldyBudW1lcmljLmNjc0RGUzAobSk7XG4gICAgaWYodHlwZW9mIHRocmVzaG9sZCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0aHJlc2hvbGQgPSAxOyB9XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIHNvbChMLEEseSx4aixpLFBpbnYsUCxkZnMpO1xuICAgICAgICBhID0gLTE7XG4gICAgICAgIGUgPSAtMTtcbiAgICAgICAgZm9yKGo9eGoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgayA9IHhqW2pdO1xuICAgICAgICAgICAgaWYoayA8PSBpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGMgPSBhYnMoeVtQW2tdXSk7XG4gICAgICAgICAgICBpZihjID4gYSkgeyBlID0gazsgYSA9IGM7IH1cbiAgICAgICAgfVxuICAgICAgICBpZihhYnMoeVtQW2ldXSk8dGhyZXNob2xkKmEpIHtcbiAgICAgICAgICAgIGogPSBQW2ldO1xuICAgICAgICAgICAgYSA9IFBbZV07XG4gICAgICAgICAgICBQW2ldID0gYTsgUGludlthXSA9IGk7XG4gICAgICAgICAgICBQW2VdID0gajsgUGludltqXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IExpW2ldO1xuICAgICAgICBlID0gVWlbaV07XG4gICAgICAgIGQgPSB5W1BbaV1dO1xuICAgICAgICBMalthXSA9IFBbaV07XG4gICAgICAgIEx2W2FdID0gMTtcbiAgICAgICAgKythO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBjID0geVtQW2tdXTtcbiAgICAgICAgICAgIHhqW2pdID0gMDtcbiAgICAgICAgICAgIHlbUFtrXV0gPSAwO1xuICAgICAgICAgICAgaWYoazw9aSkgeyBValtlXSA9IGs7IFV2W2VdID0gYzsgICArK2U7IH1cbiAgICAgICAgICAgIGVsc2UgICAgIHsgTGpbYV0gPSBQW2tdOyBMdlthXSA9IGMvZDsgKythOyB9XG4gICAgICAgIH1cbiAgICAgICAgTGlbaSsxXSA9IGE7XG4gICAgICAgIFVpW2krMV0gPSBlO1xuICAgIH1cbiAgICBmb3Ioaj1Mai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7IExqW2pdID0gUGludltMaltqXV07IH1cbiAgICByZXR1cm4ge0w6TCwgVTpVLCBQOlAsIFBpbnY6UGludn07XG59XG5udW1lcmljLmNjc0xVUCA9IG51bWVyaWMuY2NzTFVQMDtcblxubnVtZXJpYy5jY3NEaW0gPSBmdW5jdGlvbiBjY3NEaW0oQSkgeyByZXR1cm4gW251bWVyaWMuc3VwKEFbMV0pKzEsQVswXS5sZW5ndGgtMV07IH1cbm51bWVyaWMuY2NzR2V0QmxvY2sgPSBmdW5jdGlvbiBjY3NHZXRCbG9jayhBLGksaikge1xuICAgIHZhciBzID0gbnVtZXJpYy5jY3NEaW0oQSksbT1zWzBdLG49c1sxXTtcbiAgICBpZih0eXBlb2YgaSA9PT0gXCJ1bmRlZmluZWRcIikgeyBpID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSk7IH1cbiAgICBlbHNlIGlmKHR5cGVvZiBpID09PSBcIm51bWJlclwiKSB7IGkgPSBbaV07IH1cbiAgICBpZih0eXBlb2YgaiA9PT0gXCJ1bmRlZmluZWRcIikgeyBqID0gbnVtZXJpYy5saW5zcGFjZSgwLG4tMSk7IH1cbiAgICBlbHNlIGlmKHR5cGVvZiBqID09PSBcIm51bWJlclwiKSB7IGogPSBbal07IH1cbiAgICB2YXIgcCxwMCxwMSxQID0gaS5sZW5ndGgscSxRID0gai5sZW5ndGgscixqcSxpcDtcbiAgICB2YXIgQmkgPSBudW1lcmljLnJlcChbbl0sMCksIEJqPVtdLCBCdj1bXSwgQiA9IFtCaSxCaixCdl07XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl07XG4gICAgdmFyIHggPSBudW1lcmljLnJlcChbbV0sMCksY291bnQ9MCxmbGFncyA9IG51bWVyaWMucmVwKFttXSwwKTtcbiAgICBmb3IocT0wO3E8UTsrK3EpIHtcbiAgICAgICAganEgPSBqW3FdO1xuICAgICAgICB2YXIgcTAgPSBBaVtqcV07XG4gICAgICAgIHZhciBxMSA9IEFpW2pxKzFdO1xuICAgICAgICBmb3IocD1xMDtwPHExOysrcCkge1xuICAgICAgICAgICAgciA9IEFqW3BdO1xuICAgICAgICAgICAgZmxhZ3Nbcl0gPSAxO1xuICAgICAgICAgICAgeFtyXSA9IEF2W3BdO1xuICAgICAgICB9XG4gICAgICAgIGZvcihwPTA7cDxQOysrcCkge1xuICAgICAgICAgICAgaXAgPSBpW3BdO1xuICAgICAgICAgICAgaWYoZmxhZ3NbaXBdKSB7XG4gICAgICAgICAgICAgICAgQmpbY291bnRdID0gcDtcbiAgICAgICAgICAgICAgICBCdltjb3VudF0gPSB4W2lbcF1dO1xuICAgICAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHA9cTA7cDxxMTsrK3ApIHtcbiAgICAgICAgICAgIHIgPSBBaltwXTtcbiAgICAgICAgICAgIGZsYWdzW3JdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBCaVtxKzFdID0gY291bnQ7XG4gICAgfVxuICAgIHJldHVybiBCO1xufVxuXG5udW1lcmljLmNjc0RvdCA9IGZ1bmN0aW9uIGNjc0RvdChBLEIpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgQmkgPSBCWzBdLCBCaiA9IEJbMV0sIEJ2ID0gQlsyXTtcbiAgICB2YXIgc0EgPSBudW1lcmljLmNjc0RpbShBKSwgc0IgPSBudW1lcmljLmNjc0RpbShCKTtcbiAgICB2YXIgbSA9IHNBWzBdLCBuID0gc0FbMV0sIG8gPSBzQlsxXTtcbiAgICB2YXIgeCA9IG51bWVyaWMucmVwKFttXSwwKSwgZmxhZ3MgPSBudW1lcmljLnJlcChbbV0sMCksIHhqID0gQXJyYXkobSk7XG4gICAgdmFyIENpID0gbnVtZXJpYy5yZXAoW29dLDApLCBDaiA9IFtdLCBDdiA9IFtdLCBDID0gW0NpLENqLEN2XTtcbiAgICB2YXIgaSxqLGssajAsajEsaTAsaTEsbCxwLGEsYjtcbiAgICBmb3Ioaz0wO2shPT1vOysraykge1xuICAgICAgICBqMCA9IEJpW2tdO1xuICAgICAgICBqMSA9IEJpW2srMV07XG4gICAgICAgIHAgPSAwO1xuICAgICAgICBmb3Ioaj1qMDtqPGoxOysraikge1xuICAgICAgICAgICAgYSA9IEJqW2pdO1xuICAgICAgICAgICAgYiA9IEJ2W2pdO1xuICAgICAgICAgICAgaTAgPSBBaVthXTtcbiAgICAgICAgICAgIGkxID0gQWlbYSsxXTtcbiAgICAgICAgICAgIGZvcihpPWkwO2k8aTE7KytpKSB7XG4gICAgICAgICAgICAgICAgbCA9IEFqW2ldO1xuICAgICAgICAgICAgICAgIGlmKGZsYWdzW2xdPT09MCkge1xuICAgICAgICAgICAgICAgICAgICB4altwXSA9IGw7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2xdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHArMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeFtsXSA9IHhbbF0gKyBBdltpXSpiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGowID0gQ2lba107XG4gICAgICAgIGoxID0gajArcDtcbiAgICAgICAgQ2lbaysxXSA9IGoxO1xuICAgICAgICBmb3Ioaj1wLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgYiA9IGowK2o7XG4gICAgICAgICAgICBpID0geGpbal07XG4gICAgICAgICAgICBDaltiXSA9IGk7XG4gICAgICAgICAgICBDdltiXSA9IHhbaV07XG4gICAgICAgICAgICBmbGFnc1tpXSA9IDA7XG4gICAgICAgICAgICB4W2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBDaVtrKzFdID0gQ2lba10rcDtcbiAgICB9XG4gICAgcmV0dXJuIEM7XG59XG5cbm51bWVyaWMuY2NzTFVQU29sdmUgPSBmdW5jdGlvbiBjY3NMVVBTb2x2ZShMVVAsQikge1xuICAgIHZhciBMID0gTFVQLkwsIFUgPSBMVVAuVSwgUCA9IExVUC5QO1xuICAgIHZhciBCaSA9IEJbMF07XG4gICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICBpZih0eXBlb2YgQmkgIT09IFwib2JqZWN0XCIpIHsgQiA9IFtbMCxCLmxlbmd0aF0sbnVtZXJpYy5saW5zcGFjZSgwLEIubGVuZ3RoLTEpLEJdOyBCaSA9IEJbMF07IGZsYWcgPSB0cnVlOyB9XG4gICAgdmFyIEJqID0gQlsxXSwgQnYgPSBCWzJdO1xuICAgIHZhciBuID0gTFswXS5sZW5ndGgtMSwgbSA9IEJpLmxlbmd0aC0xO1xuICAgIHZhciB4ID0gbnVtZXJpYy5yZXAoW25dLDApLCB4aiA9IEFycmF5KG4pO1xuICAgIHZhciBiID0gbnVtZXJpYy5yZXAoW25dLDApLCBiaiA9IEFycmF5KG4pO1xuICAgIHZhciBYaSA9IG51bWVyaWMucmVwKFttKzFdLDApLCBYaiA9IFtdLCBYdiA9IFtdO1xuICAgIHZhciBzb2wgPSBudW1lcmljLmNjc1RTb2x2ZTtcbiAgICB2YXIgaSxqLGowLGoxLGssSixOPTA7XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgICBqMCA9IEJpW2ldO1xuICAgICAgICBqMSA9IEJpW2krMV07XG4gICAgICAgIGZvcihqPWowO2o8ajE7KytqKSB7IFxuICAgICAgICAgICAgSiA9IExVUC5QaW52W0JqW2pdXTtcbiAgICAgICAgICAgIGJqW2tdID0gSjtcbiAgICAgICAgICAgIGJbSl0gPSBCdltqXTtcbiAgICAgICAgICAgICsraztcbiAgICAgICAgfVxuICAgICAgICBiai5sZW5ndGggPSBrO1xuICAgICAgICBzb2woTCxiLHgsYmoseGopO1xuICAgICAgICBmb3Ioaj1iai5sZW5ndGgtMTtqIT09LTE7LS1qKSBiW2JqW2pdXSA9IDA7XG4gICAgICAgIHNvbChVLHgsYix4aixiaik7XG4gICAgICAgIGlmKGZsYWcpIHJldHVybiBiO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB4W3hqW2pdXSA9IDA7XG4gICAgICAgIGZvcihqPWJqLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIEogPSBialtqXTtcbiAgICAgICAgICAgIFhqW05dID0gSjtcbiAgICAgICAgICAgIFh2W05dID0gYltKXTtcbiAgICAgICAgICAgIGJbSl0gPSAwO1xuICAgICAgICAgICAgKytOO1xuICAgICAgICB9XG4gICAgICAgIFhpW2krMV0gPSBOO1xuICAgIH1cbiAgICByZXR1cm4gW1hpLFhqLFh2XTtcbn1cblxubnVtZXJpYy5jY3NiaW5vcCA9IGZ1bmN0aW9uIGNjc2Jpbm9wKGJvZHksc2V0dXApIHtcbiAgICBpZih0eXBlb2Ygc2V0dXAgPT09IFwidW5kZWZpbmVkXCIpIHNldHVwPScnO1xuICAgIHJldHVybiBGdW5jdGlvbignWCcsJ1knLFxuICAgICAgICAgICAgJ3ZhciBYaSA9IFhbMF0sIFhqID0gWFsxXSwgWHYgPSBYWzJdO1xcbicrXG4gICAgICAgICAgICAndmFyIFlpID0gWVswXSwgWWogPSBZWzFdLCBZdiA9IFlbMl07XFxuJytcbiAgICAgICAgICAgICd2YXIgbiA9IFhpLmxlbmd0aC0xLG0gPSBNYXRoLm1heChudW1lcmljLnN1cChYaiksbnVtZXJpYy5zdXAoWWopKSsxO1xcbicrXG4gICAgICAgICAgICAndmFyIFppID0gbnVtZXJpYy5yZXAoW24rMV0sMCksIFpqID0gW10sIFp2ID0gW107XFxuJytcbiAgICAgICAgICAgICd2YXIgeCA9IG51bWVyaWMucmVwKFttXSwwKSx5ID0gbnVtZXJpYy5yZXAoW21dLDApO1xcbicrXG4gICAgICAgICAgICAndmFyIHhrLHlrLHprO1xcbicrXG4gICAgICAgICAgICAndmFyIGksaixqMCxqMSxrLHA9MDtcXG4nK1xuICAgICAgICAgICAgc2V0dXArXG4gICAgICAgICAgICAnZm9yKGk9MDtpPG47KytpKSB7XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWGlbaV07IGoxID0gWGlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikge1xcbicrXG4gICAgICAgICAgICAnICAgIGsgPSBYaltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICB4W2tdID0gMTtcXG4nK1xuICAgICAgICAgICAgJyAgICBaaltwXSA9IGs7XFxuJytcbiAgICAgICAgICAgICcgICAgKytwO1xcbicrXG4gICAgICAgICAgICAnICB9XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWWlbaV07IGoxID0gWWlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikge1xcbicrXG4gICAgICAgICAgICAnICAgIGsgPSBZaltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICB5W2tdID0gWXZbal07XFxuJytcbiAgICAgICAgICAgICcgICAgaWYoeFtrXSA9PT0gMCkge1xcbicrXG4gICAgICAgICAgICAnICAgICAgWmpbcF0gPSBrO1xcbicrXG4gICAgICAgICAgICAnICAgICAgKytwO1xcbicrXG4gICAgICAgICAgICAnICAgIH1cXG4nK1xuICAgICAgICAgICAgJyAgfVxcbicrXG4gICAgICAgICAgICAnICBaaVtpKzFdID0gcDtcXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBYaVtpXTsgajEgPSBYaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB4W1hqW2pdXSA9IFh2W2pdO1xcbicrXG4gICAgICAgICAgICAnICBqMCA9IFppW2ldOyBqMSA9IFppW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHtcXG4nK1xuICAgICAgICAgICAgJyAgICBrID0gWmpbal07XFxuJytcbiAgICAgICAgICAgICcgICAgeGsgPSB4W2tdO1xcbicrXG4gICAgICAgICAgICAnICAgIHlrID0geVtrXTtcXG4nK1xuICAgICAgICAgICAgYm9keSsnXFxuJytcbiAgICAgICAgICAgICcgICAgWnZbal0gPSB6aztcXG4nK1xuICAgICAgICAgICAgJyAgfVxcbicrXG4gICAgICAgICAgICAnICBqMCA9IFhpW2ldOyBqMSA9IFhpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHhbWGpbal1dID0gMDtcXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBZaVtpXTsgajEgPSBZaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB5W1lqW2pdXSA9IDA7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gW1ppLFpqLFp2XTsnXG4gICAgICAgICAgICApO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBrLEEsQixDO1xuICAgIGZvcihrIGluIG51bWVyaWMub3BzMikge1xuICAgICAgICBpZihpc0Zpbml0ZShldmFsKCcxJytudW1lcmljLm9wczJba10rJzAnKSkpIEEgPSAnW1lbMF0sWVsxXSxudW1lcmljLicraysnKFgsWVsyXSldJztcbiAgICAgICAgZWxzZSBBID0gJ05hTic7XG4gICAgICAgIGlmKGlzRmluaXRlKGV2YWwoJzAnK251bWVyaWMub3BzMltrXSsnMScpKSkgQiA9ICdbWFswXSxYWzFdLG51bWVyaWMuJytrKycoWFsyXSxZKV0nO1xuICAgICAgICBlbHNlIEIgPSAnTmFOJztcbiAgICAgICAgaWYoaXNGaW5pdGUoZXZhbCgnMScrbnVtZXJpYy5vcHMyW2tdKycwJykpICYmIGlzRmluaXRlKGV2YWwoJzAnK251bWVyaWMub3BzMltrXSsnMScpKSkgQyA9ICdudW1lcmljLmNjcycraysnTU0oWCxZKSc7XG4gICAgICAgIGVsc2UgQyA9ICdOYU4nO1xuICAgICAgICBudW1lcmljWydjY3MnK2srJ01NJ10gPSBudW1lcmljLmNjc2Jpbm9wKCd6ayA9IHhrICcrbnVtZXJpYy5vcHMyW2tdKyd5azsnKTtcbiAgICAgICAgbnVtZXJpY1snY2NzJytrXSA9IEZ1bmN0aW9uKCdYJywnWScsXG4gICAgICAgICAgICAgICAgJ2lmKHR5cGVvZiBYID09PSBcIm51bWJlclwiKSByZXR1cm4gJytBKyc7XFxuJytcbiAgICAgICAgICAgICAgICAnaWYodHlwZW9mIFkgPT09IFwibnVtYmVyXCIpIHJldHVybiAnK0IrJztcXG4nK1xuICAgICAgICAgICAgICAgICdyZXR1cm4gJytDKyc7XFxuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgfVxufSgpKTtcblxubnVtZXJpYy5jY3NTY2F0dGVyID0gZnVuY3Rpb24gY2NzU2NhdHRlcihBKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl07XG4gICAgdmFyIG4gPSBudW1lcmljLnN1cChBaikrMSxtPUFpLmxlbmd0aDtcbiAgICB2YXIgUmkgPSBudW1lcmljLnJlcChbbl0sMCksUmo9QXJyYXkobSksIFJ2ID0gQXJyYXkobSk7XG4gICAgdmFyIGNvdW50cyA9IG51bWVyaWMucmVwKFtuXSwwKSxpO1xuICAgIGZvcihpPTA7aTxtOysraSkgY291bnRzW0FqW2ldXSsrO1xuICAgIGZvcihpPTA7aTxuOysraSkgUmlbaSsxXSA9IFJpW2ldICsgY291bnRzW2ldO1xuICAgIHZhciBwdHIgPSBSaS5zbGljZSgwKSxrLEFpaTtcbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgQWlpID0gQWpbaV07XG4gICAgICAgIGsgPSBwdHJbQWlpXTtcbiAgICAgICAgUmpba10gPSBBaVtpXTtcbiAgICAgICAgUnZba10gPSBBdltpXTtcbiAgICAgICAgcHRyW0FpaV09cHRyW0FpaV0rMTtcbiAgICB9XG4gICAgcmV0dXJuIFtSaSxSaixSdl07XG59XG5cbm51bWVyaWMuY2NzR2F0aGVyID0gZnVuY3Rpb24gY2NzR2F0aGVyKEEpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgbiA9IEFpLmxlbmd0aC0xLG0gPSBBai5sZW5ndGg7XG4gICAgdmFyIFJpID0gQXJyYXkobSksIFJqID0gQXJyYXkobSksIFJ2ID0gQXJyYXkobSk7XG4gICAgdmFyIGksaixqMCxqMSxwO1xuICAgIHA9MDtcbiAgICBmb3IoaT0wO2k8bjsrK2kpIHtcbiAgICAgICAgajAgPSBBaVtpXTtcbiAgICAgICAgajEgPSBBaVtpKzFdO1xuICAgICAgICBmb3Ioaj1qMDtqIT09ajE7KytqKSB7XG4gICAgICAgICAgICBSaltwXSA9IGk7XG4gICAgICAgICAgICBSaVtwXSA9IEFqW2pdO1xuICAgICAgICAgICAgUnZbcF0gPSBBdltqXTtcbiAgICAgICAgICAgICsrcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1JpLFJqLFJ2XTtcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBzcGFyc2UgbGluZWFyIGFsZ2VicmEgcm91dGluZXMgYXJlIGRlcHJlY2F0ZWQuXG5cbm51bWVyaWMuc2RpbSA9IGZ1bmN0aW9uIGRpbShBLHJldCxrKSB7XG4gICAgaWYodHlwZW9mIHJldCA9PT0gXCJ1bmRlZmluZWRcIikgeyByZXQgPSBbXTsgfVxuICAgIGlmKHR5cGVvZiBBICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmV0O1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSB7IGs9MDsgfVxuICAgIGlmKCEoayBpbiByZXQpKSB7IHJldFtrXSA9IDA7IH1cbiAgICBpZihBLmxlbmd0aCA+IHJldFtrXSkgcmV0W2tdID0gQS5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZihBLmhhc093blByb3BlcnR5KGkpKSBkaW0oQVtpXSxyZXQsaysxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbm51bWVyaWMuc2Nsb25lID0gZnVuY3Rpb24gY2xvbmUoQSxrLG4pIHtcbiAgICBpZih0eXBlb2YgayA9PT0gXCJ1bmRlZmluZWRcIikgeyBrPTA7IH1cbiAgICBpZih0eXBlb2YgbiA9PT0gXCJ1bmRlZmluZWRcIikgeyBuID0gbnVtZXJpYy5zZGltKEEpLmxlbmd0aDsgfVxuICAgIHZhciBpLHJldCA9IEFycmF5KEEubGVuZ3RoKTtcbiAgICBpZihrID09PSBuLTEpIHtcbiAgICAgICAgZm9yKGkgaW4gQSkgeyBpZihBLmhhc093blByb3BlcnR5KGkpKSByZXRbaV0gPSBBW2ldOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvcihpIGluIEEpIHtcbiAgICAgICAgaWYoQS5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0W2ldID0gY2xvbmUoQVtpXSxrKzEsbik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2RpYWcgPSBmdW5jdGlvbiBkaWFnKGQpIHtcbiAgICB2YXIgbiA9IGQubGVuZ3RoLGkscmV0ID0gQXJyYXkobiksaTEsaTIsaTM7XG4gICAgZm9yKGk9bi0xO2k+PTE7aS09Mikge1xuICAgICAgICBpMSA9IGktMTtcbiAgICAgICAgcmV0W2ldID0gW107IHJldFtpXVtpXSA9IGRbaV07XG4gICAgICAgIHJldFtpMV0gPSBbXTsgcmV0W2kxXVtpMV0gPSBkW2kxXTtcbiAgICB9XG4gICAgaWYoaT09PTApIHsgcmV0WzBdID0gW107IHJldFswXVswXSA9IGRbaV07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNpZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KG4pIHsgcmV0dXJuIG51bWVyaWMuc2RpYWcobnVtZXJpYy5yZXAoW25dLDEpKTsgfVxuXG5udW1lcmljLnN0cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoQSkge1xuICAgIHZhciByZXQgPSBbXSwgbiA9IEEubGVuZ3RoLCBpLGosQWk7XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZighKEEuaGFzT3duUHJvcGVydHkoaSkpKSBjb250aW51ZTtcbiAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICBmb3IoaiBpbiBBaSkge1xuICAgICAgICAgICAgaWYoIShBaS5oYXNPd25Qcm9wZXJ0eShqKSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYodHlwZW9mIHJldFtqXSAhPT0gXCJvYmplY3RcIikgeyByZXRbal0gPSBbXTsgfVxuICAgICAgICAgICAgcmV0W2pdW2ldID0gQWlbal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zTFVQID0gZnVuY3Rpb24gTFVQKEEsdG9sKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIG51bWVyaWMuc0xVUCBoYWQgYSBidWcgaW4gaXQgYW5kIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlIG5ldyBudW1lcmljLmNjc0xVUCBmdW5jdGlvbiBpbnN0ZWFkLlwiKTtcbn07XG5cbm51bWVyaWMuc2RvdE1NID0gZnVuY3Rpb24gZG90TU0oQSxCKSB7XG4gICAgdmFyIHAgPSBBLmxlbmd0aCwgcSA9IEIubGVuZ3RoLCBCVCA9IG51bWVyaWMuc3RyYW5zcG9zZShCKSwgciA9IEJULmxlbmd0aCwgQWksIEJUaztcbiAgICB2YXIgaSxqLGssYWNjdW07XG4gICAgdmFyIHJldCA9IEFycmF5KHApLHJldGk7XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7XG4gICAgICAgIHJldGkgPSBbXTtcbiAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICBmb3Ioaz1yLTE7az49MDtrLS0pIHtcbiAgICAgICAgICAgIGFjY3VtID0gMDtcbiAgICAgICAgICAgIEJUayA9IEJUW2tdO1xuICAgICAgICAgICAgZm9yKGogaW4gQWkpIHtcbiAgICAgICAgICAgICAgICBpZighKEFpLmhhc093blByb3BlcnR5KGopKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYoaiBpbiBCVGspIHsgYWNjdW0gKz0gQWlbal0qQlRrW2pdOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihhY2N1bSkgcmV0aVtrXSA9IGFjY3VtO1xuICAgICAgICB9XG4gICAgICAgIHJldFtpXSA9IHJldGk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2RvdE1WID0gZnVuY3Rpb24gZG90TVYoQSx4KSB7XG4gICAgdmFyIHAgPSBBLmxlbmd0aCwgQWksIGksajtcbiAgICB2YXIgcmV0ID0gQXJyYXkocCksIGFjY3VtO1xuICAgIGZvcihpPXAtMTtpPj0wO2ktLSkge1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGFjY3VtID0gMDtcbiAgICAgICAgZm9yKGogaW4gQWkpIHtcbiAgICAgICAgICAgIGlmKCEoQWkuaGFzT3duUHJvcGVydHkoaikpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmKHhbal0pIGFjY3VtICs9IEFpW2pdKnhbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoYWNjdW0pIHJldFtpXSA9IGFjY3VtO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkb3RWTSA9IGZ1bmN0aW9uIGRvdE1WKHgsQSkge1xuICAgIHZhciBpLGosQWksYWxwaGE7XG4gICAgdmFyIHJldCA9IFtdLCBhY2N1bTtcbiAgICBmb3IoaSBpbiB4KSB7XG4gICAgICAgIGlmKCF4Lmhhc093blByb3BlcnR5KGkpKSBjb250aW51ZTtcbiAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICBhbHBoYSA9IHhbaV07XG4gICAgICAgIGZvcihqIGluIEFpKSB7XG4gICAgICAgICAgICBpZighQWkuaGFzT3duUHJvcGVydHkoaikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYoIXJldFtqXSkgeyByZXRbal0gPSAwOyB9XG4gICAgICAgICAgICByZXRbal0gKz0gYWxwaGEqQWlbal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZG90VlYgPSBmdW5jdGlvbiBkb3RWVih4LHkpIHtcbiAgICB2YXIgaSxyZXQ9MDtcbiAgICBmb3IoaSBpbiB4KSB7IGlmKHhbaV0gJiYgeVtpXSkgcmV0Kz0geFtpXSp5W2ldOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZG90ID0gZnVuY3Rpb24gZG90KEEsQikge1xuICAgIHZhciBtID0gbnVtZXJpYy5zZGltKEEpLmxlbmd0aCwgbiA9IG51bWVyaWMuc2RpbShCKS5sZW5ndGg7XG4gICAgdmFyIGsgPSBtKjEwMDArbjtcbiAgICBzd2l0Y2goaykge1xuICAgIGNhc2UgMDogcmV0dXJuIEEqQjtcbiAgICBjYXNlIDEwMDE6IHJldHVybiBudW1lcmljLnNkb3RWVihBLEIpO1xuICAgIGNhc2UgMjAwMTogcmV0dXJuIG51bWVyaWMuc2RvdE1WKEEsQik7XG4gICAgY2FzZSAxMDAyOiByZXR1cm4gbnVtZXJpYy5zZG90Vk0oQSxCKTtcbiAgICBjYXNlIDIwMDI6IHJldHVybiBudW1lcmljLnNkb3RNTShBLEIpO1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignbnVtZXJpYy5zZG90IG5vdCBpbXBsZW1lbnRlZCBmb3IgdGVuc29ycyBvZiBvcmRlciAnK20rJyBhbmQgJytuKTtcbiAgICB9XG59XG5cbm51bWVyaWMuc3NjYXR0ZXIgPSBmdW5jdGlvbiBzY2F0dGVyKFYpIHtcbiAgICB2YXIgbiA9IFZbMF0ubGVuZ3RoLCBWaWosIGksIGosIG0gPSBWLmxlbmd0aCwgQSA9IFtdLCBBajtcbiAgICBmb3IoaT1uLTE7aT49MDstLWkpIHtcbiAgICAgICAgaWYoIVZbbS0xXVtpXSkgY29udGludWU7XG4gICAgICAgIEFqID0gQTtcbiAgICAgICAgZm9yKGo9MDtqPG0tMjtqKyspIHtcbiAgICAgICAgICAgIFZpaiA9IFZbal1baV07XG4gICAgICAgICAgICBpZighQWpbVmlqXSkgQWpbVmlqXSA9IFtdO1xuICAgICAgICAgICAgQWogPSBBaltWaWpdO1xuICAgICAgICB9XG4gICAgICAgIEFqW1Zbal1baV1dID0gVltqKzFdW2ldO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cblxubnVtZXJpYy5zZ2F0aGVyID0gZnVuY3Rpb24gZ2F0aGVyKEEscmV0LGspIHtcbiAgICBpZih0eXBlb2YgcmV0ID09PSBcInVuZGVmaW5lZFwiKSByZXQgPSBbXTtcbiAgICBpZih0eXBlb2YgayA9PT0gXCJ1bmRlZmluZWRcIikgayA9IFtdO1xuICAgIHZhciBuLGksQWk7XG4gICAgbiA9IGsubGVuZ3RoO1xuICAgIGZvcihpIGluIEEpIHtcbiAgICAgICAgaWYoQS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAga1tuXSA9IHBhcnNlSW50KGkpO1xuICAgICAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICAgICAgaWYodHlwZW9mIEFpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYoQWkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYocmV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGk9bisxO2k+PTA7LS1pKSByZXRbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IoaT1uO2k+PTA7LS1pKSByZXRbaV0ucHVzaChrW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0W24rMV0ucHVzaChBaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGdhdGhlcihBaSxyZXQsayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoay5sZW5ndGg+bikgay5wb3AoKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyA2LiBDb29yZGluYXRlIG1hdHJpY2VzXG5udW1lcmljLmNMVSA9IGZ1bmN0aW9uIExVKEEpIHtcbiAgICB2YXIgSSA9IEFbMF0sIEogPSBBWzFdLCBWID0gQVsyXTtcbiAgICB2YXIgcCA9IEkubGVuZ3RoLCBtPTAsIGksaixrLGEsYixjO1xuICAgIGZvcihpPTA7aTxwO2krKykgaWYoSVtpXT5tKSBtPUlbaV07XG4gICAgbSsrO1xuICAgIHZhciBMID0gQXJyYXkobSksIFUgPSBBcnJheShtKSwgbGVmdCA9IG51bWVyaWMucmVwKFttXSxJbmZpbml0eSksIHJpZ2h0ID0gbnVtZXJpYy5yZXAoW21dLC1JbmZpbml0eSk7XG4gICAgdmFyIFVpLCBVaixhbHBoYTtcbiAgICBmb3Ioaz0wO2s8cDtrKyspIHtcbiAgICAgICAgaSA9IElba107XG4gICAgICAgIGogPSBKW2tdO1xuICAgICAgICBpZihqPGxlZnRbaV0pIGxlZnRbaV0gPSBqO1xuICAgICAgICBpZihqPnJpZ2h0W2ldKSByaWdodFtpXSA9IGo7XG4gICAgfVxuICAgIGZvcihpPTA7aTxtLTE7aSsrKSB7IGlmKHJpZ2h0W2ldID4gcmlnaHRbaSsxXSkgcmlnaHRbaSsxXSA9IHJpZ2h0W2ldOyB9XG4gICAgZm9yKGk9bS0xO2k+PTE7aS0tKSB7IGlmKGxlZnRbaV08bGVmdFtpLTFdKSBsZWZ0W2ktMV0gPSBsZWZ0W2ldOyB9XG4gICAgdmFyIGNvdW50TCA9IDAsIGNvdW50VSA9IDA7XG4gICAgZm9yKGk9MDtpPG07aSsrKSB7XG4gICAgICAgIFVbaV0gPSBudW1lcmljLnJlcChbcmlnaHRbaV0tbGVmdFtpXSsxXSwwKTtcbiAgICAgICAgTFtpXSA9IG51bWVyaWMucmVwKFtpLWxlZnRbaV1dLDApO1xuICAgICAgICBjb3VudEwgKz0gaS1sZWZ0W2ldKzE7XG4gICAgICAgIGNvdW50VSArPSByaWdodFtpXS1pKzE7XG4gICAgfVxuICAgIGZvcihrPTA7azxwO2srKykgeyBpID0gSVtrXTsgVVtpXVtKW2tdLWxlZnRbaV1dID0gVltrXTsgfVxuICAgIGZvcihpPTA7aTxtLTE7aSsrKSB7XG4gICAgICAgIGEgPSBpLWxlZnRbaV07XG4gICAgICAgIFVpID0gVVtpXTtcbiAgICAgICAgZm9yKGo9aSsxO2xlZnRbal08PWkgJiYgajxtO2orKykge1xuICAgICAgICAgICAgYiA9IGktbGVmdFtqXTtcbiAgICAgICAgICAgIGMgPSByaWdodFtpXS1pO1xuICAgICAgICAgICAgVWogPSBVW2pdO1xuICAgICAgICAgICAgYWxwaGEgPSBValtiXS9VaVthXTtcbiAgICAgICAgICAgIGlmKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgZm9yKGs9MTtrPD1jO2srKykgeyBValtrK2JdIC09IGFscGhhKlVpW2srYV07IH1cbiAgICAgICAgICAgICAgICBMW2pdW2ktbGVmdFtqXV0gPSBhbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgVWkgPSBbXSwgVWogPSBbXSwgVXYgPSBbXSwgTGkgPSBbXSwgTGogPSBbXSwgTHYgPSBbXTtcbiAgICB2YXIgcCxxLGZvbztcbiAgICBwPTA7IHE9MDtcbiAgICBmb3IoaT0wO2k8bTtpKyspIHtcbiAgICAgICAgYSA9IGxlZnRbaV07XG4gICAgICAgIGIgPSByaWdodFtpXTtcbiAgICAgICAgZm9vID0gVVtpXTtcbiAgICAgICAgZm9yKGo9aTtqPD1iO2orKykge1xuICAgICAgICAgICAgaWYoZm9vW2otYV0pIHtcbiAgICAgICAgICAgICAgICBVaVtwXSA9IGk7XG4gICAgICAgICAgICAgICAgVWpbcF0gPSBqO1xuICAgICAgICAgICAgICAgIFV2W3BdID0gZm9vW2otYV07XG4gICAgICAgICAgICAgICAgcCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvbyA9IExbaV07XG4gICAgICAgIGZvcihqPWE7ajxpO2orKykge1xuICAgICAgICAgICAgaWYoZm9vW2otYV0pIHtcbiAgICAgICAgICAgICAgICBMaVtxXSA9IGk7XG4gICAgICAgICAgICAgICAgTGpbcV0gPSBqO1xuICAgICAgICAgICAgICAgIEx2W3FdID0gZm9vW2otYV07XG4gICAgICAgICAgICAgICAgcSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExpW3FdID0gaTtcbiAgICAgICAgTGpbcV0gPSBpO1xuICAgICAgICBMdltxXSA9IDE7XG4gICAgICAgIHErKztcbiAgICB9XG4gICAgcmV0dXJuIHtVOltVaSxVaixVdl0sIEw6W0xpLExqLEx2XX07XG59O1xuXG5udW1lcmljLmNMVXNvbHZlID0gZnVuY3Rpb24gTFVzb2x2ZShsdSxiKSB7XG4gICAgdmFyIEwgPSBsdS5MLCBVID0gbHUuVSwgcmV0ID0gbnVtZXJpYy5jbG9uZShiKTtcbiAgICB2YXIgTGkgPSBMWzBdLCBMaiA9IExbMV0sIEx2ID0gTFsyXTtcbiAgICB2YXIgVWkgPSBVWzBdLCBVaiA9IFVbMV0sIFV2ID0gVVsyXTtcbiAgICB2YXIgcCA9IFVpLmxlbmd0aCwgcSA9IExpLmxlbmd0aDtcbiAgICB2YXIgbSA9IHJldC5sZW5ndGgsaSxqLGs7XG4gICAgayA9IDA7XG4gICAgZm9yKGk9MDtpPG07aSsrKSB7XG4gICAgICAgIHdoaWxlKExqW2tdIDwgaSkge1xuICAgICAgICAgICAgcmV0W2ldIC09IEx2W2tdKnJldFtMaltrXV07XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgaysrO1xuICAgIH1cbiAgICBrID0gcC0xO1xuICAgIGZvcihpPW0tMTtpPj0wO2ktLSkge1xuICAgICAgICB3aGlsZShValtrXSA+IGkpIHtcbiAgICAgICAgICAgIHJldFtpXSAtPSBVdltrXSpyZXRbVWpba11dO1xuICAgICAgICAgICAgay0tO1xuICAgICAgICB9XG4gICAgICAgIHJldFtpXSAvPSBVdltrXTtcbiAgICAgICAgay0tO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxubnVtZXJpYy5jZ3JpZCA9IGZ1bmN0aW9uIGdyaWQobixzaGFwZSkge1xuICAgIGlmKHR5cGVvZiBuID09PSBcIm51bWJlclwiKSBuID0gW24sbl07XG4gICAgdmFyIHJldCA9IG51bWVyaWMucmVwKG4sLTEpO1xuICAgIHZhciBpLGosY291bnQ7XG4gICAgaWYodHlwZW9mIHNoYXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3dpdGNoKHNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgc2hhcGUgPSBmdW5jdGlvbihpLGopIHsgcmV0dXJuIChpPj1uWzBdLzIgfHwgajxuWzFdLzIpOyB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNoYXBlID0gZnVuY3Rpb24oaSxqKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY291bnQ9MDtcbiAgICBmb3IoaT0xO2k8blswXS0xO2krKykgZm9yKGo9MTtqPG5bMV0tMTtqKyspIFxuICAgICAgICBpZihzaGFwZShpLGopKSB7XG4gICAgICAgICAgICByZXRbaV1bal0gPSBjb3VudDtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmNkZWxzcSA9IGZ1bmN0aW9uIGRlbHNxKGcpIHtcbiAgICB2YXIgZGlyID0gW1stMSwwXSxbMCwtMV0sWzAsMV0sWzEsMF1dO1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oZyksIG0gPSBzWzBdLCBuID0gc1sxXSwgaSxqLGsscCxxO1xuICAgIHZhciBMaSA9IFtdLCBMaiA9IFtdLCBMdiA9IFtdO1xuICAgIGZvcihpPTE7aTxtLTE7aSsrKSBmb3Ioaj0xO2o8bi0xO2orKykge1xuICAgICAgICBpZihnW2ldW2pdPDApIGNvbnRpbnVlO1xuICAgICAgICBmb3Ioaz0wO2s8NDtrKyspIHtcbiAgICAgICAgICAgIHAgPSBpK2RpcltrXVswXTtcbiAgICAgICAgICAgIHEgPSBqK2RpcltrXVsxXTtcbiAgICAgICAgICAgIGlmKGdbcF1bcV08MCkgY29udGludWU7XG4gICAgICAgICAgICBMaS5wdXNoKGdbaV1bal0pO1xuICAgICAgICAgICAgTGoucHVzaChnW3BdW3FdKTtcbiAgICAgICAgICAgIEx2LnB1c2goLTEpO1xuICAgICAgICB9XG4gICAgICAgIExpLnB1c2goZ1tpXVtqXSk7XG4gICAgICAgIExqLnB1c2goZ1tpXVtqXSk7XG4gICAgICAgIEx2LnB1c2goNCk7XG4gICAgfVxuICAgIHJldHVybiBbTGksTGosTHZdO1xufVxuXG5udW1lcmljLmNkb3RNViA9IGZ1bmN0aW9uIGRvdE1WKEEseCkge1xuICAgIHZhciByZXQsIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl0sayxwPUFpLmxlbmd0aCxOO1xuICAgIE49MDtcbiAgICBmb3Ioaz0wO2s8cDtrKyspIHsgaWYoQWlba10+TikgTiA9IEFpW2tdOyB9XG4gICAgTisrO1xuICAgIHJldCA9IG51bWVyaWMucmVwKFtOXSwwKTtcbiAgICBmb3Ioaz0wO2s8cDtrKyspIHsgcmV0W0FpW2tdXSs9QXZba10qeFtBaltrXV07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyA3LiBTcGxpbmVzXG5cbm51bWVyaWMuU3BsaW5lID0gZnVuY3Rpb24gU3BsaW5lKHgseWwseXIsa2wsa3IpIHsgdGhpcy54ID0geDsgdGhpcy55bCA9IHlsOyB0aGlzLnlyID0geXI7IHRoaXMua2wgPSBrbDsgdGhpcy5rciA9IGtyOyB9XG5udW1lcmljLlNwbGluZS5wcm90b3R5cGUuX2F0ID0gZnVuY3Rpb24gX2F0KHgxLHApIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeWwgPSB0aGlzLnlsO1xuICAgIHZhciB5ciA9IHRoaXMueXI7XG4gICAgdmFyIGtsID0gdGhpcy5rbDtcbiAgICB2YXIga3IgPSB0aGlzLmtyO1xuICAgIHZhciB4MSxhLGIsdDtcbiAgICB2YXIgYWRkID0gbnVtZXJpYy5hZGQsIHN1YiA9IG51bWVyaWMuc3ViLCBtdWwgPSBudW1lcmljLm11bDtcbiAgICBhID0gc3ViKG11bChrbFtwXSx4W3ArMV0teFtwXSksc3ViKHlyW3ArMV0seWxbcF0pKTtcbiAgICBiID0gYWRkKG11bChrcltwKzFdLHhbcF0teFtwKzFdKSxzdWIoeXJbcCsxXSx5bFtwXSkpO1xuICAgIHQgPSAoeDEteFtwXSkvKHhbcCsxXS14W3BdKTtcbiAgICB2YXIgcyA9IHQqKDEtdCk7XG4gICAgcmV0dXJuIGFkZChhZGQoYWRkKG11bCgxLXQseWxbcF0pLG11bCh0LHlyW3ArMV0pKSxtdWwoYSxzKigxLXQpKSksbXVsKGIscyp0KSk7XG59XG5udW1lcmljLlNwbGluZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCh4MCkge1xuICAgIGlmKHR5cGVvZiB4MCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICAgICAgdmFyIHAscSxtaWQsZmxvb3IgPSBNYXRoLmZsb29yLGEsYix0O1xuICAgICAgICBwID0gMDtcbiAgICAgICAgcSA9IG4tMTtcbiAgICAgICAgd2hpbGUocS1wPjEpIHtcbiAgICAgICAgICAgIG1pZCA9IGZsb29yKChwK3EpLzIpO1xuICAgICAgICAgICAgaWYoeFttaWRdIDw9IHgwKSBwID0gbWlkO1xuICAgICAgICAgICAgZWxzZSBxID0gbWlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hdCh4MCxwKTtcbiAgICB9XG4gICAgdmFyIG4gPSB4MC5sZW5ndGgsIGksIHJldCA9IEFycmF5KG4pO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSByZXRbaV0gPSB0aGlzLmF0KHgwW2ldKTtcbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5TcGxpbmUucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiBkaWZmKCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5bCA9IHRoaXMueWw7XG4gICAgdmFyIHlyID0gdGhpcy55cjtcbiAgICB2YXIga2wgPSB0aGlzLmtsO1xuICAgIHZhciBrciA9IHRoaXMua3I7XG4gICAgdmFyIG4gPSB5bC5sZW5ndGg7XG4gICAgdmFyIGksZHgsZHk7XG4gICAgdmFyIHpsID0ga2wsIHpyID0ga3IsIHBsID0gQXJyYXkobiksIHByID0gQXJyYXkobik7XG4gICAgdmFyIGFkZCA9IG51bWVyaWMuYWRkLCBtdWwgPSBudW1lcmljLm11bCwgZGl2ID0gbnVtZXJpYy5kaXYsIHN1YiA9IG51bWVyaWMuc3ViO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGR4ID0geFtpKzFdLXhbaV07XG4gICAgICAgIGR5ID0gc3ViKHlyW2krMV0seWxbaV0pO1xuICAgICAgICBwbFtpXSA9IGRpdihhZGQobXVsKGR5LCA2KSxtdWwoa2xbaV0sLTQqZHgpLG11bChrcltpKzFdLC0yKmR4KSksZHgqZHgpO1xuICAgICAgICBwcltpKzFdID0gZGl2KGFkZChtdWwoZHksLTYpLG11bChrbFtpXSwgMipkeCksbXVsKGtyW2krMV0sIDQqZHgpKSxkeCpkeCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5TcGxpbmUoeCx6bCx6cixwbCxwcik7XG59XG5udW1lcmljLlNwbGluZS5wcm90b3R5cGUucm9vdHMgPSBmdW5jdGlvbiByb290cygpIHtcbiAgICBmdW5jdGlvbiBzcXIoeCkgeyByZXR1cm4geCp4OyB9XG4gICAgZnVuY3Rpb24gaGV2YWwoeTAseTEsazAsazEseCkge1xuICAgICAgICB2YXIgQSA9IGswKjItKHkxLXkwKTtcbiAgICAgICAgdmFyIEIgPSAtazEqMisoeTEteTApO1xuICAgICAgICB2YXIgdCA9ICh4KzEpKjAuNTtcbiAgICAgICAgdmFyIHMgPSB0KigxLXQpO1xuICAgICAgICByZXR1cm4gKDEtdCkqeTArdCp5MStBKnMqKDEtdCkrQipzKnQ7XG4gICAgfVxuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgeCA9IHRoaXMueCwgeWwgPSB0aGlzLnlsLCB5ciA9IHRoaXMueXIsIGtsID0gdGhpcy5rbCwga3IgPSB0aGlzLmtyO1xuICAgIGlmKHR5cGVvZiB5bFswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB5bCA9IFt5bF07XG4gICAgICAgIHlyID0gW3lyXTtcbiAgICAgICAga2wgPSBba2xdO1xuICAgICAgICBrciA9IFtrcl07XG4gICAgfVxuICAgIHZhciBtID0geWwubGVuZ3RoLG49eC5sZW5ndGgtMSxpLGosayx5LHMsdDtcbiAgICB2YXIgYWksYmksY2ksZGksIHJldCA9IEFycmF5KG0pLHJpLGswLGsxLHkwLHkxLEEsQixELGR4LGN4LHN0b3BzLHowLHoxLHptLHQwLHQxLHRtO1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIGZvcihpPTA7aSE9PW07KytpKSB7XG4gICAgICAgIGFpID0geWxbaV07XG4gICAgICAgIGJpID0geXJbaV07XG4gICAgICAgIGNpID0ga2xbaV07XG4gICAgICAgIGRpID0ga3JbaV07XG4gICAgICAgIHJpID0gW107XG4gICAgICAgIGZvcihqPTA7aiE9PW47aisrKSB7XG4gICAgICAgICAgICBpZihqPjAgJiYgYmlbal0qYWlbal08MCkgcmkucHVzaCh4W2pdKTtcbiAgICAgICAgICAgIGR4ID0gKHhbaisxXS14W2pdKTtcbiAgICAgICAgICAgIGN4ID0geFtqXTtcbiAgICAgICAgICAgIHkwID0gYWlbal07XG4gICAgICAgICAgICB5MSA9IGJpW2orMV07XG4gICAgICAgICAgICBrMCA9IGNpW2pdL2R4O1xuICAgICAgICAgICAgazEgPSBkaVtqKzFdL2R4O1xuICAgICAgICAgICAgRCA9IHNxcihrMC1rMSszKih5MC15MSkpICsgMTIqazEqeTA7XG4gICAgICAgICAgICBBID0gazErMyp5MCsyKmswLTMqeTE7XG4gICAgICAgICAgICBCID0gMyooazErazArMiooeTAteTEpKTtcbiAgICAgICAgICAgIGlmKEQ8PTApIHtcbiAgICAgICAgICAgICAgICB6MCA9IEEvQjtcbiAgICAgICAgICAgICAgICBpZih6MD54W2pdICYmIHowPHhbaisxXSkgc3RvcHMgPSBbeFtqXSx6MCx4W2orMV1dO1xuICAgICAgICAgICAgICAgIGVsc2Ugc3RvcHMgPSBbeFtqXSx4W2orMV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB6MCA9IChBLXNxcnQoRCkpL0I7XG4gICAgICAgICAgICAgICAgejEgPSAoQStzcXJ0KEQpKS9CO1xuICAgICAgICAgICAgICAgIHN0b3BzID0gW3hbal1dO1xuICAgICAgICAgICAgICAgIGlmKHowPnhbal0gJiYgejA8eFtqKzFdKSBzdG9wcy5wdXNoKHowKTtcbiAgICAgICAgICAgICAgICBpZih6MT54W2pdICYmIHoxPHhbaisxXSkgc3RvcHMucHVzaCh6MSk7XG4gICAgICAgICAgICAgICAgc3RvcHMucHVzaCh4W2orMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDAgPSBzdG9wc1swXTtcbiAgICAgICAgICAgIHowID0gdGhpcy5fYXQodDAsaik7XG4gICAgICAgICAgICBmb3Ioaz0wO2s8c3RvcHMubGVuZ3RoLTE7aysrKSB7XG4gICAgICAgICAgICAgICAgdDEgPSBzdG9wc1trKzFdO1xuICAgICAgICAgICAgICAgIHoxID0gdGhpcy5fYXQodDEsaik7XG4gICAgICAgICAgICAgICAgaWYoejAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmkucHVzaCh0MCk7IFxuICAgICAgICAgICAgICAgICAgICB0MCA9IHQxO1xuICAgICAgICAgICAgICAgICAgICB6MCA9IHoxO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoejEgPT09IDAgfHwgejAqejE+MCkge1xuICAgICAgICAgICAgICAgICAgICB0MCA9IHQxO1xuICAgICAgICAgICAgICAgICAgICB6MCA9IHoxO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNpZGUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdG0gPSAoejAqdDEtejEqdDApLyh6MC16MSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtIDw9IHQwIHx8IHRtID49IHQxKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIHptID0gdGhpcy5fYXQodG0saik7XG4gICAgICAgICAgICAgICAgICAgIGlmKHptKnoxPjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdG07XG4gICAgICAgICAgICAgICAgICAgICAgICB6MSA9IHptO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gLTEpIHowKj0wLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih6bSp6MD4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0MCA9IHRtO1xuICAgICAgICAgICAgICAgICAgICAgICAgejAgPSB6bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNpZGUgPT09IDEpIHoxKj0wLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByaS5wdXNoKHRtKTtcbiAgICAgICAgICAgICAgICB0MCA9IHN0b3BzW2srMV07XG4gICAgICAgICAgICAgICAgejAgPSB0aGlzLl9hdCh0MCwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih6MSA9PT0gMCkgcmkucHVzaCh0MSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldID0gcmk7XG4gICAgfVxuICAgIGlmKHR5cGVvZiB0aGlzLnlsWzBdID09PSBcIm51bWJlclwiKSByZXR1cm4gcmV0WzBdO1xuICAgIHJldHVybiByZXQ7XG59XG5udW1lcmljLnNwbGluZSA9IGZ1bmN0aW9uIHNwbGluZSh4LHksazEsa24pIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoLCBiID0gW10sIGR4ID0gW10sIGR5ID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHN1YiA9IG51bWVyaWMuc3ViLG11bCA9IG51bWVyaWMubXVsLGFkZCA9IG51bWVyaWMuYWRkO1xuICAgIGZvcihpPW4tMjtpPj0wO2ktLSkgeyBkeFtpXSA9IHhbaSsxXS14W2ldOyBkeVtpXSA9IHN1Yih5W2krMV0seVtpXSk7IH1cbiAgICBpZih0eXBlb2YgazEgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGtuID09PSBcInN0cmluZ1wiKSB7IFxuICAgICAgICBrMSA9IGtuID0gXCJwZXJpb2RpY1wiO1xuICAgIH1cbiAgICAvLyBCdWlsZCBzcGFyc2UgdHJpZGlhZ29uYWwgc3lzdGVtXG4gICAgdmFyIFQgPSBbW10sW10sW11dO1xuICAgIHN3aXRjaCh0eXBlb2YgazEpIHtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIGJbMF0gPSBtdWwoMy8oZHhbMF0qZHhbMF0pLGR5WzBdKTtcbiAgICAgICAgVFswXS5wdXNoKDAsMCk7XG4gICAgICAgIFRbMV0ucHVzaCgwLDEpO1xuICAgICAgICBUWzJdLnB1c2goMi9keFswXSwxL2R4WzBdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBiWzBdID0gYWRkKG11bCgzLyhkeFtuLTJdKmR4W24tMl0pLGR5W24tMl0pLG11bCgzLyhkeFswXSpkeFswXSksZHlbMF0pKTtcbiAgICAgICAgVFswXS5wdXNoKDAsMCwwKTtcbiAgICAgICAgVFsxXS5wdXNoKG4tMiwwLDEpO1xuICAgICAgICBUWzJdLnB1c2goMS9keFtuLTJdLDIvZHhbbi0yXSsyL2R4WzBdLDEvZHhbMF0pO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICBiWzBdID0gazE7XG4gICAgICAgIFRbMF0ucHVzaCgwKTtcbiAgICAgICAgVFsxXS5wdXNoKDApO1xuICAgICAgICBUWzJdLnB1c2goMSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IoaT0xO2k8bi0xO2krKykge1xuICAgICAgICBiW2ldID0gYWRkKG11bCgzLyhkeFtpLTFdKmR4W2ktMV0pLGR5W2ktMV0pLG11bCgzLyhkeFtpXSpkeFtpXSksZHlbaV0pKTtcbiAgICAgICAgVFswXS5wdXNoKGksaSxpKTtcbiAgICAgICAgVFsxXS5wdXNoKGktMSxpLGkrMSk7XG4gICAgICAgIFRbMl0ucHVzaCgxL2R4W2ktMV0sMi9keFtpLTFdKzIvZHhbaV0sMS9keFtpXSk7XG4gICAgfVxuICAgIHN3aXRjaCh0eXBlb2Yga24pIHtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIGJbbi0xXSA9IG11bCgzLyhkeFtuLTJdKmR4W24tMl0pLGR5W24tMl0pO1xuICAgICAgICBUWzBdLnB1c2gobi0xLG4tMSk7XG4gICAgICAgIFRbMV0ucHVzaChuLTIsbi0xKTtcbiAgICAgICAgVFsyXS5wdXNoKDEvZHhbbi0yXSwyL2R4W24tMl0pO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIFRbMV1bVFsxXS5sZW5ndGgtMV0gPSAwO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICBiW24tMV0gPSBrbjtcbiAgICAgICAgVFswXS5wdXNoKG4tMSk7XG4gICAgICAgIFRbMV0ucHVzaChuLTEpO1xuICAgICAgICBUWzJdLnB1c2goMSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZih0eXBlb2YgYlswXSAhPT0gXCJudW1iZXJcIikgYiA9IG51bWVyaWMudHJhbnNwb3NlKGIpO1xuICAgIGVsc2UgYiA9IFtiXTtcbiAgICB2YXIgayA9IEFycmF5KGIubGVuZ3RoKTtcbiAgICBpZih0eXBlb2YgazEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9yKGk9ay5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgICAgICBrW2ldID0gbnVtZXJpYy5jY3NMVVBTb2x2ZShudW1lcmljLmNjc0xVUChudW1lcmljLmNjc1NjYXR0ZXIoVCkpLGJbaV0pO1xuICAgICAgICAgICAga1tpXVtuLTFdID0ga1tpXVswXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcihpPWsubGVuZ3RoLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAgICAga1tpXSA9IG51bWVyaWMuY0xVc29sdmUobnVtZXJpYy5jTFUoVCksYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYodHlwZW9mIHlbMF0gPT09IFwibnVtYmVyXCIpIGsgPSBrWzBdO1xuICAgIGVsc2UgayA9IG51bWVyaWMudHJhbnNwb3NlKGspO1xuICAgIHJldHVybiBuZXcgbnVtZXJpYy5TcGxpbmUoeCx5LHksayxrKTtcbn1cblxuLy8gOC4gRkZUXG5udW1lcmljLmZmdHBvdzIgPSBmdW5jdGlvbiBmZnRwb3cyKHgseSkge1xuICAgIHZhciBuID0geC5sZW5ndGg7XG4gICAgaWYobiA9PT0gMSkgcmV0dXJuO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW4sIGksajtcbiAgICB2YXIgeGUgPSBBcnJheShuLzIpLCB5ZSA9IEFycmF5KG4vMiksIHhvID0gQXJyYXkobi8yKSwgeW8gPSBBcnJheShuLzIpO1xuICAgIGogPSBuLzI7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgLS1qO1xuICAgICAgICB4b1tqXSA9IHhbaV07XG4gICAgICAgIHlvW2pdID0geVtpXTtcbiAgICAgICAgLS1pO1xuICAgICAgICB4ZVtqXSA9IHhbaV07XG4gICAgICAgIHllW2pdID0geVtpXTtcbiAgICB9XG4gICAgZmZ0cG93Mih4ZSx5ZSk7XG4gICAgZmZ0cG93Mih4byx5byk7XG4gICAgaiA9IG4vMjtcbiAgICB2YXIgdCxrID0gKC02LjI4MzE4NTMwNzE3OTU4NjQ3NjkyNTI4Njc2NjU1OTAwNTc2ODM5NDMzODc5ODc1MDIxMTY0MTkvbiksY2ksc2k7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgLS1qO1xuICAgICAgICBpZihqID09PSAtMSkgaiA9IG4vMi0xO1xuICAgICAgICB0ID0gayppO1xuICAgICAgICBjaSA9IGNvcyh0KTtcbiAgICAgICAgc2kgPSBzaW4odCk7XG4gICAgICAgIHhbaV0gPSB4ZVtqXSArIGNpKnhvW2pdIC0gc2kqeW9bal07XG4gICAgICAgIHlbaV0gPSB5ZVtqXSArIGNpKnlvW2pdICsgc2kqeG9bal07XG4gICAgfVxufVxubnVtZXJpYy5faWZmdHBvdzIgPSBmdW5jdGlvbiBfaWZmdHBvdzIoeCx5KSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICBpZihuID09PSAxKSByZXR1cm47XG4gICAgdmFyIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbiwgaSxqO1xuICAgIHZhciB4ZSA9IEFycmF5KG4vMiksIHllID0gQXJyYXkobi8yKSwgeG8gPSBBcnJheShuLzIpLCB5byA9IEFycmF5KG4vMik7XG4gICAgaiA9IG4vMjtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIHhvW2pdID0geFtpXTtcbiAgICAgICAgeW9bal0gPSB5W2ldO1xuICAgICAgICAtLWk7XG4gICAgICAgIHhlW2pdID0geFtpXTtcbiAgICAgICAgeWVbal0gPSB5W2ldO1xuICAgIH1cbiAgICBfaWZmdHBvdzIoeGUseWUpO1xuICAgIF9pZmZ0cG93Mih4byx5byk7XG4gICAgaiA9IG4vMjtcbiAgICB2YXIgdCxrID0gKDYuMjgzMTg1MzA3MTc5NTg2NDc2OTI1Mjg2NzY2NTU5MDA1NzY4Mzk0MzM4Nzk4NzUwMjExNjQxOS9uKSxjaSxzaTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIGlmKGogPT09IC0xKSBqID0gbi8yLTE7XG4gICAgICAgIHQgPSBrKmk7XG4gICAgICAgIGNpID0gY29zKHQpO1xuICAgICAgICBzaSA9IHNpbih0KTtcbiAgICAgICAgeFtpXSA9IHhlW2pdICsgY2kqeG9bal0gLSBzaSp5b1tqXTtcbiAgICAgICAgeVtpXSA9IHllW2pdICsgY2kqeW9bal0gKyBzaSp4b1tqXTtcbiAgICB9XG59XG5udW1lcmljLmlmZnRwb3cyID0gZnVuY3Rpb24gaWZmdHBvdzIoeCx5KSB7XG4gICAgbnVtZXJpYy5faWZmdHBvdzIoeCx5KTtcbiAgICBudW1lcmljLmRpdmVxKHgseC5sZW5ndGgpO1xuICAgIG51bWVyaWMuZGl2ZXEoeSx5Lmxlbmd0aCk7XG59XG5udW1lcmljLmNvbnZwb3cyID0gZnVuY3Rpb24gY29udnBvdzIoYXgsYXksYngsYnkpIHtcbiAgICBudW1lcmljLmZmdHBvdzIoYXgsYXkpO1xuICAgIG51bWVyaWMuZmZ0cG93MihieCxieSk7XG4gICAgdmFyIGksbiA9IGF4Lmxlbmd0aCxheGksYnhpLGF5aSxieWk7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgYXhpID0gYXhbaV07IGF5aSA9IGF5W2ldOyBieGkgPSBieFtpXTsgYnlpID0gYnlbaV07XG4gICAgICAgIGF4W2ldID0gYXhpKmJ4aS1heWkqYnlpO1xuICAgICAgICBheVtpXSA9IGF4aSpieWkrYXlpKmJ4aTtcbiAgICB9XG4gICAgbnVtZXJpYy5pZmZ0cG93MihheCxheSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmZmdCA9IGZ1bmN0aW9uIGZmdCgpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICB2YXIgbiA9IHgubGVuZ3RoLCBsb2cgPSBNYXRoLmxvZywgbG9nMiA9IGxvZygyKSxcbiAgICAgICAgcCA9IE1hdGguY2VpbChsb2coMipuLTEpL2xvZzIpLCBtID0gTWF0aC5wb3coMixwKTtcbiAgICB2YXIgY3ggPSBudW1lcmljLnJlcChbbV0sMCksIGN5ID0gbnVtZXJpYy5yZXAoW21dLDApLCBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW47XG4gICAgdmFyIGssIGMgPSAoLTMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTA1ODIwL24pLHQ7XG4gICAgdmFyIGEgPSBudW1lcmljLnJlcChbbV0sMCksIGIgPSBudW1lcmljLnJlcChbbV0sMCksbmhhbGYgPSBNYXRoLmZsb29yKG4vMik7XG4gICAgZm9yKGs9MDtrPG47aysrKSBhW2tdID0geFtrXTtcbiAgICBpZih0eXBlb2YgeSAhPT0gXCJ1bmRlZmluZWRcIikgZm9yKGs9MDtrPG47aysrKSBiW2tdID0geVtrXTtcbiAgICBjeFswXSA9IDE7XG4gICAgZm9yKGs9MTtrPD1tLzI7aysrKSB7XG4gICAgICAgIHQgPSBjKmsqaztcbiAgICAgICAgY3hba10gPSBjb3ModCk7XG4gICAgICAgIGN5W2tdID0gc2luKHQpO1xuICAgICAgICBjeFttLWtdID0gY29zKHQpO1xuICAgICAgICBjeVttLWtdID0gc2luKHQpXG4gICAgfVxuICAgIHZhciBYID0gbmV3IG51bWVyaWMuVChhLGIpLCBZID0gbmV3IG51bWVyaWMuVChjeCxjeSk7XG4gICAgWCA9IFgubXVsKFkpO1xuICAgIG51bWVyaWMuY29udnBvdzIoWC54LFgueSxudW1lcmljLmNsb25lKFkueCksbnVtZXJpYy5uZWcoWS55KSk7XG4gICAgWCA9IFgubXVsKFkpO1xuICAgIFgueC5sZW5ndGggPSBuO1xuICAgIFgueS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBYO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5pZmZ0ID0gZnVuY3Rpb24gaWZmdCgpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICB2YXIgbiA9IHgubGVuZ3RoLCBsb2cgPSBNYXRoLmxvZywgbG9nMiA9IGxvZygyKSxcbiAgICAgICAgcCA9IE1hdGguY2VpbChsb2coMipuLTEpL2xvZzIpLCBtID0gTWF0aC5wb3coMixwKTtcbiAgICB2YXIgY3ggPSBudW1lcmljLnJlcChbbV0sMCksIGN5ID0gbnVtZXJpYy5yZXAoW21dLDApLCBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW47XG4gICAgdmFyIGssIGMgPSAoMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjAvbiksdDtcbiAgICB2YXIgYSA9IG51bWVyaWMucmVwKFttXSwwKSwgYiA9IG51bWVyaWMucmVwKFttXSwwKSxuaGFsZiA9IE1hdGguZmxvb3Iobi8yKTtcbiAgICBmb3Ioaz0wO2s8bjtrKyspIGFba10gPSB4W2tdO1xuICAgIGlmKHR5cGVvZiB5ICE9PSBcInVuZGVmaW5lZFwiKSBmb3Ioaz0wO2s8bjtrKyspIGJba10gPSB5W2tdO1xuICAgIGN4WzBdID0gMTtcbiAgICBmb3Ioaz0xO2s8PW0vMjtrKyspIHtcbiAgICAgICAgdCA9IGMqayprO1xuICAgICAgICBjeFtrXSA9IGNvcyh0KTtcbiAgICAgICAgY3lba10gPSBzaW4odCk7XG4gICAgICAgIGN4W20ta10gPSBjb3ModCk7XG4gICAgICAgIGN5W20ta10gPSBzaW4odClcbiAgICB9XG4gICAgdmFyIFggPSBuZXcgbnVtZXJpYy5UKGEsYiksIFkgPSBuZXcgbnVtZXJpYy5UKGN4LGN5KTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgbnVtZXJpYy5jb252cG93MihYLngsWC55LG51bWVyaWMuY2xvbmUoWS54KSxudW1lcmljLm5lZyhZLnkpKTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgWC54Lmxlbmd0aCA9IG47XG4gICAgWC55Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIFguZGl2KG4pO1xufVxuXG4vLzkuIFVuY29uc3RyYWluZWQgb3B0aW1pemF0aW9uXG5udW1lcmljLmdyYWRpZW50ID0gZnVuY3Rpb24gZ3JhZGllbnQoZix4KSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICB2YXIgZjAgPSBmKHgpO1xuICAgIGlmKGlzTmFOKGYwKSkgdGhyb3cgbmV3IEVycm9yKCdncmFkaWVudDogZih4KSBpcyBhIE5hTiEnKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIGkseDAgPSBudW1lcmljLmNsb25lKHgpLGYxLGYyLCBKID0gQXJyYXkobik7XG4gICAgdmFyIGRpdiA9IG51bWVyaWMuZGl2LCBzdWIgPSBudW1lcmljLnN1YixlcnJlc3Qscm91bmRvZmYsbWF4ID0gTWF0aC5tYXgsZXBzID0gMWUtMyxhYnMgPSBNYXRoLmFicywgbWluID0gTWF0aC5taW47XG4gICAgdmFyIHQwLHQxLHQyLGl0PTAsZDEsZDIsTjtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHtcbiAgICAgICAgdmFyIGggPSBtYXgoMWUtNipmMCwxZS04KTtcbiAgICAgICAgd2hpbGUoMSkge1xuICAgICAgICAgICAgKytpdDtcbiAgICAgICAgICAgIGlmKGl0PjIwKSB7IHRocm93IG5ldyBFcnJvcihcIk51bWVyaWNhbCBncmFkaWVudCBmYWlsc1wiKTsgfVxuICAgICAgICAgICAgeDBbaV0gPSB4W2ldK2g7XG4gICAgICAgICAgICBmMSA9IGYoeDApO1xuICAgICAgICAgICAgeDBbaV0gPSB4W2ldLWg7XG4gICAgICAgICAgICBmMiA9IGYoeDApO1xuICAgICAgICAgICAgeDBbaV0gPSB4W2ldO1xuICAgICAgICAgICAgaWYoaXNOYU4oZjEpIHx8IGlzTmFOKGYyKSkgeyBoLz0xNjsgY29udGludWU7IH1cbiAgICAgICAgICAgIEpbaV0gPSAoZjEtZjIpLygyKmgpO1xuICAgICAgICAgICAgdDAgPSB4W2ldLWg7XG4gICAgICAgICAgICB0MSA9IHhbaV07XG4gICAgICAgICAgICB0MiA9IHhbaV0raDtcbiAgICAgICAgICAgIGQxID0gKGYxLWYwKS9oO1xuICAgICAgICAgICAgZDIgPSAoZjAtZjIpL2g7XG4gICAgICAgICAgICBOID0gbWF4KGFicyhKW2ldKSxhYnMoZjApLGFicyhmMSksYWJzKGYyKSxhYnModDApLGFicyh0MSksYWJzKHQyKSwxZS04KTtcbiAgICAgICAgICAgIGVycmVzdCA9IG1pbihtYXgoYWJzKGQxLUpbaV0pLGFicyhkMi1KW2ldKSxhYnMoZDEtZDIpKS9OLGgvTik7XG4gICAgICAgICAgICBpZihlcnJlc3Q+ZXBzKSB7IGgvPTE2OyB9XG4gICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSjtcbn1cblxubnVtZXJpYy51bmNtaW4gPSBmdW5jdGlvbiB1bmNtaW4oZix4MCx0b2wsZ3JhZGllbnQsbWF4aXQsY2FsbGJhY2ssb3B0aW9ucykge1xuICAgIHZhciBncmFkID0gbnVtZXJpYy5ncmFkaWVudDtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikgeyBvcHRpb25zID0ge307IH1cbiAgICBpZih0eXBlb2YgdG9sID09PSBcInVuZGVmaW5lZFwiKSB7IHRvbCA9IDFlLTg7IH1cbiAgICBpZih0eXBlb2YgZ3JhZGllbnQgPT09IFwidW5kZWZpbmVkXCIpIHsgZ3JhZGllbnQgPSBmdW5jdGlvbih4KSB7IHJldHVybiBncmFkKGYseCk7IH07IH1cbiAgICBpZih0eXBlb2YgbWF4aXQgPT09IFwidW5kZWZpbmVkXCIpIG1heGl0ID0gMTAwMDtcbiAgICB4MCA9IG51bWVyaWMuY2xvbmUoeDApO1xuICAgIHZhciBuID0geDAubGVuZ3RoO1xuICAgIHZhciBmMCA9IGYoeDApLGYxLGRmMDtcbiAgICBpZihpc05hTihmMCkpIHRocm93IG5ldyBFcnJvcigndW5jbWluOiBmKHgwKSBpcyBhIE5hTiEnKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgsIG5vcm0yID0gbnVtZXJpYy5ub3JtMjtcbiAgICB0b2wgPSBtYXgodG9sLG51bWVyaWMuZXBzaWxvbik7XG4gICAgdmFyIHN0ZXAsZzAsZzEsSDEgPSBvcHRpb25zLkhpbnYgfHwgbnVtZXJpYy5pZGVudGl0eShuKTtcbiAgICB2YXIgZG90ID0gbnVtZXJpYy5kb3QsIGludiA9IG51bWVyaWMuaW52LCBzdWIgPSBudW1lcmljLnN1YiwgYWRkID0gbnVtZXJpYy5hZGQsIHRlbiA9IG51bWVyaWMudGVuc29yLCBkaXYgPSBudW1lcmljLmRpdiwgbXVsID0gbnVtZXJpYy5tdWw7XG4gICAgdmFyIGFsbCA9IG51bWVyaWMuYWxsLCBpc2Zpbml0ZSA9IG51bWVyaWMuaXNGaW5pdGUsIG5lZyA9IG51bWVyaWMubmVnO1xuICAgIHZhciBpdD0wLGkscyx4MSx5LEh5LEhzLHlzLGkwLHQsbnN0ZXAsdDEsdDI7XG4gICAgdmFyIG1zZyA9IFwiXCI7XG4gICAgZzAgPSBncmFkaWVudCh4MCk7XG4gICAgd2hpbGUoaXQ8bWF4aXQpIHtcbiAgICAgICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHsgaWYoY2FsbGJhY2soaXQseDAsZjAsZzAsSDEpKSB7IG1zZyA9IFwiQ2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZVwiOyBicmVhazsgfSB9XG4gICAgICAgIGlmKCFhbGwoaXNmaW5pdGUoZzApKSkgeyBtc2cgPSBcIkdyYWRpZW50IGhhcyBJbmZpbml0eSBvciBOYU5cIjsgYnJlYWs7IH1cbiAgICAgICAgc3RlcCA9IG5lZyhkb3QoSDEsZzApKTtcbiAgICAgICAgaWYoIWFsbChpc2Zpbml0ZShzdGVwKSkpIHsgbXNnID0gXCJTZWFyY2ggZGlyZWN0aW9uIGhhcyBJbmZpbml0eSBvciBOYU5cIjsgYnJlYWs7IH1cbiAgICAgICAgbnN0ZXAgPSBub3JtMihzdGVwKTtcbiAgICAgICAgaWYobnN0ZXAgPCB0b2wpIHsgbXNnPVwiTmV3dG9uIHN0ZXAgc21hbGxlciB0aGFuIHRvbFwiOyBicmVhazsgfVxuICAgICAgICB0ID0gMTtcbiAgICAgICAgZGYwID0gZG90KGcwLHN0ZXApO1xuICAgICAgICAvLyBsaW5lIHNlYXJjaFxuICAgICAgICB4MSA9IHgwO1xuICAgICAgICB3aGlsZShpdCA8IG1heGl0KSB7XG4gICAgICAgICAgICBpZih0Km5zdGVwIDwgdG9sKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICBzID0gbXVsKHN0ZXAsdCk7XG4gICAgICAgICAgICB4MSA9IGFkZCh4MCxzKTtcbiAgICAgICAgICAgIGYxID0gZih4MSk7XG4gICAgICAgICAgICBpZihmMS1mMCA+PSAwLjEqdCpkZjAgfHwgaXNOYU4oZjEpKSB7XG4gICAgICAgICAgICAgICAgdCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgKytpdDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHQqbnN0ZXAgPCB0b2wpIHsgbXNnID0gXCJMaW5lIHNlYXJjaCBzdGVwIHNpemUgc21hbGxlciB0aGFuIHRvbFwiOyBicmVhazsgfVxuICAgICAgICBpZihpdCA9PT0gbWF4aXQpIHsgbXNnID0gXCJtYXhpdCByZWFjaGVkIGR1cmluZyBsaW5lIHNlYXJjaFwiOyBicmVhazsgfVxuICAgICAgICBnMSA9IGdyYWRpZW50KHgxKTtcbiAgICAgICAgeSA9IHN1YihnMSxnMCk7XG4gICAgICAgIHlzID0gZG90KHkscyk7XG4gICAgICAgIEh5ID0gZG90KEgxLHkpO1xuICAgICAgICBIMSA9IHN1YihhZGQoSDEsXG4gICAgICAgICAgICAgICAgbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgKHlzK2RvdCh5LEh5KSkvKHlzKnlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbihzLHMpICAgICkpLFxuICAgICAgICAgICAgICAgIGRpdihhZGQodGVuKEh5LHMpLHRlbihzLEh5KSkseXMpKTtcbiAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgZjAgPSBmMTtcbiAgICAgICAgZzAgPSBnMTtcbiAgICAgICAgKytpdDtcbiAgICB9XG4gICAgcmV0dXJuIHtzb2x1dGlvbjogeDAsIGY6IGYwLCBncmFkaWVudDogZzAsIGludkhlc3NpYW46IEgxLCBpdGVyYXRpb25zOml0LCBtZXNzYWdlOiBtc2d9O1xufVxuXG4vLyAxMC4gT2RlIHNvbHZlciAoRG9ybWFuZC1QcmluY2UpXG5udW1lcmljLkRvcHJpID0gZnVuY3Rpb24gRG9wcmkoeCx5LGYseW1pZCxpdGVyYXRpb25zLG1zZyxldmVudHMpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5mID0gZjtcbiAgICB0aGlzLnltaWQgPSB5bWlkO1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xufVxubnVtZXJpYy5Eb3ByaS5wcm90b3R5cGUuX2F0ID0gZnVuY3Rpb24gX2F0KHhpLGopIHtcbiAgICBmdW5jdGlvbiBzcXIoeCkgeyByZXR1cm4geCp4OyB9XG4gICAgdmFyIHNvbCA9IHRoaXM7XG4gICAgdmFyIHhzID0gc29sLng7XG4gICAgdmFyIHlzID0gc29sLnk7XG4gICAgdmFyIGsxID0gc29sLmY7XG4gICAgdmFyIHltaWQgPSBzb2wueW1pZDtcbiAgICB2YXIgbiA9IHhzLmxlbmd0aDtcbiAgICB2YXIgeDAseDEseGgseTAseTEseWgseGk7XG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcixoO1xuICAgIHZhciBjID0gMC41O1xuICAgIHZhciBhZGQgPSBudW1lcmljLmFkZCwgbXVsID0gbnVtZXJpYy5tdWwsc3ViID0gbnVtZXJpYy5zdWIsIHAscSx3O1xuICAgIHgwID0geHNbal07XG4gICAgeDEgPSB4c1tqKzFdO1xuICAgIHkwID0geXNbal07XG4gICAgeTEgPSB5c1tqKzFdO1xuICAgIGggID0geDEteDA7XG4gICAgeGggPSB4MCtjKmg7XG4gICAgeWggPSB5bWlkW2pdO1xuICAgIHAgPSBzdWIoazFbaiAgXSxtdWwoeTAsMS8oeDAteGgpKzIvKHgwLXgxKSkpO1xuICAgIHEgPSBzdWIoazFbaisxXSxtdWwoeTEsMS8oeDEteGgpKzIvKHgxLXgwKSkpO1xuICAgIHcgPSBbc3FyKHhpIC0geDEpICogKHhpIC0geGgpIC8gc3FyKHgwIC0geDEpIC8gKHgwIC0geGgpLFxuICAgICAgICAgc3FyKHhpIC0geDApICogc3FyKHhpIC0geDEpIC8gc3FyKHgwIC0geGgpIC8gc3FyKHgxIC0geGgpLFxuICAgICAgICAgc3FyKHhpIC0geDApICogKHhpIC0geGgpIC8gc3FyKHgxIC0geDApIC8gKHgxIC0geGgpLFxuICAgICAgICAgKHhpIC0geDApICogc3FyKHhpIC0geDEpICogKHhpIC0geGgpIC8gc3FyKHgwLXgxKSAvICh4MCAtIHhoKSxcbiAgICAgICAgICh4aSAtIHgxKSAqIHNxcih4aSAtIHgwKSAqICh4aSAtIHhoKSAvIHNxcih4MC14MSkgLyAoeDEgLSB4aCldO1xuICAgIHJldHVybiBhZGQoYWRkKGFkZChhZGQobXVsKHkwLHdbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsKHloLHdbMV0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bCh5MSx3WzJdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWwoIHAsd1szXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsKCBxLHdbNF0pKTtcbn1cbm51bWVyaWMuRG9wcmkucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQoeCkge1xuICAgIHZhciBpLGosayxmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgaWYodHlwZW9mIHggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmFyIG4gPSB4Lmxlbmd0aCwgcmV0ID0gQXJyYXkobik7XG4gICAgICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgICAgICByZXRbaV0gPSB0aGlzLmF0KHhbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHZhciB4MCA9IHRoaXMueDtcbiAgICBpID0gMDsgaiA9IHgwLmxlbmd0aC0xO1xuICAgIHdoaWxlKGotaT4xKSB7XG4gICAgICAgIGsgPSBmbG9vcigwLjUqKGkraikpO1xuICAgICAgICBpZih4MFtrXSA8PSB4KSBpID0gaztcbiAgICAgICAgZWxzZSBqID0gaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2F0KHgsaSk7XG59XG5cbm51bWVyaWMuZG9wcmkgPSBmdW5jdGlvbiBkb3ByaSh4MCx4MSx5MCxmLHRvbCxtYXhpdCxldmVudCkge1xuICAgIGlmKHR5cGVvZiB0b2wgPT09IFwidW5kZWZpbmVkXCIpIHsgdG9sID0gMWUtNjsgfVxuICAgIGlmKHR5cGVvZiBtYXhpdCA9PT0gXCJ1bmRlZmluZWRcIikgeyBtYXhpdCA9IDEwMDA7IH1cbiAgICB2YXIgeHMgPSBbeDBdLCB5cyA9IFt5MF0sIGsxID0gW2YoeDAseTApXSwgazIsazMsazQsazUsazYsazcsIHltaWQgPSBbXTtcbiAgICB2YXIgQTIgPSAxLzU7XG4gICAgdmFyIEEzID0gWzMvNDAsOS80MF07XG4gICAgdmFyIEE0ID0gWzQ0LzQ1LC01Ni8xNSwzMi85XTtcbiAgICB2YXIgQTUgPSBbMTkzNzIvNjU2MSwtMjUzNjAvMjE4Nyw2NDQ0OC82NTYxLC0yMTIvNzI5XTtcbiAgICB2YXIgQTYgPSBbOTAxNy8zMTY4LC0zNTUvMzMsNDY3MzIvNTI0Nyw0OS8xNzYsLTUxMDMvMTg2NTZdO1xuICAgIHZhciBiID0gWzM1LzM4NCwwLDUwMC8xMTEzLDEyNS8xOTIsLTIxODcvNjc4NCwxMS84NF07XG4gICAgdmFyIGJtID0gWzAuNSo2MDI1MTkyNzQzLzMwMDg1NTUzMTUyLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwLjUqNTEyNTIyOTI5MjUvNjU0MDA4MjE1OTgsXG4gICAgICAgICAgICAgIDAuNSotMjY5MTg2ODkyNS80NTEyODMyOTcyOCxcbiAgICAgICAgICAgICAgMC41KjE4Nzk0MDM3MjA2Ny8xNTk0NTM0MzE3MDU2LFxuICAgICAgICAgICAgICAwLjUqLTE3NzYwOTQzMzEvMTk3NDM2NDQyNTYsXG4gICAgICAgICAgICAgIDAuNSoxMTIzNzA5OS8yMzUwNDMzODRdO1xuICAgIHZhciBjID0gWzEvNSwzLzEwLDQvNSw4LzksMSwxXTtcbiAgICB2YXIgZSA9IFstNzEvNTc2MDAsMCw3MS8xNjY5NSwtNzEvMTkyMCwxNzI1My8zMzkyMDAsLTIyLzUyNSwxLzQwXTtcbiAgICB2YXIgaSA9IDAsZXIsajtcbiAgICB2YXIgaCA9ICh4MS14MCkvMTA7XG4gICAgdmFyIGl0ID0gMDtcbiAgICB2YXIgYWRkID0gbnVtZXJpYy5hZGQsIG11bCA9IG51bWVyaWMubXVsLCB5MSxlcmluZjtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgsIG1pbiA9IE1hdGgubWluLCBhYnMgPSBNYXRoLmFicywgbm9ybWluZiA9IG51bWVyaWMubm9ybWluZixwb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgYW55ID0gbnVtZXJpYy5hbnksIGx0ID0gbnVtZXJpYy5sdCwgYW5kID0gbnVtZXJpYy5hbmQsIHN1YiA9IG51bWVyaWMuc3ViO1xuICAgIHZhciBlMCwgZTEsIGV2O1xuICAgIHZhciByZXQgPSBuZXcgbnVtZXJpYy5Eb3ByaSh4cyx5cyxrMSx5bWlkLC0xLFwiXCIpO1xuICAgIGlmKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSBlMCA9IGV2ZW50KHgwLHkwKTtcbiAgICB3aGlsZSh4MDx4MSAmJiBpdDxtYXhpdCkge1xuICAgICAgICArK2l0O1xuICAgICAgICBpZih4MCtoPngxKSBoID0geDEteDA7XG4gICAgICAgIGsyID0gZih4MCtjWzBdKmgsICAgICAgICAgICAgICAgIGFkZCh5MCxtdWwoICAgQTIqaCxrMVtpXSkpKTtcbiAgICAgICAgazMgPSBmKHgwK2NbMV0qaCwgICAgICAgICAgICBhZGQoYWRkKHkwLG11bChBM1swXSpoLGsxW2ldKSksbXVsKEEzWzFdKmgsazIpKSk7XG4gICAgICAgIGs0ID0gZih4MCtjWzJdKmgsICAgICAgICBhZGQoYWRkKGFkZCh5MCxtdWwoQTRbMF0qaCxrMVtpXSkpLG11bChBNFsxXSpoLGsyKSksbXVsKEE0WzJdKmgsazMpKSk7XG4gICAgICAgIGs1ID0gZih4MCtjWzNdKmgsICAgIGFkZChhZGQoYWRkKGFkZCh5MCxtdWwoQTVbMF0qaCxrMVtpXSkpLG11bChBNVsxXSpoLGsyKSksbXVsKEE1WzJdKmgsazMpKSxtdWwoQTVbM10qaCxrNCkpKTtcbiAgICAgICAgazYgPSBmKHgwK2NbNF0qaCxhZGQoYWRkKGFkZChhZGQoYWRkKHkwLG11bChBNlswXSpoLGsxW2ldKSksbXVsKEE2WzFdKmgsazIpKSxtdWwoQTZbMl0qaCxrMykpLG11bChBNlszXSpoLGs0KSksbXVsKEE2WzRdKmgsazUpKSk7XG4gICAgICAgIHkxID0gYWRkKGFkZChhZGQoYWRkKGFkZCh5MCxtdWwoazFbaV0saCpiWzBdKSksbXVsKGszLGgqYlsyXSkpLG11bChrNCxoKmJbM10pKSxtdWwoazUsaCpiWzRdKSksbXVsKGs2LGgqYls1XSkpO1xuICAgICAgICBrNyA9IGYoeDAraCx5MSk7XG4gICAgICAgIGVyID0gYWRkKGFkZChhZGQoYWRkKGFkZChtdWwoazFbaV0saCplWzBdKSxtdWwoazMsaCplWzJdKSksbXVsKGs0LGgqZVszXSkpLG11bChrNSxoKmVbNF0pKSxtdWwoazYsaCplWzVdKSksbXVsKGs3LGgqZVs2XSkpO1xuICAgICAgICBpZih0eXBlb2YgZXIgPT09IFwibnVtYmVyXCIpIGVyaW5mID0gYWJzKGVyKTtcbiAgICAgICAgZWxzZSBlcmluZiA9IG5vcm1pbmYoZXIpO1xuICAgICAgICBpZihlcmluZiA+IHRvbCkgeyAvLyByZWplY3RcbiAgICAgICAgICAgIGggPSAwLjIqaCpwb3codG9sL2VyaW5mLDAuMjUpO1xuICAgICAgICAgICAgaWYoeDAraCA9PT0geDApIHtcbiAgICAgICAgICAgICAgICByZXQubXNnID0gXCJTdGVwIHNpemUgYmVjYW1lIHRvbyBzbWFsbFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgeW1pZFtpXSA9IGFkZChhZGQoYWRkKGFkZChhZGQoYWRkKHkwLFxuICAgICAgICAgICAgICAgIG11bChrMVtpXSxoKmJtWzBdKSksXG4gICAgICAgICAgICAgICAgbXVsKGszICAgLGgqYm1bMl0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazQgICAsaCpibVszXSkpLFxuICAgICAgICAgICAgICAgIG11bChrNSAgICxoKmJtWzRdKSksXG4gICAgICAgICAgICAgICAgbXVsKGs2ICAgLGgqYm1bNV0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazcgICAsaCpibVs2XSkpO1xuICAgICAgICArK2k7XG4gICAgICAgIHhzW2ldID0geDAraDtcbiAgICAgICAgeXNbaV0gPSB5MTtcbiAgICAgICAgazFbaV0gPSBrNztcbiAgICAgICAgaWYodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciB5aSx4bCA9IHgwLHhyID0geDArMC41KmgseGk7XG4gICAgICAgICAgICBlMSA9IGV2ZW50KHhyLHltaWRbaS0xXSk7XG4gICAgICAgICAgICBldiA9IGFuZChsdChlMCwwKSxsdCgwLGUxKSk7XG4gICAgICAgICAgICBpZighYW55KGV2KSkgeyB4bCA9IHhyOyB4ciA9IHgwK2g7IGUwID0gZTE7IGUxID0gZXZlbnQoeHIseTEpOyBldiA9IGFuZChsdChlMCwwKSxsdCgwLGUxKSk7IH1cbiAgICAgICAgICAgIGlmKGFueShldikpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGMsIHljLCBlbixlaTtcbiAgICAgICAgICAgICAgICB2YXIgc2lkZT0wLCBzbCA9IDEuMCwgc3IgPSAxLjA7XG4gICAgICAgICAgICAgICAgd2hpbGUoMSkge1xuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZTAgPT09IFwibnVtYmVyXCIpIHhpID0gKHNyKmUxKnhsLXNsKmUwKnhyKS8oc3IqZTEtc2wqZTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3Ioaj1lMC5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZTBbal08MCAmJiBlMVtqXT4wKSB4aSA9IG1pbih4aSwoc3IqZTFbal0qeGwtc2wqZTBbal0qeHIpLyhzciplMVtqXS1zbCplMFtqXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHhpIDw9IHhsIHx8IHhpID49IHhyKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgeWkgPSByZXQuX2F0KHhpLCBpLTEpO1xuICAgICAgICAgICAgICAgICAgICBlaSA9IGV2ZW50KHhpLHlpKTtcbiAgICAgICAgICAgICAgICAgICAgZW4gPSBhbmQobHQoZTAsMCksbHQoMCxlaSkpO1xuICAgICAgICAgICAgICAgICAgICBpZihhbnkoZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ciA9IHhpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZTEgPSBlaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ID0gZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBzciA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNpZGUgPT09IC0xKSBzbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHNsID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGwgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUwID0gZWk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbCA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNpZGUgPT09IDEpIHNyICo9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugc3IgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5MSA9IHJldC5fYXQoMC41Kih4MCt4aSksaS0xKTtcbiAgICAgICAgICAgICAgICByZXQuZltpXSA9IGYoeGkseWkpO1xuICAgICAgICAgICAgICAgIHJldC54W2ldID0geGk7XG4gICAgICAgICAgICAgICAgcmV0LnlbaV0gPSB5aTtcbiAgICAgICAgICAgICAgICByZXQueW1pZFtpLTFdID0geTE7XG4gICAgICAgICAgICAgICAgcmV0LmV2ZW50cyA9IGV2O1xuICAgICAgICAgICAgICAgIHJldC5pdGVyYXRpb25zID0gaXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4MCArPSBoO1xuICAgICAgICB5MCA9IHkxO1xuICAgICAgICBlMCA9IGUxO1xuICAgICAgICBoID0gbWluKDAuOCpoKnBvdyh0b2wvZXJpbmYsMC4yNSksNCpoKTtcbiAgICB9XG4gICAgcmV0Lml0ZXJhdGlvbnMgPSBpdDtcbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyAxMS4gQXggPSBiXG5udW1lcmljLkxVID0gZnVuY3Rpb24oQSwgZmFzdCkge1xuICBmYXN0ID0gZmFzdCB8fCBmYWxzZTtcblxuICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gIHZhciBpLCBqLCBrLCBhYnNBamssIEFraywgQWssIFBrLCBBaTtcbiAgdmFyIG1heDtcbiAgdmFyIG4gPSBBLmxlbmd0aCwgbjEgPSBuLTE7XG4gIHZhciBQID0gbmV3IEFycmF5KG4pO1xuICBpZighZmFzdCkgQSA9IG51bWVyaWMuY2xvbmUoQSk7XG5cbiAgZm9yIChrID0gMDsgayA8IG47ICsraykge1xuICAgIFBrID0gaztcbiAgICBBayA9IEFba107XG4gICAgbWF4ID0gYWJzKEFrW2tdKTtcbiAgICBmb3IgKGogPSBrICsgMTsgaiA8IG47ICsraikge1xuICAgICAgYWJzQWprID0gYWJzKEFbal1ba10pO1xuICAgICAgaWYgKG1heCA8IGFic0Fqaykge1xuICAgICAgICBtYXggPSBhYnNBams7XG4gICAgICAgIFBrID0gajtcbiAgICAgIH1cbiAgICB9XG4gICAgUFtrXSA9IFBrO1xuXG4gICAgaWYgKFBrICE9IGspIHtcbiAgICAgIEFba10gPSBBW1BrXTtcbiAgICAgIEFbUGtdID0gQWs7XG4gICAgICBBayA9IEFba107XG4gICAgfVxuXG4gICAgQWtrID0gQWtba107XG5cbiAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47ICsraSkge1xuICAgICAgQVtpXVtrXSAvPSBBa2s7XG4gICAgfVxuXG4gICAgZm9yIChpID0gayArIDE7IGkgPCBuOyArK2kpIHtcbiAgICAgIEFpID0gQVtpXTtcbiAgICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjE7ICsraikge1xuICAgICAgICBBaVtqXSAtPSBBaVtrXSAqIEFrW2pdO1xuICAgICAgICArK2o7XG4gICAgICAgIEFpW2pdIC09IEFpW2tdICogQWtbal07XG4gICAgICB9XG4gICAgICBpZihqPT09bjEpIEFpW2pdIC09IEFpW2tdICogQWtbal07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBMVTogQSxcbiAgICBQOiAgUFxuICB9O1xufVxuXG5udW1lcmljLkxVc29sdmUgPSBmdW5jdGlvbiBMVXNvbHZlKExVUCwgYikge1xuICB2YXIgaSwgajtcbiAgdmFyIExVID0gTFVQLkxVO1xuICB2YXIgbiAgID0gTFUubGVuZ3RoO1xuICB2YXIgeCA9IG51bWVyaWMuY2xvbmUoYik7XG4gIHZhciBQICAgPSBMVVAuUDtcbiAgdmFyIFBpLCBMVWksIExVaWksIHRtcDtcblxuICBmb3IgKGk9bi0xO2khPT0tMTstLWkpIHhbaV0gPSBiW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgUGkgPSBQW2ldO1xuICAgIGlmIChQW2ldICE9PSBpKSB7XG4gICAgICB0bXAgPSB4W2ldO1xuICAgICAgeFtpXSA9IHhbUGldO1xuICAgICAgeFtQaV0gPSB0bXA7XG4gICAgfVxuXG4gICAgTFVpID0gTFVbaV07XG4gICAgZm9yIChqID0gMDsgaiA8IGk7ICsraikge1xuICAgICAgeFtpXSAtPSB4W2pdICogTFVpW2pdO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgIExVaSA9IExVW2ldO1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICB4W2ldIC09IHhbal0gKiBMVWlbal07XG4gICAgfVxuXG4gICAgeFtpXSAvPSBMVWlbaV07XG4gIH1cblxuICByZXR1cm4geDtcbn1cblxubnVtZXJpYy5zb2x2ZSA9IGZ1bmN0aW9uIHNvbHZlKEEsYixmYXN0KSB7IHJldHVybiBudW1lcmljLkxVc29sdmUobnVtZXJpYy5MVShBLGZhc3QpLCBiKTsgfVxuXG4vLyAxMi4gTGluZWFyIHByb2dyYW1taW5nXG5udW1lcmljLmVjaGVsb25pemUgPSBmdW5jdGlvbiBlY2hlbG9uaXplKEEpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKEEpLCBtID0gc1swXSwgbiA9IHNbMV07XG4gICAgdmFyIEkgPSBudW1lcmljLmlkZW50aXR5KG0pO1xuICAgIHZhciBQID0gQXJyYXkobSk7XG4gICAgdmFyIGksaixrLGwsQWksSWksWixhO1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgZGl2ZXEgPSBudW1lcmljLmRpdmVxO1xuICAgIEEgPSBudW1lcmljLmNsb25lKEEpO1xuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBrID0gMDtcbiAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICBJaSA9IElbaV07XG4gICAgICAgIGZvcihqPTE7ajxuOysraikgaWYoYWJzKEFpW2tdKTxhYnMoQWlbal0pKSBrPWo7XG4gICAgICAgIFBbaV0gPSBrO1xuICAgICAgICBkaXZlcShJaSxBaVtrXSk7XG4gICAgICAgIGRpdmVxKEFpLEFpW2tdKTtcbiAgICAgICAgZm9yKGo9MDtqPG07KytqKSBpZihqIT09aSkge1xuICAgICAgICAgICAgWiA9IEFbal07IGEgPSBaW2tdO1xuICAgICAgICAgICAgZm9yKGw9bi0xO2whPT0tMTstLWwpIFpbbF0gLT0gQWlbbF0qYTtcbiAgICAgICAgICAgIFogPSBJW2pdO1xuICAgICAgICAgICAgZm9yKGw9bS0xO2whPT0tMTstLWwpIFpbbF0gLT0gSWlbbF0qYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge0k6SSwgQTpBLCBQOlB9O1xufVxuXG5udW1lcmljLl9fc29sdmVMUCA9IGZ1bmN0aW9uIF9fc29sdmVMUChjLEEsYix0b2wsbWF4aXQseCxmbGFnKSB7XG4gICAgdmFyIHN1bSA9IG51bWVyaWMuc3VtLCBsb2cgPSBudW1lcmljLmxvZywgbXVsID0gbnVtZXJpYy5tdWwsIHN1YiA9IG51bWVyaWMuc3ViLCBkb3QgPSBudW1lcmljLmRvdCwgZGl2ID0gbnVtZXJpYy5kaXYsIGFkZCA9IG51bWVyaWMuYWRkO1xuICAgIHZhciBtID0gYy5sZW5ndGgsIG4gPSBiLmxlbmd0aCx5O1xuICAgIHZhciB1bmJvdW5kZWQgPSBmYWxzZSwgY2IsaTA9MDtcbiAgICB2YXIgYWxwaGEgPSAxLjA7XG4gICAgdmFyIGYwLGRmMCxBVCA9IG51bWVyaWMudHJhbnNwb3NlKEEpLCBzdmQgPSBudW1lcmljLnN2ZCx0cmFuc3Bvc2UgPSBudW1lcmljLnRyYW5zcG9zZSxsZXEgPSBudW1lcmljLmxlcSwgc3FydCA9IE1hdGguc3FydCwgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIG11bGVxID0gbnVtZXJpYy5tdWxlcTtcbiAgICB2YXIgbm9ybSA9IG51bWVyaWMubm9ybWluZiwgYW55ID0gbnVtZXJpYy5hbnksbWluID0gTWF0aC5taW47XG4gICAgdmFyIGFsbCA9IG51bWVyaWMuYWxsLCBndCA9IG51bWVyaWMuZ3Q7XG4gICAgdmFyIHAgPSBBcnJheShtKSwgQTAgPSBBcnJheShuKSxlPW51bWVyaWMucmVwKFtuXSwxKSwgSDtcbiAgICB2YXIgc29sdmUgPSBudW1lcmljLnNvbHZlLCB6ID0gc3ViKGIsZG90KEEseCkpLGNvdW50O1xuICAgIHZhciBkb3RjYyA9IGRvdChjLGMpO1xuICAgIHZhciBnO1xuICAgIGZvcihjb3VudD1pMDtjb3VudDxtYXhpdDsrK2NvdW50KSB7XG4gICAgICAgIHZhciBpLGosZDtcbiAgICAgICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIEEwW2ldID0gZGl2KEFbaV0seltpXSk7XG4gICAgICAgIHZhciBBMSA9IHRyYW5zcG9zZShBMCk7XG4gICAgICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSBwW2ldID0gKC8qeFtpXSsqL3N1bShBMVtpXSkpO1xuICAgICAgICBhbHBoYSA9IDAuMjUqYWJzKGRvdGNjL2RvdChjLHApKTtcbiAgICAgICAgdmFyIGExID0gMTAwKnNxcnQoZG90Y2MvZG90KHAscCkpO1xuICAgICAgICBpZighaXNGaW5pdGUoYWxwaGEpIHx8IGFscGhhPmExKSBhbHBoYSA9IGExO1xuICAgICAgICBnID0gYWRkKGMsbXVsKGFscGhhLHApKTtcbiAgICAgICAgSCA9IGRvdChBMSxBMCk7XG4gICAgICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSBIW2ldW2ldICs9IDE7XG4gICAgICAgIGQgPSBzb2x2ZShILGRpdihnLGFscGhhKSx0cnVlKTtcbiAgICAgICAgdmFyIHQwID0gZGl2KHosZG90KEEsZCkpO1xuICAgICAgICB2YXIgdCA9IDEuMDtcbiAgICAgICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIGlmKHQwW2ldPDApIHQgPSBtaW4odCwtMC45OTkqdDBbaV0pO1xuICAgICAgICB5ID0gc3ViKHgsbXVsKGQsdCkpO1xuICAgICAgICB6ID0gc3ViKGIsZG90KEEseSkpO1xuICAgICAgICBpZighYWxsKGd0KHosMCkpKSByZXR1cm4geyBzb2x1dGlvbjogeCwgbWVzc2FnZTogXCJcIiwgaXRlcmF0aW9uczogY291bnQgfTtcbiAgICAgICAgeCA9IHk7XG4gICAgICAgIGlmKGFscGhhPHRvbCkgcmV0dXJuIHsgc29sdXRpb246IHksIG1lc3NhZ2U6IFwiXCIsIGl0ZXJhdGlvbnM6IGNvdW50IH07XG4gICAgICAgIGlmKGZsYWcpIHtcbiAgICAgICAgICAgIHZhciBzID0gZG90KGMsZyksIEFnID0gZG90KEEsZyk7XG4gICAgICAgICAgICB1bmJvdW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIGlmKHMqQWdbaV08MCkgeyB1bmJvdW5kZWQgPSBmYWxzZTsgYnJlYWs7IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHhbbS0xXT49MCkgdW5ib3VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIHVuYm91bmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYodW5ib3VuZGVkKSByZXR1cm4geyBzb2x1dGlvbjogeSwgbWVzc2FnZTogXCJVbmJvdW5kZWRcIiwgaXRlcmF0aW9uczogY291bnQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc29sdXRpb246IHgsIG1lc3NhZ2U6IFwibWF4aW11bSBpdGVyYXRpb24gY291bnQgZXhjZWVkZWRcIiwgaXRlcmF0aW9uczpjb3VudCB9O1xufVxuXG5udW1lcmljLl9zb2x2ZUxQID0gZnVuY3Rpb24gX3NvbHZlTFAoYyxBLGIsdG9sLG1heGl0KSB7XG4gICAgdmFyIG0gPSBjLmxlbmd0aCwgbiA9IGIubGVuZ3RoLHk7XG4gICAgdmFyIHN1bSA9IG51bWVyaWMuc3VtLCBsb2cgPSBudW1lcmljLmxvZywgbXVsID0gbnVtZXJpYy5tdWwsIHN1YiA9IG51bWVyaWMuc3ViLCBkb3QgPSBudW1lcmljLmRvdCwgZGl2ID0gbnVtZXJpYy5kaXYsIGFkZCA9IG51bWVyaWMuYWRkO1xuICAgIHZhciBjMCA9IG51bWVyaWMucmVwKFttXSwwKS5jb25jYXQoWzFdKTtcbiAgICB2YXIgSiA9IG51bWVyaWMucmVwKFtuLDFdLC0xKTtcbiAgICB2YXIgQTAgPSBudW1lcmljLmJsb2NrTWF0cml4KFtbQSAgICAgICAgICAgICAgICAgICAsICAgSiAgXV0pO1xuICAgIHZhciBiMCA9IGI7XG4gICAgdmFyIHkgPSBudW1lcmljLnJlcChbbV0sMCkuY29uY2F0KE1hdGgubWF4KDAsbnVtZXJpYy5zdXAobnVtZXJpYy5uZWcoYikpKSsxKTtcbiAgICB2YXIgeDAgPSBudW1lcmljLl9fc29sdmVMUChjMCxBMCxiMCx0b2wsbWF4aXQseSxmYWxzZSk7XG4gICAgdmFyIHggPSBudW1lcmljLmNsb25lKHgwLnNvbHV0aW9uKTtcbiAgICB4Lmxlbmd0aCA9IG07XG4gICAgdmFyIGZvbyA9IG51bWVyaWMuaW5mKHN1YihiLGRvdChBLHgpKSk7XG4gICAgaWYoZm9vPDApIHsgcmV0dXJuIHsgc29sdXRpb246IE5hTiwgbWVzc2FnZTogXCJJbmZlYXNpYmxlXCIsIGl0ZXJhdGlvbnM6IHgwLml0ZXJhdGlvbnMgfTsgfVxuICAgIHZhciByZXQgPSBudW1lcmljLl9fc29sdmVMUChjLCBBLCBiLCB0b2wsIG1heGl0LXgwLml0ZXJhdGlvbnMsIHgsIHRydWUpO1xuICAgIHJldC5pdGVyYXRpb25zICs9IHgwLml0ZXJhdGlvbnM7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbm51bWVyaWMuc29sdmVMUCA9IGZ1bmN0aW9uIHNvbHZlTFAoYyxBLGIsQWVxLGJlcSx0b2wsbWF4aXQpIHtcbiAgICBpZih0eXBlb2YgbWF4aXQgPT09IFwidW5kZWZpbmVkXCIpIG1heGl0ID0gMTAwMDtcbiAgICBpZih0eXBlb2YgdG9sID09PSBcInVuZGVmaW5lZFwiKSB0b2wgPSBudW1lcmljLmVwc2lsb247XG4gICAgaWYodHlwZW9mIEFlcSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bWVyaWMuX3NvbHZlTFAoYyxBLGIsdG9sLG1heGl0KTtcbiAgICB2YXIgbSA9IEFlcS5sZW5ndGgsIG4gPSBBZXFbMF0ubGVuZ3RoLCBvID0gQS5sZW5ndGg7XG4gICAgdmFyIEIgPSBudW1lcmljLmVjaGVsb25pemUoQWVxKTtcbiAgICB2YXIgZmxhZ3MgPSBudW1lcmljLnJlcChbbl0sMCk7XG4gICAgdmFyIFAgPSBCLlA7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgaTtcbiAgICBmb3IoaT1QLmxlbmd0aC0xO2khPT0tMTstLWkpIGZsYWdzW1BbaV1dID0gMTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgaWYoZmxhZ3NbaV09PT0wKSBRLnB1c2goaSk7XG4gICAgdmFyIGcgPSBudW1lcmljLmdldFJhbmdlO1xuICAgIHZhciBJID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSksIEogPSBudW1lcmljLmxpbnNwYWNlKDAsby0xKTtcbiAgICB2YXIgQWVxMiA9IGcoQWVxLEksUSksIEExID0gZyhBLEosUCksIEEyID0gZyhBLEosUSksIGRvdCA9IG51bWVyaWMuZG90LCBzdWIgPSBudW1lcmljLnN1YjtcbiAgICB2YXIgQTMgPSBkb3QoQTEsQi5JKTtcbiAgICB2YXIgQTQgPSBzdWIoQTIsZG90KEEzLEFlcTIpKSwgYjQgPSBzdWIoYixkb3QoQTMsYmVxKSk7XG4gICAgdmFyIGMxID0gQXJyYXkoUC5sZW5ndGgpLCBjMiA9IEFycmF5KFEubGVuZ3RoKTtcbiAgICBmb3IoaT1QLmxlbmd0aC0xO2khPT0tMTstLWkpIGMxW2ldID0gY1tQW2ldXTtcbiAgICBmb3IoaT1RLmxlbmd0aC0xO2khPT0tMTstLWkpIGMyW2ldID0gY1tRW2ldXTtcbiAgICB2YXIgYzQgPSBzdWIoYzIsZG90KGMxLGRvdChCLkksQWVxMikpKTtcbiAgICB2YXIgUyA9IG51bWVyaWMuX3NvbHZlTFAoYzQsQTQsYjQsdG9sLG1heGl0KTtcbiAgICB2YXIgeDIgPSBTLnNvbHV0aW9uO1xuICAgIGlmKHgyIT09eDIpIHJldHVybiBTO1xuICAgIHZhciB4MSA9IGRvdChCLkksc3ViKGJlcSxkb3QoQWVxMix4MikpKTtcbiAgICB2YXIgeCA9IEFycmF5KGMubGVuZ3RoKTtcbiAgICBmb3IoaT1QLmxlbmd0aC0xO2khPT0tMTstLWkpIHhbUFtpXV0gPSB4MVtpXTtcbiAgICBmb3IoaT1RLmxlbmd0aC0xO2khPT0tMTstLWkpIHhbUVtpXV0gPSB4MltpXTtcbiAgICByZXR1cm4geyBzb2x1dGlvbjogeCwgbWVzc2FnZTpTLm1lc3NhZ2UsIGl0ZXJhdGlvbnM6IFMuaXRlcmF0aW9ucyB9O1xufVxuXG5udW1lcmljLk1QU3RvTFAgPSBmdW5jdGlvbiBNUFN0b0xQKE1QUykge1xuICAgIGlmKE1QUyBpbnN0YW5jZW9mIFN0cmluZykgeyBNUFMuc3BsaXQoJ1xcbicpOyB9XG4gICAgdmFyIHN0YXRlID0gMDtcbiAgICB2YXIgc3RhdGVzID0gWydJbml0aWFsIHN0YXRlJywnTkFNRScsJ1JPV1MnLCdDT0xVTU5TJywnUkhTJywnQk9VTkRTJywnRU5EQVRBJ107XG4gICAgdmFyIG4gPSBNUFMubGVuZ3RoO1xuICAgIHZhciBpLGoseixOPTAscm93cyA9IHt9LCBzaWduID0gW10sIHJsID0gMCwgdmFycyA9IHt9LCBudiA9IDA7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIGMgPSBbXSwgQSA9IFtdLCBiID0gW107XG4gICAgZnVuY3Rpb24gZXJyKGUpIHsgdGhyb3cgbmV3IEVycm9yKCdNUFN0b0xQOiAnK2UrJ1xcbkxpbmUgJytpKyc6ICcrTVBTW2ldKydcXG5DdXJyZW50IHN0YXRlOiAnK3N0YXRlc1tzdGF0ZV0rJ1xcbicpOyB9XG4gICAgZm9yKGk9MDtpPG47KytpKSB7XG4gICAgICAgIHogPSBNUFNbaV07XG4gICAgICAgIHZhciB3MCA9IHoubWF0Y2goL1xcUyovZyk7XG4gICAgICAgIHZhciB3ID0gW107XG4gICAgICAgIGZvcihqPTA7ajx3MC5sZW5ndGg7KytqKSBpZih3MFtqXSE9PVwiXCIpIHcucHVzaCh3MFtqXSk7XG4gICAgICAgIGlmKHcubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgZm9yKGo9MDtqPHN0YXRlcy5sZW5ndGg7KytqKSBpZih6LnN1YnN0cigwLHN0YXRlc1tqXS5sZW5ndGgpID09PSBzdGF0ZXNbal0pIGJyZWFrO1xuICAgICAgICBpZihqPHN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXRlID0gajtcbiAgICAgICAgICAgIGlmKGo9PT0xKSB7IG5hbWUgPSB3WzFdOyB9XG4gICAgICAgICAgICBpZihqPT09NikgcmV0dXJuIHsgbmFtZTpuYW1lLCBjOmMsIEE6bnVtZXJpYy50cmFuc3Bvc2UoQSksIGI6Yiwgcm93czpyb3dzLCB2YXJzOnZhcnMgfTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChzdGF0ZSkge1xuICAgICAgICBjYXNlIDA6IGNhc2UgMTogZXJyKCdVbmV4cGVjdGVkIGxpbmUnKTtcbiAgICAgICAgY2FzZSAyOiBcbiAgICAgICAgICAgIHN3aXRjaCh3WzBdKSB7XG4gICAgICAgICAgICBjYXNlICdOJzogaWYoTj09PTApIE4gPSB3WzFdOyBlbHNlIGVycignVHdvIG9yIG1vcmUgTiByb3dzJyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTCc6IHJvd3Nbd1sxXV0gPSBybDsgc2lnbltybF0gPSAxOyBiW3JsXSA9IDA7ICsrcmw7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRyc6IHJvd3Nbd1sxXV0gPSBybDsgc2lnbltybF0gPSAtMTtiW3JsXSA9IDA7ICsrcmw7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRSc6IHJvd3Nbd1sxXV0gPSBybDsgc2lnbltybF0gPSAwO2JbcmxdID0gMDsgKytybDsgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiBlcnIoJ1BhcnNlIGVycm9yICcrbnVtZXJpYy5wcmV0dHlQcmludCh3KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYoIXZhcnMuaGFzT3duUHJvcGVydHkod1swXSkpIHsgdmFyc1t3WzBdXSA9IG52OyBjW252XSA9IDA7IEFbbnZdID0gbnVtZXJpYy5yZXAoW3JsXSwwKTsgKytudjsgfVxuICAgICAgICAgICAgdmFyIHAgPSB2YXJzW3dbMF1dO1xuICAgICAgICAgICAgZm9yKGo9MTtqPHcubGVuZ3RoO2orPTIpIHtcbiAgICAgICAgICAgICAgICBpZih3W2pdID09PSBOKSB7IGNbcF0gPSBwYXJzZUZsb2F0KHdbaisxXSk7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgdmFyIHEgPSByb3dzW3dbal1dO1xuICAgICAgICAgICAgICAgIEFbcF1bcV0gPSAoc2lnbltxXTwwPy0xOjEpKnBhcnNlRmxvYXQod1tqKzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBmb3Ioaj0xO2o8dy5sZW5ndGg7ais9MikgYltyb3dzW3dbal1dXSA9IChzaWduW3Jvd3Nbd1tqXV1dPDA/LTE6MSkqcGFyc2VGbG9hdCh3W2orMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTogLypGSVhNRSovIGJyZWFrO1xuICAgICAgICBjYXNlIDY6IGVycignSW50ZXJuYWwgZXJyb3InKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnIoJ1JlYWNoZWQgZW5kIG9mIGZpbGUgd2l0aG91dCBFTkRBVEEnKTtcbn1cbi8vIHNlZWRyYW5kb20uanMgdmVyc2lvbiAyLjAuXG4vLyBBdXRob3I6IERhdmlkIEJhdSA0LzIvMjAxMVxuLy9cbi8vIERlZmluZXMgYSBtZXRob2QgTWF0aC5zZWVkcmFuZG9tKCkgdGhhdCwgd2hlbiBjYWxsZWQsIHN1YnN0aXR1dGVzXG4vLyBhbiBleHBsaWNpdGx5IHNlZWRlZCBSQzQtYmFzZWQgYWxnb3JpdGhtIGZvciBNYXRoLnJhbmRvbSgpLiAgQWxzb1xuLy8gc3VwcG9ydHMgYXV0b21hdGljIHNlZWRpbmcgZnJvbSBsb2NhbCBvciBuZXR3b3JrIHNvdXJjZXMgb2YgZW50cm9weS5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyAgIDxzY3JpcHQgc3JjPWh0dHA6Ly9kYXZpZGJhdS5jb20vZW5jb2RlL3NlZWRyYW5kb20tbWluLmpzPjwvc2NyaXB0PlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKCd5aXBlZScpOyBTZXRzIE1hdGgucmFuZG9tIHRvIGEgZnVuY3Rpb24gdGhhdCBpc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkIHVzaW5nIHRoZSBnaXZlbiBleHBsaWNpdCBzZWVkLlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKCk7ICAgICAgICBTZXRzIE1hdGgucmFuZG9tIHRvIGEgZnVuY3Rpb24gdGhhdCBpc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRlZCB1c2luZyB0aGUgY3VycmVudCB0aW1lLCBkb20gc3RhdGUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIG90aGVyIGFjY3VtdWxhdGVkIGxvY2FsIGVudHJvcHkuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGdlbmVyYXRlZCBzZWVkIHN0cmluZyBpcyByZXR1cm5lZC5cbi8vXG4vLyAgIE1hdGguc2VlZHJhbmRvbSgneW93emEnLCB0cnVlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWVkcyB1c2luZyB0aGUgZ2l2ZW4gZXhwbGljaXQgc2VlZCBtaXhlZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2V0aGVyIHdpdGggYWNjdW11bGF0ZWQgZW50cm9weS5cbi8vXG4vLyAgIDxzY3JpcHQgc3JjPVwiaHR0cDovL2JpdC5seS9zcmFuZG9tLTUxMlwiPjwvc2NyaXB0PlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZWRzIHVzaW5nIHBoeXNpY2FsIHJhbmRvbSBiaXRzIGRvd25sb2FkZWRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHJhbmRvbS5vcmcuXG4vL1xuLy8gICA8c2NyaXB0IHNyYz1cImh0dHBzOi8vanNvbmxpYi5hcHBzcG90LmNvbS91cmFuZG9tP2NhbGxiYWNrPU1hdGguc2VlZHJhbmRvbVwiPlxuLy8gICA8L3NjcmlwdD4gICAgICAgICAgICAgICAgIFNlZWRzIHVzaW5nIHVyYW5kb20gYml0cyBmcm9tIGNhbGwuanNvbmxpYi5jb20sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggaXMgZmFzdGVyIHRoYW4gcmFuZG9tLm9yZy5cbi8vXG4vLyBFeGFtcGxlczpcbi8vXG4vLyAgIE1hdGguc2VlZHJhbmRvbShcImhlbGxvXCIpOyAgICAgICAgICAgIC8vIFVzZSBcImhlbGxvXCIgYXMgdGhlIHNlZWQuXG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBBbHdheXMgMC41NDYzNjYzNzY4MTQwNzM0XG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBBbHdheXMgMC40Mzk3Mzc5Mzc3MDU5MjIzNFxuLy8gICB2YXIgcm5nMSA9IE1hdGgucmFuZG9tOyAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGN1cnJlbnQgcHJuZy5cbi8vXG4vLyAgIHZhciBhdXRvc2VlZCA9IE1hdGguc2VlZHJhbmRvbSgpOyAgICAvLyBOZXcgcHJuZyB3aXRoIGFuIGF1dG9tYXRpYyBzZWVkLlxuLy8gICBkb2N1bWVudC53cml0ZShNYXRoLnJhbmRvbSgpKTsgICAgICAgLy8gUHJldHR5IG11Y2ggdW5wcmVkaWN0YWJsZS5cbi8vXG4vLyAgIE1hdGgucmFuZG9tID0gcm5nMTsgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBcImhlbGxvXCIgcHJuZyBzZXF1ZW5jZS5cbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIEFsd2F5cyAwLjU1NDc2OTQzMjQ3MzQ1NVxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKGF1dG9zZWVkKTsgICAgICAgICAgIC8vIFJlc3RhcnQgYXQgdGhlIHByZXZpb3VzIHNlZWQuXG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBSZXBlYXQgdGhlICd1bnByZWRpY3RhYmxlJyB2YWx1ZS5cbi8vXG4vLyBOb3Rlczpcbi8vXG4vLyBFYWNoIHRpbWUgc2VlZHJhbmRvbSgnYXJnJykgaXMgY2FsbGVkLCBlbnRyb3B5IGZyb20gdGhlIHBhc3NlZCBzZWVkXG4vLyBpcyBhY2N1bXVsYXRlZCBpbiBhIHBvb2wgdG8gaGVscCBnZW5lcmF0ZSBmdXR1cmUgc2VlZHMgZm9yIHRoZVxuLy8gemVyby1hcmd1bWVudCBmb3JtIG9mIE1hdGguc2VlZHJhbmRvbSwgc28gZW50cm9weSBjYW4gYmUgaW5qZWN0ZWQgb3ZlclxuLy8gdGltZSBieSBjYWxsaW5nIHNlZWRyYW5kb20gd2l0aCBleHBsaWNpdCBkYXRhIHJlcGVhdGVkbHkuXG4vL1xuLy8gT24gc3BlZWQgLSBUaGlzIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgTWF0aC5yYW5kb20oKSBpcyBhYm91dFxuLy8gMy0xMHggc2xvd2VyIHRoYW4gdGhlIGJ1aWx0LWluIE1hdGgucmFuZG9tKCkgYmVjYXVzZSBpdCBpcyBub3QgbmF0aXZlXG4vLyBjb2RlLCBidXQgdGhpcyBpcyB0eXBpY2FsbHkgZmFzdCBlbm91Z2ggYW55d2F5LiAgU2VlZGluZyBpcyBtb3JlIGV4cGVuc2l2ZSxcbi8vIGVzcGVjaWFsbHkgaWYgeW91IHVzZSBhdXRvLXNlZWRpbmcuICBTb21lIGRldGFpbHMgKHRpbWluZ3Mgb24gQ2hyb21lIDQpOlxuLy9cbi8vIE91ciBNYXRoLnJhbmRvbSgpICAgICAgICAgICAgLSBhdmcgbGVzcyB0aGFuIDAuMDAyIG1pbGxpc2Vjb25kcyBwZXIgY2FsbFxuLy8gc2VlZHJhbmRvbSgnZXhwbGljaXQnKSAgICAgICAtIGF2ZyBsZXNzIHRoYW4gMC41IG1pbGxpc2Vjb25kcyBwZXIgY2FsbFxuLy8gc2VlZHJhbmRvbSgnZXhwbGljaXQnLCB0cnVlKSAtIGF2ZyBsZXNzIHRoYW4gMiBtaWxsaXNlY29uZHMgcGVyIGNhbGxcbi8vIHNlZWRyYW5kb20oKSAgICAgICAgICAgICAgICAgLSBhdmcgYWJvdXQgMzggbWlsbGlzZWNvbmRzIHBlciBjYWxsXG4vL1xuLy8gTElDRU5TRSAoQlNEKTpcbi8vXG4vLyBDb3B5cmlnaHQgMjAxMCBEYXZpZCBCYXUsIGFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbi8vIFxuLy8gICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vL1xuLy8gICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4vLyAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vLyBcbi8vICAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGlzIG1vZHVsZSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4vLyAgICAgIGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4vLyAgICAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vL1xuLyoqXG4gKiBBbGwgY29kZSBpcyBpbiBhbiBhbm9ueW1vdXMgY2xvc3VyZSB0byBrZWVwIHRoZSBnbG9iYWwgbmFtZXNwYWNlIGNsZWFuLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3ZlcmZsb3cgXG4gKiBAcGFyYW0ge251bWJlcj19IHN0YXJ0ZGVub21cbiAqL1xuXG4vLyBQYXRjaGVkIGJ5IFNlYiBzbyB0aGF0IHNlZWRyYW5kb20uanMgZG9lcyBub3QgcG9sbHV0ZSB0aGUgTWF0aCBvYmplY3QuXG4vLyBNeSB0ZXN0cyBzdWdnZXN0IHRoYXQgZG9pbmcgTWF0aC50cm91YmxlID0gMSBtYWtlcyBNYXRoIGxvb2t1cHMgYWJvdXQgNSVcbi8vIHNsb3dlci5cbm51bWVyaWMuc2VlZHJhbmRvbSA9IHsgcG93Ok1hdGgucG93LCByYW5kb206TWF0aC5yYW5kb20gfTtcblxuKGZ1bmN0aW9uIChwb29sLCBtYXRoLCB3aWR0aCwgY2h1bmtzLCBzaWduaWZpY2FuY2UsIG92ZXJmbG93LCBzdGFydGRlbm9tKSB7XG5cblxuLy9cbi8vIHNlZWRyYW5kb20oKVxuLy8gVGhpcyBpcyB0aGUgc2VlZHJhbmRvbSBmdW5jdGlvbiBkZXNjcmliZWQgYWJvdmUuXG4vL1xubWF0aFsnc2VlZHJhbmRvbSddID0gZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCB1c2VfZW50cm9weSkge1xuICB2YXIga2V5ID0gW107XG4gIHZhciBhcmM0O1xuXG4gIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuICBzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXG4gICAgdXNlX2VudHJvcHkgPyBbc2VlZCwgcG9vbF0gOlxuICAgIGFyZ3VtZW50cy5sZW5ndGggPyBzZWVkIDpcbiAgICBbbmV3IERhdGUoKS5nZXRUaW1lKCksIHBvb2wsIHdpbmRvd10sIDMpLCBrZXkpO1xuXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcblxuICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuICBtaXhrZXkoYXJjNC5TLCBwb29sKTtcblxuICAvLyBPdmVycmlkZSBNYXRoLnJhbmRvbVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcbiAgLy8gcmFuZG9tbmVzcyBpbiBldmVyeSBiaXQgb2YgdGhlIG1hbnRpc3NhIG9mIHRoZSBJRUVFIDc1NCB2YWx1ZS5cblxuICBtYXRoWydyYW5kb20nXSA9IGZ1bmN0aW9uIHJhbmRvbSgpIHsgIC8vIENsb3N1cmUgdG8gcmV0dXJuIGEgcmFuZG9tIGRvdWJsZTpcbiAgICB2YXIgbiA9IGFyYzQuZyhjaHVua3MpOyAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICB2YXIgZCA9IHN0YXJ0ZGVub207ICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgIHZhciB4ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxuICAgIHdoaWxlIChuIDwgc2lnbmlmaWNhbmNlKSB7ICAgICAgICAgIC8vIEZpbGwgdXAgYWxsIHNpZ25pZmljYW50IGRpZ2l0cyBieVxuICAgICAgbiA9IChuICsgeCkgKiB3aWR0aDsgICAgICAgICAgICAgIC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxuICAgICAgZCAqPSB3aWR0aDsgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuICAgICAgeCA9IGFyYzQuZygxKTsgICAgICAgICAgICAgICAgICAgIC8vICAgbmV3IGxlYXN0LXNpZ25pZmljYW50LWJ5dGUuXG4gICAgfVxuICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7ICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJvdW5kaW5nIHVwLCBiZWZvcmUgYWRkaW5nXG4gICAgICBuIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcbiAgICAgIGQgLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJpZ2h0IHVzaW5nIGludGVnZXIgbWF0aCB1bnRpbFxuICAgICAgeCA+Pj49IDE7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXG4gICAgfVxuICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgc2VlZCB0aGF0IHdhcyB1c2VkXG4gIHJldHVybiBzZWVkO1xufTtcblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbi8qKiBAY29uc3RydWN0b3IgKi9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCB1LCBtZSA9IHRoaXMsIGtleWxlbiA9IGtleS5sZW5ndGg7XG4gIHZhciBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gbWUubSA9IDA7XG4gIG1lLlMgPSBbXTtcbiAgbWUuYyA9IFtdO1xuXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG4gIGlmICgha2V5bGVuKSB7IGtleSA9IFtrZXlsZW4rK107IH1cblxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuICB3aGlsZSAoaSA8IHdpZHRoKSB7IG1lLlNbaV0gPSBpKys7IH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICB0ID0gbWUuU1tpXTtcbiAgICBqID0gbG93Yml0cyhqICsgdCArIGtleVtpICUga2V5bGVuXSk7XG4gICAgdSA9IG1lLlNbal07XG4gICAgbWUuU1tpXSA9IHU7XG4gICAgbWUuU1tqXSA9IHQ7XG4gIH1cblxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG4gIG1lLmcgPSBmdW5jdGlvbiBnZXRuZXh0KGNvdW50KSB7XG4gICAgdmFyIHMgPSBtZS5TO1xuICAgIHZhciBpID0gbG93Yml0cyhtZS5pICsgMSk7IHZhciB0ID0gc1tpXTtcbiAgICB2YXIgaiA9IGxvd2JpdHMobWUuaiArIHQpOyB2YXIgdSA9IHNbal07XG4gICAgc1tpXSA9IHU7XG4gICAgc1tqXSA9IHQ7XG4gICAgdmFyIHIgPSBzW2xvd2JpdHModCArIHUpXTtcbiAgICB3aGlsZSAoLS1jb3VudCkge1xuICAgICAgaSA9IGxvd2JpdHMoaSArIDEpOyB0ID0gc1tpXTtcbiAgICAgIGogPSBsb3diaXRzKGogKyB0KTsgdSA9IHNbal07XG4gICAgICBzW2ldID0gdTtcbiAgICAgIHNbal0gPSB0O1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbG93Yml0cyh0ICsgdSldO1xuICAgIH1cbiAgICBtZS5pID0gaTtcbiAgICBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgfTtcbiAgLy8gRm9yIHJvYnVzdCB1bnByZWRpY3RhYmlsaXR5IGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiB2YWx1ZXMuXG4gIC8vIFNlZSBodHRwOi8vd3d3LnJzYS5jb20vcnNhbGFicy9ub2RlLmFzcD9pZD0yMDA5XG4gIG1lLmcod2lkdGgpO1xufVxuXG4vL1xuLy8gZmxhdHRlbigpXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXG4vL1xuLyoqIEBwYXJhbSB7T2JqZWN0PX0gcmVzdWx0IFxuICAqIEBwYXJhbSB7c3RyaW5nPX0gcHJvcFxuICAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwICovXG5mdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgsIHJlc3VsdCwgcHJvcCwgdHlwKSB7XG4gIHJlc3VsdCA9IFtdO1xuICB0eXAgPSB0eXBlb2Yob2JqKTtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChwcm9wLmluZGV4T2YoJ1MnKSA8IDUpIHsgICAgLy8gQXZvaWQgRkYzIGJ1ZyAobG9jYWwvc2Vzc2lvblN0b3JhZ2UpXG4gICAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogb2JqICsgKHR5cCAhPSAnc3RyaW5nJyA/ICdcXDAnIDogJycpKTtcbn1cblxuLy9cbi8vIG1peGtleSgpXG4vLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXG4vLyByZXR1cm5zIGEgc2hvcnRlbmVkIHN0cmluZyBzZWVkIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGUgcmVzdWx0IGtleS5cbi8vXG4vKiogQHBhcmFtIHtudW1iZXI9fSBzbWVhciBcbiAgKiBAcGFyYW0ge251bWJlcj19IGogKi9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXksIHNtZWFyLCBqKSB7XG4gIHNlZWQgKz0gJyc7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgc2VlZCBpcyBhIHN0cmluZ1xuICBzbWVhciA9IDA7XG4gIGZvciAoaiA9IDA7IGogPCBzZWVkLmxlbmd0aDsgaisrKSB7XG4gICAga2V5W2xvd2JpdHMoaildID1cbiAgICAgIGxvd2JpdHMoKHNtZWFyIF49IGtleVtsb3diaXRzKGopXSAqIDE5KSArIHNlZWQuY2hhckNvZGVBdChqKSk7XG4gIH1cbiAgc2VlZCA9ICcnO1xuICBmb3IgKGogaW4ga2V5KSB7IHNlZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlbal0pOyB9XG4gIHJldHVybiBzZWVkO1xufVxuXG4vL1xuLy8gbG93Yml0cygpXG4vLyBBIHF1aWNrIFwibiBtb2Qgd2lkdGhcIiBmb3Igd2lkdGggYSBwb3dlciBvZiAyLlxuLy9cbmZ1bmN0aW9uIGxvd2JpdHMobikgeyByZXR1cm4gbiAmICh3aWR0aCAtIDEpOyB9XG5cbi8vXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXG4vL1xuc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpO1xuc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgc2lnbmlmaWNhbmNlKTtcbm92ZXJmbG93ID0gc2lnbmlmaWNhbmNlICogMjtcblxuLy9cbi8vIFdoZW4gc2VlZHJhbmRvbS5qcyBpcyBsb2FkZWQsIHdlIGltbWVkaWF0ZWx5IG1peCBhIGZldyBiaXRzXG4vLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuLy8gbm90IHdhbnQgdG8gaW50ZWZlcmUgd2l0aCBkZXRlcm1pbnN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4vLyBpbml0aWFsaXphdGlvbi5cbi8vXG5taXhrZXkobWF0aC5yYW5kb20oKSwgcG9vbCk7XG5cbi8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxufShcbiAgW10sICAgLy8gcG9vbDogZW50cm9weSBwb29sIHN0YXJ0cyBlbXB0eVxuICBudW1lcmljLnNlZWRyYW5kb20sIC8vIG1hdGg6IHBhY2thZ2UgY29udGFpbmluZyByYW5kb20sIHBvdywgYW5kIHNlZWRyYW5kb21cbiAgMjU2LCAgLy8gd2lkdGg6IGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgNiwgICAgLy8gY2h1bmtzOiBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gIDUyICAgIC8vIHNpZ25pZmljYW5jZTogdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICApKTtcbi8qIFRoaXMgZmlsZSBpcyBhIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgcXVhZHByb2cuanMgZnJvbSBBbGJlcnRvIFNhbnRpbmkuXG4gKiBJdCBoYXMgYmVlbiBzbGlnaHRseSBtb2RpZmllZCBieSBTw6liYXN0aWVuIExvaXNlbCB0byBtYWtlIHN1cmUgdGhhdCBpdCBoYW5kbGVzXG4gKiAwLWJhc2VkIEFycmF5cyBpbnN0ZWFkIG9mIDEtYmFzZWQgQXJyYXlzLlxuICogTGljZW5zZSBpcyBpbiByZXNvdXJjZXMvTElDRU5TRS5xdWFkcHJvZyAqL1xuKGZ1bmN0aW9uKGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gYmFzZTB0bzEoQSkge1xuICAgIGlmKHR5cGVvZiBBICE9PSBcIm9iamVjdFwiKSB7IHJldHVybiBBOyB9XG4gICAgdmFyIHJldCA9IFtdLCBpLG49QS5sZW5ndGg7XG4gICAgZm9yKGk9MDtpPG47aSsrKSByZXRbaSsxXSA9IGJhc2UwdG8xKEFbaV0pO1xuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBiYXNlMXRvMChBKSB7XG4gICAgaWYodHlwZW9mIEEgIT09IFwib2JqZWN0XCIpIHsgcmV0dXJuIEE7IH1cbiAgICB2YXIgcmV0ID0gW10sIGksbj1BLmxlbmd0aDtcbiAgICBmb3IoaT0xO2k8bjtpKyspIHJldFtpLTFdID0gYmFzZTF0bzAoQVtpXSk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZHBvcmkoYSwgbGRhLCBuKSB7XG4gICAgdmFyIGksIGosIGssIGtwMSwgdDtcblxuICAgIGZvciAoayA9IDE7IGsgPD0gbjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGFba11ba10gPSAxIC8gYVtrXVtrXTtcbiAgICAgICAgdCA9IC1hW2tdW2tdO1xuICAgICAgICAvL34gZHNjYWwoayAtIDEsIHQsIGFbMV1ba10sIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBhW2ldW2tdID0gdCAqIGFbaV1ba107XG4gICAgICAgIH1cblxuICAgICAgICBrcDEgPSBrICsgMTtcbiAgICAgICAgaWYgKG4gPCBrcDEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IGtwMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIHQgPSBhW2tdW2pdO1xuICAgICAgICAgICAgYVtrXVtqXSA9IDA7XG4gICAgICAgICAgICAvL34gZGF4cHkoaywgdCwgYVsxXVtrXSwgMSwgYVsxXVtqXSwgMSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIGFbaV1bal0gPSBhW2ldW2pdICsgKHQgKiBhW2ldW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBkcG9zbChhLCBsZGEsIG4sIGIpIHtcbiAgICB2YXIgaSwgaywga2IsIHQ7XG5cbiAgICBmb3IgKGsgPSAxOyBrIDw9IG47IGsgPSBrICsgMSkge1xuICAgICAgICAvL34gdCA9IGRkb3QoayAtIDEsIGFbMV1ba10sIDEsIGJbMV0sIDEpO1xuICAgICAgICB0ID0gMDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgdCA9IHQgKyAoYVtpXVtrXSAqIGJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYltrXSA9IChiW2tdIC0gdCkgLyBhW2tdW2tdO1xuICAgIH1cblxuICAgIGZvciAoa2IgPSAxOyBrYiA8PSBuOyBrYiA9IGtiICsgMSkge1xuICAgICAgICBrID0gbiArIDEgLSBrYjtcbiAgICAgICAgYltrXSA9IGJba10gLyBhW2tdW2tdO1xuICAgICAgICB0ID0gLWJba107XG4gICAgICAgIC8vfiBkYXhweShrIC0gMSwgdCwgYVsxXVtrXSwgMSwgYlsxXSwgMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBrOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGJbaV0gPSBiW2ldICsgKHQgKiBhW2ldW2tdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZHBvZmEoYSwgbGRhLCBuLCBpbmZvKSB7XG4gICAgdmFyIGksIGosIGptMSwgaywgdCwgcztcblxuICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgIGluZm9bMV0gPSBqO1xuICAgICAgICBzID0gMDtcbiAgICAgICAgam0xID0gaiAtIDE7XG4gICAgICAgIGlmIChqbTEgPCAxKSB7XG4gICAgICAgICAgICBzID0gYVtqXVtqXSAtIHM7XG4gICAgICAgICAgICBpZiAocyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2pdW2pdID0gTWF0aC5zcXJ0KHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMTsgayA8PSBqbTE7IGsgPSBrICsgMSkge1xuICAgICAgICAgICAgICAgIC8vfiB0ID0gYVtrXVtqXSAtIGRkb3QoayAtIDEsIGFbMV1ba10sIDEsIGFbMV1bal0sIDEpO1xuICAgICAgICAgICAgICAgIHQgPSBhW2tdW2pdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBrOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHQgLSAoYVtpXVtqXSAqIGFbaV1ba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ID0gdCAvIGFba11ba107XG4gICAgICAgICAgICAgICAgYVtrXVtqXSA9IHQ7XG4gICAgICAgICAgICAgICAgcyA9IHMgKyB0ICogdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBhW2pdW2pdIC0gcztcbiAgICAgICAgICAgIGlmIChzIDw9IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbal1bal0gPSBNYXRoLnNxcnQocyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5mb1sxXSA9IDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBxcGdlbjIoZG1hdCwgZHZlYywgZmRkbWF0LCBuLCBzb2wsIGNydmFsLCBhbWF0LFxuICAgIGJ2ZWMsIGZkYW1hdCwgcSwgbWVxLCBpYWN0LCBuYWN0LCBpdGVyLCB3b3JrLCBpZXJyKSB7XG5cbiAgICB2YXIgaSwgaiwgbCwgbDEsIGluZm8sIGl0MSwgaXd6diwgaXdydiwgaXdybSwgaXdzdiwgaXd1diwgbnZsLCByLCBpd25idixcbiAgICAgICAgdGVtcCwgc3VtLCB0MSwgdHQsIGdjLCBncywgbnUsXG4gICAgICAgIHQxaW5mLCB0Mm1pbixcbiAgICAgICAgdnNtYWxsLCB0bXBhLCB0bXBiLFxuICAgICAgICBnbztcblxuICAgIHIgPSBNYXRoLm1pbihuLCBxKTtcbiAgICBsID0gMiAqIG4gKyAociAqIChyICsgNSkpIC8gMiArIDIgKiBxICsgMTtcblxuICAgIHZzbWFsbCA9IDEuMGUtNjA7XG4gICAgZG8ge1xuICAgICAgICB2c21hbGwgPSB2c21hbGwgKyB2c21hbGw7XG4gICAgICAgIHRtcGEgPSAxICsgMC4xICogdnNtYWxsO1xuICAgICAgICB0bXBiID0gMSArIDAuMiAqIHZzbWFsbDtcbiAgICB9IHdoaWxlICh0bXBhIDw9IDEgfHwgdG1wYiA8PSAxKTtcblxuICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgIHdvcmtbaV0gPSBkdmVjW2ldO1xuICAgIH1cbiAgICBmb3IgKGkgPSBuICsgMTsgaSA8PSBsOyBpID0gaSArIDEpIHtcbiAgICAgICAgd29ya1tpXSA9IDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgIGlhY3RbaV0gPSAwO1xuICAgIH1cblxuICAgIGluZm8gPSBbXTtcblxuICAgIGlmIChpZXJyWzFdID09PSAwKSB7XG4gICAgICAgIGRwb2ZhKGRtYXQsIGZkZG1hdCwgbiwgaW5mbyk7XG4gICAgICAgIGlmIChpbmZvWzFdICE9PSAwKSB7XG4gICAgICAgICAgICBpZXJyWzFdID0gMjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkcG9zbChkbWF0LCBmZGRtYXQsIG4sIGR2ZWMpO1xuICAgICAgICBkcG9yaShkbWF0LCBmZGRtYXQsIG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICBzb2xbal0gPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBqOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBzb2xbal0gPSBzb2xbal0gKyBkbWF0W2ldW2pdICogZHZlY1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgZHZlY1tqXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSBqOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIGR2ZWNbal0gPSBkdmVjW2pdICsgZG1hdFtqXVtpXSAqIHNvbFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNydmFsWzFdID0gMDtcbiAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICBzb2xbal0gPSBkdmVjW2pdO1xuICAgICAgICBjcnZhbFsxXSA9IGNydmFsWzFdICsgd29ya1tqXSAqIHNvbFtqXTtcbiAgICAgICAgd29ya1tqXSA9IDA7XG4gICAgICAgIGZvciAoaSA9IGogKyAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgZG1hdFtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3J2YWxbMV0gPSAtY3J2YWxbMV0gLyAyO1xuICAgIGllcnJbMV0gPSAwO1xuXG4gICAgaXd6diA9IG47XG4gICAgaXdydiA9IGl3enYgKyBuO1xuICAgIGl3dXYgPSBpd3J2ICsgcjtcbiAgICBpd3JtID0gaXd1diArIHIgKyAxO1xuICAgIGl3c3YgPSBpd3JtICsgKHIgKiAociArIDEpKSAvIDI7XG4gICAgaXduYnYgPSBpd3N2ICsgcTtcblxuICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICBzdW0gPSBzdW0gKyBhbWF0W2pdW2ldICogYW1hdFtqXVtpXTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrW2l3bmJ2ICsgaV0gPSBNYXRoLnNxcnQoc3VtKTtcbiAgICB9XG4gICAgbmFjdCA9IDA7XG4gICAgaXRlclsxXSA9IDA7XG4gICAgaXRlclsyXSA9IDA7XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzUwKCkge1xuICAgICAgICBpdGVyWzFdID0gaXRlclsxXSArIDE7XG5cbiAgICAgICAgbCA9IGl3c3Y7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBsID0gbCArIDE7XG4gICAgICAgICAgICBzdW0gPSAtYnZlY1tpXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgYW1hdFtqXVtpXSAqIHNvbFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdW0pIDwgdnNtYWxsKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gbWVxKSB7XG4gICAgICAgICAgICAgICAgd29ya1tsXSA9IHN1bTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd29ya1tsXSA9IC1NYXRoLmFicyhzdW0pO1xuICAgICAgICAgICAgICAgIGlmIChzdW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbWF0W2pdW2ldID0gLWFtYXRbal1baV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnZlY1tpXSA9IC1idmVjW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmFjdDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB3b3JrW2l3c3YgKyBpYWN0W2ldXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBudmwgPSAwO1xuICAgICAgICB0ZW1wID0gMDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGlmICh3b3JrW2l3c3YgKyBpXSA8IHRlbXAgKiB3b3JrW2l3bmJ2ICsgaV0pIHtcbiAgICAgICAgICAgICAgICBudmwgPSBpO1xuICAgICAgICAgICAgICAgIHRlbXAgPSB3b3JrW2l3c3YgKyBpXSAvIHdvcmtbaXduYnYgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnZsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gOTk5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm5fZ290b181NSgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIGRtYXRbal1baV0gKiBhbWF0W2pdW252bF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrW2ldID0gc3VtO1xuICAgICAgICB9XG5cbiAgICAgICAgbDEgPSBpd3p2O1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgd29ya1tsMSArIGldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSBuYWN0ICsgMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgd29ya1tsMSArIGldID0gd29ya1tsMSArIGldICsgZG1hdFtpXVtqXSAqIHdvcmtbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0MWluZiA9IHRydWU7XG4gICAgICAgIGZvciAoaSA9IG5hY3Q7IGkgPj0gMTsgaSA9IGkgLSAxKSB7XG4gICAgICAgICAgICBzdW0gPSB3b3JrW2ldO1xuICAgICAgICAgICAgbCA9IGl3cm0gKyAoaSAqIChpICsgMykpIC8gMjtcbiAgICAgICAgICAgIGwxID0gbCAtIGk7XG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8PSBuYWN0OyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0gLSB3b3JrW2xdICogd29ya1tpd3J2ICsgal07XG4gICAgICAgICAgICAgICAgbCA9IGwgKyBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtID0gc3VtIC8gd29ya1tsMV07XG4gICAgICAgICAgICB3b3JrW2l3cnYgKyBpXSA9IHN1bTtcbiAgICAgICAgICAgIGlmIChpYWN0W2ldIDwgbWVxKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VtIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDFpbmYgPSBmYWxzZTtcbiAgICAgICAgICAgIGl0MSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXQxaW5mKSB7XG4gICAgICAgICAgICB0MSA9IHdvcmtbaXd1diArIGl0MV0gLyB3b3JrW2l3cnYgKyBpdDFdO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWFjdFtpXSA8IG1lcSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3b3JrW2l3cnYgKyBpXSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wID0gd29ya1tpd3V2ICsgaV0gLyB3b3JrW2l3cnYgKyBpXTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcCA8IHQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgaXQxID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKGkgPSBpd3p2ICsgMTsgaSA8PSBpd3p2ICsgbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBzdW0gPSBzdW0gKyB3b3JrW2ldICogd29ya1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA8PSB2c21hbGwpIHtcbiAgICAgICAgICAgIGlmICh0MWluZikge1xuICAgICAgICAgICAgICAgIGllcnJbMV0gPSAxO1xuICAgICAgICAgICAgICAgIC8vIEdPVE8gOTk5XG4gICAgICAgICAgICAgICAgcmV0dXJuIDk5OTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tpd3V2ICsgaV0gPSB3b3JrW2l3dXYgKyBpXSAtIHQxICogd29ya1tpd3J2ICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdvcmtbaXd1diArIG5hY3QgKyAxXSA9IHdvcmtbaXd1diArIG5hY3QgKyAxXSArIHQxO1xuICAgICAgICAgICAgICAgIC8vIEdPVE8gNzAwXG4gICAgICAgICAgICAgICAgcmV0dXJuIDcwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIHdvcmtbaXd6diArIGldICogYW1hdFtpXVtudmxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHQgPSAtd29ya1tpd3N2ICsgbnZsXSAvIHN1bTtcbiAgICAgICAgICAgIHQybWluID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdDFpbmYpIHtcbiAgICAgICAgICAgICAgICBpZiAodDEgPCB0dCkge1xuICAgICAgICAgICAgICAgICAgICB0dCA9IHQxO1xuICAgICAgICAgICAgICAgICAgICB0Mm1pbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBzb2xbaV0gPSBzb2xbaV0gKyB0dCAqIHdvcmtbaXd6diArIGldO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzb2xbaV0pIDwgdnNtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjcnZhbFsxXSA9IGNydmFsWzFdICsgdHQgKiBzdW0gKiAodHQgLyAyICsgd29ya1tpd3V2ICsgbmFjdCArIDFdKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmFjdDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgd29ya1tpd3V2ICsgaV0gPSB3b3JrW2l3dXYgKyBpXSAtIHR0ICogd29ya1tpd3J2ICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrW2l3dXYgKyBuYWN0ICsgMV0gPSB3b3JrW2l3dXYgKyBuYWN0ICsgMV0gKyB0dDtcblxuICAgICAgICAgICAgaWYgKHQybWluKSB7XG4gICAgICAgICAgICAgICAgbmFjdCA9IG5hY3QgKyAxO1xuICAgICAgICAgICAgICAgIGlhY3RbbmFjdF0gPSBudmw7XG5cbiAgICAgICAgICAgICAgICBsID0gaXdybSArICgobmFjdCAtIDEpICogbmFjdCkgLyAyICsgMTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3QgLSAxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tsXSA9IHdvcmtbaV07XG4gICAgICAgICAgICAgICAgICAgIGwgPSBsICsgMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmFjdCA9PT0gbikge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2xdID0gd29ya1tuXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBuOyBpID49IG5hY3QgKyAxOyBpID0gaSAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrW2ldID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnYyA9IE1hdGgubWF4KE1hdGguYWJzKHdvcmtbaSAtIDFdKSwgTWF0aC5hYnMod29ya1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3MgPSBNYXRoLm1pbihNYXRoLmFicyh3b3JrW2kgLSAxXSksIE1hdGguYWJzKHdvcmtbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrW2kgLSAxXSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IE1hdGguYWJzKGdjICogTWF0aC5zcXJ0KDEgKyBncyAqIGdzIC8gKGdjICogZ2MpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSAtTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdjID0gd29ya1tpIC0gMV0gLyB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3MgPSB3b3JrW2ldIC8gdGVtcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdjID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrW2kgLSAxXSA9IGdzICogdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gZG1hdFtqXVtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtYXRbal1baSAtIDFdID0gZG1hdFtqXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1hdFtqXVtpXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrW2kgLSAxXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnUgPSBncyAvICgxICsgZ2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBnYyAqIGRtYXRbal1baSAtIDFdICsgZ3MgKiBkbWF0W2pdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWF0W2pdW2ldID0gbnUgKiAoZG1hdFtqXVtpIC0gMV0gKyB0ZW1wKSAtIGRtYXRbal1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtYXRbal1baSAtIDFdID0gdGVtcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrW2xdID0gd29ya1tuYWN0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1bSA9IC1idmVjW252bF07XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgc29sW2pdICogYW1hdFtqXVtudmxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnZsID4gbWVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbaXdzdiArIG52bF0gPSBzdW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tpd3N2ICsgbnZsXSA9IC1NYXRoLmFicyhzdW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VtID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWF0W2pdW252bF0gPSAtYW1hdFtqXVtudmxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnZlY1tudmxdID0gLWJ2ZWNbbnZsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHT1RPIDcwMFxuICAgICAgICAgICAgICAgIHJldHVybiA3MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzc5NygpIHtcbiAgICAgICAgbCA9IGl3cm0gKyAoaXQxICogKGl0MSArIDEpKSAvIDIgKyAxO1xuICAgICAgICBsMSA9IGwgKyBpdDE7XG4gICAgICAgIGlmICh3b3JrW2wxXSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gR09UTyA3OThcbiAgICAgICAgICAgIHJldHVybiA3OTg7XG4gICAgICAgIH1cbiAgICAgICAgZ2MgPSBNYXRoLm1heChNYXRoLmFicyh3b3JrW2wxIC0gMV0pLCBNYXRoLmFicyh3b3JrW2wxXSkpO1xuICAgICAgICBncyA9IE1hdGgubWluKE1hdGguYWJzKHdvcmtbbDEgLSAxXSksIE1hdGguYWJzKHdvcmtbbDFdKSk7XG4gICAgICAgIGlmICh3b3JrW2wxIC0gMV0gPj0gMCkge1xuICAgICAgICAgICAgdGVtcCA9IE1hdGguYWJzKGdjICogTWF0aC5zcXJ0KDEgKyBncyAqIGdzIC8gKGdjICogZ2MpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gLU1hdGguYWJzKGdjICogTWF0aC5zcXJ0KDEgKyBncyAqIGdzIC8gKGdjICogZ2MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MgPSB3b3JrW2wxIC0gMV0gLyB0ZW1wO1xuICAgICAgICBncyA9IHdvcmtbbDFdIC8gdGVtcDtcblxuICAgICAgICBpZiAoZ2MgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEdPVE8gNzk4XG4gICAgICAgICAgICByZXR1cm4gNzk4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChnYyA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gaXQxICsgMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gd29ya1tsMSAtIDFdO1xuICAgICAgICAgICAgICAgIHdvcmtbbDEgLSAxXSA9IHdvcmtbbDFdO1xuICAgICAgICAgICAgICAgIHdvcmtbbDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICBsMSA9IGwxICsgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IGRtYXRbaV1baXQxXTtcbiAgICAgICAgICAgICAgICBkbWF0W2ldW2l0MV0gPSBkbWF0W2ldW2l0MSArIDFdO1xuICAgICAgICAgICAgICAgIGRtYXRbaV1baXQxICsgMV0gPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnUgPSBncyAvICgxICsgZ2MpO1xuICAgICAgICAgICAgZm9yIChpID0gaXQxICsgMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gZ2MgKiB3b3JrW2wxIC0gMV0gKyBncyAqIHdvcmtbbDFdO1xuICAgICAgICAgICAgICAgIHdvcmtbbDFdID0gbnUgKiAod29ya1tsMSAtIDFdICsgdGVtcCkgLSB3b3JrW2wxXTtcbiAgICAgICAgICAgICAgICB3b3JrW2wxIC0gMV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGwxID0gbDEgKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gZ2MgKiBkbWF0W2ldW2l0MV0gKyBncyAqIGRtYXRbaV1baXQxICsgMV07XG4gICAgICAgICAgICAgICAgZG1hdFtpXVtpdDEgKyAxXSA9IG51ICogKGRtYXRbaV1baXQxXSArIHRlbXApIC0gZG1hdFtpXVtpdDEgKyAxXTtcbiAgICAgICAgICAgICAgICBkbWF0W2ldW2l0MV0gPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm5fZ290b183OTgoKSB7XG4gICAgICAgIGwxID0gbCAtIGl0MTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBpdDE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgd29ya1tsMV0gPSB3b3JrW2xdO1xuICAgICAgICAgICAgbCA9IGwgKyAxO1xuICAgICAgICAgICAgbDEgPSBsMSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB3b3JrW2l3dXYgKyBpdDFdID0gd29ya1tpd3V2ICsgaXQxICsgMV07XG4gICAgICAgIGlhY3RbaXQxXSA9IGlhY3RbaXQxICsgMV07XG4gICAgICAgIGl0MSA9IGl0MSArIDE7XG4gICAgICAgIGlmIChpdDEgPCBuYWN0KSB7XG4gICAgICAgICAgICAvLyBHT1RPIDc5N1xuICAgICAgICAgICAgcmV0dXJuIDc5NztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNzk5KCkge1xuICAgICAgICB3b3JrW2l3dXYgKyBuYWN0XSA9IHdvcmtbaXd1diArIG5hY3QgKyAxXTtcbiAgICAgICAgd29ya1tpd3V2ICsgbmFjdCArIDFdID0gMDtcbiAgICAgICAgaWFjdFtuYWN0XSA9IDA7XG4gICAgICAgIG5hY3QgPSBuYWN0IC0gMTtcbiAgICAgICAgaXRlclsyXSA9IGl0ZXJbMl0gKyAxO1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGdvID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBnbyA9IGZuX2dvdG9fNTAoKTtcbiAgICAgICAgaWYgKGdvID09PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZ28gPSBmbl9nb3RvXzU1KCk7XG4gICAgICAgICAgICBpZiAoZ28gPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnbyA9PT0gOTk5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvID09PSA3MDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXQxID09PSBuYWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZuX2dvdG9fNzk5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuX2dvdG9fNzk3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbyA9IGZuX2dvdG9fNzk4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ28gIT09IDc5Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZuX2dvdG9fNzk5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIHNvbHZlUVAoRG1hdCwgZHZlYywgQW1hdCwgYnZlYywgbWVxLCBmYWN0b3JpemVkKSB7XG4gICAgRG1hdCA9IGJhc2UwdG8xKERtYXQpO1xuICAgIGR2ZWMgPSBiYXNlMHRvMShkdmVjKTtcbiAgICBBbWF0ID0gYmFzZTB0bzEoQW1hdCk7XG4gICAgdmFyIGksIG4sIHEsXG4gICAgICAgIG5hY3QsIHIsXG4gICAgICAgIGNydmFsID0gW10sIGlhY3QgPSBbXSwgc29sID0gW10sIHdvcmsgPSBbXSwgaXRlciA9IFtdLFxuICAgICAgICBtZXNzYWdlO1xuXG4gICAgbWVxID0gbWVxIHx8IDA7XG4gICAgZmFjdG9yaXplZCA9IGZhY3Rvcml6ZWQgPyBiYXNlMHRvMShmYWN0b3JpemVkKSA6IFt1bmRlZmluZWQsIDBdO1xuICAgIGJ2ZWMgPSBidmVjID8gYmFzZTB0bzEoYnZlYykgOiBbXTtcblxuICAgIC8vIEluIEZvcnRyYW4gdGhlIGFycmF5IGluZGV4IHN0YXJ0cyBmcm9tIDFcbiAgICBuID0gRG1hdC5sZW5ndGggLSAxO1xuICAgIHEgPSBBbWF0WzFdLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoIWJ2ZWMpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGJ2ZWNbaV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgIGlhY3RbaV0gPSAwO1xuICAgIH1cbiAgICBuYWN0ID0gMDtcbiAgICByID0gTWF0aC5taW4obiwgcSk7XG4gICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgc29sW2ldID0gMDtcbiAgICB9XG4gICAgY3J2YWxbMV0gPSAwO1xuICAgIGZvciAoaSA9IDE7IGkgPD0gKDIgKiBuICsgKHIgKiAociArIDUpKSAvIDIgKyAyICogcSArIDEpOyBpID0gaSArIDEpIHtcbiAgICAgICAgd29ya1tpXSA9IDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDE7IGkgPD0gMjsgaSA9IGkgKyAxKSB7XG4gICAgICAgIGl0ZXJbaV0gPSAwO1xuICAgIH1cblxuICAgIHFwZ2VuMihEbWF0LCBkdmVjLCBuLCBuLCBzb2wsIGNydmFsLCBBbWF0LFxuICAgICAgICBidmVjLCBuLCBxLCBtZXEsIGlhY3QsIG5hY3QsIGl0ZXIsIHdvcmssIGZhY3Rvcml6ZWQpO1xuXG4gICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgaWYgKGZhY3Rvcml6ZWRbMV0gPT09IDEpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiY29uc3RyYWludHMgYXJlIGluY29uc2lzdGVudCwgbm8gc29sdXRpb24hXCI7XG4gICAgfVxuICAgIGlmIChmYWN0b3JpemVkWzFdID09PSAyKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIm1hdHJpeCBEIGluIHF1YWRyYXRpYyBmdW5jdGlvbiBpcyBub3QgcG9zaXRpdmUgZGVmaW5pdGUhXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc29sdXRpb246IGJhc2UxdG8wKHNvbCksXG4gICAgICAgIHZhbHVlOiBiYXNlMXRvMChjcnZhbCksXG4gICAgICAgIHVuY29uc3RyYWluZWRfc29sdXRpb246IGJhc2UxdG8wKGR2ZWMpLFxuICAgICAgICBpdGVyYXRpb25zOiBiYXNlMXRvMChpdGVyKSxcbiAgICAgICAgaWFjdDogYmFzZTF0bzAoaWFjdCksXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9O1xufVxuZXhwb3J0cy5zb2x2ZVFQID0gc29sdmVRUDtcbn0obnVtZXJpYykpO1xuLypcclxuU2hhbnRpIFJhbyBzZW50IG1lIHRoaXMgcm91dGluZSBieSBwcml2YXRlIGVtYWlsLiBJIGhhZCB0byBtb2RpZnkgaXRcclxuc2xpZ2h0bHkgdG8gd29yayBvbiBBcnJheXMgaW5zdGVhZCBvZiB1c2luZyBhIE1hdHJpeCBvYmplY3QuXHJcbkl0IGlzIGFwcGFyZW50bHkgdHJhbnNsYXRlZCBmcm9tIGh0dHA6Ly9zdGl0Y2hwYW5vcmFtYS5zb3VyY2Vmb3JnZS5uZXQvUHl0aG9uL3N2ZC5weVxyXG4qL1xyXG5cclxubnVtZXJpYy5zdmQ9IGZ1bmN0aW9uIHN2ZChBKSB7XHJcbiAgICB2YXIgdGVtcDtcclxuLy9Db21wdXRlIHRoZSB0aGluIFNWRCBmcm9tIEcuIEguIEdvbHViIGFuZCBDLiBSZWluc2NoLCBOdW1lci4gTWF0aC4gMTQsIDQwMy00MjAgKDE5NzApXHJcblx0dmFyIHByZWM9IG51bWVyaWMuZXBzaWxvbjsgLy9NYXRoLnBvdygyLC01MikgLy8gYXNzdW1lcyBkb3VibGUgcHJlY1xyXG5cdHZhciB0b2xlcmFuY2U9IDEuZS02NC9wcmVjO1xyXG5cdHZhciBpdG1heD0gNTA7XHJcblx0dmFyIGM9MDtcclxuXHR2YXIgaT0wO1xyXG5cdHZhciBqPTA7XHJcblx0dmFyIGs9MDtcclxuXHR2YXIgbD0wO1xyXG5cdFxyXG5cdHZhciB1PSBudW1lcmljLmNsb25lKEEpO1xyXG5cdHZhciBtPSB1Lmxlbmd0aDtcclxuXHRcclxuXHR2YXIgbj0gdVswXS5sZW5ndGg7XHJcblx0XHJcblx0aWYgKG0gPCBuKSB0aHJvdyBcIk5lZWQgbW9yZSByb3dzIHRoYW4gY29sdW1uc1wiXHJcblx0XHJcblx0dmFyIGUgPSBuZXcgQXJyYXkobik7XHJcblx0dmFyIHEgPSBuZXcgQXJyYXkobik7XHJcblx0Zm9yIChpPTA7IGk8bjsgaSsrKSBlW2ldID0gcVtpXSA9IDAuMDtcclxuXHR2YXIgdiA9IG51bWVyaWMucmVwKFtuLG5dLDApO1xyXG4vL1x0di56ZXJvKCk7XHJcblx0XHJcbiBcdGZ1bmN0aW9uIHB5dGhhZyhhLGIpXHJcbiBcdHtcclxuXHRcdGEgPSBNYXRoLmFicyhhKVxyXG5cdFx0YiA9IE1hdGguYWJzKGIpXHJcblx0XHRpZiAoYSA+IGIpXHJcblx0XHRcdHJldHVybiBhKk1hdGguc3FydCgxLjArKGIqYi9hL2EpKVxyXG5cdFx0ZWxzZSBpZiAoYiA9PSAwLjApIFxyXG5cdFx0XHRyZXR1cm4gYVxyXG5cdFx0cmV0dXJuIGIqTWF0aC5zcXJ0KDEuMCsoYSphL2IvYikpXHJcblx0fVxyXG5cclxuXHQvL0hvdXNlaG9sZGVyJ3MgcmVkdWN0aW9uIHRvIGJpZGlhZ29uYWwgZm9ybVxyXG5cclxuXHR2YXIgZj0gMC4wO1xyXG5cdHZhciBnPSAwLjA7XHJcblx0dmFyIGg9IDAuMDtcclxuXHR2YXIgeD0gMC4wO1xyXG5cdHZhciB5PSAwLjA7XHJcblx0dmFyIHo9IDAuMDtcclxuXHR2YXIgcz0gMC4wO1xyXG5cdFxyXG5cdGZvciAoaT0wOyBpIDwgbjsgaSsrKVxyXG5cdHtcdFxyXG5cdFx0ZVtpXT0gZztcclxuXHRcdHM9IDAuMDtcclxuXHRcdGw9IGkrMTtcclxuXHRcdGZvciAoaj1pOyBqIDwgbTsgaisrKSBcclxuXHRcdFx0cyArPSAodVtqXVtpXSp1W2pdW2ldKTtcclxuXHRcdGlmIChzIDw9IHRvbGVyYW5jZSlcclxuXHRcdFx0Zz0gMC4wO1xyXG5cdFx0ZWxzZVxyXG5cdFx0e1x0XHJcblx0XHRcdGY9IHVbaV1baV07XHJcblx0XHRcdGc9IE1hdGguc3FydChzKTtcclxuXHRcdFx0aWYgKGYgPj0gMC4wKSBnPSAtZztcclxuXHRcdFx0aD0gZipnLXNcclxuXHRcdFx0dVtpXVtpXT1mLWc7XHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cz0gMC4wXHJcblx0XHRcdFx0Zm9yIChrPWk7IGsgPCBtOyBrKyspIFxyXG5cdFx0XHRcdFx0cyArPSB1W2tdW2ldKnVba11bal1cclxuXHRcdFx0XHRmPSBzL2hcclxuXHRcdFx0XHRmb3IgKGs9aTsgayA8IG07IGsrKykgXHJcblx0XHRcdFx0XHR1W2tdW2pdKz1mKnVba11baV1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cVtpXT0gZ1xyXG5cdFx0cz0gMC4wXHJcblx0XHRmb3IgKGo9bDsgaiA8IG47IGorKykgXHJcblx0XHRcdHM9IHMgKyB1W2ldW2pdKnVbaV1bal1cclxuXHRcdGlmIChzIDw9IHRvbGVyYW5jZSlcclxuXHRcdFx0Zz0gMC4wXHJcblx0XHRlbHNlXHJcblx0XHR7XHRcclxuXHRcdFx0Zj0gdVtpXVtpKzFdXHJcblx0XHRcdGc9IE1hdGguc3FydChzKVxyXG5cdFx0XHRpZiAoZiA+PSAwLjApIGc9IC1nXHJcblx0XHRcdGg9IGYqZyAtIHNcclxuXHRcdFx0dVtpXVtpKzFdID0gZi1nO1xyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKykgZVtqXT0gdVtpXVtqXS9oXHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbTsgaisrKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRzPTAuMFxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbjsgaysrKSBcclxuXHRcdFx0XHRcdHMgKz0gKHVbal1ba10qdVtpXVtrXSlcclxuXHRcdFx0XHRmb3IgKGs9bDsgayA8IG47IGsrKykgXHJcblx0XHRcdFx0XHR1W2pdW2tdKz1zKmVba11cclxuXHRcdFx0fVx0XHJcblx0XHR9XHJcblx0XHR5PSBNYXRoLmFicyhxW2ldKStNYXRoLmFicyhlW2ldKVxyXG5cdFx0aWYgKHk+eCkgXHJcblx0XHRcdHg9eVxyXG5cdH1cclxuXHRcclxuXHQvLyBhY2N1bXVsYXRpb24gb2YgcmlnaHQgaGFuZCBndHJhbnNmb3JtYXRpb25zXHJcblx0Zm9yIChpPW4tMTsgaSAhPSAtMTsgaSs9IC0xKVxyXG5cdHtcdFxyXG5cdFx0aWYgKGcgIT0gMC4wKVxyXG5cdFx0e1xyXG5cdFx0IFx0aD0gZyp1W2ldW2krMV1cclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspIFxyXG5cdFx0XHRcdHZbal1baV09dVtpXVtqXS9oXHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRzPTAuMFxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbjsgaysrKSBcclxuXHRcdFx0XHRcdHMgKz0gdVtpXVtrXSp2W2tdW2pdXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBuOyBrKyspIFxyXG5cdFx0XHRcdFx0dltrXVtqXSs9KHMqdltrXVtpXSlcclxuXHRcdFx0fVx0XHJcblx0XHR9XHJcblx0XHRmb3IgKGo9bDsgaiA8IG47IGorKylcclxuXHRcdHtcclxuXHRcdFx0dltpXVtqXSA9IDA7XHJcblx0XHRcdHZbal1baV0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dltpXVtpXSA9IDE7XHJcblx0XHRnPSBlW2ldXHJcblx0XHRsPSBpXHJcblx0fVxyXG5cdFxyXG5cdC8vIGFjY3VtdWxhdGlvbiBvZiBsZWZ0IGhhbmQgdHJhbnNmb3JtYXRpb25zXHJcblx0Zm9yIChpPW4tMTsgaSAhPSAtMTsgaSs9IC0xKVxyXG5cdHtcdFxyXG5cdFx0bD0gaSsxXHJcblx0XHRnPSBxW2ldXHJcblx0XHRmb3IgKGo9bDsgaiA8IG47IGorKykgXHJcblx0XHRcdHVbaV1bal0gPSAwO1xyXG5cdFx0aWYgKGcgIT0gMC4wKVxyXG5cdFx0e1xyXG5cdFx0XHRoPSB1W2ldW2ldKmdcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzPTAuMFxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbTsgaysrKSBzICs9IHVba11baV0qdVtrXVtqXTtcclxuXHRcdFx0XHRmPSBzL2hcclxuXHRcdFx0XHRmb3IgKGs9aTsgayA8IG07IGsrKykgdVtrXVtqXSs9Zip1W2tdW2ldO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAoaj1pOyBqIDwgbTsgaisrKSB1W2pdW2ldID0gdVtqXVtpXS9nO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0XHRmb3IgKGo9aTsgaiA8IG07IGorKykgdVtqXVtpXSA9IDA7XHJcblx0XHR1W2ldW2ldICs9IDE7XHJcblx0fVxyXG5cdFxyXG5cdC8vIGRpYWdvbmFsaXphdGlvbiBvZiB0aGUgYmlkaWFnb25hbCBmb3JtXHJcblx0cHJlYz0gcHJlYyp4XHJcblx0Zm9yIChrPW4tMTsgayAhPSAtMTsgays9IC0xKVxyXG5cdHtcclxuXHRcdGZvciAodmFyIGl0ZXJhdGlvbj0wOyBpdGVyYXRpb24gPCBpdG1heDsgaXRlcmF0aW9uKyspXHJcblx0XHR7XHQvLyB0ZXN0IGYgc3BsaXR0aW5nXHJcblx0XHRcdHZhciB0ZXN0X2NvbnZlcmdlbmNlID0gZmFsc2VcclxuXHRcdFx0Zm9yIChsPWs7IGwgIT0gLTE7IGwrPSAtMSlcclxuXHRcdFx0e1x0XHJcblx0XHRcdFx0aWYgKE1hdGguYWJzKGVbbF0pIDw9IHByZWMpXHJcblx0XHRcdFx0e1x0dGVzdF9jb252ZXJnZW5jZT0gdHJ1ZVxyXG5cdFx0XHRcdFx0YnJlYWsgXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChNYXRoLmFicyhxW2wtMV0pIDw9IHByZWMpXHJcblx0XHRcdFx0XHRicmVhayBcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIXRlc3RfY29udmVyZ2VuY2UpXHJcblx0XHRcdHtcdC8vIGNhbmNlbGxhdGlvbiBvZiBlW2xdIGlmIGw+MFxyXG5cdFx0XHRcdGM9IDAuMFxyXG5cdFx0XHRcdHM9IDEuMFxyXG5cdFx0XHRcdHZhciBsMT0gbC0xXHJcblx0XHRcdFx0Zm9yIChpID1sOyBpPGsrMTsgaSsrKVxyXG5cdFx0XHRcdHtcdFxyXG5cdFx0XHRcdFx0Zj0gcyplW2ldXHJcblx0XHRcdFx0XHRlW2ldPSBjKmVbaV1cclxuXHRcdFx0XHRcdGlmIChNYXRoLmFicyhmKSA8PSBwcmVjKVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Zz0gcVtpXVxyXG5cdFx0XHRcdFx0aD0gcHl0aGFnKGYsZylcclxuXHRcdFx0XHRcdHFbaV09IGhcclxuXHRcdFx0XHRcdGM9IGcvaFxyXG5cdFx0XHRcdFx0cz0gLWYvaFxyXG5cdFx0XHRcdFx0Zm9yIChqPTA7IGogPCBtOyBqKyspXHJcblx0XHRcdFx0XHR7XHRcclxuXHRcdFx0XHRcdFx0eT0gdVtqXVtsMV1cclxuXHRcdFx0XHRcdFx0ej0gdVtqXVtpXVxyXG5cdFx0XHRcdFx0XHR1W2pdW2wxXSA9ICB5KmMrKHoqcylcclxuXHRcdFx0XHRcdFx0dVtqXVtpXSA9IC15KnMrKHoqYylcclxuXHRcdFx0XHRcdH0gXHJcblx0XHRcdFx0fVx0XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gdGVzdCBmIGNvbnZlcmdlbmNlXHJcblx0XHRcdHo9IHFba11cclxuXHRcdFx0aWYgKGw9PSBrKVxyXG5cdFx0XHR7XHQvL2NvbnZlcmdlbmNlXHJcblx0XHRcdFx0aWYgKHo8MC4wKVxyXG5cdFx0XHRcdHtcdC8vcVtrXSBpcyBtYWRlIG5vbi1uZWdhdGl2ZVxyXG5cdFx0XHRcdFx0cVtrXT0gLXpcclxuXHRcdFx0XHRcdGZvciAoaj0wOyBqIDwgbjsgaisrKVxyXG5cdFx0XHRcdFx0XHR2W2pdW2tdID0gLXZbal1ba11cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWsgIC8vYnJlYWsgb3V0IG9mIGl0ZXJhdGlvbiBsb29wIGFuZCBtb3ZlIG9uIHRvIG5leHQgayB2YWx1ZVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChpdGVyYXRpb24gPj0gaXRtYXgtMSlcclxuXHRcdFx0XHR0aHJvdyAnRXJyb3I6IG5vIGNvbnZlcmdlbmNlLidcclxuXHRcdFx0Ly8gc2hpZnQgZnJvbSBib3R0b20gMngyIG1pbm9yXHJcblx0XHRcdHg9IHFbbF1cclxuXHRcdFx0eT0gcVtrLTFdXHJcblx0XHRcdGc9IGVbay0xXVxyXG5cdFx0XHRoPSBlW2tdXHJcblx0XHRcdGY9ICgoeS16KSooeSt6KSsoZy1oKSooZytoKSkvKDIuMCpoKnkpXHJcblx0XHRcdGc9IHB5dGhhZyhmLDEuMClcclxuXHRcdFx0aWYgKGYgPCAwLjApXHJcblx0XHRcdFx0Zj0gKCh4LXopKih4K3opK2gqKHkvKGYtZyktaCkpL3hcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGY9ICgoeC16KSooeCt6KStoKih5LyhmK2cpLWgpKS94XHJcblx0XHRcdC8vIG5leHQgUVIgdHJhbnNmb3JtYXRpb25cclxuXHRcdFx0Yz0gMS4wXHJcblx0XHRcdHM9IDEuMFxyXG5cdFx0XHRmb3IgKGk9bCsxOyBpPCBrKzE7IGkrKylcclxuXHRcdFx0e1x0XHJcblx0XHRcdFx0Zz0gZVtpXVxyXG5cdFx0XHRcdHk9IHFbaV1cclxuXHRcdFx0XHRoPSBzKmdcclxuXHRcdFx0XHRnPSBjKmdcclxuXHRcdFx0XHR6PSBweXRoYWcoZixoKVxyXG5cdFx0XHRcdGVbaS0xXT0gelxyXG5cdFx0XHRcdGM9IGYvelxyXG5cdFx0XHRcdHM9IGgvelxyXG5cdFx0XHRcdGY9IHgqYytnKnNcclxuXHRcdFx0XHRnPSAteCpzK2cqY1xyXG5cdFx0XHRcdGg9IHkqc1xyXG5cdFx0XHRcdHk9IHkqY1xyXG5cdFx0XHRcdGZvciAoaj0wOyBqIDwgbjsgaisrKVxyXG5cdFx0XHRcdHtcdFxyXG5cdFx0XHRcdFx0eD0gdltqXVtpLTFdXHJcblx0XHRcdFx0XHR6PSB2W2pdW2ldXHJcblx0XHRcdFx0XHR2W2pdW2ktMV0gPSB4KmMreipzXHJcblx0XHRcdFx0XHR2W2pdW2ldID0gLXgqcyt6KmNcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ej0gcHl0aGFnKGYsaClcclxuXHRcdFx0XHRxW2ktMV09IHpcclxuXHRcdFx0XHRjPSBmL3pcclxuXHRcdFx0XHRzPSBoL3pcclxuXHRcdFx0XHRmPSBjKmcrcyp5XHJcblx0XHRcdFx0eD0gLXMqZytjKnlcclxuXHRcdFx0XHRmb3IgKGo9MDsgaiA8IG07IGorKylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR5PSB1W2pdW2ktMV1cclxuXHRcdFx0XHRcdHo9IHVbal1baV1cclxuXHRcdFx0XHRcdHVbal1baS0xXSA9IHkqYyt6KnNcclxuXHRcdFx0XHRcdHVbal1baV0gPSAteSpzK3oqY1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlW2xdPSAwLjBcclxuXHRcdFx0ZVtrXT0gZlxyXG5cdFx0XHRxW2tdPSB4XHJcblx0XHR9IFxyXG5cdH1cclxuXHRcdFxyXG5cdC8vdnQ9IHRyYW5zcG9zZSh2KVxyXG5cdC8vcmV0dXJuICh1LHEsdnQpXHJcblx0Zm9yIChpPTA7aTxxLmxlbmd0aDsgaSsrKSBcclxuXHQgIGlmIChxW2ldIDwgcHJlYykgcVtpXSA9IDBcclxuXHQgIFxyXG5cdC8vc29ydCBlaWdlbnZhbHVlc1x0XHJcblx0Zm9yIChpPTA7IGk8IG47IGkrKylcclxuXHR7XHQgXHJcblx0Ly93cml0ZWxuKHEpXHJcblx0IGZvciAoaj1pLTE7IGogPj0gMDsgai0tKVxyXG5cdCB7XHJcblx0ICBpZiAocVtqXSA8IHFbaV0pXHJcblx0ICB7XHJcblx0Ly8gIHdyaXRlbG4oaSwnLScsailcclxuXHQgICBjID0gcVtqXVxyXG5cdCAgIHFbal0gPSBxW2ldXHJcblx0ICAgcVtpXSA9IGNcclxuXHQgICBmb3Ioaz0wO2s8dS5sZW5ndGg7aysrKSB7IHRlbXAgPSB1W2tdW2ldOyB1W2tdW2ldID0gdVtrXVtqXTsgdVtrXVtqXSA9IHRlbXA7IH1cclxuXHQgICBmb3Ioaz0wO2s8di5sZW5ndGg7aysrKSB7IHRlbXAgPSB2W2tdW2ldOyB2W2tdW2ldID0gdltrXVtqXTsgdltrXVtqXSA9IHRlbXA7IH1cclxuLy9cdCAgIHUuc3dhcENvbHMoaSxqKVxyXG4vL1x0ICAgdi5zd2FwQ29scyhpLGopXHJcblx0ICAgaSA9IGpcdCAgIFxyXG5cdCAgfVxyXG5cdCB9XHRcclxuXHR9XHJcblx0XHJcblx0cmV0dXJuIHtVOnUsUzpxLFY6dn1cclxufTtcclxuXHJcbiIsImZ1bmN0aW9uIFNwcmVhZFNoZWV0RXJyb3IoKSB7XG4gICAgdGhpcy5uYW1lID0gJ1NwcmVhZFNoZWV0RXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9ICflj5HnlJ/kuobplJnor68nO1xufVxuXG5TcHJlYWRTaGVldEVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuU3ByZWFkU2hlZXRFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJlYWRTaGVldEVycm9yO1xuU3ByZWFkU2hlZXRFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZSArICcgPT4gJyArIHRoaXMubWVzc2FnZTtcbn07XG5cbmV4cG9ydCB7U3ByZWFkU2hlZXRFcnJvcn1cblxuIiwiaW1wb3J0IHtnbG9iYWxTZXR0aW5ncywgZGVmYXVsdFNldHRpbmdzfSBmcm9tICcuL3NldHRpbmdzJztcbmltcG9ydCBTcHJlYWRTaGVldCBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IHBvbHlmaWxsIGZyb20gJy4vcG9seWZpbGwnO1xuLy9ub2luc3BlY3Rpb24gRVM2VW51c2VkSW1wb3J0cyDov5nkuKrlr7zlhaXmmK/kuLrkuobmnoTlu7rml7bliqDovb3nm7jlupTnmoTljIVcbmltcG9ydCBYRm9ybXVsYXMgZnJvbSAnLi9wbHVnaW5zL3hmb3JtdWxhcy9YRm9ybXVsYXMnO1xuaW1wb3J0IHtQbHVnaW4sIHJlZ2lzdGVyUGx1Z2lufSBmcm9tICcuL3BsdWdpbnMvUGx1Z2luJztcbmltcG9ydCBQZXJzaXN0ZW50IGZyb20gJy4vcGx1Z2lucy9wZXJzaXN0ZW50L1BlcnNpc3RlbnQnO1xuXG5cblNwcmVhZFNoZWV0Lmdsb2JhbFNldHRpbmdzID0gZ2xvYmFsU2V0dGluZ3M7XG5TcHJlYWRTaGVldC5kZWZhdWx0U2V0dGluZ3MgPSBkZWZhdWx0U2V0dGluZ3M7XG5TcHJlYWRTaGVldC52ZXJzaW9uID0gJ0BAX3ZlcnNpb25fQEAnO1xuXG5TcHJlYWRTaGVldC5wbHVnaW5zID0ge1xuICAgIFBsdWdpbjogUGx1Z2luLFxuICAgIHJlZ2lzdGVyUGx1Z2luOiByZWdpc3RlclBsdWdpblxufTtcblxuLy8g5YaF572u5o+S5Lu2XG5yZWdpc3RlclBsdWdpbigncGVyc2lzdGVudCcsIFBlcnNpc3RlbnQpO1xuXG5cbi8vIOa1j+iniOWZqOeOr+Wig+S4i+eahOWFqOWxgOWPmOmHj+WQjeOAglxud2luZG93LkJyaWNrU3ByZWFkU2hlZXQgPSBTcHJlYWRTaGVldDtcbndpbmRvdy5fVUlQcm92aWRlciA9IHt9O1xucG9seWZpbGwod2luZG93KTtcblxuLy8gVE9ETyDmj5Dkvpvmm7TmlLnlhajlsYDlj5jph4/lkI3nmoTmlrnms5XvvIzku6XpmLLmraLlhajlsYDlj5jph4/lhrLnqoHjgIJcblxuIiwiaW1wb3J0IEZyYW1lIGZyb20gJy4vZGVzaWduZXIvRnJhbWUnO1xuaW1wb3J0IFdvcmtib29rIGZyb20gJy4vZGVzaWduZXIvV29ya2Jvb2snO1xuaW1wb3J0IHtleHRlbmQsIGVtcHR5RnVuY3Rpb24sIHJhbmRvbVN0cmluZ30gZnJvbSAnLi91dGlscy9jb21tb24nO1xuaW1wb3J0IHtnZXRBbGxQbHVnaW5zLCB2YWxpZGF0ZVBsdWdpbn0gZnJvbSAnLi9wbHVnaW5zL1BsdWdpbic7XG5pbXBvcnQgRW1pdHRlciBmcm9tICcuL3V0aWxzL0VtaXR0ZXInO1xuXG52YXIgQVVUT19JRCA9IDE7XG5cbmNsYXNzIFNwcmVhZFNoZWV0IGV4dGVuZHMgRW1pdHRlciB7XG5cbiAgICAvKipcbiAgICAgKiDnsbvkvLwgRXhjZWwg55qE55S15a2Q6KGo5qC844CCXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IHVzZXJTZXR0aW5ncyAtIOeUteWtkOihqOagvOeahOeUqOaIt+mFjee9ruS/oeaBr1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1c2VyU2V0dGluZ3Mud29ya2Jvb2sgLSBXb3JrYm9vayDnmoTphY3nva5cbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSB1c2VyU2V0dGluZ3Muc2hlZXRzIC0g6YWN572u5omA5pyJ5Yid5aeLIFNoZWV0IOmhteeahOaVsOe7hFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtkaXNwbGF5TW9kZT1mYWxzZV0gLSDlsZXnpLrmqKHlvI/vvIzkuI3lj6/nvJbovpHjgIJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb290RWxlbWVudCwgdXNlclNldHRpbmdzLCBkaXNwbGF5TW9kZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuICAgICAgICB0aGlzLmdldFVzZXJTZXR0aW5ncyh1c2VyU2V0dGluZ3MpO1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgZXh0ZW5kKHRoaXMuc2V0dGluZ3MsIFNwcmVhZFNoZWV0LmRlZmF1bHRTZXR0aW5ncyk7XG4gICAgICAgIGV4dGVuZCh0aGlzLnNldHRpbmdzLCB0aGlzLnVzZXJTZXR0aW5ncyk7XG5cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuc2V0dGluZ3MuaWQgfHwgdGhpcy5nZXRJZCgpO1xuICAgICAgICB0aGlzLmRpc3BsYXlNb2RlID0gZGlzcGxheU1vZGU7XG5cbiAgICAgICAgdGhpcy5faW5pdFBsdWdpbigpO1xuICAgICAgICB0aGlzLmZyYW1lID0gbmV3IEZyYW1lKHRoaXMsIHRoaXMuc2V0dGluZ3MuZnJhbWUpO1xuICAgICAgICB0aGlzLndvcmtib29rID0gbmV3IFdvcmtib29rKHRoaXMsIHRoaXMuc2V0dGluZ3Mud29ya2Jvb2spO1xuICAgICAgICB0aGlzLl9lbmFibGVQbHVnaW4oKTtcbiAgICB9XG5cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgLy8g5LiN5oyH5a6aIGlkIOaXtu+8jOWwvemHj+eUn+aIkOS4jeWPr+mHjeWkjeeahCBpZO+8iOS9v+eUqOW9k+WJjSBpZnJhbWUg6Ieq5aKe5Y+Y6YeP6YWN5ZCI6ZqP5py65a2X56ym5Liy55qE5pa55byP77yJXG4gICAgICAgIHJldHVybiB0aGlzLmlkIHx8IFNwcmVhZFNoZWV0Lmdsb2JhbFNldHRpbmdzLmlkUHJlZml4ICsgKEFVVE9fSUQrKykgKyAnLScgKyByYW5kb21TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBnZXRSb290RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZ2V0RGlzcGxheU1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlNb2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPlueUqOaIt+S8oOWFpeeahOWIneWni+mFjee9ruOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gcyAtIOihqOekuueUqOaIt+mFjee9rueahCBKU09OIOWtl+espuS4slxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VXNlclNldHRpbmdzKHMpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlclNldHRpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2VyU2V0dGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMgJiYgdHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJTZXR0aW5ncyA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJTZXR0aW5ncyA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXNlclNldHRpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPliBTcHJlYWRTaGVldCDlrp7pmYXnlJ/mlYjnmoTphY3nva7kv6Hmga/jgIJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5blj6/kuqTmjaLnmoTkuK3pl7TmlbDmja7vvIznlKjkuo7mlbDmja7mj5DkuqTjgIHop6PmnpDovazmjaLnrYnjgIJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcmFnaW49ZmFsc2VdIC0g5Li6IGB0cnVlYCDml7bojrflj5bljp/lp4sgSmF2YVNjcmlwdCDlr7nosaFcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldEV4Y2hhbmdlRGF0YShvcmFnaW4gPSBmYWxzZSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29ya2Jvb2suX2dldEV4Y2hhbmdlKCk7XG4gICAgICAgIHZhciBmID0gdGhpcy5mcmFtZS5fZ2V0RXhjaGFuZ2UoKTsgLy8gVE9ETyBmcmFtZVxuICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgIHdvcmtib29rOiB3LFxuICAgICAgICAgICAgZnJhbWU6IGYsXG4gICAgICAgICAgICBpZDogdGhpcy5nZXRJZCgpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvcmFnaW4gPyBvIDogSlNPTi5zdHJpbmdpZnkobyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmNIFNwcmVhZFNoZWV0IOWvueW6lOeahCBXb3JrYm9vayDlrp7kvovjgIJcbiAgICAgKiBAcmV0dXJucyB7V29ya2Jvb2t9XG4gICAgICovXG4gICAgZ2V0V29ya2Jvb2tJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2Jvb2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmNIFNwcmVhZFNoZWV0IOWvueW6lOeahCBGcmFtZSDlrp7kvovjgIJcbiAgICAgKiBAcmV0dXJucyB7RnJhbWV9XG4gICAgICovXG4gICAgZ2V0RnJhbWVJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWU7XG4gICAgfVxuXG5cbiAgICBfaW5pdFBsdWdpbigpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgICAgICBnZXRBbGxQbHVnaW5zKCkuZm9yRWFjaChQID0+IHtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IFAodGhpcyk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBsdWdpbihwKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucy5zZXQocC5fX25hbWVfXywgcCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9lbmFibGVQbHVnaW4oKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgaWYgKHAuaXNFbmFibGUoKSkge1xuICAgICAgICAgICAgICAgIHAuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3ByZWFkU2hlZXQ7IiwiLyoqXG4gKiDphY3nva7nv7vor5HnsbvjgIJcbiAqIOahhuaetuWGhemDqOS9v+eUqO+8jOeUqOaIt+S7o+eggeS4jeW6lOivpeiwg+eUqOWug+OAglxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbmZpZ1RyYW5zbGF0b3Ige1xuXG4gICAgLyoqXG4gICAgICog5p6E6YCg5ZmoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTaGVldH0gc2hlZXRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNoZWV0KSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbENvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuICAgICAgICB0aGlzLnNwcmVhZFNoZWV0ID0gc2hlZXQud29ya2Jvb2suc3ByZWFkU2hlZXQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDnv7vor5HphY3nva7jgIJcbiAgICAgKiDkuK3pl7TmlbDmja7moLzlvI/nmoTorr7orqHkvJrlsL3ph4/lkIzml7bkv53or4HlnKggRXhjZWwg5Y+KIFdlYiDpobXpnaLkuK3lnYfkvr/kuo7lpITnkIbvvIxcbiAgICAgKiDkvYbkuI3lhY3lrZjlnKjkuIDkupsgV2ViIOS4remavuS7peebtOaOpeS9v+eUqOeahOaVsOaNruagvOW8j++8jOivpeaWueazleWNs+aYr+WujOaIkOatpOexu+aVsOaNruagvOW8j1xuICAgICAqIOeahOmAgumFjei9rOaNouW3peS9nOOAglxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGUoKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHt9O1xuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnR5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlbaV0uc3RhcnRzV2l0aCgnX3RyYW5zJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5W2ldXS5jYWxsKHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZHNvbnRhYmxlIOS4reeahOS4gOS6m+eKtuaAgeaXoOazlemAmui/h+WIneWni+mFjee9ruWPguaVsOaOp+WItu+8jFxuICAgICAqIOWPquiDveWcqOWunuS+i+WMluS5i+WQjuiwg+eUqOebuOW6lOeahOaWueazleadpeaBouWkjeebuOW6lOeahOeKtuaAge+8jOatpOaWueazlVxuICAgICAqIOWNs+aYr+WujOaIkOivpeWKn+iDveOAglxuICAgICAqL1xuICAgIGluaXRTaGVldFN0YXRlKCkge1xuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnR5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlbaV0uc3RhcnRzV2l0aCgnX2luaXQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlbaV1dLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gdHJhbnNsYXRlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgX3RyYW5zQ2VsbChzZXR0aW5ncykge1xuICAgICAgICB2YXIgbSA9IHRoaXMuaW5pdGlhbENvbmZpZy5jZWxsTWV0YXM7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5jZWxsID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gbVtpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbE1ldGEgPSByb3dbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGwgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwucm93ID0gY2VsbE1ldGEucm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb2wgPSBjZWxsTWV0YS5jb2w7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGFUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuZGF0YVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkdCBpbiBjZWxsTWV0YS5kYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuZGF0YVR5cGUuaGFzT3duUHJvcGVydHkoZHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsW2R0XSA9IGNlbGxNZXRhLmRhdGFUeXBlW2R0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnR5cGUgPSBjZWxsTWV0YS5kYXRhVHlwZS50eXBlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2VsbC50eXBlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxNZXRhLnN0eWxlcy5hbGlnbm1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjID0gY2VsbE1ldGEuc3R5bGVzLmFsaWdubWVudHMuam9pbignIGh0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NOYW1lID0gY2VsbC5jbGFzc05hbWUgPyAoY2VsbC5jbGFzc05hbWUgKz0gJyBodCcgKyBjKSA6ICdodCcgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuc3R5bGVzLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5fc3R5bGVfZm9udEZhbWlseSA9IGNlbGxNZXRhLnN0eWxlcy5mb250RmFtaWx5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuc3R5bGVzLmZvbnRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuX3N0eWxlX2ZvbnRTaXplID0gY2VsbE1ldGEuc3R5bGVzLmZvbnRTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuc3R5bGVzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuX3N0eWxlX2NvbG9yID0gY2VsbE1ldGEuc3R5bGVzLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuc3R5bGVzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLl9zdHlsZV9iYWNrZ3JvdW5kQ29sb3IgPSBjZWxsTWV0YS5zdHlsZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuc3R5bGVzLmZvbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNsYXNzTmFtZSA9IGNlbGwuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChjZWxsLmNsYXNzTmFtZSArPSAnIHNzZC1mb250LScgKyBjZWxsTWV0YS5zdHlsZXMuZm9udFN0eWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc3NkLWZvbnQtJyArIGNlbGxNZXRhLnN0eWxlcy5mb250U3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuZm9udFdlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNsYXNzTmFtZSA9IGNlbGwuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChjZWxsLmNsYXNzTmFtZSArPSAnIHNzZC1mb250LWJvbGQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc3NkLWZvbnQtYm9sZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMudGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jbGFzc05hbWUgPSBjZWxsLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoY2VsbC5jbGFzc05hbWUgKz0gJyBzc2QtZm9udC11bmRlcmxpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc3NkLWZvbnQtdW5kZXJsaW5lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5jZWxsLnB1c2goY2VsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdHJhbnNEYXRhKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbml0aWFsQ29uZmlnLmRhdGE7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAvLyBob3RUYWJsZSDlnKjmnIkgZGF0YSDnmoTmg4XlhrXkuIvlj6rog73mmL7npLrmnInmlbDmja7nmoTooYzliJfvvIzov5nlr7nkuo7orr7orqHlmajmnaXor7TlubbkuI3mlrnkvr/kvb/nlKjvvIxcbiAgICAgICAgICAgIC8vIOaVheWhq+WFheepuuaVsOaNruS7peaSkei1t+ihqOagvOiHsyBpbml0Um93cyAqIGluaXRDb2xzIOeahOWkp+Wwj+OAglxuICAgICAgICAgICAgLy8gICAgaWYgKHMubGVuZ3RoIDwgdGhpcy5zaGVldC5pbml0Um93cykge1xuICAgICAgICAgICAgLy8gICAgICAgIGxldCBmb3JtZXJDb2wgPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vICAgICAgICBzLmxlbmd0aCA9IHRoaXMuc2hlZXQuaW5pdFJvd3M7XG4gICAgICAgICAgICAvLyAgICAgICAgcy5maWxsKFtdLCBmb3JtZXJDb2wpO1xuICAgICAgICAgICAgLy8gICAgfVxuICAgICAgICAgICAgLy8gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgbGV0IHJvdyA9IHNbaV07XG4gICAgICAgICAgICAvLyAgICAgICAgaWYgKHJvdy5sZW5ndGggPCB0aGlzLnNoZWV0LmluaXRDb2xzKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGxldCBmb3JtZXJSb3cgPSByb3cubGVuZ3RoO1xuICAgICAgICAgICAgLy8gICAgICAgICAgICByb3cubGVuZ3RoID0gdGhpcy5zaGVldC5pbml0Q29scztcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgcm93LmZpbGwoJycsIGZvcm1lclJvdyk7XG4gICAgICAgICAgICAvLyAgICAgICAgfVxuICAgICAgICAgICAgLy8gICAgfVxuXG4gICAgICAgICAgICAvLyDkvb/nlKggaG90IEFQSSDlrozmiJDkuIrov7Dlip/og71cbiAgICAgICAgICAgIGlmICghdGhpcy5zcHJlYWRTaGVldC5kaXNwbGF5TW9kZSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm1pblJvd3MgPSB0aGlzLnNoZWV0LmluaXRSb3dzO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm1pbkNvbHMgPSB0aGlzLnNoZWV0LmluaXRDb2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0dGluZ3MuZGF0YSA9IHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDliJflrr1cbiAgICAvLyBOT1RFOiBIYW5kc29udGFibGUg55qEIGNvbFdpZHRocyDmnIkgQlVH77yM6K6+5a6a5ZCO5bCG5LiN5Y+v5Lul5omL5bel5pS55Y+Y5YiX5a6977yMXG4gICAgLy8gICAgICAg6K+V5Zu+5L2/55SoIG1hbnVhbENvbHVtblJlc2l6ZSDlnKjooajmoLzliJ3lp4vljJbkuYvlkI7mnaXmlLnlrr3luqZcbiAgICAvLyBfdHJhbnNDb2xXaWR0aHMoc2V0dGluZ3MpIHtcbiAgICAvLyAgICAgdmFyIHcgPSB0aGlzLmluaXRpYWxDb25maWcuY29sV2lkdGhzO1xuICAgIC8vICAgICBpZiAodykge1xuICAgIC8vICAgICAgICAgc2V0dGluZ3MuY29sV2lkdGhzID0gdztcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIC8vIOihjOmrmFxuICAgIC8vIE5PVEU6IEhhbmRzb250YWJsZSDnmoQgcm93SGVpZ2h0cyDmnIkgQlVH77yM6K6+5a6a5ZCO5bCG5LiN5Y+v5Lul5omL5bel5pS55Y+Y5YiX5a69XG4gICAgLy8gX3RyYW5zUm93SGVpZ2h0cyhzZXR0aW5ncykge1xuICAgIC8vICAgICB2YXIgaCA9IHRoaXMuaW5pdGlhbENvbmZpZy5yb3dIZWlnaHRzO1xuICAgIC8vICAgICBpZiAoaCkge1xuICAgIC8vICAgICAgICAgc2V0dGluZ3Mucm93SGVpZ2h0cyA9IGg7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICAvLyBGSVhNRSDovrnmoYYgaG90IEJVR1xuICAgIF90cmFuc0JvcmRlcnMoc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gdmFyIHMgPSB0aGlzLmluaXRpYWxDb25maWcuYm9yZGVycztcbiAgICAgICAgLy8gaWYgKHMpIHtcbiAgICAgICAgLy8gICAgIHNldHRpbmdzLmN1c3RvbUJvcmRlcnMgPSBzO1xuICAgICAgICAvLyB9XG4gICAgfVxuXG4gICAgLy8g5ZCI5bm25Y2V5YWD5qC8XG4gICAgX3RyYW5zTWVyZ2VDZWxscyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgcyA9IHRoaXMuaW5pdGlhbENvbmZpZy5tZXJnZUNlbGxzO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgc2V0dGluZ3MubWVyZ2VDZWxscyA9IHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaW5pdFN0YXRlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8g6YCJ5Yy6XG4gICAgX2luaXRTZWxlY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbml0aWFsQ29uZmlnLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2hlZXQuc2VsZWN0KHMucm93LCBzLmNvbCwgcy5lbmRSb3csIHMuZW5kQ29sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hlZXQuc2VsZWN0KDAsIDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5YiX5a69XG4gICAgX2luaXRDb2xXaWR0aHMoKSB7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLmluaXRpYWxDb25maWcuY29sV2lkdGhzO1xuICAgICAgICBjb25zdCBtY3IgPSB0aGlzLnNoZWV0LmhhbmRzb250YWJsZS5nZXRQbHVnaW4oJ21hbnVhbENvbHVtblJlc2l6ZScpO1xuICAgICAgICBsZXQgaSwgbGVuO1xuXG4gICAgICAgIGlmICh3ICYmIHcubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB3Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbWNyLnNldE1hbnVhbFNpemUoaSwgd1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDooYzpq5hcbiAgICBfaW5pdFJvd0hlaWdodHMoKSB7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmluaXRpYWxDb25maWcucm93SGVpZ2h0cztcbiAgICAgICAgY29uc3QgbXJyID0gdGhpcy5zaGVldC5oYW5kc29udGFibGUuZ2V0UGx1Z2luKCdtYW51YWxSb3dSZXNpemUnKTtcbiAgICAgICAgbGV0IGksIGxlbjtcblxuICAgICAgICBpZiAoaCAmJiBoLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIG1yci5zZXRNYW51YWxTaXplKGksIGhbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1RyYW5zbGF0b3I7IiwiaW1wb3J0IENvbnRleHRNZW51IGZyb20gJy4vZnJhbWUvQ29udGV4dE1lbnUnXG5cbi8qKlxuICog55S15a2Q6KGo5qC86K6+6K6h5Zmo5Lit77yM6Zmk5LqGIFdvcmtib29rIOWklueahOe7hOS7tueuoeeQhuWZqO+8jFxuICog5YyF5ZCr6I+c5Y2V5qCP44CB5bel5YW35qCP44CB5L6n6L655qCP44CB5Y+z6ZSu6I+c5Y2V562J562J44CCXG4gKi9cbmNsYXNzIEZyYW1lIHtcblxuICAgIGNvbnN0cnVjdG9yKGluc3RhbmNlLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5zcHJlYWRTaGVldCA9IGluc3RhbmNlO1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0NvbnRleHRNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0TWVudSA9IG5ldyBDb250ZXh0TWVudShpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgX2dldEV4Y2hhbmdlKCkge1xuXG4gICAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEZyYW1lOyIsIi8qKlxuICogSGFuZHNvbnRhYmxlIOe7hOS7tueahOmAgumFjeexu1xuICovXG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uL3V0aWxzL2NvbW1vbi5qc1wiO1xuaW1wb3J0IENvbmZpZ1RyYW5zbGF0b3IgZnJvbSBcIi4vQ29uZmlnVHJhbnNsYXRvci5qc1wiO1xuXG5jbGFzcyBIb3RUYWJsZUFkYXB0b3IgZXh0ZW5kcyBIYW5kc29udGFibGUge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290RWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSDljp/lp4vphY3nva7kv6Hmga9cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXh0Q29uZmlnIC0g6ZmE5Yqg55qE6YWN572u5L+h5oGvXG4gICAgICogQHBhcmFtIHtTaGVldH0gc2hlZXQgLSDlr7nlupTnmoQgc2hlZXQg5a6e5L6LXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdEVsZW1lbnQsIGNvbmZpZywgZXh0Q29uZmlnLCBzaGVldCkge1xuICAgICAgICBsZXQgaG90U2V0dGluZ3MgPSB7fTtcbiAgICAgICAgbGV0IHRyYW5zbGF0b3IgPSBuZXcgQ29uZmlnVHJhbnNsYXRvcihjb25maWcsIHNoZWV0KTtcbiAgICAgICAgbGV0IHNldHRpbmdzID0gdHJhbnNsYXRvci50cmFuc2xhdGUoKTtcbiAgICAgICAgbGV0IHNzID0gc2hlZXQud29ya2Jvb2suc3ByZWFkU2hlZXQ7XG5cbiAgICAgICAgbGV0IGZyYW1lID0gc3MuZ2V0RnJhbWVJbnN0YW5jZSgpO1xuICAgICAgICBsZXQgZGlzcGxheU1vZGUgPSBzcy5nZXREaXNwbGF5TW9kZSgpO1xuICAgICAgICBsZXQgbWVudUl0ZW1zID0gZnJhbWUuY29udGV4dE1lbnUubWVudUl0ZW1zO1xuICAgICAgICBsZXQgY29udGV4dE1lbnUgPSB7fTtcblxuICAgICAgICBjb250ZXh0TWVudS5pdGVtcyA9IGZyYW1lLmNvbnRleHRNZW51LmdldE1lbnVJdGVtczRIb3RUYWJsZSgpO1xuICAgICAgICBjb250ZXh0TWVudS5jYWxsYmFjayA9IChmdW5jdGlvbiAoc2hlZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IG1lbnVJdGVtcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5oYW5kbGVyLmNhbGwodGhpcywgc2hlZXQsIG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oc2hlZXQpKTtcblxuICAgICAgICAhZGlzcGxheU1vZGUgJiYgKEhvdFRhYmxlQWRhcHRvci5fcHJlZmVyZW5jZS5jb250ZXh0TWVudSA9IGNvbnRleHRNZW51KTtcbiAgICAgICAgZGlzcGxheU1vZGUgJiYgKEhvdFRhYmxlQWRhcHRvci5fcHJlZmVyZW5jZS50YWJsZUNsYXNzTmFtZSArPSAnIGRpc3BsYXltb2RlJyk7XG5cbiAgICAgICAgZXh0ZW5kKGhvdFNldHRpbmdzLCBIb3RUYWJsZUFkYXB0b3IuX3ByZWZlcmVuY2UpO1xuICAgICAgICBleHRlbmQoaG90U2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgZXh0ZW5kKGhvdFNldHRpbmdzLCBleHRDb25maWcpO1xuXG4gICAgICAgIGlmIChkaXNwbGF5TW9kZSkge1xuICAgICAgICAgICAgaG90U2V0dGluZ3MuY29sSGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgaG90U2V0dGluZ3Mucm93SGVhZGVycyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIocm9vdEVsZW1lbnQsIGhvdFNldHRpbmdzKTtcblxuICAgICAgICB0aGlzLl90cmFuc2xhdG9yID0gdHJhbnNsYXRvcjtcblxuICAgICAgICAvLyBoYW5kb250YWJsZSDmr4/mrKEgcmVuZGVyIOeahOaXtuWAme+8jOS4jeS/neeVmSB0ZCDnmoTnirbmgIHvvIzlm6DmraTpgJrov4for6Xkuovku7bph43lu7rkuIDkupvmoLflvI/jgIJcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gRVM2TW9kdWxlc0RlcGVuZGVuY2llc1xuICAgICAgICBIYW5kc29udGFibGUuaG9va3MuYWRkKCdiZWZvcmVSZW5kZXJlcicsIGZ1bmN0aW9uIChURCwgcm93LCBjb2wsIHByb3AsIHZhbHVlLCBjZWxsUHJvcGVydGllcykge1xuICAgICAgICAgICAgVEQuc3R5bGUuY29sb3IgPSBjZWxsUHJvcGVydGllcy5fc3R5bGVfY29sb3IgfHwgJyc7XG4gICAgICAgICAgICBURC5zdHlsZS5mb250RmFtaWx5ID0gY2VsbFByb3BlcnRpZXMuX3N0eWxlX2ZvbnRGYW1pbHkgfHwgJyc7XG4gICAgICAgICAgICBURC5zdHlsZS5mb250U2l6ZSA9IGNlbGxQcm9wZXJ0aWVzLl9zdHlsZV9mb250U2l6ZSB8fCAnJztcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLl9zdHlsZV9mb250U2l6ZSAmJiAoVEQuc3R5bGUubGluZUhlaWdodCA9IGNlbGxQcm9wZXJ0aWVzLl9zdHlsZV9mb250U2l6ZSk7XG4gICAgICAgICAgICBURC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjZWxsUHJvcGVydGllcy5fc3R5bGVfYmFja2dyb3VuZENvbG9yIHx8ICcnO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiDlsIYgSGFuZHNvbnRhYmxlIOeahOaJgOacieS6i+S7tumDveWnlOaJmOe7mSBTcHJlYWRTaGVldCDlkI7kvJrmnInkupvljaHjgIJcbiAgICAgICAgICog5Y+q5aW95bCGIEhhbmRzb250YWJsZS5ob29rcy5nZXRSZWdpc3RlcmVkKCkg5o2i5oiQIEVDUCDpobnnm67pnIDopoHnmoTjgIJcbiAgICAgICAgICovXG4gICAgICAgIFsnYWZ0ZXJTZWxlY3Rpb25FbmQnXS5mb3JFYWNoKGhvb2sgPT4ge1xuICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gRVM2TW9kdWxlc0RlcGVuZGVuY2llc1xuICAgICAgICAgICAgSGFuZHNvbnRhYmxlLmhvb2tzLmFkZChob29rLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goaG9vayk7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHNoZWV0KTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICBsZXQgY3h0ID0gc2hlZXQud29ya2Jvb2suc3ByZWFkU2hlZXQ7XG4gICAgICAgICAgICAgICAgY3h0LmVtaXQuYXBwbHkoY3h0LCBhcmdzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc2xhdG9yO1xuICAgIH1cblxufVxuXG5cbi8qKlxuICog6aKE6K6+6YWN572u44CCXG4gKiBAcHJpdmF0ZVxuICovXG5Ib3RUYWJsZUFkYXB0b3IuX3ByZWZlcmVuY2UgPSB7XG4gICAgb3V0c2lkZUNsaWNrRGVzZWxlY3RzOiBmYWxzZSxcbiAgICBjb250ZXh0TWVudTogZmFsc2UsXG5cbiAgICByb3dIZWFkZXJzOiB0cnVlLFxuICAgIGNvbEhlYWRlcnM6IHRydWUsXG5cbiAgICBtYW51YWxDb2x1bW5SZXNpemU6IHRydWUsXG4gICAgbWFudWFsUm93UmVzaXplOiB0cnVlLFxuXG4gICAgdGFibGVDbGFzc05hbWU6ICdzc2QtaGFuZHNvbnRhYmxlLXRhYmxlJyxcblxuICAgIGN1c3RvbUJvcmRlcnM6IHRydWUsXG5cbiAgICB4Rm9ybXVsYXM6IHRydWVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhvdFRhYmxlQWRhcHRvcjsiLCJpbXBvcnQgSGFuZHNvbnRhYmxlIGZyb20gJy4vSG90VGFibGVBZGFwdG9yJztcbmltcG9ydCB7U2hlZXRFcnJvcn0gZnJvbSAnLi9TaGVldEVycm9yJztcbmltcG9ydCB7RXhjaGFuZ2V9IGZyb20gJy4vZXh0L1NoZWV0X2V4Y2hhbmdlJztcbmltcG9ydCB7U2hlZXRIZWxwZXJ9IGZyb20gJy4vZXh0L1NoZWV0X2hlbHBlcic7XG5pbXBvcnQge0Nvb3JkaW5hdGUsIGV4dGVuZH0gZnJvbSAnLi4vdXRpbHMvY29tbW9uJztcbmltcG9ydCBFbWl0dGVyIGZyb20gJy4uL3V0aWxzL0VtaXR0ZXInO1xuXG5cbmNvbnN0IElOSVRfUk9XUyA9IDE1MDsgLy8gU2hlZXQg5Yid5aeL5Y+v5pi+56S655qE6KGM5pWwXG5jb25zdCBJTklUX0NPTFMgPSA1MDsgIC8vIFNoZWV0IOWIneWni+WPr+aYvuekuueahOWIl+aVsFxuXG4vKipcbiAqIOW3peS9nOihqFxuICpcbiAqIEBmaXJlcyBTaGVldCNhZnRlclJlbmFtZVxuICogQGZpcmVzIFNoZWV0I2FmdGVyUmVuYW1lQ2FuY2VsXG4gKi9cbmNsYXNzIFNoZWV0IGV4dGVuZHMgU2hlZXRIZWxwZXIoRXhjaGFuZ2UoRW1pdHRlcikpIHtcblxuICAgIC8qKlxuICAgICAqIOaehOmAoCBTaGVldCDlrp7kvovvvIznlKjmiLfku6PnoIHkuI3lupTor6Xnm7TmjqXosIPnlKjlroPvvIxcbiAgICAgKiDogIzmmK/kvb/nlKggV29ya2Jvb2suY3JlYXRlU2hlZXQoKSDmlrnms5XmnoTpgKDjgIJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V29ya2Jvb2t9IHdvcmtib29rXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iod29ya2Jvb2ssIGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogc2hlZXQg5omA5Zyo55qE5bel5L2c6KGoXG4gICAgICAgICAqIEB0eXBlIHtXb3JrYm9va31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud29ya2Jvb2sgPSB3b3JrYm9vaztcbiAgICAgICAgdGhpcy4kJHZpZXcgPSB3b3JrYm9vay4kJHZpZXc7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBjb25maWc7XG4gICAgICAgIHRoaXMuc2hlZXROYW1lID0gY29uZmlnLm5hbWU7XG5cbiAgICAgICAgdGhpcy5pbml0Um93cyA9IElOSVRfUk9XUztcbiAgICAgICAgdGhpcy5pbml0Q29scyA9IElOSVRfQ09MUztcblxuICAgICAgICB0aGlzLmZ4ID0ge307IC8vIFRPRE9cblxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuJCR2aWV3LmFwcGVuZFRhYih0aGlzLnNoZWV0TmFtZSk7XG4gICAgICAgIHZhciB7Y29udGFpbmVyLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuJCR2aWV3Ll9ob3RUYWJsZXMuZ2V0KHRoaXMuc2hlZXROYW1lKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0hhbmRzb250YWJsZX1cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUgPSBuZXcgSGFuZHNvbnRhYmxlKGNvbnRhaW5lciwgdGhpcy5zZXR0aW5ncywge1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICByZWFkT25seTogdGhpcy53b3JrYm9vay5zcHJlYWRTaGVldC5nZXREaXNwbGF5TW9kZSgpLFxuICAgICAgICAgICAgc3RhcnRSb3dzOiB0aGlzLmluaXRSb3dzLFxuICAgICAgICAgICAgc3RhcnRDb2xzOiB0aGlzLmluaXRDb2xzLFxuICAgICAgICAgICAgX2lzSG90VGFibGVBZGFwdG9yOiB0cnVlLFxuICAgICAgICAgICAgX3NoZWV0OiB0aGlzXG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5fdHJhbnNsYXRvci5pbml0U2hlZXRTdGF0ZSgpO1xuICAgICAgICB0aGlzLl9oYWNrKCk7XG4gICAgICAgIHRoaXMuJCR2aWV3LmhpZGVDb250ZW50KHRoaXMuZ2V0TmFtZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5blvZPliY0gc2hlZXQg55qE5ZCN5a2XXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGVldE5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5r+A5rS75b2T5YmNIHNoZWV0IOmhtVxuICAgICAqL1xuICAgIGFjdGl2ZSgpIHtcbiAgICAgICAgdGhpcy53b3JrYm9vay5hY3RpdmVTaGVldCA9IHRoaXMuZ2V0TmFtZSgpO1xuICAgICAgICB0aGlzLiQkdmlldy5hY3RpdmVUYWIodGhpcy5nZXROYW1lKCkpO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmo4DmtYvlvZPliY0gc2hlZXQg5piv5ZCm6KKr5r+A5rS7XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtib29rLmFjdGl2ZVNoZWV0ID09PSB0aGlzLmdldE5hbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlhbPpl60gc2hlZXQg6aG1XG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMud29ya2Jvb2suY2xvc2VTaGVldCh0aGlzLmdldE5hbWUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6ZSA5q+B5b2T5YmNIHNoZWV0XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLndvcmtib29rLnNoZWV0cy5kZWxldGUodGhpcy5nZXROYW1lKCkpO1xuICAgICAgICBkZWxldGUgdGhpcy53b3JrYm9vaztcbiAgICAgICAgZGVsZXRlIHRoaXMuJCR2aWV3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe7mSBzaGVldCDpobXph43lkb3lkI1cbiAgICAgKiBAcGFyYW0gbmFtZSAtIOaWsOWQjeWtl1xuICAgICAqL1xuICAgIHJlbmFtZShuYW1lKSB7XG4gICAgICAgIHRoaXMud29ya2Jvb2sucmVuYW1lU2hlZXQodGhpcy5nZXROYW1lKCksIG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOmAieS4rSBzaGVldCDkuK3nmoTmn5DljLrln5/jgIJcbiAgICAgKiDkuI3mjIflrpogdG9Sb3cg44CBdG9Db2wg5pe25YiZ6YCJ5Lit5a+55bqU55qE5Y2V5YWD5qC844CCXG4gICAgICogQHBhcmFtIHtpbnR9IGZyb21Sb3cgLSDotbflp4vooYxcbiAgICAgKiBAcGFyYW0ge2ludH0gZnJvbUNvbCAtIOi1t+Wni+WIl1xuICAgICAqIEBwYXJhbSB7aW50fSBbdG9Sb3ddIC0g57uI5q2i6KGMXG4gICAgICogQHBhcmFtIHtpbnR9IFt0b0NvbF0gLSDnu4jmraLliJdcbiAgICAgKi9cbiAgICBzZWxlY3QoZnJvbVJvdywgZnJvbUNvbCwgdG9Sb3csIHRvQ29sKSB7XG4gICAgICAgIHRvUm93ID0gdG9Sb3cgfHwgZnJvbVJvdztcbiAgICAgICAgdG9Db2wgPSB0b0NvbCB8fCBmcm9tQ29sO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5zZWxlY3RDZWxsKGZyb21Sb3csIGZyb21Db2wsIHRvUm93LCB0b0NvbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+W+l+W9k+WJjSBzaGVldCDnmoTpgInljLpcbiAgICAgKiBAcmV0dXJucyB7e3JvdywgY29sLCBlbmRSb3csIGVuZENvbH19XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5oYW5kc29udGFibGUuZ2V0U2VsZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogc2VsZWN0aW9uWzBdLFxuICAgICAgICAgICAgY29sOiBzZWxlY3Rpb25bMV0sXG4gICAgICAgICAgICBlbmRSb3c6IHNlbGVjdGlvblsyXSxcbiAgICAgICAgICAgIGVuZENvbDogc2VsZWN0aW9uWzNdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlkIjlubbljZXlhYPmoLxcbiAgICAgKiBUSVA6IGhhbmRzb250YWJsZSDlrpjmlrnlkIjlubblip/og73kuI3og73mraPnoa7lpITnkIblt7LmnInnmoTlkIjlubbljLrln5/vvIzmlYXlgZrph43mlrDorqHnrpfjgIJcbiAgICAgKiBAcGFyYW0ge2ludH0gcm93IC0g6LW35aeL6KGMXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbCAtIOi1t+Wni+WIl1xuICAgICAqIEBwYXJhbSB7aW50fSByb3dzcGFuIC0g5b6F5ZCI5bm255qE6KGM5pWwXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbHNwYW4gLSDlvoXlkIjlubbnmoTliJfmlbBcbiAgICAgKi9cbiAgICAvLyBUT0RPIOacgOWkp+ihjOWIl+aVsOmZkOWItlxuICAgIG1lcmdlQ2VsbHMocm93LCBjb2wsIHJvd3NwYW4sIGNvbHNwYW4pIHtcbiAgICAgICAgdmFyIHIgPSAwO1xuICAgICAgICB2YXIgY292ZXIgPSBbXTtcbiAgICAgICAgdmFyIG1lcmdlQ2VsbHMgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRTZXR0aW5ncygpLm1lcmdlQ2VsbHM7XG5cbiAgICAgICAgdmFyIHIxID0gW3JvdywgY29sLCByb3cgKyByb3dzcGFuIC0gMSwgY29sICsgY29sc3BhbiAtIDFdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBtZXJnZUNlbGxzLmxlbmd0aDsgaTsgLS1pKSB7XG4gICAgICAgICAgICBsZXQgZiA9IG1lcmdlQ2VsbHNbaSAtIDFdO1xuICAgICAgICAgICAgbGV0IHIyID0gW2Yucm93LCBmLmNvbCwgZi5yb3cgKyBmLnJvd3NwYW4gLSAxLCBmLmNvbCArIGYuY29sc3BhbiAtIDFdO1xuXG4gICAgICAgICAgICAvLyDkuI7ljp/ljLrln5/lrZjlnKjlrozlhajph43lj6BcbiAgICAgICAgICAgIGlmIChDb29yZGluYXRlLmlzRXF1YWwocjEsIHIyKSkge1xuICAgICAgICAgICAgICAgIHIgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5piv5Y6f5Yy65Z+f55qE5a2Q6ZuGXG4gICAgICAgICAgICBpZiAoQ29vcmRpbmF0ZS5pc1N1YnNldChyMSwgcjIpKSB7XG4gICAgICAgICAgICAgICAgciA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDopobnm5bljp/ljLrln5/vvIjmraTml7blj6/og73kuI7lj6bkuIDkuKrljp/ljLrln5/kuqTpm4bmiJblrozlhajopobnm5bvvIlcbiAgICAgICAgICAgIGlmIChDb29yZGluYXRlLmlzU3VwZXJzZXQocjEsIHIyKSkge1xuICAgICAgICAgICAgICAgIGNvdmVyLnB1c2goaSAtIDEpO1xuICAgICAgICAgICAgICAgIHIgPSAzO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5LiO5Y6f5Yy65Z+f5a2Y5Zyo5Lqk6ZuGKOS4jeWQq+WtkOmbhuOAgei2hembhuaDheWGtSlcbiAgICAgICAgICAgIGlmIChDb29yZGluYXRlLmludGVyc2VjdGlvbihyMSwgcjIpKSB7XG4gICAgICAgICAgICAgICAgciA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAociA9PT0gMCB8fCByID09PSAzKSB7XG4gICAgICAgICAgICBpZiAociA9PT0gMykgeyAvLyDov5nnp43mg4XlhrXkuIvkuIDlrprlrZjlnKjlt7Lnu4/lkIjlubbov4fnmoTljZXlhYPmoLxcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlQ2VsbHMuc3BsaWNlKGNvdmVyW2ldLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZUNlbGxzID0gbWVyZ2VDZWxscyB8fCBbXTtcbiAgICAgICAgICAgIG1lcmdlQ2VsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgcm93c3Bhbjogcm93c3BhbixcbiAgICAgICAgICAgICAgICBjb2xzcGFuOiBjb2xzcGFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnVwZGF0ZVNldHRpbmdzKHtcbiAgICAgICAgICAgICAgICBtZXJnZUNlbGxzOiBtZXJnZUNlbGxzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChyID09PSAyIHx8IHIgPT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDnu5nlrprnmoTlkIjlubbljLrln5/kuI3lkIjms5U6IFske3Jvd30sICR7Y29sfSwgJHtyb3dzcGFufSwgJHtjb2xzcGFufV1gKVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDlj5bmtojljZXlhYPmoLzlkIjlubZcbiAgICAgKiBAcGFyYW0ge2ludH0gcm93IC0g6LW35aeL6KGMXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbCAtIOi1t+Wni+WIl1xuICAgICAqIEBwYXJhbSB7aW50fSByb3dzcGFuIC0g5b6F5ZCI5bm255qE6KGM5pWwXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbHNwYW4gLSDlvoXlkIjlubbnmoTliJfmlbBcbiAgICAgKi9cbiAgICB1bk1lcmdlQ2VsbHMocm93LCBjb2wsIHJvd3NwYW4sIGNvbHNwYW4pIHtcbiAgICAgICAgdmFyIG1lcmdlZCA9IHRoaXMuaGFuZHNvbnRhYmxlLmdldFNldHRpbmdzKCkubWVyZ2VDZWxscztcbiAgICAgICAgdmFyIG1lcmdlQ2VsbHMgPSBbXTtcbiAgICAgICAgaWYgKG1lcmdlZCAmJiBtZXJnZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lcmdlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChDb29yZGluYXRlLmlzU3Vic2V0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZFtpXS5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRbaV0uY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW2ldLnJvdyArIG1lcmdlZFtpXS5yb3dzcGFuIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZFtpXS5jb2wgKyBtZXJnZWRbaV0uY29sc3BhbiAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSwgW3JvdywgY29sLCByb3cgKyByb3dzcGFuIC0gMSwgY29sICsgY29sc3BhbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVyZ2VDZWxscy5wdXNoKG1lcmdlZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe1xuICAgICAgICAgICAgbWVyZ2VDZWxsczogbWVyZ2VDZWxscy5sZW5ndGggPT09IDAgPyBmYWxzZSA6IG1lcmdlQ2VsbHNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3BsaWNlQ2xhc3Moc2VsZWN0aW9uLCBuZXdDbGFzc05hbWUsIC4uLmNsYXNzTmFtZXMpIHtcbiAgICAgICAgdGhpcy5fd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgKHJvdywgY29sLCBjZWxsTWV0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICh0aGlzLl9yZW1vdmVGb3JtZXJDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgY2VsbE1ldGEuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzXG4gICAgICAgICAgICAgICAgKSArICcgJyArIG5ld0NsYXNzTmFtZSkudHJpbSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7Y2xhc3NOYW1lOiBuZXdDbGFzc05hbWV9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva7lrZfkvZPliqDnspdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZT10cnVlXSBgdHJ1ZWAg5Li65Yqg57KX77yMYGZhbHNlYCDlj5bmtojliqDnspdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VsZWN0aW9uIC0g5b6F6K6+572u55qE6YCJ5Yy6XG4gICAgICogQHBhcmFtIHtpbnR9IHNlbGVjdGlvbi5yb3dcbiAgICAgKiBAcGFyYW0ge2ludH0gc2VsZWN0aW9uLmNvbFxuICAgICAqIEBwYXJhbSB7aW50fSBbc2VsZWN0aW9uLmVuZFJvd11cbiAgICAgKiBAcGFyYW0ge2ludH0gW3NlbGVjdGlvbi5lbmRDb2xdXG4gICAgICovXG4gICAgc2V0Rm9udEJvbGQodmFsdWUgPSB0cnVlLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2VDbGFzcyhzZWxlY3Rpb24sICdzc2QtZm9udC1ib2xkJywgJ3NzZC1mb250LWJvbGQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlQ2xhc3Moc2VsZWN0aW9uLCAnJywgJ3NzZC1mb250LWJvbGQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva7mlpzkvZPlrZdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZT10cnVlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZWxlY3Rpb24gLSDlvoXorr7nva7nmoTpgInljLpcbiAgICAgKiBAcGFyYW0ge2ludH0gc2VsZWN0aW9uLnJvd1xuICAgICAqIEBwYXJhbSB7aW50fSBzZWxlY3Rpb24uY29sXG4gICAgICogQHBhcmFtIHtpbnR9IFtzZWxlY3Rpb24uZW5kUm93XVxuICAgICAqIEBwYXJhbSB7aW50fSBbc2VsZWN0aW9uLmVuZENvbF1cbiAgICAgKi9cbiAgICBzZXRGb250SXRhbGljKHZhbHVlID0gdHJ1ZSwgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlQ2xhc3Moc2VsZWN0aW9uLCAnc3NkLWZvbnQtaXRhbGljJywgJ3NzZC1mb250LWl0YWxpYycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2VDbGFzcyhzZWxlY3Rpb24sICcnLCAnc3NkLWZvbnQtaXRhbGljJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUucmVuZGVyKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDorr7nva7lrZfkvZPkuIvliJLnur9cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZT10cnVlXVxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb24gLSDlvoXorr7nva7nmoTpgInljLpcbiAgICAgKiBAcGFyYW0ge2ludH0gc2VsZWN0aW9uLnJvd1xuICAgICAqIEBwYXJhbSB7aW50fSBzZWxlY3Rpb24uY29sXG4gICAgICogQHBhcmFtIHtpbnR9IFtzZWxlY3Rpb24uZW5kUm93XVxuICAgICAqIEBwYXJhbSB7aW50fSBbc2VsZWN0aW9uLmVuZENvbF1cbiAgICAgKi9cbiAgICBzZXRGb250VW5kZXJsaW5lKHZhbHVlID0gdHJ1ZSwgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlQ2xhc3Moc2VsZWN0aW9uLCAnc3NkLWZvbnQtdW5kZXJsaW5lJywgJ3NzZC1mb250LXVuZGVybGluZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2VDbGFzcyhzZWxlY3Rpb24sICcnLCAnc3NkLWZvbnQtdW5kZXJsaW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u5a2X5L2T6aKc6ImyXG4gICAgICogVElQIOWmguaenCDigJxoYW5kb250YWJsZSDnm7TmjqXpgJrov4cgZ2V0Q2VsbCDojrflvpcgVEQg5ZCO6K6+572u5qC35byP4oCd77yM5b2T5YaN5qyhIHJlbmRlciDml7bkvJrlpLHmlYjjgIJcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2V0Rm9udENvbG9yKHZhbHVlID0gJycsIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5fd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfc3R5bGVfY29sb3I6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7X3N0eWxlX2NvbG9yOiB2YWx1ZX0pO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlrZfkvZPnsbvlnotcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2V0Rm9udEZhbWlseSh2YWx1ZSA9ICcnLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIHRoaXMuX3dhbGtvbkNlbGxNZXRhcyhzZWxlY3Rpb24sICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3N0eWxlX2ZvbnRGYW1pbHk6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7X3N0eWxlX2ZvbnRGYW1pbHk6IHZhbHVlfSk7XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWtl+S9k+Wkp+Wwj1xuICAgICAqIEBwYXJhbSB2YWx1ZSAtIOmcgOimgeaMh+WumuWNleS9je+8jOWmgiAxMnB4XG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNldEZvbnRTaXplKHZhbHVlLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIHRoaXMuX3dhbGtvbkNlbGxNZXRhcyhzZWxlY3Rpb24sICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3N0eWxlX2ZvbnRTaXplOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwge19zdHlsZV9mb250U2l6ZTogdmFsdWV9KTtcbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u6IOM5pmv6ImyXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNldEJhY2tncm91bmRDb2xvcih2YWx1ZSA9ICcnLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIHRoaXMuX3dhbGtvbkNlbGxNZXRhcyhzZWxlY3Rpb24sICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3N0eWxlX2JhY2tncm91bmRDb2xvcjogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHtfc3R5bGVfYmFja2dyb3VuZENvbG9yOiB2YWx1ZX0pO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEZJWE1FIGhhbmRzb250YWJsZSDnmoQgQlVHIOWwmuacquWkhOeQhu+8jOa6kOeggeWkjeadgu+8jOS4gOaXtuS5n+S4jeWlveaJqeWxleOAglxuICAgICAqIOiuvue9rui+ueahhlxuICAgICAqIEBwYXJhbSByYW5nZSAtIOi+ueahhuiMg+WbtO+8jOW9ouWmgiBge2Zvcm06IHtyb3c6IDEsIGNvbDogMX0sIHRvOiB7cm93OiAzLCBjb2w6IDR9fWAg55qE5a+56LGhXG4gICAgICogQHBhcmFtIHRvcCAtIOS4iui+ueahhu+8jOW9ouWmgiBge3dpZHRoOiAyLCBjb2xvcjogJyM1MjkyRjcnfWAg55qE5a+56LGhXG4gICAgICogQHBhcmFtIFtyaWdodF1cbiAgICAgKiBAcGFyYW0gW2JvdHRvbV1cbiAgICAgKiBAcGFyYW0gW2xlZnRdXG4gICAgICovXG4gICAgc2V0Qm9yZGVyKHJhbmdlLCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgIH07XG4gICAgICAgIGNvbmZpZy5yaWdodCA9IHJpZ2h0IHx8IHRvcDtcbiAgICAgICAgY29uZmlnLmJvdHRvbSA9IGJvdHRvbSB8fCB0b3A7XG4gICAgICAgIGNvbmZpZy5sZWZ0ID0gbGVmdCB8fCBjb25maWcucmlnaHQ7XG5cbiAgICAgICAgbGV0IGZvcm1lckJvcmRlcnMgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRTZXR0aW5ncygpLmN1c3RvbUJvcmRlcnM7XG4gICAgICAgIGlmIChmb3JtZXJCb3JkZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmb3JtZXJCb3JkZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWVyQm9yZGVycy5wdXNoKGNvbmZpZyk7XG5cbiAgICAgICAgLy8gVE9ETyBjdXN0b21Cb3JkZXJzIGNhbm5vdCBiZSB1cGRhdGVkIHZpYSB1cGRhdGVTZXR0aW5nc1xuICAgICAgICAvLyBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvMjAwMn1cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe1xuICAgICAgICAgICAgY3VzdG9tQm9yZGVyczogZm9ybWVyQm9yZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgLy90aGlzLmhhbmRzb250YWJsZS5ydW5Ib29rcygnYWZ0ZXJJbml0Jyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDorr7nva7mlbDmja7moLzlvI9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gYHRleHRgIHwgYGRhdGVgIHwgYG51bWVyaWNgXG4gICAgICogQHBhcmFtIHNldHRpbmdzXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNldERhdGFGb3JtYXQodHlwZT0ndGV4dCcsIHNldHRpbmdzID0ge30sIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5fd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgKHJvdywgY29sLCBjZWxsTWV0YSkgPT4ge1xuICAgICAgICAgICAgbGV0IGZUeXBlID0gY2VsbE1ldGEudHlwZTtcblxuICAgICAgICAgICAgaWYgKGZUeXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2VsbE1ldGEuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2VsbE1ldGEuZGVmYXVsdERhdGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNlbGxNZXRhLmNvcnJlY3RGb3JtYXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZUeXBlID09PSAnbnVtZXJpYycpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2VsbE1ldGEuZm9ybWF0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjZWxsTWV0YS5sYW5ndWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxNZXRhLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvNDM2MFxuICAgICAgICAgICAgZGVsZXRlIGNlbGxNZXRhLnJlbmRlcmVyO1xuICAgICAgICAgICAgZGVsZXRlIGNlbGxNZXRhLmVkaXRvcjtcbiAgICAgICAgICAgIGRlbGV0ZSBjZWxsTWV0YS52YWxpZGF0b3I7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKGNlbGxNZXRhLCBzZXR0aW5ncyk7XG4gICAgICAgIH0sIHt0eXBlOiB0eXBlfSk7XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnJlbmRlcigpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTaGVldDtcblxuXG4vKipcbiAqIGFmdGVyUmVuYW1lIOS6i+S7tuOAglxuICpcbiAqIEBldmVudCBTaGVldCNhZnRlclJlbmFtZVxuICogQHR5cGUge1NoZWV0fVxuICogQHR5cGUge3N0cmluZ31cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblxuLyoqXG4gKiBhZnRlclJlbmFtZUNhbmNlbCDkuovku7bjgIJcbiAqXG4gKiBAZXZlbnQgU2hlZXQjYWZ0ZXJSZW5hbWVDYW5jZWxcbiAqIEB0eXBlIHtTaGVldH1cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5cbiIsImltcG9ydCB7U3ByZWFkU2hlZXRFcnJvcn0gZnJvbSAnLi4vU3ByZWFkU2hlZXRFcnJvcidcblxuZXhwb3J0IGZ1bmN0aW9uIFNoZWV0RXJyb3IodmFsdWUpIHtcbiAgICB0aGlzLm5hbWUgPSAnU2hlZXRFcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gdmFsdWU7XG59XG5TaGVldEVycm9yLnByb3RvdHlwZSA9IG5ldyBTcHJlYWRTaGVldEVycm9yKCk7XG5TaGVldEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoZWV0RXJyb3I7IiwiaW1wb3J0IFRhYnMgZnJvbSAgJy4vdmlld3MvVGFicydcbmltcG9ydCBTaGVldCBmcm9tICcuL1NoZWV0J1xuaW1wb3J0IHtTaGVldEVycm9yfSBmcm9tICcuL1NoZWV0RXJyb3InXG5pbXBvcnQge0Nhc2VJbnNlbnNpdGl2ZU1hcH0gZnJvbSAnLi4vdXRpbHMvZGF0YVN0cnVjdHVyZSdcbmltcG9ydCB7dXBwZXJDYXNlfSBmcm9tICcuLi91dGlscy9jb21tb24nXG5pbXBvcnQge2dsb2JhbFNldHRpbmdzfSBmcm9tICcuLi9zZXR0aW5ncydcblxuXG5jb25zdCByZWdFeHAgPSBnbG9iYWxTZXR0aW5ncy5zaGVldC5zaGVldE5hbWU7XG5cbi8qKlxuICog5bel5L2c57C/44CC5LiA5LiqIFdvcmtib29rIOWMheWQq+S4gOS4quaIluWkmuS4qiBTaGVldCAuXG4gKi9cbmNsYXNzIFdvcmtib29rIHtcblxuICAgIC8qKlxuICAgICAqIFdvcmtib29rIOaehOmAoOWZqFxuICAgICAqIEBwYXJhbSB7U3ByZWFkU2hlZXR9IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluc3RhbmNlLCBjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTcHJlYWRTaGVldH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ByZWFkU2hlZXQgPSBpbnN0YW5jZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtDYXNlSW5zZW5zaXRpdmVNYXB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoZWV0cyA9IG5ldyBDYXNlSW5zZW5zaXRpdmVNYXAoKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IGNvbmZpZztcblxuICAgICAgICB0aGlzLl9pbml0U2V0dGluZ3MoY29uZmlnKTtcbiAgICAgICAgdGhpcy4kJHZpZXcgPSBuZXcgVGFicyh0aGlzKTtcblxuICAgICAgICBjb25maWcuc2hlZXRzLmZvckVhY2godiA9PiB0aGlzLmNyZWF0ZVNoZWV0KHYpKTtcblxuICAgICAgICAvLyDmoLnmja7liJ3lp4vljJbmlbDmja7mv4DmtLsgc2hlZXQg6aG1XG4gICAgICAgIGxldCB0b0FjdGl2ZSA9IHRoaXMuZ2V0U2hlZXQodGhpcy5hY3RpdmVTaGVldCk7XG4gICAgICAgIGlmICghdG9BY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDmjIflrprnmoQgYWN0aXZlU2hlZXQg5LiN5a2Y5ZyoOiAke3RoaXMuYWN0aXZlU2hlZXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9BY3RpdmUuYWN0aXZlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoa2V5c1tpXSA9PT0gJ3NoZWV0cycpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBzZXR0aW5nc1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPliBXb3JrYm9vayDmiYDlsZ7nmoTnlLXlrZDooajmoLznmoTnlKjmiLfliJ3lp4vphY3nva7jgIJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcHJlYWRTaGVldC5nZXRTZXR0aW5ncygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjSBXb3JrYm9vayDnmoQgaWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCB8fCAodGhpcy5pZCA9IHRoaXMuc3ByZWFkU2hlZXQuZ2V0SWQoKSArIGdsb2JhbFNldHRpbmdzLmlkU3VmZml4NFdvcmtib29rKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmoLnmja7mjIflrpogc2hlZXQg5ZCN6I635Y+WIHNoZWV0IOWunuS+i1xuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHJldHVybnMge1NoZWV0fVxuICAgICAqL1xuICAgIGdldFNoZWV0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hlZXRzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5blvZPliY0gV29ya2Jvb2sg5LiL55qE5omA5pyJIHNoZWV0IOWunuS+i1xuICAgICAqIEByZXR1cm5zIHtDYXNlSW5zZW5zaXRpdmVNYXB9XG4gICAgICovXG4gICAgZ2V0U2hlZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGVldHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5omA5pyJIHNoZWV0IOeahOWQjeWtl1xuICAgICAqIEByZXR1cm5zIHtJdGVyYXRvci48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBnZXRTaGVldE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGVldHMua2V5cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOajgOmqjCBzaGVldCDmmK/lkKblt7LlrZjlnKhcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4YWN0bHk9ZmFsc2VdIC0g5piv5ZCm5L2/55So57K+56Gu5aSn5bCP5YaZ55qEIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NoZWV0RXhpc3QobmFtZSwgZXhhY3RseSkge1xuICAgICAgICBpZiAoZXhhY3RseSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hlZXRzLmhhc0V4YWN0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiAhIXRoaXMuZ2V0U2hlZXQobmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNoZWV0cy5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog55Sf5oiQIHNoZWV0IOe0ouW8lVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBfZ2V0QXV0b1NoZWV0SW5kZXgoKSB7XG4gICAgICAgIGlmICghdGhpcy4kJGF1dG9TaGVldEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLiQkYXV0b1NoZWV0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiArK3RoaXMuJCRhdXRvU2hlZXRJbmRleDsgLy8g5LuOIDEg5byA5aeLXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6Ieq5Yqo55Sf5oiQIHNoZWV0IOWQjVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QXV0b1NoZWV0TmFtZSgpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gZ2xvYmFsU2V0dGluZ3Muc2hlZXQuYXV0b1ByZWZpeCArICcnOyAvLyDpmLLmraLlh7rnjrDmlbDlrZfnm7jliqBcbiAgICAgICAgbGV0IG5hbWUgPSBwcmVmaXggKyB0aGlzLl9nZXRBdXRvU2hlZXRJbmRleCgpO1xuICAgICAgICBpZiAodGhpcy5pc1NoZWV0RXhpc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBdXRvU2hlZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmN5r+A5rS755qEIHNoZWV0IOmhtVxuICAgICAqIEByZXR1cm5zIHtTaGVldH1cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVTaGVldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hlZXRzLmdldCh0aGlzLmFjdGl2ZVNoZWV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliJvlu7rmlrDnmoQgc2hlZXQg6aG1XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb25maWddIC0gc2hlZXQg6aG155qE6YWN572u5L+h5oGvXG4gICAgICogQHJldHVybnMge1NoZWV0fSDmlrDliJvlu7rnmoTlt6XkvZzooahcbiAgICAgKi9cbiAgICBjcmVhdGVTaGVldChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZykgeyAgLy8g5qC55o2u5Yid5aeL6YWN572u5Yib5bu677yMbmFtZSDkuI3og73kuLrnqbpcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlU2hlZXROYW1lKGNvbmZpZy5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHsgLy8g55So5oi35pON5L2c5Yib5bu677yM5Yqo5oCB55Sf5oiQIG5hbWVcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgY29uZmlnLm5hbWUgPSB0aGlzLl9nZXRBdXRvU2hlZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld09uZSA9IG5ldyBTaGVldCh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLnNoZWV0cy5zZXQoY29uZmlnLm5hbWUsIG5ld09uZSk7XG4gICAgICAgIHJldHVybiBuZXdPbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6ZSA5q+B5oyH5a6aIHNoZWV0IOmhtVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgU2hlZXR9IHNoZWV0IC0gc2hlZXQg5ZCN56ew5oiW5a6e5L6LXG4gICAgICovXG4gICAgZGVzdHJveVNoZWV0KHNoZWV0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2hlZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoc2hlZXQpO1xuICAgICAgICB9XG4gICAgICAgIHNoZWV0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu5nmjIflrprnmoQgc2hlZXQg6aG16YeN5ZG95ZCNXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUxIC0g5b6F6YeN5ZG95ZCN55qEIHNoZWV0IOmhteWQjeWtl1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lMiAtIOaWsOWQjeWtl1xuICAgICAqL1xuICAgIC8vIEZJWE1FIOe8lui+kemUmeS9je+8mlxuICAgIC8vIGhhbmRzb250YWJsZSDlnKjpgInkuK3mn5DljZXlhYPmoLzkvYbmsqHov5vlhaXnvJbovpHml7bvvIzkvJrnm5HlkKwgZG9jdW1lbnQg5LiK55qEIGtleWRvd24g5LqL5Lu277yMXG4gICAgLy8g6YCg5oiQ5L+u5pS5IHNoZWV0IOWQjeaXtueahOaWh+acrOahhuaXoOazleato+ehruWkhOeQhu+8iOS8mui+k+WFpeWIsOihqOagvOS4re+8iVxuICAgIC8vIOaaguaXtuS9v+eUqCBpbnB1dCDnmoQgc2VsZWN0IOS7o+abvyBmb2N1c++8jOi/q+S9v+eUqOaIt+WGjeasoeeCueWHu3NoZWV05ZCN5pe25omN6IO95L+u5pS544CCXG4gICAgcmVuYW1lU2hlZXQobmFtZTEsIG5hbWUyKSB7XG4gICAgICAgIGxldCBzaGVldCA9IHRoaXMuZ2V0U2hlZXQobmFtZTEpO1xuICAgICAgICBpZiAoIXNoZWV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5bel5L2c6KGoIFwiJHtuYW1lMX1cIiDkuI3lrZjlnKhgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZTEgIT09IG5hbWUyKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVNoZWV0TmFtZShuYW1lMiwgdXBwZXJDYXNlKG5hbWUxKSA9PT0gdXBwZXJDYXNlKG5hbWUyKSk7XG4gICAgICAgICAgICBzaGVldC5zaGVldE5hbWUgPSBuYW1lMjtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVNoZWV0ID09PSBuYW1lMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlU2hlZXQgPSBuYW1lMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2V0U2hlZXRzKCkuZGVsZXRlKG5hbWUxKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2hlZXRzKCkuc2V0KG5hbWUyLCBzaGVldCk7XG4gICAgICAgICAgICB0aGlzLiQkdmlldy50YWJSZW5hbWUobmFtZTEsIG5hbWUyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCR2aWV3LnRhYlJlbmFtZUNhbmNlbChuYW1lMSwgbmFtZTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5YWz6Zet5oyH5a6aIHNoZWV0IOmhtVxuICAgICAqL1xuICAgIGNsb3NlU2hlZXQobmFtZSkge1xuICAgICAgICBsZXQgc2hlZXQgPSB0aGlzLmdldFNoZWV0KG5hbWUpO1xuICAgICAgICBpZiAoIXNoZWV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5peg5rOV5YWz6Zet5LiN5a2Y5Zyo55qE5bel5L2c6KGoIFwiJHtuYW1lfVwiIOOAgmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNoZWV0cy5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDml6Dms5XlhbPpl63ku4XmnInnmoTkuIDkuKrlt6XkvZzooaggXCIke25hbWV9XCIg44CCYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoZWV0LmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgb2YgdGhpcy5zaGVldHMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsgJiYgayAhPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVNoZWV0ID0gaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTaGVldChrKS5hY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hlZXRzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgdGhpcy4kJHZpZXcucmVtb3ZlVGFiKG5hbWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lTaGVldChzaGVldCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDmv4DmtLvlvZPliY0gd29ya2Jvb2tcbiAgICAgKi9cbiAgICBhY3RpdmUoKSB7XG4gICAgICAgIHRoaXMuZ2V0QWN0aXZlU2hlZXQoKS5hY3RpdmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmv4DmtLvmjIflrpogc2hlZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lXG4gICAgICovXG4gICAgYWN0aXZlU2hlZXQoc2hlZXROYW1lKSB7XG4gICAgICAgIGxldCBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoc2hlZXROYW1lKTtcbiAgICAgICAgaWYgKHNoZWV0KSB7XG4gICAgICAgICAgICBzaGVldC5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOmqjOivgSBzaGVldCDlkI3mmK/lkKblkIjms5VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhhY3RseVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbGlkYXRlU2hlZXROYW1lKG5hbWUsIGV4YWN0bHkpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcign5bel5L2c6KGo55qE5ZCN56ew5LiN6IO95Li656m6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIOemgeatouS4gOS6m+eJueauiuWtl+esplxuICAgICAgICBpZiAocmVnRXhwLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDlt6XkvZzooaggXCIke25hbWV9XCIg5YyF5ZCr6Z2e5rOV5a2X56ymYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTaGVldEV4aXN0KG5hbWUsIGV4YWN0bHkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5bel5L2c6KGoIFwiJHtuYW1lfVwiIOW3suWtmOWcqGApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldEV4Y2hhbmdlKCkge1xuICAgICAgICBsZXQgc2hlZXRzID0gW107XG4gICAgICAgIGZvciAobGV0IFssc2hlZXRdIG9mIHRoaXMuZ2V0U2hlZXRzKCkudG9NYXAoKSkge1xuICAgICAgICAgICAgc2hlZXQgJiYgc2hlZXRzLnB1c2goc2hlZXQuX2dldEV4Y2hhbmdlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmVTaGVldDogdGhpcy5hY3RpdmVTaGVldCxcbiAgICAgICAgICAgIHNoZWV0czogc2hlZXRzXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV29ya2Jvb2s7IiwiZXhwb3J0IGNvbnN0IEV4Y2hhbmdlID0gU3VwID0+IGNsYXNzIGV4dGVuZHMgU3VwIHtcblxuICAgIF9nZXRFeGNoYW5nZSgpIHtcbiAgICAgICAgdmFyIHtkYXRhLCBjZWxsc30gPSB0aGlzLl9nZXREYXRhTWV0YSgpO1xuICAgICAgICB2YXIge2hlaWdodHMsIHdpZHRoc30gPSB0aGlzLl9nZXRTaXplRXgoKTtcbiAgICAgICAgdmFyIG1lcmdlQ2VsbHMgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRTZXR0aW5ncygpLm1lcmdlQ2VsbHM7XG5cbiAgICAgICAgaWYgKG1lcmdlQ2VsbHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtZXJnZUNlbGxzID0gbnVsbDsgLy8g6YG/5YWN5by657G75Z6L6K+t6KiA6Kej5p6Q5pe25peg5rOV5aSE55CG5Yqo5oCB57G75Z6LXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5nZXROYW1lKCksXG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBkYXRhOiBkYXRhLmxlbmd0aCA/IGRhdGEgOiBbXS5fLFxuICAgICAgICAgICAgcm93SGVpZ2h0czogaGVpZ2h0cyxcbiAgICAgICAgICAgIGNvbFdpZHRoczogd2lkdGhzLFxuICAgICAgICAgICAgbWVyZ2VDZWxsczogbWVyZ2VDZWxscyxcbiAgICAgICAgICAgIGNlbGxNZXRhczogY2VsbHNcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgX2dldFN0eWxlc0V4KG1ldGEpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICB2YXIgYWxpZ25tZW50cyA9IHRoaXMuX2dldEFsaWdubWVudEV4KG1ldGEuY2xhc3NOYW1lKTtcbiAgICAgICAgaWYgKGFsaWdubWVudHMpIHtcbiAgICAgICAgICAgIHJldC5hbGlnbm1lbnRzID0gYWxpZ25tZW50c1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dldEZvbnRFeChtZXRhLCByZXQpO1xuICAgICAgICB0aGlzLl9nZXRCZ0NvbG9yRXgobWV0YSwgcmV0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cblxuICAgIF9nZXRCZ0NvbG9yRXgobWV0YSwgcmV0KSB7XG4gICAgICAgIGlmIChtZXRhLl9zdHlsZV9iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIHJldC5iYWNrZ3JvdW5kQ29sb3IgPSBtZXRhLl9zdHlsZV9iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9nZXRGb250RXgobWV0YSwgcmV0KSB7XG4gICAgICAgIGlmIChtZXRhLl9zdHlsZV9mb250RmFtaWx5KSB7XG4gICAgICAgICAgICByZXQuZm9udEZhbWlseSA9IG1ldGEuX3N0eWxlX2ZvbnRGYW1pbHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuX3N0eWxlX2ZvbnRTaXplKSB7XG4gICAgICAgICAgICByZXQuZm9udFNpemUgPSBtZXRhLl9zdHlsZV9mb250U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5jbGFzc05hbWUgJiYgbWV0YS5jbGFzc05hbWUuY29udGFpbnMoJ3NzZC1mb250LWl0YWxpYycpKSB7XG4gICAgICAgICAgICByZXQuZm9udFN0eWxlID0gJ2l0YWxpYyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuY2xhc3NOYW1lICYmIG1ldGEuY2xhc3NOYW1lLmNvbnRhaW5zKCdzc2QtZm9udC1ib2xkJykpIHtcbiAgICAgICAgICAgIHJldC5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmNsYXNzTmFtZSAmJiBtZXRhLmNsYXNzTmFtZS5jb250YWlucygnc3NkLWZvbnQtdW5kZXJsaW5lJykpIHtcbiAgICAgICAgICAgIHJldC50ZXh0RGVjb3JhdGlvbiA9ICd1bmRlcmxpbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLl9zdHlsZV9jb2xvcikge1xuICAgICAgICAgICAgcmV0LmNvbG9yID0gbWV0YS5fc3R5bGVfY29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9nZXRBbGlnbm1lbnRFeChjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGFsaWdubWVudCA9IFtdO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0TGVmdCcpICYmIGFsaWdubWVudC5wdXNoKCdMZWZ0Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0Q2VudGVyJykgJiYgYWxpZ25tZW50LnB1c2goJ0NlbnRlcicpO1xuICAgICAgICAgICAgY2xhc3NOYW1lLmNvbnRhaW5zKCdodFJpZ2h0JykgJiYgYWxpZ25tZW50LnB1c2goJ1JpZ2h0Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0SnVzdGlmeScpICYmIGFsaWdubWVudC5wdXNoKCdKdXN0aWZ5Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0VG9wJykgJiYgYWxpZ25tZW50LnB1c2goJ1RvcCcpO1xuICAgICAgICAgICAgY2xhc3NOYW1lLmNvbnRhaW5zKCdodE1pZGRsZScpICYmIGFsaWdubWVudC5wdXNoKCdNaWRkbGUnKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZS5jb250YWlucygnaHRCb3R0b20nKSAmJiBhbGlnbm1lbnQucHVzaCgnQm90dG9tJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsaWdubWVudC5sZW5ndGggPyBhbGlnbm1lbnQgOiBmYWxzZTtcbiAgICB9XG5cblxuICAgIF9nZXRTaXplRXgoKSB7XG4gICAgICAgIHZhciBob3QgPSB0aGlzLmhhbmRzb250YWJsZTtcbiAgICAgICAgdmFyIGNvbHMgPSBNYXRoLm1heChob3QuY291bnRDb2xzKCkgLSBob3QuY291bnRFbXB0eUNvbHModHJ1ZSksIDIwKTtcbiAgICAgICAgdmFyIHJvd3MgPSBNYXRoLm1heChob3QuY291bnRSb3dzKCkgLSBob3QuY291bnRFbXB0eVJvd3ModHJ1ZSksIDUwKTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBbXTtcbiAgICAgICAgdmFyIHdpZHRocyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGhvdC5nZXRSb3dIZWlnaHQoaSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiAhaCkgeyAvLyBoYW5kc29udGFibGUgYnVnXG4gICAgICAgICAgICAgICAgaCA9IDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVpZ2h0cy5wdXNoKGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgKytpKSB7XG4gICAgICAgICAgICB3aWR0aHMucHVzaChob3QuZ2V0Q29sV2lkdGgoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7aGVpZ2h0cywgd2lkdGhzfTtcbiAgICB9XG5cblxuICAgIF9nZXREYXRhTWV0YSgpIHtcbiAgICAgICAgdmFyIGhvdCA9IHRoaXMuaGFuZHNvbnRhYmxlO1xuICAgICAgICB2YXIgY29scyA9IGhvdC5jb3VudENvbHMoKSAtIGhvdC5jb3VudEVtcHR5Q29scyh0cnVlKTtcbiAgICAgICAgdmFyIHJvd3MgPSBob3QuY291bnRSb3dzKCkgLSBob3QuY291bnRFbXB0eVJvd3ModHJ1ZSk7XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIHZhciBjZWxscyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBsZXQgcm93UmVzdWx0ID0gW107XG4gICAgICAgICAgICBsZXQgcm93Q2VsbE1ldGEgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgX3NvdXJjZURhdGEgPSBob3QuZ2V0U291cmNlRGF0YUF0Q2VsbChpLCBqKTtcbiAgICAgICAgICAgICAgICBsZXQgX21ldGEgPSBob3QuZ2V0Q2VsbE1ldGEoaSwgaik7XG4gICAgICAgICAgICAgICAgbGV0IF9kYXRhID0gaG90LmdldERhdGFBdENlbGwoaSwgaik7XG4gICAgICAgICAgICAgICAgbGV0IF9jZWxsTWF0YSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLnJvdyA9IGk7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLmNvbCA9IGo7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLmlzRm9ybXVsYSA9ICEhKF9zb3VyY2VEYXRhICYmIChfc291cmNlRGF0YSArICcnKS5jaGFyQXQoMCkgPT09ICc9Jyk7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLnNvdXJjZVZhbHVlID0gX3NvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLnZhbHVlID0gX2RhdGE7XG5cbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKG8sIG0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRMb2NhbFN5bWJvbHMsTG9vcFN0YXRlbWVudFRoYXREb2VzbnRMb29wSlNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCBpbiBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnN0eWxlcyA9IG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KHRoaXMuX2dldFN0eWxlc0V4KF9tZXRhKSwgX2NlbGxNYXRhKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9nZXREYXRhVHlwZShfbWV0YSwgX2NlbGxNYXRhKTtcblxuICAgICAgICAgICAgICAgIHJvd1Jlc3VsdC5wdXNoKF9zb3VyY2VEYXRhKTtcbiAgICAgICAgICAgICAgICByb3dDZWxsTWV0YS5wdXNoKF9jZWxsTWF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLnB1c2gocm93UmVzdWx0KTtcbiAgICAgICAgICAgIGNlbGxzLnB1c2gocm93Q2VsbE1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ZGF0YSwgY2VsbHN9O1xuICAgIH1cblxuICAgIC8vIFRPRE9cbiAgICBfZ2V0Qm9yZGVyc0V4KCkge1xuXG4gICAgfVxuXG4gICAgLy8g5pWw5o2u5qC85byPIG51bWVyaWPjgIFkYXRlIOetiVxuICAgIF9nZXREYXRhVHlwZShfbWV0YSwgX2NlbGxNYXRhKSB7XG4gICAgICAgIGxldCB0ID0gX21ldGEudHlwZTtcbiAgICAgICAgX2NlbGxNYXRhLmRhdGFUeXBlID0ge307XG4gICAgICAgIF9jZWxsTWF0YS5kYXRhVHlwZS50eXBlTmFtZSA9IHQ7XG5cbiAgICAgICAgaWYgKHQgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgX2NlbGxNYXRhLmRhdGFUeXBlLmRhdGVGb3JtYXQgPSBfbWV0YS5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgX21ldGEuZGVmYXVsdERhdGUgJiYgKF9jZWxsTWF0YS5kYXRhVHlwZS5kZWZhdWx0RGF0ZSA9IF9tZXRhLmRlZmF1bHREYXRlKTtcbiAgICAgICAgICAgIF9tZXRhLmNvcnJlY3RGb3JtYXQgJiYgKF9jZWxsTWF0YS5kYXRhVHlwZS5jb3JyZWN0Rm9ybWF0ID0gX21ldGEuY29ycmVjdEZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ251bWVyaWMnKSB7XG4gICAgICAgICAgICBfY2VsbE1hdGEuZGF0YVR5cGUuZm9ybWF0ID0gX21ldGEuZm9ybWF0O1xuICAgICAgICAgICAgX21ldGEubGFuZ3VhZ2UgJiYgKF9jZWxsTWF0YS5kYXRhVHlwZS5sYW5ndWFnZSA9IF9tZXRhLmxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwiZXhwb3J0IGNvbnN0IFNoZWV0SGVscGVyID0gU3VwID0+IHtcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBTdXAge1xuXG4gICAgICAgIC8vIOi/meS4quaWueazleeUqOadpeWujOaIkOS4gOS6m+Whq+WdkeaTjeS9nFxuICAgICAgICBfaGFjaygpIHtcbiAgICAgICAgICAgIHZhciBob3QgPSB0aGlzLmhhbmRzb250YWJsZTtcblxuICAgICAgICAgICAgLy8gQlVHIEZJWEVEIC0+IGh0dHBzOi8vZ2l0aHViLmNvbS9oYW5kc29udGFibGUvaGFuZHNvbnRhYmxlL2lzc3Vlcy80Mzc1XG4gICAgICAgICAgICBob3QuYWRkSG9vaygnYmVmb3JlUmVtb3ZlQ29sJywgKGluZGV4LCBhbW91bnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtY3IgPSBob3QuZ2V0UGx1Z2luKCdtYW51YWxDb2x1bW5SZXNpemUnKTtcbiAgICAgICAgICAgICAgICBsZXQgY29sV2lkdGhzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBpbmRleCArIGFtb3VudCwgajtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gaG90LmNvdW50Q29scygpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sV2lkdGhzLnB1c2goaG90LmdldENvbFdpZHRoKGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IGluZGV4LCBsZW4gPSBjb2xXaWR0aHMubGVuZ3RoOyBpIDwgbGVuOyArK2ksICsraikge1xuICAgICAgICAgICAgICAgICAgICBtY3Iuc2V0TWFudWFsU2l6ZShqLCBjb2xXaWR0aHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaG90LmFkZEhvb2soJ2JlZm9yZVJlbW92ZVJvdycsIChpbmRleCwgYW1vdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXJyID0gaG90LmdldFBsdWdpbignbWFudWFsUm93UmVzaXplJyk7XG4gICAgICAgICAgICAgICAgbGV0IHJvd0hlaWdodHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGluZGV4ICsgYW1vdW50LCBqO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBob3QuY291bnRSb3dzKCk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHRzLnB1c2goaG90LmdldFJvd0hlaWdodChpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBpbmRleCwgbGVuID0gcm93SGVpZ2h0cy5sZW5ndGg7IGkgPCBsZW47ICsraSwgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIG1yci5zZXRNYW51YWxTaXplKGosIHJvd0hlaWdodHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g6YCJ5Yy66buY6K6k5YC8XG4gICAgICAgIC8vICAgMS4g6YCJ5Yy65Y+v6IO95LuO5Y+z5LiL5b6A5bem5LiK6YCJ77yM5q2k5pe2IHJvdyA+IGVuZFJvd1xuICAgICAgICAvLyAgIDIuIGVuZFJvdyDlj4ogZW5kQ29sIOWPr+iDveS4jeWtmOWcqFxuICAgICAgICAvL++8iOS4jemcgOimgeWFs+azqOmAieWMuuaWueWQkeaXtuiwg+eUqOatpOaWueazlei/m+ihjOmihOWkhOeQhu+8iVxuICAgICAgICBfZGVmYXVsdFNlbGVjdGlvbihzKSB7XG4gICAgICAgICAgICBzLnJvdyA+IHMuZW5kUm93ICYmIChzLnJvdyA9IFtzLmVuZFJvdywgcy5lbmRSb3cgPSBzLnJvd11bMF0pO1xuICAgICAgICAgICAgcy5jb2wgPiBzLmVuZENvbCAmJiAocy5jb2wgPSBbcy5lbmRDb2wsIHMuZW5kQ29sID0gcy5jb2xdWzBdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydFJvdzogcy5yb3csXG4gICAgICAgICAgICAgICAgZW5kUm93OiBzLmVuZFJvdyB8fCBzLnJvdyxcbiAgICAgICAgICAgICAgICBzdGFydENvbDogcy5jb2wsXG4gICAgICAgICAgICAgICAgZW5kQ29sOiBzLmVuZENvbCB8fCBzLmNvbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgICAgICBfcmVtb3ZlRm9ybWVyQ2xhc3MoY3VycmVudCwgLi4uc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjbGF6eiBvZiBzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zcGxpdChjbGF6eikuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudC50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICAgICAgX3dhbGtvbkNlbGxNZXRhcyhzZWxlY3Rpb24sIGNhbGxiYWNrLCB1bmhvbGQpIHtcbiAgICAgICAgICAgIGxldCB7c3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2wsIGVuZENvbH0gPSB0aGlzLl9kZWZhdWx0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRSb3c7IGkgPD0gZW5kUm93OyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gc3RhcnRDb2w7IGogPD0gZW5kQ29sOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGxNZXRhID0gdGhpcy5oYW5kc29udGFibGUuZ2V0Q2VsbE1ldGEoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld01ldGEgPSBjYWxsYmFjay5jYWxsKHRoaXMsIGksIGosIGNlbGxNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld01ldGEgJiYgdGhpcy5oYW5kc29udGFibGUuc2V0Q2VsbE1ldGFPYmplY3QoaSwgaiwgbmV3TWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmhvbGQgJiYgdGhpcy5oYW5kc29udGFibGUuc2V0Q2VsbE1ldGFPYmplY3QoaSwgaiwgdW5ob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgICAgICBfd2Fsa29uQ2VsbHMoc2VsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgbGV0IHtzdGFydFJvdywgZW5kUm93LCBzdGFydENvbCwgZW5kQ29sfSA9IHRoaXMuX2RlZmF1bHRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydFJvdzsgaSA8PSBlbmRSb3c7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydENvbDsgaiA8PSBlbmRDb2w7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbFREID0gdGhpcy5oYW5kc29udGFibGUuZ2V0Q2VsbChpLCBqLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxURCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBpLCBqLCBjZWxsVEQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICAgICAgX3dhbGtvblNlbGVjdGlvbihzZWxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsZXQge3N0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sLCBlbmRDb2x9ID0gdGhpcy5fZGVmYXVsdFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Um93OyBpIDw9IGVuZFJvdzsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0Q29sOyBqIDw9IGVuZENvbDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgaSwgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xufTsiLCJpbXBvcnQge2FsaWdubWVudEl0ZW19IGZyb20gJy4vQ29udGV4dE1lbnVfYWxpZ25tZW50J1xuaW1wb3J0IHttZXJnZUNlbGxzLCBtZXJnZUNlbGxzSGFuZGxlciwgY2FuY2VsTWVyZ2VDZWxscywgY2FuY2VsTWVyZ2VDZWxsc0hhbmRsZXJ9IGZyb20gJy4vQ29udGV4dE1lbnVfbWVyZ2VDZWxscydcbmltcG9ydCB7cm93UmVzaXplLCByb3dSZXNpemVIYW5kbGVyLCBjb2xSZXNpemUsIGNvbFJlc2l6ZUhhbmRsZXJ9IGZyb20gJy4vQ29udGV4dE1lbnVfcm93T3JDb2x1bW5SZXNpemUnXG5cbi8qKlxuICog55S15a2Q6KGo5qC85Y+z6ZSu6I+c5Y2V44CCXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRNZW51KHNwcmVhZFNoZWV0KSB7XG4gICAgdGhpcy5zcHJlYWRTaGVldCA9IHNwcmVhZFNoZWV0O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge01hcH1cbiAgICAgKi9cbiAgICB0aGlzLm1lbnVJdGVtcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9pbml0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRleHRNZW51O1xuXG5Db250ZXh0TWVudS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoa2V5LCBjb25maWcsIGhhbmRsZXIpIHtcbiAgICB0aGlzLm1lbnVJdGVtcy5zZXQoa2V5LCB7XG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIOiOt+WPliBoYW5kc29udGFibGUg6ZyA6KaB55qE6I+c5Y2V6YWN572u6aG5XG4gKi9cbkNvbnRleHRNZW51LnByb3RvdHlwZS5nZXRNZW51SXRlbXM0SG90VGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9ob3RUYWJsZUl0ZW1zKSB7XG4gICAgICAgIHRoaXMuX2hvdFRhYmxlSXRlbXMgPSB7fTtcbiAgICAgICAgdGhpcy5tZW51SXRlbXMuZm9yRWFjaCgoe2NvbmZpZ30sIGtleSkgPT4gdGhpcy5faG90VGFibGVJdGVtc1trZXldID0gY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2hvdFRhYmxlSXRlbXM7XG59O1xuXG5cbi8qXG4gIyMjIGhhbmRzb250YWJsZSDoh6rluKblj7PplK7lip/og73vvJojIyNcbiByb3dfYWJvdmVcbiByb3dfYmVsb3dcbiBoc2VwMVxuIGNvbF9sZWZ0XG4gY29sX3JpZ2h0XG4gaHNlcDJcbiByZW1vdmVfcm93XG4gcmVtb3ZlX2NvbFxuIGhzZXAzXG4gdW5kb1xuIHJlZG9cbiBtYWtlX3JlYWRfb25seVxuIGFsaWdubWVudFxuIGJvcmRlcnNcbiAqL1xuQ29udGV4dE1lbnUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IFNFUCA9ICctLS0tLS0tLS0nO1xuXG5cbiAgICB0aGlzLnJlZ2lzdGVyKCdyb3dfYWJvdmUnLCB7XG4gICAgICAgIG5hbWU6ICfkuIrmlrnmj5LlhaXkuIDooYwnLFxuICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8g6LCD55So6ICF6KaB56Gu5L+d5q2k5aSEIHRoaXMgIOS4uuW9k+WJjSBob3RUYWJsZSDlrp7kvotcbiAgICAgICAgICAgIC8vIFRPRE8g6ZmQ5Yi25pyA5aSn6KGM5pWwXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXIoJ3Jvd19iZWxvdycsIHtcbiAgICAgICAgbmFtZTogJ+S4i+aWueaPkuWFpeS4gOihjCdcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXIoJ2NvbF9sZWZ0Jywge1xuICAgICAgICBuYW1lOiAn5bem5L6n5o+S5YWl5LiA5YiXJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlcignY29sX3JpZ2h0Jywge1xuICAgICAgICBuYW1lOiAn5Y+z5L6n5o+S5YWl5LiA5YiXJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlcignaHNlcF9idF9pbnNlcnQnLCBTRVApO1xuXG4gICAgLy8gRklYTUUgaGFuZHNvbnRhYmxlIOiHquW4pueahOWIoOmZpOWKn+iDve+8jOWcqOWtmOWcqOWNleWFg+agvOWQiOW5tuaXtuaciUJVR++8jOaUueaIkOiHquWumuS5iemAu+i+keOAglxuICAgIHRoaXMucmVnaXN0ZXIoJ3JlbW92ZV9yb3cnLCB7XG4gICAgICAgIG5hbWU6ICfliKDpmaTpgInkuK3ooYwnLFxuICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETyDpmZDliLbmnIDlsI/ooYzmlbBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoJ3JlbW92ZV9jb2wnLCB7XG4gICAgICAgIG5hbWU6ICfliKDpmaTpgInkuK3liJcnXG4gICAgfSk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyKCdoc2VwX2J0X3JlbW92ZScsIFNFUCk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyKCdhbGlnbm1lbnQnLCBhbGlnbm1lbnRJdGVtKCkpO1xuICAgIHRoaXMucmVnaXN0ZXIoJ3Jvd19yZXNpemUnLCByb3dSZXNpemUsIHJvd1Jlc2l6ZUhhbmRsZXIpO1xuICAgIHRoaXMucmVnaXN0ZXIoJ2NvbF9yZXNpemUnLCBjb2xSZXNpemUsIGNvbFJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgdGhpcy5yZWdpc3RlcignaHNlcF9idF9mb3JtYXQnLCBTRVApO1xuXG4gICAgdGhpcy5yZWdpc3RlcigncV9tZXJnZV9jZWxscycsIG1lcmdlQ2VsbHMsIG1lcmdlQ2VsbHNIYW5kbGVyKTtcbiAgICB0aGlzLnJlZ2lzdGVyKCdxX2NhbmNlbF9tZXJnZV9jZWxscycsIGNhbmNlbE1lcmdlQ2VsbHMsIGNhbmNlbE1lcmdlQ2VsbHNIYW5kbGVyKTtcbn07XG4iLCJpbXBvcnQge01FTlV9IGZyb20gJy4uLy4uL2kxOG4nO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvMzgwN1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWdubWVudEl0ZW0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogTUVOVS5TNSxcbiAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhKHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpICYmICF0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZEhlYWRlci5jb3JuZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzdWJtZW51OiB7XG4gICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGlnbm1lbnQ6bGVmdCcsXG4gICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZS5pbmRleE9mKCdodExlZnQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNDbGFzcyA/IG1hcmtMYWJlbEFzU2VsZWN0ZWQoTUVOVS5TNikgOiBNRU5VLlM2O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGlnbm1lbnQgPSAnaHRMZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ2VsbEFsaWdubWVudCcsIHN0YXRlQmVmb3JlLCByYW5nZSwgdHlwZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24ocmFuZ2UsIHR5cGUsIGFsaWdubWVudCwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGlnbm1lbnQ6Y2VudGVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNDbGFzcyA9IGNoZWNrU2VsZWN0aW9uQ29uc2lzdGVuY3kodGhpcy5nZXRTZWxlY3RlZFJhbmdlKCksIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0Q2VudGVyJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzQ2xhc3MgPyBtYXJrTGFiZWxBc1NlbGVjdGVkKE1FTlUuUzcpIDogTUVOVS5TNztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdGVCZWZvcmUgPSBnZXRBbGlnbm1lbnRDbGFzc2VzKHJhbmdlLCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gJ2hvcml6b250YWwnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0Q2VudGVyJztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDZWxsQWxpZ25tZW50Jywgc3RhdGVCZWZvcmUsIHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogYGFsaWdubWVudDpyaWdodGAsXG4gICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBNRU5VLlM4O1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0UmlnaHQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IG1hcmtMYWJlbEFzU2VsZWN0ZWQobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGlnbm1lbnQgPSAnaHRSaWdodCc7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ2VsbEFsaWdubWVudCcsIHN0YXRlQmVmb3JlLCByYW5nZSwgdHlwZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24ocmFuZ2UsIHR5cGUsIGFsaWdubWVudCwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IGBhbGlnbm1lbnQ6anVzdGlmeWAsXG4gICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBNRU5VLlM5O1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0SnVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbWFya0xhYmVsQXNTZWxlY3RlZChsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGVkUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXRlQmVmb3JlID0gZ2V0QWxpZ25tZW50Q2xhc3NlcyhyYW5nZSwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9ICdob3Jpem9udGFsJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaWdubWVudCA9ICdodEp1c3RpZnknO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuSG9va3MoJ2JlZm9yZUNlbGxBbGlnbm1lbnQnLCBzdGF0ZUJlZm9yZSwgcmFuZ2UsIHR5cGUsIGFsaWdubWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduKHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbmFtZTogJy0tLS0tLS0tLSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IGBhbGlnbm1lbnQ6dG9wYCxcbiAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IE1FTlUuUzEwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZS5pbmRleE9mKCdodFRvcCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbWFya0xhYmVsQXNTZWxlY3RlZChsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0VG9wJztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDZWxsQWxpZ25tZW50Jywgc3RhdGVCZWZvcmUsIHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogYGFsaWdubWVudDptaWRkbGVgLFxuICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gTUVOVS5TMTE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNDbGFzcyA9IGNoZWNrU2VsZWN0aW9uQ29uc2lzdGVuY3kodGhpcy5nZXRTZWxlY3RlZFJhbmdlKCksIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAmJiBjbGFzc05hbWUuaW5kZXhPZignaHRNaWRkbGUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IG1hcmtMYWJlbEFzU2VsZWN0ZWQobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0TWlkZGxlJztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDZWxsQWxpZ25tZW50Jywgc3RhdGVCZWZvcmUsIHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogYGFsaWdubWVudDpib3R0b21gLFxuICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gTUVOVS5TMTI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNDbGFzcyA9IGNoZWNrU2VsZWN0aW9uQ29uc2lzdGVuY3kodGhpcy5nZXRTZWxlY3RlZFJhbmdlKCksIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAmJiBjbGFzc05hbWUuaW5kZXhPZignaHRCb3R0b20nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IG1hcmtMYWJlbEFzU2VsZWN0ZWQobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0Qm90dG9tJztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDZWxsQWxpZ25tZW50Jywgc3RhdGVCZWZvcmUsIHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb25Db25zaXN0ZW5jeShyYW5nZSwgY29tcGFyYXRvcikge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UuZm9yQWxsKGZ1bmN0aW9uIChyb3csIGNvbCkge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3Iocm93LCBjb2wpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYXJrTGFiZWxBc1NlbGVjdGVkKGxhYmVsKSB7XG4gICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInNlbGVjdGVkXCI+JyArIFN0cmluZy5mcm9tQ2hhckNvZGUoMTAwMDMpICsgJzwvc3Bhbj4nICsgbGFiZWw7XG59XG5cbmZ1bmN0aW9uIGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IHt9O1xuICAgIGZvciAobGV0IHJvdyA9IHJhbmdlLmZyb20ucm93OyByb3cgPD0gcmFuZ2UudG8ucm93OyByb3crKykge1xuICAgICAgICBmb3IgKGxldCBjb2wgPSByYW5nZS5mcm9tLmNvbDsgY29sIDw9IHJhbmdlLnRvLmNvbDsgY29sKyspIHtcbiAgICAgICAgICAgIGlmICghY2xhc3Nlc1tyb3ddKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlc1tyb3ddID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzc2VzW3Jvd11bY29sXSA9IGNhbGxiYWNrKHJvdywgY29sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3Nlcztcbn1cblxuZnVuY3Rpb24gYWxpZ24ocmFuZ2UsIHR5cGUsIGFsaWdubWVudCwgY2VsbERlc2NyaXB0b3IpIHtcbiAgICBpZiAocmFuZ2UuZnJvbS5yb3cgPT09IHJhbmdlLnRvLnJvdyAmJiByYW5nZS5mcm9tLmNvbCA9PT0gcmFuZ2UudG8uY29sKSB7XG4gICAgICAgIGFwcGx5QWxpZ25DbGFzc05hbWUocmFuZ2UuZnJvbS5yb3csIHJhbmdlLmZyb20uY29sLCB0eXBlLCBhbGlnbm1lbnQsIGNlbGxEZXNjcmlwdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCByb3cgPSByYW5nZS5mcm9tLnJvdzsgcm93IDw9IHJhbmdlLnRvLnJvdzsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHJhbmdlLmZyb20uY29sOyBjb2wgPD0gcmFuZ2UudG8uY29sOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGFwcGx5QWxpZ25DbGFzc05hbWUocm93LCBjb2wsIHR5cGUsIGFsaWdubWVudCwgY2VsbERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUFsaWduQ2xhc3NOYW1lKHJvdywgY29sLCB0eXBlLCBhbGlnbm1lbnQsIGNlbGxEZXNjcmlwdG9yKSB7XG4gICAgbGV0IGNlbGxNZXRhID0gY2VsbERlc2NyaXB0b3Iocm93LCBjb2wpO1xuICAgIGxldCBjbGFzc05hbWUgPSBhbGlnbm1lbnQ7XG5cbiAgICBpZiAoY2VsbE1ldGEuY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcmVwYXJlVmVydGljYWxBbGlnbkNsYXNzKGNlbGxNZXRhLmNsYXNzTmFtZSwgYWxpZ25tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZXBhcmVIb3Jpem9udGFsQWxpZ25DbGFzcyhjZWxsTWV0YS5jbGFzc05hbWUsIGFsaWdubWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDkuYvliY3nmoTmoLflvI/lkI3mi7zmjqXmlrnlvI/vvIzlpoLmnpzlrZjlnKggaG90IOS7peWkluiHquWumuS5ieagt+W8j+aXtu+8jOS8muS6p+eUn0JVRyAjIDgvMTQvMjAxN1xuICAgIC8vIOS7o+eggeaYryBjb3B5IEhhbnNvbnRhYmxlIOWQjuaUueeahO+8jOWFtuWunueUqCBjbGFzc0FycmF5IOadpeWkhOeQhui/meexu+mXrumimOabtOaWueS+v+S4gOS6m1xuICAgIGNlbGxNZXRhLmNsYXNzTmFtZSA9IGNsYXNzTmFtZS50cmltKCkuc3BsaXQoL158XFxzKy8pLmpvaW4oJyAnKTtcbn1cblxuXG5mdW5jdGlvbiBwcmVwYXJlVmVydGljYWxBbGlnbkNsYXNzKGNsYXNzTmFtZSwgYWxpZ25tZW50KSB7XG4gICAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKGFsaWdubWVudCkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuICAgICAgICAucmVwbGFjZSgnaHRUb3AnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ2h0TWlkZGxlJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCdodEJvdHRvbScsICcnKTtcblxuICAgIGNsYXNzTmFtZSArPSAnICcgKyBhbGlnbm1lbnQ7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUhvcml6b250YWxBbGlnbkNsYXNzKGNsYXNzTmFtZSwgYWxpZ25tZW50KSB7XG4gICAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKGFsaWdubWVudCkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuICAgICAgICAucmVwbGFjZSgnaHRMZWZ0JywgJycpXG4gICAgICAgIC5yZXBsYWNlKCdodENlbnRlcicsICcnKVxuICAgICAgICAucmVwbGFjZSgnaHRSaWdodCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnaHRKdXN0aWZ5JywgJycpO1xuXG4gICAgY2xhc3NOYW1lICs9ICcgJyArIGFsaWdubWVudDtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufSIsImltcG9ydCB7Q29vcmRpbmF0ZX0gZnJvbSAnLi4vLi4vdXRpbHMvY29tbW9uJ1xuaW1wb3J0IHtNRU5VfSBmcm9tICcuLi8uLi9pMThuJztcblxuZXhwb3J0IHZhciBtZXJnZUNlbGxzID0ge1xuICAgIG5hbWU6IE1FTlUuUzMsXG4gICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IFtyMSwgYzEsIHIyLCBjMl0gPSB0aGlzLmdldFNlbGVjdGVkKCk7XG4gICAgICAgIGlmIChyMSA9PT0gcjIgJiYgYzEgPT09IGMyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW1lcmdlQ29tcGFyZS5jYWxsKHRoaXMsICdpc0VxdWFsJyk7XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ2VsbHNIYW5kbGVyKHNoZWV0LCBzdGFydCwgZW5kKSB7XG4gICAgc2hlZXQubWVyZ2VDZWxscyhcbiAgICAgICAgc3RhcnQucm93LFxuICAgICAgICBzdGFydC5jb2wsXG4gICAgICAgIGVuZC5yb3cgLSBzdGFydC5yb3cgKyAxLFxuICAgICAgICBlbmQuY29sIC0gc3RhcnQuY29sICsgMVxuICAgICk7XG59XG5cblxuZXhwb3J0IHZhciBjYW5jZWxNZXJnZUNlbGxzID0ge1xuICAgIG5hbWU6IE1FTlUuUzQsXG4gICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlQ29tcGFyZS5jYWxsKHRoaXMsICdpc1N1YnNldCcpO1xuICAgIH1cbn07XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbE1lcmdlQ2VsbHNIYW5kbGVyKHNoZWV0LCBzdGFydCwgZW5kKSB7XG4gICAgc2hlZXQudW5NZXJnZUNlbGxzKFxuICAgICAgICBzdGFydC5yb3csXG4gICAgICAgIHN0YXJ0LmNvbCxcbiAgICAgICAgZW5kLnJvdyAtIHN0YXJ0LnJvdyArIDEsXG4gICAgICAgIGVuZC5jb2wgLSBzdGFydC5jb2wgKyAxXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDb21wYXJlKHR5cGUpIHtcbiAgICBsZXQgbWVyZ2VkID0gdGhpcy5nZXRTZXR0aW5ncygpLm1lcmdlQ2VsbHM7XG4gICAgaWYgKG1lcmdlZCAmJiBtZXJnZWQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVyZ2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQge3JvdywgY29sLCByb3dzcGFuLCBjb2xzcGFufSA9IG1lcmdlZFtpXTtcbiAgICAgICAgICAgIGlmIChDb29yZGluYXRlW3R5cGVdKFxuICAgICAgICAgICAgICAgICAgICBbcm93LCBjb2wsIHJvdyArIHJvd3NwYW4gLSAxLCBjb2wgKyBjb2xzcGFuIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRTZWxlY3Rpb24odGhpcy5nZXRTZWxlY3RlZCgpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTZWxlY3Rpb24ocykge1xuICAgIHNbMF0gPiBzWzJdICYmIChzWzBdID0gW3NbMl0sIHNbMl0gPSBzWzBdXVswXSk7XG4gICAgc1sxXSA+IHNbM10gJiYgKHNbMV0gPSBbc1szXSwgc1szXSA9IHNbMV1dWzBdKTtcbiAgICByZXR1cm4gcztcbn1cbiIsImltcG9ydCB7TUVOVX0gZnJvbSAnLi4vLi4vaTE4bic7XG5cbi8vIEZJWE1FIGhvdCDlpITnkIYgcm93SGVpZ2h0cy9jb2xXaWR0aHMg5LiOIG1hbnVhbFJvd1Jlc2l6ZS9tYW51YWxDb2x1bW5SZXNpemUg5pe25a2Y5Zyo57y66Zm3XG4vLyBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvMzMwMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2hhbmRzb250YWJsZS9oYW5kc29udGFibGUvaXNzdWVzLzQzNzFcbmV4cG9ydCB2YXIgcm93UmVzaXplID0ge1xuICAgIG5hbWU6IE1FTlUuUzEsXG4gICAgaGlkZGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCkgfHwgIXRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkSGVhZGVyLnJvd3NcbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcm93UmVzaXplSGFuZGxlcihzaGVldCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBoZWlnaHQgPSBbXS5fO1xuXG4gICAgc3RhcnQucm93ID4gZW5kLnJvdyAmJiAoc3RhcnQucm93ID0gW2VuZC5yb3csIGVuZC5yb3cgPSBzdGFydC5yb3ddWzBdKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydC5yb3c7IGkgPD0gZW5kLnJvdzsgKytpKSB7XG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBzaGVldC5oYW5kc29udGFibGUuZ2V0Um93SGVpZ2h0KGkpO1xuICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCAhPT0gc2hlZXQuaGFuZHNvbnRhYmxlLmdldFJvd0hlaWdodChpKSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWwgPSBoZWlnaHQgPT09IGZhbHNlID8gJycgOiAoaGVpZ2h0IHx8IDI0KTtcblxuICAgIGlmIChfVUlQcm92aWRlci5wcm9tcHQpIHtcbiAgICAgICAgX1VJUHJvdmlkZXIucHJvbXB0KE1FTlUuUzEzLCB2YWwsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRSb3dIZWlnaHRzKHNoZWV0LCBzdGFydC5yb3csIGVuZC5yb3csIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb250ZXh0TWVudSA9IHNoZWV0LmhhbmRzb250YWJsZS5nZXRQbHVnaW4oJ2NvbnRleHRNZW51Jyk7XG4gICAgICAgIGNvbnRleHRNZW51LmNsb3NlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBwcm9tcHQoTUVOVS5TMTMsIHZhbCk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFJvd0hlaWdodHMoc2hlZXQsIHN0YXJ0LnJvdywgZW5kLnJvdywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgdmFyIGNvbFJlc2l6ZSA9IHtcbiAgICBuYW1lOiBNRU5VLlMyLFxuICAgIGhpZGRlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpIHx8ICF0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZEhlYWRlci5jb2xzXG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbFJlc2l6ZUhhbmRsZXIoc2hlZXQsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgd2lkdGggPSBbXS5fO1xuXG4gICAgc3RhcnQuY29sID4gZW5kLmNvbCAmJiAoc3RhcnQuY29sID0gW2VuZC5jb2wsIGVuZC5jb2wgPSBzdGFydC5jb2xdWzBdKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydC5jb2w7IGkgPD0gZW5kLmNvbDsgKytpKSB7XG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gc2hlZXQuaGFuZHNvbnRhYmxlLmdldENvbFdpZHRoKGkpO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSBzaGVldC5oYW5kc29udGFibGUuZ2V0Q29sV2lkdGgoaSkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWwgPSB3aWR0aCA9PT0gZmFsc2UgPyAnJyA6ICh3aWR0aCB8fCA1MCk7XG5cbiAgICBpZiAoX1VJUHJvdmlkZXIucHJvbXB0KSB7XG4gICAgICAgIF9VSVByb3ZpZGVyLnByb21wdChNRU5VLlMxNCwgdmFsLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2V0Q29sV2lkdGhzKHNoZWV0LCBzdGFydC5jb2wsIGVuZC5jb2wsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb250ZXh0TWVudSA9IHNoZWV0LmhhbmRzb250YWJsZS5nZXRQbHVnaW4oJ2NvbnRleHRNZW51Jyk7XG4gICAgICAgIGNvbnRleHRNZW51LmNsb3NlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBwcm9tcHQoTUVOVS5TMTQsIHZhbCk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldENvbFdpZHRocyhzaGVldCwgc3RhcnQuY29sLCBlbmQuY29sLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRSb3dIZWlnaHRzKHNoZWV0LCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuICAgIHZhbHVlID0gbnVtYnJvKCkudW5mb3JtYXQodmFsdWUpIHx8IDI0O1xuICAgIGxldCByb3dIZWlnaHRzID0gc2hlZXQuaGFuZHNvbnRhYmxlLmdldFNldHRpbmdzKCkucm93SGVpZ2h0cyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgcm93SGVpZ2h0c1tpXSA9IHZhbHVlO1xuICAgIH1cbiAgICBzaGVldC5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe3Jvd0hlaWdodHM6IHJvd0hlaWdodHN9KTtcbn1cblxuZnVuY3Rpb24gc2V0Q29sV2lkdGhzKHNoZWV0LCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuICAgIHZhbHVlID0gbnVtYnJvKCkudW5mb3JtYXQodmFsdWUpIHx8IDUwO1xuICAgIGxldCBjb2xXaWR0aHMgPSBzaGVldC5oYW5kc29udGFibGUuZ2V0U2V0dGluZ3MoKS5jb2xXaWR0aHMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIGNvbFdpZHRoc1tpXSA9IHZhbHVlO1xuICAgIH1cbiAgICBzaGVldC5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe2NvbFdpZHRoczogY29sV2lkdGhzfSk7XG59IiwiaW1wb3J0IHtcbiAgICBpbm5lckhUTUwsIGluc2VydEFmdGVyLFxuICAgIGNsb3Nlc3QsIGVtcHR5LFxuICAgIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG59IGZyb20gJy4uLy4uL3V0aWxzL2RvbUhlbHBlci5qcyc7XG5pbXBvcnQge2lzRW1wdHlWYWx1ZSwgdXBwZXJDYXNlfSBmcm9tICcuLi8uLi91dGlscy9jb21tb24uanMnO1xuaW1wb3J0IHtDYXNlSW5zZW5zaXRpdmVNYXB9IGZyb20gJy4uLy4uL3V0aWxzL2RhdGFTdHJ1Y3R1cmUuanMnO1xuaW1wb3J0IHtzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb259IGZyb20gJy4uLy4uL3V0aWxzL2V2ZW50SGVscGVyLmpzJztcbmltcG9ydCB7Z2xvYmFsU2V0dGluZ3N9IGZyb20gJy4uLy4uL3NldHRpbmdzLmpzJztcbmltcG9ydCB7V0FSTlN9IGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHtTaGVldEVycm9yfSBmcm9tICcuLi8uL1NoZWV0RXJyb3InXG5cbmNvbnN0IENMQVNTX0NVUlJFTlQgPSAnY3VycmVudCc7XG5jb25zdCBDTEFTU19UQUJTID0gJ3NzZC10YWJzJztcbmNvbnN0IENMQVNTX0NPTlRFTlQgPSAnc3NkLXRhYnMtY29udGVudCc7XG5jb25zdCBDTEFTU19TRUNUSU9OID0gJ3NzZC10YWJzLXNlY3Rpb24nO1xuY29uc3QgQ0xBU1NfTkFWID0gJ3NzZC10YWJzLW5hdic7XG5jb25zdCBDTEFTU19VTCA9ICdzc2QtdGFicy11bCc7XG5jb25zdCBDTEFTU19MSSA9ICdzc2QtdGFicy1saSc7XG5jb25zdCBDTEFTU19GWCA9ICdzc2QtdGFicy1meCc7XG5cbmNvbnN0IGFuaW1hdGVkID0gZ2xvYmFsU2V0dGluZ3Muc2hlZXQuYW5pbWF0ZWQ7XG5jb25zdCByZWdFeHAgPSBnbG9iYWxTZXR0aW5ncy5zaGVldC5zaGVldE5hbWU7XG5cbi8qKlxuICogd29ya2Jvb2sg5a+55bqU55qE6KeG5Zu+77yM5a6e6ZmF55qEIERPTSDmnoTmiJDjgIJcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1dvcmtib29rfSB3b3JrYm9va1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRhYnMod29ya2Jvb2spIHtcbiAgICB0aGlzLndvcmtib29rID0gd29ya2Jvb2s7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Nhc2VJbnNlbnNpdGl2ZU1hcH1cbiAgICAgKi9cbiAgICB0aGlzLmxpSXRlbXMgPSBuZXcgQ2FzZUluc2Vuc2l0aXZlTWFwKCk7XG4gICAgdGhpcy5zZWN0aW9uSXRlbXMgPSBuZXcgQ2FzZUluc2Vuc2l0aXZlTWFwKCk7XG4gICAgdGhpcy5faG90VGFibGVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucm9vdEVsZW1lbnQgPSB3b3JrYm9vay5zcHJlYWRTaGVldC5nZXRSb290RWxlbWVudCgpO1xuICAgIHRoaXMuZGlzcGxheU1vZGUgPSB3b3JrYm9vay5zcHJlYWRTaGVldC5nZXREaXNwbGF5TW9kZSgpO1xuXG4gICAgdGhpcy5pbml0RE9NKCk7XG4gICAgdGhpcy5pbml0Qm94KCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbn1cblxuVGFicy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5UQUJTKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuVGFicy5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLlRBQlMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLkNPTlRFTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLk5BViA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25hdicpO1xuICAgIHRoaXMuVUwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG4gICAgdGhpcy5UQUJTLmNsYXNzTGlzdC5hZGQoQ0xBU1NfVEFCUyk7XG4gICAgdGhpcy5UQUJTLmlkID0gdGhpcy53b3JrYm9vay5nZXRJZCgpO1xuICAgIHRoaXMuQ09OVEVOVC5jbGFzc0xpc3QuYWRkKENMQVNTX0NPTlRFTlQpO1xuICAgIHRoaXMuTkFWLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFWKTtcbiAgICB0aGlzLlVMLmNsYXNzTGlzdC5hZGQoQ0xBU1NfVUwpO1xuXG4gICAgdGhpcy5UQUJTLmFwcGVuZENoaWxkKHRoaXMuQ09OVEVOVCk7XG4gICAgdGhpcy5UQUJTLmFwcGVuZENoaWxkKHRoaXMuTkFWKTtcbiAgICB0aGlzLk5BVi5hcHBlbmRDaGlsZCh0aGlzLlVMKTtcblxuICAgIC8vIOWinuWKoCBzaGVldCDpobXnmoQgYnV0dG9uXG4gICAgdGhpcy5hcHBlbmRBZGRCdXR0b24oKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuVGFicy5wcm90b3R5cGUuaW5pdEJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9vdEVsID0gdGhpcy53b3JrYm9vay5zcHJlYWRTaGVldC5nZXRSb290RWxlbWVudCgpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLndvcmtib29rLndpZHRoIHx8IG91dGVyV2lkdGgocm9vdEVsLCBmYWxzZSk7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLndvcmtib29rLmhlaWdodCB8fCBvdXRlckhlaWdodChyb290RWwsIGZhbHNlKTtcblxuICAgIHRoaXMuVEFCUy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgIHRoaXMuVEFCUy5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG59O1xuXG5cbi8qKlxuICog5aKe5Yqg5LiA5LiqIHRhYiDpobVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGVldE5hbWUgLSBzaGVldCDlkI3vvIwg5Y2zIHRhYiDpobXnmoTmoIfpophcbiAqL1xuVGFicy5wcm90b3R5cGUuYXBwZW5kVGFiID0gZnVuY3Rpb24gKHNoZWV0TmFtZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIHZhciBjbGF6eiA9IHRoaXMuZGlzcGxheU1vZGUgPyAnJyA6ICdjbG9zZSBoYWlybGluZSc7XG5cbiAgICBsaS5pbm5lckhUTUwgPSBgXG4gICAgICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OjtcIj5cbiAgICAgICAgICAgIDxzcGFuPiR7c2hlZXROYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtjbGF6en1cIj48L3NwYW4+XG4gICAgICAgIDwvYT5cbiAgICBgO1xuICAgIGxpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTEkpO1xuICAgIGxpLnNldEF0dHJpYnV0ZSgnZGF0YS1zaGVldCcsIHNoZWV0TmFtZSk7XG5cblxuICAgIHZhciBhY3RpdmVUYWIgPSB0aGlzLlRBQlMucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfQ1VSUkVOVH0uJHtDTEFTU19MSX1gKTtcbiAgICBpZiAoYWN0aXZlVGFiKSB7XG4gICAgICAgIGluc2VydEFmdGVyKGFjdGl2ZVRhYiwgbGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuVUwuYXBwZW5kQ2hpbGQobGkpO1xuICAgIH1cbiAgICB0aGlzLmxpSXRlbXMuc2V0KHNoZWV0TmFtZSwgbGkpO1xuXG4gICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgc2hlZXROYW1lID0gdGhpcy5kYXRhc2V0LnNoZWV0O1xuICAgICAgICB2YXIgc2hlZXQgPSB0aGF0Lndvcmtib29rLmdldFNoZWV0KHNoZWV0TmFtZSk7XG4gICAgICAgIHNoZWV0LmFjdGl2ZSgpO1xuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuZGlzcGxheU1vZGUpIHtcbiAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhhdC5fb25UYWJEYmxjbGljay5jYWxsKHRoYXQsIHRoaXMpO1xuICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsaS5xdWVyeVNlbGVjdG9yKCcuY2xvc2UnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgc2hlZXROYW1lID0gbGkuZGF0YXNldC5zaGVldDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhhdC53b3JrYm9vay5jbG9zZVNoZWV0KHNoZWV0TmFtZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTaGVldEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kQ29udGVudChzaGVldE5hbWUpO1xufTtcblxuXG4vKipcbiAqIOWinuWKoOS4gOS4qiB0YWIg6aG1XG4gKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lIC0gc2hlZXQg5ZCN77yMIOWNsyB0YWIg6aG155qE5qCH6aKYXG4gKi9cblRhYnMucHJvdG90eXBlLnJlbW92ZVRhYiA9IGZ1bmN0aW9uIChzaGVldE5hbWUpIHtcbiAgICB2YXIgbGkgPSB0aGlzLmxpSXRlbXMuZ2V0KHNoZWV0TmFtZSk7XG4gICAgdGhpcy5VTC5yZW1vdmVDaGlsZChsaSk7XG4gICAgdGhpcy5saUl0ZW1zLmRlbGV0ZShzaGVldE5hbWUpO1xuXG4gICAgdGhpcy5yZW1vdmVDb250ZW50KHNoZWV0TmFtZSk7XG59O1xuXG5UYWJzLnByb3RvdHlwZS5hcHBlbmRBZGRCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgdmFyIGlubmVySHRtbCA9IHRoaXMuZGlzcGxheU1vZGUgPyAnJm5ic3A7JyA6ICcrJztcblxuICAgIGxpLmlubmVySFRNTCA9IGA8YSBocmVmPVwiamF2YXNjcmlwdDo7XCI+PHNwYW4+JHtpbm5lckh0bWx9PC9zcGFuPjwvYT5gO1xuICAgIGxpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTEkpO1xuICAgIGlmICghdGhpcy5kaXNwbGF5TW9kZSkge1xuICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKCdhZGQtdGFiJyk7XG4gICAgfVxuICAgIHRoaXMuVUwuYXBwZW5kQ2hpbGQobGkpO1xuXG4gICAgaWYgKCF0aGlzLmRpc3BsYXlNb2RlKSB7XG4gICAgICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2hlZXQgPSB0aGF0Lndvcmtib29rLmNyZWF0ZVNoZWV0KCk7XG4gICAgICAgICAgICAgICAgbmV3U2hlZXQuYWN0aXZlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTaGVldEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbGlcbiAqIEBwcml2YXRlXG4gKi9cblRhYnMucHJvdG90eXBlLl9vblRhYkRibGNsaWNrID0gZnVuY3Rpb24gKGxpKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBzaGVldE5hbWUgPSBsaS5kYXRhc2V0LnNoZWV0O1xuICAgIHZhciBzcGFuID0gbGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NwYW4nKVswXTtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICBpbnB1dC52YWx1ZSA9IHNoZWV0TmFtZTtcbiAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdlZGl0b3JpYWwnKTtcbiAgICBpbnB1dC5zdHlsZS53aWR0aCA9IG91dGVyV2lkdGgoc3BhbikgKyAyMCArICdweCc7IC8vIOWQjeWtl+WkquefreaXtuS4jeWlvei+k+WFpe+8jOWinuihpTIwcHhcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGVjayA9IHRoYXQuX2NoZWNrVGFiTmFtZShzaGVldE5hbWUsIHRoaXMudmFsdWUpO1xuICAgICAgICBpZiAoY2hlY2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoYXQud29ya2Jvb2sucmVuYW1lU2hlZXQoc2hlZXROYW1lLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KGNoZWNrKTsgLy8gVE9ETyBhbGVydCDlpKrkuJFcbiAgICAgICAgICAgIHRoYXQudGFiUmVuYW1lQ2FuY2VsKHNoZWV0TmFtZSwgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBlbXB0eShzcGFuKTtcbiAgICBzcGFuLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICBpbnB1dC5zZWxlY3QoKTtcbn07XG5cblRhYnMucHJvdG90eXBlLl9jaGVja1RhYk5hbWUgPSBmdW5jdGlvbiAobmFtZTEsIG5hbWUyKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZShuYW1lMikpIHtcbiAgICAgICAgcmV0dXJuIFdBUk5TLlMxO1xuICAgIH1cbiAgICBpZiAocmVnRXhwLnRlc3QobmFtZTIpKSB7XG4gICAgICAgIHJldHVybiBXQVJOUy5TMjtcbiAgICB9XG4gICAgLy8g5pS55oiQ5YW25a6D5bey5pyJ55qEc2hlZXTlkI1cbiAgICBpZiAodXBwZXJDYXNlKG5hbWUxKSAhPT0gdXBwZXJDYXNlKG5hbWUyKSAmJiB0aGlzLndvcmtib29rLmlzU2hlZXRFeGlzdChuYW1lMikpIHtcbiAgICAgICAgcmV0dXJuIFdBUk5TLlMzO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIOaUueWQjeaXtu+8jERPTeS4iueahOS4gOS6m+aTjeS9nO+8jOi/m+WFpeatpOaWueazleaXtuS7o+ihqOW3sue7j+WBmuS6huWQiOazlemqjOivgeOAglxuVGFicy5wcm90b3R5cGUudGFiUmVuYW1lID0gZnVuY3Rpb24gKG5hbWUxLCBuYW1lMikge1xuICAgIHZhciBsaSA9IHRoaXMubGlJdGVtcy5nZXQobmFtZTEpO1xuICAgIHZhciBzcGFuID0gbGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NwYW4nKVswXTtcbiAgICBpbm5lckhUTUwoc3BhbiwgbmFtZTIpO1xuICAgIGxpLmRhdGFzZXQuc2hlZXQgPSBuYW1lMjtcbiAgICB0aGlzLmxpSXRlbXMuc2V0KG5hbWUyLCBsaSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25JdGVtcy5nZXQobmFtZTEpO1xuICAgIHNlY3Rpb24uZGF0YXNldC5zaGVldCA9IG5hbWUyO1xuICAgIHRoaXMuc2VjdGlvbkl0ZW1zLmRlbGV0ZShuYW1lMSk7XG4gICAgdGhpcy5zZWN0aW9uSXRlbXMuc2V0KG5hbWUyLCBzZWN0aW9uKTtcblxuICAgIHZhciBzaGVldE5vdyA9IHRoaXMud29ya2Jvb2suZ2V0U2hlZXQobmFtZTIpO1xuICAgIHNoZWV0Tm93LmVtaXQoJ2FmdGVyUmVuYW1lJywgc2hlZXROb3csIG5hbWUxLCBuYW1lMik7XG59O1xuXG4vLyDmm7TlkI3lpLHotKXvvIzlsIblkI3lrZforr7kuLogbmFtZTEsIG5hbWUy5Li65aSx6LSl55qE5ZCN5a2XXG5UYWJzLnByb3RvdHlwZS50YWJSZW5hbWVDYW5jZWwgPSBmdW5jdGlvbiAobmFtZTEsIG5hbWUyKSB7XG4gICAgdmFyIGxpID0gdGhpcy5saUl0ZW1zLmdldChuYW1lMSk7XG4gICAgdmFyIHNwYW4gPSBsaS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3BhbicpWzBdO1xuICAgIGlubmVySFRNTChzcGFuLCBuYW1lMSk7XG5cbiAgICB2YXIgc2hlZXROb3cgPSB0aGlzLndvcmtib29rLmdldFNoZWV0KG5hbWUxKTtcbiAgICBzaGVldE5vdy5lbWl0KCdhZnRlclJlbmFtZUNhbmNlbCcsIHNoZWV0Tm93LCBuYW1lMSwgbmFtZTIpO1xufTtcblxuXG4vKipcbiAqIOWinuWKoOagh+etvumhteWvueW6lOeahOWGheWuuVxuICogQHBhcmFtIHtzdHJpbmd9IHNoZWV0TmFtZVxuICovXG5UYWJzLnByb3RvdHlwZS5hcHBlbmRDb250ZW50ID0gZnVuY3Rpb24gKHNoZWV0TmFtZSkge1xuICAgIHZhciBzZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgIHZhciBmeCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBob3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdkYXRhLXNoZWV0Jywgc2hlZXROYW1lKTtcbiAgICBzZWN0aW9uLmFwcGVuZENoaWxkKGZ4KTtcbiAgICBzZWN0aW9uLmFwcGVuZENoaWxkKGhvdCk7XG4gICAgc2VjdGlvbi5jbGFzc0xpc3QuYWRkKENMQVNTX1NFQ1RJT04pO1xuICAgIGFuaW1hdGVkICYmIHNlY3Rpb24uY2xhc3NMaXN0LmFkZCgnc3NkLWFuaW1hdGVkLWZhc3QnKTtcblxuICAgIHRoaXMuQ09OVEVOVC5hcHBlbmRDaGlsZChzZWN0aW9uKTtcbiAgICB0aGlzLnNlY3Rpb25JdGVtcy5zZXQoc2hlZXROYW1lLCBzZWN0aW9uKTtcblxuICAgIHRoaXMuYXBwZW5kRngoZngsIHNoZWV0TmFtZSk7XG4gICAgdGhpcy5hcHBlbmRUYWJsZShob3QsIHNoZWV0TmFtZSk7XG59O1xuXG5cblRhYnMucHJvdG90eXBlLnJlbW92ZUNvbnRlbnQgPSBmdW5jdGlvbiAoc2hlZXROYW1lKSB7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25JdGVtcy5nZXQoc2hlZXROYW1lKTtcbiAgICB0aGlzLkNPTlRFTlQucmVtb3ZlQ2hpbGQoc2VjdGlvbik7XG4gICAgdGhpcy5zZWN0aW9uSXRlbXMuZGVsZXRlKHNoZWV0TmFtZSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lXG4gKi9cblRhYnMucHJvdG90eXBlLmhpZGVDb250ZW50ID0gZnVuY3Rpb24gKHNoZWV0TmFtZSkge1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5zZWN0aW9uSXRlbXMuZ2V0KHNoZWV0TmFtZSk7XG4gICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xufTtcblxuXG4vKipcbiAqIFRPRE8g5YWs5byP6L6T5YWl5qGGXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZnhcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGVldE5hbWVcbiAqL1xuVGFicy5wcm90b3R5cGUuYXBwZW5kRnggPSBmdW5jdGlvbiAoZngsIHNoZWV0TmFtZSkge1xuICAgIGZ4LmNsYXNzTGlzdC5hZGQoQ0xBU1NfRlgpO1xuICAgIGZ4LmNsYXNzTGlzdC5hZGQoYCR7Q0xBU1NfRlh9LSR7c2hlZXROYW1lfWApO1xufTtcblxuLyoqXG4gKiDlgYfmuLLmn5MgSGFuc29udGFibGUg57uE5Lu244CCXG4gKiBoYW5kc29udGFibGUg55qE6K6+6K6h5peg5rOV5ZyoRE9N5Lit6K6h566X6KeG5Zu+77yM5b+F6aG75riy5p+Tcm9vdEVsZW1lbnTkuYvlkI7miY3og73nlJ/mlYjjgIJcbiAqIOWvvOiHtOW7tui/n+a4suafk+mavuS7peWunueOsO+8jOaciea4suafk+aAp+iDvemXrumimOaXtuWGjeino+WGs+OAglxuICog5Y+m5aSW77yM5riy5p+T5Yiw5YWI6ZqQ6JeP5ZCO5pi+56S655qE5YWD57Sg5Lit5pe277yM5Lmf5peg5rOV5q2j5bi45pi+56S644CCXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGhvdFxuICogQHBhcmFtIHNoZWV0TmFtZVxuICovXG5UYWJzLnByb3RvdHlwZS5hcHBlbmRUYWJsZSA9IGZ1bmN0aW9uIChob3QsIHNoZWV0TmFtZSkge1xuICAgIHRoaXMuX2hvdFRhYmxlcy5zZXQoc2hlZXROYW1lLCB7XG4gICAgICAgIGNvbnRhaW5lcjogaG90LFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiAoKSA9PiB0aGlzLmhlaWdodCAtIG91dGVySGVpZ2h0KHRoaXMuTkFWKVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiDmv4DmtLvmjIflrprnmoTmoIfnrb7pobVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGVldE5hbWUgLSBzaGVldCDlkI1cbiAqL1xuVGFicy5wcm90b3R5cGUuYWN0aXZlVGFiID0gZnVuY3Rpb24gKHNoZWV0TmFtZSkge1xuICAgIHZhciBmb3JtZXIgPSB0aGlzLlRBQlMucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfQ1VSUkVOVH0uJHtDTEFTU19MSX1gKTtcbiAgICBmb3JtZXIgJiYgZm9ybWVyLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfQ1VSUkVOVCk7XG4gICAgdmFyIGxpID0gdGhpcy5saUl0ZW1zLmdldChzaGVldE5hbWUpO1xuICAgIGxpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfQ1VSUkVOVCk7XG4gICAgdGhpcy5hY3RpdmVDb250ZW50KHNoZWV0TmFtZSk7XG59O1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGVldE5hbWUgLSBzaGVldCDlkI1cbiAqL1xuVGFicy5wcm90b3R5cGUuYWN0aXZlQ29udGVudCA9IGZ1bmN0aW9uIChzaGVldE5hbWUpIHtcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbkl0ZW1zLmdldChzaGVldE5hbWUpO1xuICAgIHZhciBmb3JtZXIgPSB0aGlzLl9mb3JtZXJBY3RpdmVDb250ZW50O1xuICAgIGlmIChmb3JtZXIpIHtcbiAgICAgICAgYW5pbWF0ZWQgJiYgZm9ybWVyLmNsYXNzTGlzdC5yZW1vdmUoJ2ZhZGVJbicpO1xuICAgICAgICBmb3JtZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBhbmltYXRlZCAmJiBzZWN0aW9uLmNsYXNzTGlzdC5hZGQoJ2ZhZGVJbicpO1xuXG4gICAgdGhpcy5fZm9ybWVyQWN0aXZlQ29udGVudCA9IHNlY3Rpb247XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFRhYnM7IiwiZXhwb3J0IGNvbnN0IFdBUk5TID0ge1xuICAgIFMxOiAn5bel5L2c6KGo5ZCN5LiN6IO95Li656m655m944CCJyxcbiAgICBTMjogYOW3peS9nOihqOWQjeensOWMheWQq+aXoOaViOWtl+espjogOiBcXCAvID8gKiBbIF3jgIJgLFxuICAgIFMzOiAn6K+l5ZCN56ew5bey6KKr5L2/55So77yM6K+35bCd6K+V5YW25LuW5ZCN56ew44CCJ1xufTtcblxuXG5leHBvcnQgY29uc3QgTUVOVSA9IHtcbiAgICBTMTogJ+ihjOmrmC4uLicsXG4gICAgUzI6ICfliJflrr0uLi4nLFxuICAgIFMzOiAn5Y2V5YWD5qC85ZCI5bm2JyxcbiAgICBTNDogJ+WPlua2iOWNleWFg+agvOWQiOW5ticsXG4gICAgUzU6ICflr7npvZAnLFxuICAgIFM2OiAn5bem5a+56b2QJyxcbiAgICBTNzogJ+awtOW5s+WxheS4rScsXG4gICAgUzg6ICflj7Plr7npvZAnLFxuICAgIFM5OiAn5Lik56uv5a+56b2QJyxcbiAgICBTMTA6ICfpobbpg6jlr7npvZAnLFxuICAgIFMxMTogJ+WeguebtOWxheS4rScsXG4gICAgUzEyOiAn5bqV6YOo5a+56b2QJyxcbiAgICBTMTM6ICfor7fovpPlhaXooYzpq5gnLFxuICAgIFMxNDogJ+ivt+i+k+WFpeWIl+WuvSdcbn07IiwiaW1wb3J0IHtQbHVnaW5FcnJvcn0gZnJvbSAnLi9QbHVnaW5FcnJvcidcblxudmFyIF9wbHVnaW5zID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIOaPkuS7tuWfuuexu1xuICovXG5jbGFzcyBQbHVnaW4ge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NwcmVhZFNoZWV0fSBzcHJlYWRTaGVldFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwcmVhZFNoZWV0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U3ByZWFkU2hlZXR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwcmVhZHNoZWV0ID0gc3ByZWFkU2hlZXQ7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIOaaguaXtuS4jeiAg+iZkeW8gOaUvui/meS4quaWueazle+8jOeUqOaIt+WumuS5ieeahOaPkuS7tuS4jeiDveaJqeWxlSBTcHJlYWRTaGVldCDnmoQgQVBJXG4gICAgX3JlZ2lzdGVyTWV0aG9kKG5hbWUpIHtcbiAgICAgICAgdmFyIHByb3RvID0gdGhpcy5zcHJlYWRzaGVldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgIHByb3RvW25hbWVdID0gKCkgPT4gdGhpc1tuYW1lXSgpO1xuICAgIH1cblxuICAgIGlzRW5hYmxlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZW5hYmxlKCkge1xuXG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcblxuICAgIH1cblxufVxuXG5leHBvcnQge1BsdWdpbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUGx1Z2luKHApIHtcbiAgICBpZiAoIXAuZW5hYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBQbHVnaW5FcnJvcign5o+S5Lu25b+F6aG75YyF5ZCr5ZCv55So5pa55rOV77yaZW5hYmxlJyk7XG4gICAgfVxuICAgIGlmICghcC5kZXN0cm95KSB7XG4gICAgICAgIHRocm93IG5ldyBQbHVnaW5FcnJvcign5o+S5Lu25b+F6aG75YyF5ZCr6ZSA5q+B5pa55rOV77yaZGVzdHJveScpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICAgIF9wbHVnaW5zLnNldChuYW1lLCBwbHVnaW4pO1xuICAgIHBsdWdpbi5wcm90b3R5cGUuX19uYW1lX18gPSBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICB2YXIgcCA9IF9wbHVnaW5zLmdldChuYW1lKTtcbiAgICBpZiAoIXApIHtcbiAgICAgICAgdGhyb3cgbmV3IFBsdWdpbkVycm9yKCfmj5Lku7bkuI3lrZjlnKjvvJonICsgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG4vKipcbiAqIOiOt+WPluaJgOacieaPkuS7tlxuICogQHJldHVybnMge01hcH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIF9wbHVnaW5zO1xufVxuXG5cbiIsImltcG9ydCB7U3ByZWFkU2hlZXRFcnJvcn0gZnJvbSAnLi4vU3ByZWFkU2hlZXRFcnJvcidcblxuZXhwb3J0IGZ1bmN0aW9uIFBsdWdpbkVycm9yKHZhbHVlKSB7XG4gICAgdGhpcy5uYW1lID0gJ1BsdWdpbkVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcbn1cblBsdWdpbkVycm9yLnByb3RvdHlwZSA9IG5ldyBTcHJlYWRTaGVldEVycm9yKCk7XG5QbHVnaW5FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVnaW5FcnJvcjsiLCJpbXBvcnQge1BsdWdpbn0gZnJvbSAnLi4vUGx1Z2luJztcbmltcG9ydCB7U3RvcmFnZX0gZnJvbSAnLi9TdG9yYWdlJztcblxuY2xhc3MgUGVyc2lzdGVudCBleHRlbmRzIFBsdWdpbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcihzc2QpIHtcbiAgICAgICAgc3VwZXIoc3NkKTtcblxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNwcmVhZHNoZWV0LnNldHRpbmdzO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5wZXJzaXN0ZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBwZXJzaXN0ZW50IOS4uiBgdHJ1ZWAg5pe277yM5L2/55So6buY6K6k5pa55qGIXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOeUteWtkOihqOagvOacrOWcsOaMgeS5heWMluaXtuS9v+eUqOeahCBrZXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wZXJzaXN0ZW50S2V5ID0gc3NkLmdldElkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPIHBlcnNpc3RlbnQg5Li65a+56LGh5pe277yM5o+Q5L6bIGxvY2FsU3RvcmFnZeOAgXNlc3Npb24g562J5pa55qGI5Y+K6LaF5pe25pe26Ze0562J55u45YWz6YWN572uXG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbnRLZXkgPSBzZXR0aW5ncy5wZXJzaXN0ZW50LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ByZWFkc2hlZXQuc2V0dGluZ3MgPSBTdG9yYWdlLmxvYWQodGhpcy5wZXJzaXN0ZW50S2V5KSB8fCBzZXR0aW5ncztcblxuICAgICAgICB0aGlzLl9yZWdpc3Rlck1ldGhvZCgnc2F2ZVN0YXRlJyk7XG4gICAgfVxuXG4gICAgaXNFbmFibGUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc3ByZWFkc2hlZXQuZ2V0U2V0dGluZ3MoKS5wZXJzaXN0ZW50O1xuICAgIH1cblxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgc3VwZXIuZW5hYmxlKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHNhdmVTdGF0ZSgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnNwcmVhZHNoZWV0LmdldEV4Y2hhbmdlRGF0YSgpO1xuICAgICAgICBTdG9yYWdlLnNhdmUodGhpcy5wZXJzaXN0ZW50S2V5LCBkYXRhKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGVyc2lzdGVudDsiLCIvKipcbiAqIOWtmOWCqOaWueahiFxuICovXG5jbGFzcyBTdG9yYWdlIHtcblxuICAgIHN0YXRpYyBzYXZlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlLlBSRUZJWCArIGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb2FkKGtleSkge1xuICAgICAgICB2YXIgdmFsID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFN0b3JhZ2UuUFJFRklYICsga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmUoa2V5KSB7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlW1N0b3JhZ2UuUFJFRklYICsga2V5XSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFN0b3JhZ2UuUFJFRklYICsga2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjbGVhcigpIHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICAgIH1cblxufVxuXG5TdG9yYWdlLlBSRUZJWCA9ICckJGJyaWNrIXN0b3JhZ2UtJztcblxuZXhwb3J0IHtTdG9yYWdlfTsiLCJpbXBvcnQge0NlbGxWYWx1ZX0gZnJvbSAnLi9DZWxsVmFsdWUnO1xuaW1wb3J0IHtpc0Zvcm11bGFFeHByZXNzaW9ufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7RXhwcmVzc2lvbk1vZGlmaWVyfSBmcm9tICcuL2V4cHJlc3Npb25Nb2RpZmllcic7XG5pbXBvcnQgbG9jYWxIb29rcyBmcm9tICcuLi8uLi91dGlscy9sb2NhbEhvb2tzJztcblxudmFyIGFycmF5RWFjaCA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlFYWNoO1xudmFyIG1peGluID0gSGFuZHNvbnRhYmxlLmhlbHBlci5taXhpbjtcblxuY2xhc3MgQWx0ZXJNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzaGVldCkge1xuXG4gICAgICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcblxuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IHNoZWV0LmRhdGFQcm92aWRlcjtcblxuICAgICAgICB0aGlzLm1hdHJpeCA9IHNoZWV0Lm1hdHJpeDtcbiAgICB9XG5cbiAgICBpbnNlcnRSb3cocm93LCBhbW91bnQsIG1vZGlmeUZvcm11bGEpIHtcbiAgICAgICAgdGhpcy5fYWx0ZXIoJ2luc2VydCcsICdyb3cnLCByb3csIGFtb3VudCwgbW9kaWZ5Rm9ybXVsYSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlUm93KHJvdywgYW1vdW50LCBtb2RpZnlGb3JtdWxhKSB7XG4gICAgICAgIHRoaXMuX2FsdGVyKCdyZW1vdmUnLCAncm93Jywgcm93LCAtYW1vdW50LCBtb2RpZnlGb3JtdWxhKTtcbiAgICB9XG5cbiAgICBpbnNlcnRDb2x1bW4oY29sdW1uLCBhbW91bnQsIG1vZGlmeUZvcm11bGEpIHtcbiAgICAgICAgdGhpcy5fYWx0ZXIoJ2luc2VydCcsICdjb2x1bW4nLCBjb2x1bW4sIGFtb3VudCwgbW9kaWZ5Rm9ybXVsYSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlQ29sdW1uKGNvbHVtbiwgYW1vdW50LCBtb2RpZnlGb3JtdWxhKSB7XG4gICAgICAgIHRoaXMuX2FsdGVyKCdyZW1vdmUnLCAnY29sdW1uJywgY29sdW1uLCAtYW1vdW50LCBtb2RpZnlGb3JtdWxhKTtcbiAgICB9XG5cbiAgICBfYWx0ZXIoYWN0aW9uLCBheGlzLCBzdGFydCwgYW1vdW50LCBtb2RpZnlGb3JtdWxhID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBzdGFydENvb3JkID0gKGNlbGwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm93OiBheGlzID09PSAncm93JyA/IHN0YXJ0IDogY2VsbC5yb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBheGlzID09PSAnY29sdW1uJyA/IHN0YXJ0IDogY2VsbC5jb2x1bW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0cmFuc2xhdGVDZWxsUmVmcyA9IChyb3csIGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgYXJyYXlFYWNoKHRoaXMubWF0cml4LmNlbGxSZWZlcmVuY2VzLCAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsW2F4aXNdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwudHJhbnNsYXRlVG8ocm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IFtdO1xuICAgICAgICBjb25zdCBpbmRleE9mZnNldCA9IE1hdGguYWJzKGFtb3VudCkgLSAxO1xuXG4gICAgICAgIGlmIChheGlzID09PSAncm93Jykge1xuICAgICAgICAgICAgdHJhbnNsYXRlLnB1c2goYW1vdW50LCAwKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGUucHVzaCgwLCBhbW91bnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgIGxldCByZW1vdmVkQ2VsbFJlZiA9IHRoaXMubWF0cml4LnJlbW92ZUNlbGxSZWZzQXRSYW5nZSh7W2F4aXNdOiBzdGFydH0sIHtbYXhpc106IHN0YXJ0ICsgaW5kZXhPZmZzZXR9KTtcbiAgICAgICAgICAgIGxldCB0b1JlbW92ZSA9IFtdO1xuXG4gICAgICAgICAgICBhcnJheUVhY2godGhpcy5tYXRyaXguZGF0YSwgKGNlbGwpID0+IHtcbiAgICAgICAgICAgICAgICBhcnJheUVhY2gocmVtb3ZlZENlbGxSZWYsIChjZWxsUmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2VsbC5oYXNQcmVjZWRlbnQoY2VsbFJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNlbGwucmVtb3ZlUHJlY2VkZW50KGNlbGxSZWYpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5RWFjaCh0aGlzLnNoZWV0LmdldENlbGxEZXBlbmRlbmNpZXMoY2VsbC5yb3csIGNlbGwuY29sdW1uKSwgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChjZWxsW2F4aXNdID49IHN0YXJ0ICYmIGNlbGxbYXhpc10gPD0gKHN0YXJ0ICsgaW5kZXhPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmVtb3ZlLnB1c2goY2VsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubWF0cml4LnJlbW92ZSh0b1JlbW92ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2xhdGVDZWxsUmVmcyguLi50cmFuc2xhdGUpO1xuXG4gICAgICAgIGFycmF5RWFjaCh0aGlzLm1hdHJpeC5kYXRhLCAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ1JvdyA9IGNlbGwucm93O1xuICAgICAgICAgICAgY29uc3Qgb3JpZ0NvbHVtbiA9IGNlbGwuY29sdW1uO1xuXG4gICAgICAgICAgICBpZiAoY2VsbFtheGlzXSA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIGNlbGwudHJhbnNsYXRlVG8oLi4udHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgICBjZWxsLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9kaWZ5Rm9ybXVsYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGNlbGwucm93O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNlbGwuY29sdW1uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwTW9kaWZpZXIgPSBuZXcgRXhwcmVzc2lvbk1vZGlmaWVyKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBleHBNb2RpZmllci50cmFuc2xhdGUoc3RhcnRDb29yZCh7cm93OiBvcmlnUm93LCBjb2x1bW46IG9yaWdDb2x1bW59KSwge1theGlzXTogYW1vdW50fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIudXBkYXRlU291cmNlRGF0YShyb3csIGNvbHVtbiwgZXhwTW9kaWZpZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5Mb2NhbEhvb2tzKCdhZnRlckFsdGVyJywgYWN0aW9uLCBheGlzLCBzdGFydCwgYW1vdW50KTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNoZWV0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gICAgfVxufVxuXG5taXhpbihBbHRlck1hbmFnZXIsIGxvY2FsSG9va3MpO1xuXG5leHBvcnQge0FsdGVyTWFuYWdlcn07XG4iLCJpbXBvcnQge3RvTGFiZWx9IGZyb20gJy4vcGFyc2VyL3V0aWxzJztcblxudmFyIGlzT2JqZWN0ID0gSGFuZHNvbnRhYmxlLmhlbHBlci5pc09iamVjdDtcblxuY2xhc3MgQmFzZUNlbGwge1xuICAgIGNvbnN0cnVjdG9yKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IHJvd09iamVjdCA9IGlzT2JqZWN0KHJvdyk7XG4gICAgICAgIGNvbnN0IGNvbHVtbk9iamVjdCA9IGlzT2JqZWN0KGNvbHVtbik7XG5cbiAgICAgICAgdGhpcy5fcm93ID0gcm93T2JqZWN0ID8gcm93LmluZGV4IDogcm93O1xuICAgICAgICB0aGlzLnJvd0Fic29sdXRlID0gcm93T2JqZWN0ID8gcm93LmlzQWJzb2x1dGUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29sdW1uID0gY29sdW1uT2JqZWN0ID8gY29sdW1uLmluZGV4IDogY29sdW1uO1xuICAgICAgICB0aGlzLmNvbHVtbkFic29sdXRlID0gY29sdW1uT2JqZWN0ID8gY29sdW1uLmlzQWJzb2x1dGUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3dPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbk9mZnNldCA9IDA7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyb3cnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dPZmZzZXQgKyB0aGlzLl9yb3c7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29sdW1uJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uT2Zmc2V0ICsgdGhpcy5fY29sdW1uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYW5zbGF0ZVRvKHJvd09mZnNldCwgY29sdW1uT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucm93ID0gdGhpcy5yb3cgKyByb3dPZmZzZXQ7XG4gICAgICAgIHRoaXMuY29sdW1uID0gdGhpcy5jb2x1bW4gKyBjb2x1bW5PZmZzZXQ7XG4gICAgfVxuXG4gICAgaXNFcXVhbChjZWxsKSB7XG4gICAgICAgIHJldHVybiBjZWxsLnJvdyA9PT0gdGhpcy5yb3cgJiYgY2VsbC5jb2x1bW4gPT09IHRoaXMuY29sdW1uO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdG9MYWJlbChcbiAgICAgICAgICAgIHtpbmRleDogdGhpcy5yb3csIGlzQWJzb2x1dGU6IHRoaXMucm93QWJzb2x1dGV9LFxuICAgICAgICAgICAge2luZGV4OiB0aGlzLmNvbHVtbiwgaXNBYnNvbHV0ZTogdGhpcy5jb2x1bW5BYnNvbHV0ZX1cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VDZWxsO1xuIiwiaW1wb3J0IEJhc2VDZWxsIGZyb20gJy4vQmFzZUNlbGwnO1xuaW1wb3J0IHt0b0xhYmVsfSBmcm9tICcuL3BhcnNlci91dGlscyc7XG5cbmNsYXNzIENlbGxSZWZlcmVuY2UgZXh0ZW5kcyBCYXNlQ2VsbCB7XG4gICAgY29uc3RydWN0b3Iocm93LCBjb2x1bW4pIHtcbiAgICAgICAgc3VwZXIocm93LCBjb2x1bW4pO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdG9MYWJlbChcbiAgICAgICAgICAgIHtpbmRleDogdGhpcy5yb3csIGlzQWJzb2x1dGU6IGZhbHNlfSxcbiAgICAgICAgICAgIHtpbmRleDogdGhpcy5jb2x1bW4sIGlzQWJzb2x1dGU6IGZhbHNlfVxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IHtDZWxsUmVmZXJlbmNlfTtcbiIsImltcG9ydCBCYXNlQ2VsbCBmcm9tICcuL0Jhc2VDZWxsJztcbmltcG9ydCB7RVJST1JfUkVGfSBmcm9tICcuL3BhcnNlci9lcnJvcic7XG5cbmNvbnN0IFNUQVRFX09VVF9PRkZfREFURSA9IDE7XG5jb25zdCBTVEFURV9DT01QVVRJTkcgPSAyO1xuY29uc3QgU1RBVEVfVVBfVE9fREFURSA9IDM7XG5jb25zdCBzdGF0ZXMgPSBbU1RBVEVfT1VUX09GRl9EQVRFLCBTVEFURV9DT01QVVRJTkcsIFNUQVRFX1VQX1RPX0RBVEVdO1xuXG52YXIgYXJyYXlGaWx0ZXIgPSBIYW5kc29udGFibGUuaGVscGVyLmFycmF5RmlsdGVyO1xuXG5cbmNsYXNzIENlbGxWYWx1ZSBleHRlbmRzIEJhc2VDZWxsIHtcblxuICAgIHN0YXRpYyBnZXQgU1RBVEVfT1VUX09GRl9EQVRFKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IFNUQVRFX0NPTVBVVElORygpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBTVEFURV9VUF9UT19EQVRFKCkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihyb3csIGNvbHVtbikge1xuICAgICAgICBzdXBlcihyb3csIGNvbHVtbik7XG4gICAgICAgIHRoaXMucHJlY2VkZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDZWxsVmFsdWUuU1RBVEVfVVBfVE9fREFURTtcbiAgICB9XG5cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHNldEVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG5cbiAgICBnZXRFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3I7XG4gICAgfVxuXG4gICAgaGFzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yICE9PSBudWxsO1xuICAgIH1cblxuICAgIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZXMuaW5kZXhPZihzdGF0ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyhg5pyq55+l54q25oCBOiAke3N0YXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICBpc1N0YXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBzdGF0ZTtcbiAgICB9XG5cbiAgICBhZGRQcmVjZWRlbnQoY2VsbFJlZmVyZW5jZSkge1xuICAgICAgICBpZiAodGhpcy5pc0VxdWFsKGNlbGxSZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJPUl9SRUYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oYXNQcmVjZWRlbnQoY2VsbFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJlY2VkZW50cy5wdXNoKGNlbGxSZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlUHJlY2VkZW50KGNlbGxSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFcXVhbChjZWxsUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoRVJST1JfUkVGKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWNlZGVudHMgPSBhcnJheUZpbHRlcih0aGlzLnByZWNlZGVudHMsIChjZWxsKSA9PiAhY2VsbC5pc0VxdWFsKGNlbGxSZWZlcmVuY2UpKTtcbiAgICB9XG5cbiAgICBnZXRQcmVjZWRlbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVjZWRlbnRzO1xuICAgIH1cblxuICAgIGhhc1ByZWNlZGVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNlZGVudHMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBoYXNQcmVjZWRlbnQoY2VsbFJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlGaWx0ZXIodGhpcy5wcmVjZWRlbnRzLCAoY2VsbCkgPT4gY2VsbC5pc0VxdWFsKGNlbGxSZWZlcmVuY2UpKS5sZW5ndGggPyB0cnVlIDogZmFsc2U7XG4gICAgfVxufVxuXG5leHBvcnQge0NlbGxWYWx1ZX07XG4iLCJpbXBvcnQge2lzRm9ybXVsYUV4cHJlc3Npb259IGZyb20gJy4vdXRpbHMnO1xuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgcmFuZ2VFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5yYW5nZUVhY2g7XG5cblxuY2xhc3MgRGF0YVByb3ZpZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGhvdCkge1xuICAgICAgICB0aGlzLmhvdCA9IGhvdDtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0ge307XG4gICAgfVxuXG4gICAgY29sbGVjdENoYW5nZXMocm93LCBjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlc1tEYXRhUHJvdmlkZXIuX2Nvb3JkSWQocm93LCBjb2x1bW4pXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSB7fTtcbiAgICB9XG5cbiAgICBpc0luRGF0YVJhbmdlKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiByb3cgPj0gMCAmJiByb3cgPCB0aGlzLmhvdC5jb3VudFJvd3MoKSAmJiBjb2x1bW4gPj0gMCAmJiBjb2x1bW4gPCB0aGlzLmhvdC5jb3VudENvbHMoKTtcbiAgICB9XG5cbiAgICBnZXREYXRhQXRDZWxsKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IGlkID0gRGF0YVByb3ZpZGVyLl9jb29yZElkKHJvdywgY29sdW1uKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICBpZiAodGhpcy5jaGFuZ2VzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaGFuZ2VzW2lkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaG90LmdldERhdGFBdENlbGwocm93LCBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZ2V0RGF0YUF0Q2VsbEluU2hlZXQoc2hlZXROYW1lLCByb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgc2hlZXQgPSB0aGlzLndvcmtib29rLmdldFNoZWV0KHNoZWV0TmFtZSk7XG4gICAgICAgIHZhciBmb3JtdWxhcyA9IHNoZWV0LmhhbmRzb250YWJsZS5nZXRQbHVnaW4oJ1hGb3JtdWxhcycpO1xuICAgICAgICByZXR1cm4gZm9ybXVsYXMuc2hlZXQuZGF0YVByb3ZpZGVyLmdldERhdGFBdENlbGwocm93LCBjb2x1bW4pO1xuICAgIH1cblxuICAgIGdldERhdGFCeVJhbmdlKHJvdzEsIGNvbHVtbjEsIHJvdzIsIGNvbHVtbjIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5ob3QuZ2V0RGF0YShyb3cxLCBjb2x1bW4xLCByb3cyLCBjb2x1bW4yKTtcblxuICAgICAgICBhcnJheUVhY2gocmVzdWx0LCAocm93RGF0YSwgcm93SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFycmF5RWFjaChyb3dEYXRhLCAodmFsdWUsIGNvbHVtbkluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBEYXRhUHJvdmlkZXIuX2Nvb3JkSWQocm93SW5kZXggKyByb3cxLCBjb2x1bW5JbmRleCArIGNvbHVtbjEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jvd0luZGV4XVtjb2x1bW5JbmRleF0gPSB0aGlzLmNoYW5nZXNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldFNvdXJjZURhdGFBdENlbGwocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG90LmdldFNvdXJjZURhdGFBdENlbGwocm93LCBjb2x1bW4pO1xuICAgIH1cblxuICAgIGdldFNvdXJjZURhdGFCeVJhbmdlKHJvdzEsIGNvbHVtbjEsIHJvdzIsIGNvbHVtbjIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG90LmdldFNvdXJjZURhdGFBcnJheShyb3cxLCBjb2x1bW4xLCByb3cyLCBjb2x1bW4yKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTb3VyY2VEYXRhKHJvdywgY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmhvdC5nZXRTb3VyY2VEYXRhKClbcm93XVt0aGlzLmhvdC5jb2xUb1Byb3AoY29sdW1uKV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2Nvb3JkSWQocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGAke3Jvd306JHtjb2x1bW59YDtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmhvdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQge0RhdGFQcm92aWRlcn07XG4iLCJpbXBvcnQge0NlbGxWYWx1ZX0gZnJvbSAnLi9DZWxsVmFsdWUnO1xuaW1wb3J0IHtFUlJPUl9SRUZ9IGZyb20gXCIuL3BhcnNlci9lcnJvclwiO1xuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgYXJyYXlGaWx0ZXIgPSBIYW5kc29udGFibGUuaGVscGVyLmFycmF5RmlsdGVyO1xudmFyIGFycmF5UmVkdWNlID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheVJlZHVjZTtcblxuY2xhc3MgTWF0cml4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuY2VsbFJlZmVyZW5jZXMgPSBbXTtcbiAgICB9XG5cbiAgICBnZXRDZWxsQXQocm93LCBjb2x1bW4pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgYXJyYXlFYWNoKHRoaXMuZGF0YSwgKGNlbGwpID0+IHtcbiAgICAgICAgICAgIGlmIChjZWxsLnJvdyA9PT0gcm93ICYmIGNlbGwuY29sdW1uID09PSBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjZWxsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldE91dE9mRGF0ZUNlbGxzKCkge1xuICAgICAgICByZXR1cm4gYXJyYXlGaWx0ZXIodGhpcy5kYXRhLCAoY2VsbCkgPT4gY2VsbC5pc1N0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpKTtcbiAgICB9XG5cbiAgICBhZGQoY2VsbFZhbHVlKSB7XG4gICAgICAgIGlmICghYXJyYXlGaWx0ZXIodGhpcy5kYXRhLCAoY2VsbCkgPT4gY2VsbC5pc0VxdWFsKGNlbGxWYWx1ZSkpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goY2VsbFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZShjZWxsVmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY2VsbFZhbHVlKTtcbiAgICAgICAgY29uc3QgaXNFcXVhbCA9IChjZWxsLCBjZWxsVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheUVhY2goY2VsbFZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuaXNFcXVhbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjZWxsLmlzRXF1YWwoY2VsbFZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhID0gYXJyYXlGaWx0ZXIodGhpcy5kYXRhLCAoY2VsbCkgPT4gIWlzRXF1YWwoY2VsbCwgY2VsbFZhbHVlKSk7XG4gICAgfVxuXG4gICAgZ2V0RGVwZW5kZW5jaWVzKGNlbGxWYWx1ZSkge1xuICAgICAgICBjb25zdCBnZXREZXBlbmRlbmNpZXMgPSAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHRoaXMuZGF0YSwgKGFjYywgY2VsbFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxWYWx1ZS5oYXNQcmVjZWRlbnQoY2VsbCkgJiYgYWNjLmluZGV4T2YoY2VsbFZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goY2VsbFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBnZXRUb3RhbERlcGVuZGVuY2llcyA9IChjZWxsKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGVwcyA9IGdldERlcGVuZGVuY2llcyhjZWxsKTtcblxuICAgICAgICAgICAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlFYWNoKGRlcHMsIChjZWxsVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxWYWx1ZS5oYXNQcmVjZWRlbnRzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMgPSBkZXBzLmNvbmNhdChnZXRUb3RhbERlcGVuZGVuY2llcyhjZWxsVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlcHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUb3RhbERlcGVuZGVuY2llcyhjZWxsVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBUT0RPIOWinuWKoOivpeS7o+eggeaYr+ino+WGs+S7peS4i+mXrumimOeahOadg+WunOS5i+etlu+8mlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2hhbmRzb250YWJsZS9oYW5kc29udGFibGUvaXNzdWVzLzQzNTdcbiAgICAgICAgICAgIGxldCBlcnJvclZhbHVlID0gbmV3IENlbGxWYWx1ZShjZWxsVmFsdWUucm93LCBjZWxsVmFsdWUuY29sdW1uKTtcbiAgICAgICAgICAgIGVycm9yVmFsdWUuc2V0RXJyb3IoRVJST1JfUkVGKTtcbiAgICAgICAgICAgIGVycm9yVmFsdWUuc2V0U3RhdGUoQ2VsbFZhbHVlLlNUQVRFX1VQX1RPX0RBVEUpO1xuICAgICAgICAgICAgcmV0dXJuIFtlcnJvclZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcmVnaXN0ZXJDZWxsUmVmKGNlbGxSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKCFhcnJheUZpbHRlcih0aGlzLmNlbGxSZWZlcmVuY2VzLCAoY2VsbCkgPT4gY2VsbC5pc0VxdWFsKGNlbGxSZWZlcmVuY2UpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbFJlZmVyZW5jZXMucHVzaChjZWxsUmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUNlbGxSZWZzQXRSYW5nZSh7cm93OiBzdGFydFJvdywgY29sdW1uOiBzdGFydENvbHVtbn0sIHtyb3c6IGVuZFJvdywgY29sdW1uOiBlbmRDb2x1bW59KSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcblxuICAgICAgICBjb25zdCByb3dNYXRjaCA9IChjZWxsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRSb3cgPT09IHZvaWQgMCA/IHRydWUgOiBjZWxsLnJvdyA+PSBzdGFydFJvdyAmJiBjZWxsLnJvdyA8PSBlbmRSb3c7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbE1hdGNoID0gKGNlbGwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydENvbHVtbiA9PT0gdm9pZCAwID8gdHJ1ZSA6IGNlbGwuY29sdW1uID49IHN0YXJ0Q29sdW1uICYmIGNlbGwuY29sdW1uIDw9IGVuZENvbHVtbjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNlbGxSZWZlcmVuY2VzID0gYXJyYXlGaWx0ZXIodGhpcy5jZWxsUmVmZXJlbmNlcywgKGNlbGwpID0+IHtcbiAgICAgICAgICAgIGlmIChyb3dNYXRjaChjZWxsKSAmJiBjb2xNYXRjaChjZWxsKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChjZWxsKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmRhdGEubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jZWxsUmVmZXJlbmNlcy5sZW5ndGggPSAwO1xuICAgIH1cbn1cblxuZXhwb3J0IHtNYXRyaXh9O1xuIiwiaW1wb3J0IHtDZWxsVmFsdWV9IGZyb20gJy4vQ2VsbFZhbHVlJztcbmltcG9ydCB7Q2VsbFJlZmVyZW5jZX0gZnJvbSAnLi9DZWxsUmVmZXJlbmNlJztcbmltcG9ydCB7aXNGb3JtdWxhRXhwcmVzc2lvbiwgdG9VcHBlckNhc2VGb3JtdWxhfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7TWF0cml4fSBmcm9tICcuL01hdHJpeCc7XG5pbXBvcnQge0FsdGVyTWFuYWdlcn0gZnJvbSAnLi9BbHRlck1hbmFnZXInO1xuaW1wb3J0IHtQYXJzZXJ9IGZyb20gJy4vcGFyc2VyL3BhcnNlcic7XG5pbXBvcnQge0VSUk9SX1JFRn0gZnJvbSAnLi9wYXJzZXIvZXJyb3InO1xuaW1wb3J0IGxvY2FsSG9va3MgZnJvbSAnLi4vLi4vdXRpbHMvbG9jYWxIb29rcyc7XG5cbmNvbnN0IFNUQVRFX1VQX1RPX0RBVEUgPSAxO1xuY29uc3QgU1RBVEVfTkVFRF9SRUJVSUxEID0gMjtcbmNvbnN0IFNUQVRFX05FRURfRlVMTF9SRUJVSUxEID0gMztcblxudmFyIGFycmF5RWFjaCA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlFYWNoO1xudmFyIGFycmF5TWFwID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheU1hcDtcbnZhciByYW5nZUVhY2ggPSBIYW5kc29udGFibGUuaGVscGVyLnJhbmdlRWFjaDtcbnZhciBvYmplY3RFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5vYmplY3RFYWNoO1xudmFyIG1peGluID0gSGFuZHNvbnRhYmxlLmhlbHBlci5taXhpbjtcblxuXG5jbGFzcyBTaGVldCB7XG5cbiAgICBjb25zdHJ1Y3RvcihkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBkYXRhUHJvdmlkZXI7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgICAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5hbHRlck1hbmFnZXIgPSBuZXcgQWx0ZXJNYW5hZ2VyKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NpbmdDZWxsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURV9ORUVEX0ZVTExfUkVCVUlMRDtcblxuICAgICAgICB0aGlzLnBhcnNlci5vbignY2FsbENlbGxWYWx1ZScsICguLi5hcmdzKSA9PiB0aGlzLl9vbkNhbGxDZWxsVmFsdWUoLi4uYXJncykpO1xuICAgICAgICB0aGlzLnBhcnNlci5vbignY2FsbFJhbmdlVmFsdWUnLCAoLi4uYXJncykgPT4gdGhpcy5fb25DYWxsUmFuZ2VWYWx1ZSguLi5hcmdzKSk7XG4gICAgICAgIHRoaXMucGFyc2VyLm9uKCdjYWxsQ2VsbFZhbHVlSW5TaGVldCcsICguLi5hcmdzKSA9PiB0aGlzLl9vbkNhbGxDZWxsVmFsdWVJblNoZWV0KC4uLmFyZ3MpKTtcbiAgICAgICAgdGhpcy5wYXJzZXIub24oJ2NhbGxSYW5nZVZhbHVlSW5TaGVldCcsICguLi5hcmdzKSA9PiB0aGlzLl9vbkNhbGxSYW5nZVZhbHVlSW5TaGVldCguLi5hcmdzKSk7XG4gICAgICAgIHRoaXMuYWx0ZXJNYW5hZ2VyLmFkZExvY2FsSG9vaygnYWZ0ZXJBbHRlcicsICguLi5hcmdzKSA9PiB0aGlzLl9vbkFmdGVyQWx0ZXIoLi4uYXJncykpO1xuICAgIH1cblxuICAgIHJlY2FsY3VsYXRlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFNUQVRFX05FRURfRlVMTF9SRUJVSUxEOlxuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGVGdWxsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNUQVRFX05FRURfUkVCVUlMRDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlT3B0aW1pemVkKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWNhbGN1bGF0ZU9wdGltaXplZCgpIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSB0aGlzLm1hdHJpeC5nZXRPdXRPZkRhdGVDZWxscygpO1xuXG4gICAgICAgIGFycmF5RWFjaChjZWxscywgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRhdGFQcm92aWRlci5nZXRTb3VyY2VEYXRhQXRDZWxsKGNlbGxWYWx1ZS5yb3csIGNlbGxWYWx1ZS5jb2x1bW4pO1xuXG4gICAgICAgICAgICBpZiAoaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXhwcmVzc2lvbihjZWxsVmFsdWUsIHZhbHVlLnN1YnN0cigxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gU1RBVEVfVVBfVE9fREFURTtcbiAgICAgICAgdGhpcy5ydW5Mb2NhbEhvb2tzKCdhZnRlclJlY2FsY3VsYXRlJywgY2VsbHMsICdvcHRpbWl6ZWQnKTtcbiAgICB9XG5cbiAgICByZWNhbGN1bGF0ZUZ1bGwoKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5kYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUJ5UmFuZ2UoKTtcbiAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcblxuICAgICAgICBhcnJheUVhY2goY2VsbHMsIChyb3dEYXRhLCByb3cpID0+IHtcbiAgICAgICAgICAgIGFycmF5RWFjaChyb3dEYXRhLCAodmFsdWUsIGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXhwcmVzc2lvbihuZXcgQ2VsbFZhbHVlKHJvdywgY29sdW1uKSwgdmFsdWUuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURV9VUF9UT19EQVRFO1xuICAgICAgICB0aGlzLnJ1bkxvY2FsSG9va3MoJ2FmdGVyUmVjYWxjdWxhdGUnLCBjZWxscywgJ2Z1bGwnKTtcbiAgICB9XG5cbiAgICBzZXRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcnNlci5zZXRWYXJpYWJsZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG5cbiAgICBnZXRWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5nZXRWYXJpYWJsZShuYW1lKTtcbiAgICB9XG5cblxuICAgIGFwcGx5Q2hhbmdlcyhyb3csIGNvbHVtbiwgbmV3VmFsdWUpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIHJlY2FsY3VsYXRlKClcbiAgICAgICAgdGhpcy5tYXRyaXgucmVtb3ZlKHtyb3csIGNvbHVtbn0pO1xuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byByZWNhbGN1bGF0ZSgpXG4gICAgICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUV4cHJlc3Npb24obmV3IENlbGxWYWx1ZShyb3csIGNvbHVtbiksIG5ld1ZhbHVlLnN1YnN0cigxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXBzID0gdGhpcy5nZXRDZWxsRGVwZW5kZW5jaWVzKHJvdywgY29sdW1uKTtcblxuICAgICAgICBhcnJheUVhY2goZGVwcywgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY2VsbFZhbHVlLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IFNUQVRFX05FRURfUkVCVUlMRDtcbiAgICB9XG5cbiAgICBwYXJzZUV4cHJlc3Npb24oY2VsbFZhbHVlLCBmb3JtdWxhKSB7XG4gICAgICAgIGNlbGxWYWx1ZS5zZXRTdGF0ZShDZWxsVmFsdWUuU1RBVEVfQ09NUFVUSU5HKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ0NlbGwgPSBjZWxsVmFsdWU7XG5cbiAgICAgICAgLy8gVE9ETyAgd3JhcHBlciBmb3JtdWxhXG4gICAgICAgIC8vIHZhciBzaGVldE5hbWVzID0gdGhpcy5kYXRhUHJvdmlkZXIud29ya2Jvb2suZ2V0U2hlZXROYW1lcygpO1xuXG4gICAgICAgIGNvbnN0IHtlcnJvciwgcmVzdWx0fSA9IHRoaXMucGFyc2VyLnBhcnNlKHRvVXBwZXJDYXNlRm9ybXVsYShmb3JtdWxhKSk7XG5cbiAgICAgICAgY2VsbFZhbHVlLnNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIGNlbGxWYWx1ZS5zZXRFcnJvcihlcnJvcik7XG4gICAgICAgIGNlbGxWYWx1ZS5zZXRTdGF0ZShDZWxsVmFsdWUuU1RBVEVfVVBfVE9fREFURSk7XG5cbiAgICAgICAgdGhpcy5tYXRyaXguYWRkKGNlbGxWYWx1ZSk7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NpbmdDZWxsID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRDZWxsQXQocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldENlbGxBdChyb3csIGNvbHVtbik7XG4gICAgfVxuXG4gICAgZ2V0Q2VsbERlcGVuZGVuY2llcyhyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0RGVwZW5kZW5jaWVzKHtyb3csIGNvbHVtbn0pO1xuICAgIH1cblxuICAgIF9vbkNhbGxDZWxsVmFsdWUoe3JvdywgY29sdW1ufSwgZG9uZSkge1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IENlbGxSZWZlcmVuY2Uocm93LCBjb2x1bW4pO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhUHJvdmlkZXIuaXNJbkRhdGFSYW5nZShjZWxsLnJvdywgY2VsbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJPUl9SRUYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXRyaXgucmVnaXN0ZXJDZWxsUmVmKGNlbGwpO1xuICAgICAgICB0aGlzLl9wcm9jZXNzaW5nQ2VsbC5hZGRQcmVjZWRlbnQoY2VsbCk7XG5cbiAgICAgICAgZG9uZSh0aGlzLmRhdGFQcm92aWRlci5nZXREYXRhQXRDZWxsKGNlbGwucm93LCBjZWxsLmNvbHVtbikpO1xuICAgIH1cblxuICAgIF9vbkNhbGxDZWxsVmFsdWVJblNoZWV0KHtzaGVldE5hbWUsIHJvdywgY29sdW1ufSwgZG9uZSkge1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IENlbGxSZWZlcmVuY2Uocm93LCBjb2x1bW4pO1xuXG4gICAgICAgIC8vIFRPRE8g5pu05pS55pWw5o2u5pe277yM5YWs5byP5byV55So55qE5pWw5o2u57qn6IGU5pu05pawXG5cbiAgICAgICAgZG9uZSh0aGlzLmRhdGFQcm92aWRlci5nZXREYXRhQXRDZWxsSW5TaGVldChzaGVldE5hbWUsIGNlbGwucm93LCBjZWxsLmNvbHVtbikpO1xuICAgIH1cblxuICAgIF9vbkNhbGxSYW5nZVZhbHVlKHtyb3c6IHN0YXJ0Um93LCBjb2x1bW46IHN0YXJ0Q29sdW1ufSwge3JvdzogZW5kUm93LCBjb2x1bW46IGVuZENvbHVtbn0sIGRvbmUpIHtcbiAgICAgICAgcmFuZ2VFYWNoKHN0YXJ0Um93LmluZGV4LCBlbmRSb3cuaW5kZXgsIChyb3cpID0+IHtcbiAgICAgICAgICAgIHJhbmdlRWFjaChzdGFydENvbHVtbi5pbmRleCwgZW5kQ29sdW1uLmluZGV4LCAoY29sdW1uKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGwgPSBuZXcgQ2VsbFJlZmVyZW5jZShyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC5yZWdpc3RlckNlbGxSZWYoY2VsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ0NlbGwuYWRkUHJlY2VkZW50KGNlbGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb25lKHRoaXMuZGF0YVByb3ZpZGVyLmdldERhdGFCeVJhbmdlKHN0YXJ0Um93LmluZGV4LCBzdGFydENvbHVtbi5pbmRleCwgZW5kUm93LmluZGV4LCBlbmRDb2x1bW4uaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIOiwg+eUqOiMg+WbtOWFrOW8j1xuICAgIF9vbkNhbGxSYW5nZVZhbHVlSW5TaGVldChzaGVldE5hbWUsIHtyb3c6IHN0YXJ0Um93LCBjb2x1bW46IHN0YXJ0Q29sdW1ufSwge3JvdzogZW5kUm93LCBjb2x1bW46IGVuZENvbHVtbn0sIGRvbmUpIHtcblxuXG4gICAgICAgIGRvbmUoJ19vbkNhbGxSYW5nZVZhbHVlSW5TaGVldCcpO1xuICAgIH1cblxuICAgIF9vbkFmdGVyQWx0ZXIoKSB7XG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVPcHRpbWl6ZWQoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbHRlck1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmFsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICAgIH1cbn1cblxubWl4aW4oU2hlZXQsIGxvY2FsSG9va3MpO1xuXG5leHBvcnQge1NoZWV0fTtcbiIsImltcG9ydCB7Q2VsbFZhbHVlfSBmcm9tICcuL0NlbGxWYWx1ZSc7XG5pbXBvcnQge1N0YWNrfSBmcm9tICcuLi8uLi91dGlscy9kYXRhU3RydWN0dXJlJ1xuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgcmFuZ2VFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5yYW5nZUVhY2g7XG5cbmNsYXNzIFVuZG9SZWRvU25hcHNob3Qge1xuICAgIGNvbnN0cnVjdG9yKHNoZWV0KSB7XG4gICAgICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIH1cblxuICAgIHNhdmUoYXhpcywgaW5kZXgsIGFtb3VudCkge1xuICAgICAgICBjb25zdCB7bWF0cml4LCBkYXRhUHJvdmlkZXJ9ID0gdGhpcy5zaGVldDtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuXG4gICAgICAgIGFycmF5RWFjaChtYXRyaXguZGF0YSwgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge3JvdywgY29sdW1ufSA9IGNlbGxWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKGNlbGxWYWx1ZVtheGlzXSA8IGluZGV4IHx8IGNlbGxWYWx1ZVtheGlzXSA+IGluZGV4ICsgKGFtb3VudCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe3JvdywgY29sdW1uLCB2YWx1ZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN0YWNrLnB1c2goe2F4aXMsIGluZGV4LCBhbW91bnQsIGNoYW5nZXN9KTtcbiAgICB9XG5cbiAgICByZXN0b3JlKCkge1xuICAgICAgICBjb25zdCB7bWF0cml4LCBkYXRhUHJvdmlkZXJ9ID0gdGhpcy5zaGVldDtcbiAgICAgICAgY29uc3Qge2F4aXMsIGluZGV4LCBhbW91bnQsIGNoYW5nZXN9ID0gdGhpcy5zdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgYXJyYXlFYWNoKGNoYW5nZXMsIChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlW2F4aXNdID4gaW5kZXggKyAoYW1vdW50IC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlW2F4aXNdIC09IGFtb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qge3JvdywgY29sdW1uLCB2YWx1ZX0gPSBjaGFuZ2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBkYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBpZiAocmF3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm92aWRlci51cGRhdGVTb3VyY2VEYXRhKHJvdywgY29sdW1uLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXRDZWxsQXQocm93LCBjb2x1bW4pLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zaGVldCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IHtVbmRvUmVkb1NuYXBzaG90fTtcbiIsIi8qKlxuICog5omp5bGV5YWs5byP77ya5pSv5oyB6Leo5bel5L2c6KGo55qE5YWs5byP44CCXG4gKiDnpLrkvovvvJpcbiAqICsgd29ya3NoZWV0MuS4reafkOWNleWFg+agvOWAvOS4uiBgPXdvcmtzaGVldDEhQTIrQjJgXG4gKiArIOW3peS9nOihqDPkuK3mn5DljZXlhYPmoLzlgLzkuLogYD3lt6XkvZzooagxIUExK+W3peS9nOihqDJCMWBcbiAqICsgc2hlZXQ15Lit5p+Q5Y2V5YWD5qC85YC85Li6YD1TVU0oc2hlZXQzIUIxOkI1LCBzaGVldDQhQjYpYFxuICpcbiAqIFRPRE8g55uu5YmN5LuF5pSv5oyB4oCc55u45a+55byV55So4oCd55qE5Z2Q5qCH5b2i5byP77yM5L2G5rKh5pyJ5YWs5byP5aGr5YWF55qE5pWI5p6c77ybXG4gKiDnm67liY3kuI3mlK/mjIHigJznu53lr7nlvJXnlKjigJ3lkozigJzmt7flkIjlvJXnlKjigJ3mlrnlvI/jgIJcbiAqXG4gKiDmraTmj5Lku7bpnIDopoHnu5XlvIAgaGFuc29udGFibGUg5LiA5Liq5o+S5Lu25a+55bqU5LiA5Liq5a6e5L6L55qE6K6+6K6h5oCd6Lev77yM6ICM5ZCM5pe2566h55CG5aSa5Liq5a6e5L6L44CCXG4gKiDlrp7kvovnmoTnrqHnkIblt6XkvZzkuqTnu5kgV29ya2Jvb2sg5p2l5YGa77yM5Zug5q2k77yM5q2k5o+S5Lu25LiN5Y+v5L2c5Li654us56uL55qEIGhhbnNvbnRhYmxlIOaPkuS7tlxuICog5L2/55So77yM5Y+q6IO95L6d5omY5LqO6K+l55S15a2Q6KGo5qC86K6+6K6h5Zmo44CCXG4gKlxuICogQHBsdWdpbiBFeHRlcm5hbCBwbHVnaW4gWEZvcm11bGFzLlxuICogQHBhcmFtIGhvdEluc3RhbmNlXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKi9cblxuLy8gVE9ETyDnpoHmraLlhazlvI/lvqrnjq/lvJXnlKggQTE9QjEsIEIxPUExXG5cbmltcG9ydCB7XG4gICAgaXNGb3JtdWxhRXhwcmVzc2lvbixcbiAgICB0b1VwcGVyQ2FzZUZvcm11bGEsXG4gICAgaXNGb3JtdWxhRXhwcmVzc2lvbkVzY2FwZWQsXG4gICAgdW5lc2NhcGVGb3JtdWxhRXhwcmVzc2lvblxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7U2hlZXR9IGZyb20gJy4vU2hlZXQnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4vRGF0YVByb3ZpZGVyJztcbmltcG9ydCB7VW5kb1JlZG9TbmFwc2hvdH0gZnJvbSAnLi9VbmRvUmVkb1NuYXBzaG90JztcblxuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgaXNPYmplY3QgPSBIYW5kc29udGFibGUuaGVscGVyLmlzT2JqZWN0O1xudmFyIG9iamVjdEVhY2ggPSBIYW5kc29udGFibGUuaGVscGVyLm9iamVjdEVhY2g7XG5cbmZ1bmN0aW9uIFhGb3JtdWxhcyhob3RJbnN0YW5jZSkge1xuICAgIEhhbmRzb250YWJsZS5wbHVnaW5zLkJhc2VQbHVnaW4uY2FsbCh0aGlzLCBob3RJbnN0YW5jZSk7XG4gICAgdGhpcy5fc3VwZXJDbGFzcyA9IEhhbmRzb250YWJsZS5wbHVnaW5zLkJhc2VQbHVnaW47XG5cbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG5ldyBIYW5kc29udGFibGUuRXZlbnRNYW5hZ2VyKCk7XG4gICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBuZXcgRGF0YVByb3ZpZGVyKHRoaXMuaG90KTtcbiAgICB0aGlzLnNoZWV0ID0gbmV3IFNoZWV0KHRoaXMuZGF0YVByb3ZpZGVyKTtcbiAgICB0aGlzLnVuZG9SZWRvU25hcHNob3QgPSBuZXcgVW5kb1JlZG9TbmFwc2hvdCh0aGlzLnNoZWV0KTtcblxuICAgIHRoaXMuX3NraXBSZW5kZXJpbmcgPSBmYWxzZTtcbn1cblxuWEZvcm11bGFzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSGFuZHNvbnRhYmxlLnBsdWdpbnMuQmFzZVBsdWdpbi5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogWEZvcm11bGFzXG4gICAgfVxufSk7XG5cblxuWEZvcm11bGFzLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5ob3QuZ2V0U2V0dGluZ3MoKS54Rm9ybXVsYXM7XG59O1xuXG4vKipcbiAqIOaPkuS7tuWIneWni+WMlui/h+eoi+OAglxuICogUFM6IGVuYWJsZVBsdWdpbiDmlrnms5XkvJrlnKggYmVmb3JlSW5pdCBob29rIOS4reinpuWPke+8jFxuICogICAgIOS7heW9kyBpc0VuYWJsZWQg5pa55rOV6L+U5ZueIHRydWUg5pe25omn6KGM44CCXG4gKi9cblhGb3JtdWxhcy5wcm90b3R5cGUuZW5hYmxlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5ob3QuZ2V0U2V0dGluZ3MoKTtcbiAgICBpZiAoIXNldHRpbmdzLl9pc0hvdFRhYmxlQWRhcHRvcikge1xuICAgICAgICB0aHJvdygnWEZvcm11bGFzIOaPkuS7tuWQr+eUqOWksei0pScpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm11bGFzU2V0dGluZ3MgPSBzZXR0aW5ncy5mb3JtdWxhcztcbiAgICBpZiAoaXNPYmplY3QoZm9ybXVsYXNTZXR0aW5ncykpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGZvcm11bGFzU2V0dGluZ3MudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgb2JqZWN0RWFjaChmb3JtdWxhc1NldHRpbmdzLnZhcmlhYmxlcywgKHZhbHVlLCBuYW1lKSA9PiB0aGlzLnNldFZhcmlhYmxlKG5hbWUsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPIG1vdmUgdG8gRGF0YVByb3ZpZGVyXG4gICAgdmFyIHdvcmtzaGVldCA9IHRoaXMuZGF0YVByb3ZpZGVyLndvcmtzaGVldCA9IHRoaXMuaG90LmdldFNldHRpbmdzKCkuX3NoZWV0O1xuICAgIHRoaXMuZGF0YVByb3ZpZGVyLndvcmtib29rID0gd29ya3NoZWV0Lndvcmtib29rO1xuXG4gICAgdGhpcy5hZGRIb29rKCdhZnRlckNyZWF0ZUNvbCcsICguLi5hcmdzKSA9PiB0aGlzLm9uQWZ0ZXJDcmVhdGVDb2woLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnYWZ0ZXJDcmVhdGVSb3cnLCAoLi4uYXJncykgPT4gdGhpcy5vbkFmdGVyQ3JlYXRlUm93KC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2FmdGVyTG9hZERhdGEnLCAoKSA9PiB0aGlzLm9uQWZ0ZXJMb2FkRGF0YSgpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2FmdGVyUmVtb3ZlQ29sJywgKC4uLmFyZ3MpID0+IHRoaXMub25BZnRlclJlbW92ZUNvbCguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdhZnRlclJlbW92ZVJvdycsICguLi5hcmdzKSA9PiB0aGlzLm9uQWZ0ZXJSZW1vdmVSb3coLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnYWZ0ZXJTZXREYXRhQXRDZWxsJywgKC4uLmFyZ3MpID0+IHRoaXMub25BZnRlclNldERhdGFBdENlbGwoLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnYWZ0ZXJTZXREYXRhQXRSb3dQcm9wJywgKC4uLmFyZ3MpID0+IHRoaXMub25BZnRlclNldERhdGFBdENlbGwoLi4uYXJncykpO1xuICAgIC8vdGhpcy5hZGRIb29rKCdiZWZvcmVLZXlEb3duJywgKC4uLmFyZ3MpID0+IHRoaXMub25CZWZvcmVLZXlEb3duKC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZUNyZWF0ZUNvbCcsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlQ3JlYXRlQ29sKC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZUNyZWF0ZVJvdycsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlQ3JlYXRlUm93KC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZVJlbW92ZUNvbCcsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlUmVtb3ZlQ29sKC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZVJlbW92ZVJvdycsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlUmVtb3ZlUm93KC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZVZhbGlkYXRlJywgKC4uLmFyZ3MpID0+IHRoaXMub25CZWZvcmVWYWxpZGF0ZSguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdiZWZvcmVWYWx1ZVJlbmRlcicsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlVmFsdWVSZW5kZXIoLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnbW9kaWZ5RGF0YScsICguLi5hcmdzKSA9PiB0aGlzLm9uTW9kaWZ5RGF0YSguLi5hcmdzKSk7XG5cbiAgICB0aGlzLnNoZWV0LmFkZExvY2FsSG9vaygnYWZ0ZXJSZWNhbGN1bGF0ZScsICguLi5hcmdzKSA9PiB0aGlzLm9uU2hlZXRBZnRlclJlY2FsY3VsYXRlKC4uLmFyZ3MpKTtcblxuICAgIHRoaXMuX3N1cGVyQ2xhc3MucHJvdG90eXBlLmVuYWJsZVBsdWdpbi5jYWxsKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIOemgeeUqOaPkuS7tuOAglxuICogUFM6IOazqOaEj+WwhuaJgOacieWxnuaAp+mHjee9ruS4uum7mOiupOWAvFxuICovXG5YRm9ybXVsYXMucHJvdG90eXBlLmRpc2FibGVQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc3VwZXJDbGFzcy5wcm90b3R5cGUuZGlzYWJsZVBsdWdpbi5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiDph43nva4gSGFuZHNvbnRhYmxlIOeahCBzZXR0aW5ncyDml7bvvIznlKjmnaXph43nva4gWEZvcm11bGFzIOaPkuS7tueahOWxnuaAp+OAglxuICogUFM6IOWcqCBhZnRlclVwZGF0ZVNldHRpbmdzIGhvb2sg5Lit6LCD55So44CCXG4gKi9cblhGb3JtdWxhcy5wcm90b3R5cGUudXBkYXRlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzYWJsZVBsdWdpbigpO1xuICAgIHRoaXMuZW5hYmxlUGx1Z2luKCk7XG4gICAgdGhpcy5fc3VwZXJDbGFzcy5wcm90b3R5cGUudXBkYXRlUGx1Z2luLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIOmUgOavgeaPkuS7tlxuICovXG5YRm9ybXVsYXMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kYXRhUHJvdmlkZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gbnVsbDtcbiAgICB0aGlzLnNoZWV0LmRlc3Ryb3koKTtcbiAgICB0aGlzLnNoZWV0ID0gbnVsbDtcbiAgICB0aGlzLl9zdXBlckNsYXNzLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVtzdGFydF0gSG9va3NcblxuLy8gVE9ETyDlt6XkvZzooajmlLnlkI3ml7bvvIzlhbblroPlt6XkvZzooajlhbPogZTliLDlroPnmoTlhazlvI/lgLzopoHmlLlcblhGb3JtdWxhcy5wcm90b3R5cGUub25TaGVldFJlbmFtZSA9IGZ1bmN0aW9uIChzaGVldCwgbmFtZTEsIG5hbWUyKSB7XG5cblxufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vblNoZWV0QWZ0ZXJSZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChjZWxscykge1xuICAgIGlmICh0aGlzLl9za2lwUmVuZGVyaW5nKSB7XG4gICAgICAgIHRoaXMuX3NraXBSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBob3QgPSB0aGlzLmhvdDtcblxuICAgIGFycmF5RWFjaChjZWxscywgKHtyb3csIGNvbHVtbn0pID0+IHtcbiAgICAgICAgaG90LnZhbGlkYXRlQ2VsbChcbiAgICAgICAgICAgIGhvdC5nZXREYXRhQXRDZWxsKHJvdywgY29sdW1uKSxcbiAgICAgICAgICAgIGhvdC5nZXRDZWxsTWV0YShyb3csIGNvbHVtbiksXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgaG90LnJlbmRlcigpO1xufTtcblxuXG4vKipcbiAqIFRPRE9cbiAqIENhdXRpb24gLSDosIPnlKggZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkg5Y+v5Lul6Zi75q2i6buY6K6k6KGM5Li644CCXG4gKiBAcGFyYW0gZXZlbnRcbiAqL1xuWEZvcm11bGFzLnByb3RvdHlwZS5vbkJlZm9yZUtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbk1vZGlmeURhdGEgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIHZhbHVlSG9sZGVyLCBpb01vZGUpIHtcbiAgICBpZiAoaW9Nb2RlID09PSAnZ2V0JyAmJiB0aGlzLmhhc0NvbXB1dGVkQ2VsbFZhbHVlKHJvdywgY29sdW1uKSkge1xuICAgICAgICB2YWx1ZUhvbGRlci52YWx1ZSA9IHRoaXMuZ2V0Q2VsbFZhbHVlKHJvdywgY29sdW1uKTtcbiAgICB9IGVsc2UgaWYgKGlvTW9kZSA9PT0gJ3NldCcgJiYgaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZUhvbGRlci52YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVIb2xkZXIudmFsdWUgPSB0b1VwcGVyQ2FzZUZvcm11bGEodmFsdWVIb2xkZXIudmFsdWUpO1xuICAgIH1cbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25CZWZvcmVWYWx1ZVJlbmRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uRXNjYXBlZCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB1bmVzY2FwZUZvcm11bGFFeHByZXNzaW9uKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkJlZm9yZVZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCByb3csIHByb3ApIHtcbiAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmhvdC5wcm9wVG9Db2wocHJvcCk7XG5cbiAgICBpZiAodGhpcy5oYXNDb21wdXRlZENlbGxWYWx1ZShyb3csIGNvbHVtbikpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldENlbGxWYWx1ZShyb3csIGNvbHVtbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkFmdGVyU2V0RGF0YUF0Q2VsbCA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAnbG9hZERhdGEnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFQcm92aWRlci5jbGVhckNoYW5nZXMoKTtcbiAgICBhcnJheUVhY2goY2hhbmdlcywgKFtyb3csIGNvbHVtbiwgb2xkVmFsdWUsIG5ld1ZhbHVlXSkgPT4ge1xuICAgICAgICBjb2x1bW4gPSB0aGlzLmhvdC5wcm9wVG9Db2woY29sdW1uKTtcbiAgICAgICAgaWYgKGlzRm9ybXVsYUV4cHJlc3Npb24obmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvVXBwZXJDYXNlRm9ybXVsYShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuY29sbGVjdENoYW5nZXMocm93LCBjb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zaGVldC5hcHBseUNoYW5nZXMocm93LCBjb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25CZWZvcmVDcmVhdGVSb3cgPSBmdW5jdGlvbiAocm93LCBhbW91bnQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09ICdVbmRvUmVkby51bmRvJykge1xuICAgICAgICB0aGlzLnVuZG9SZWRvU25hcHNob3QucmVzdG9yZSgpO1xuICAgIH1cbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25BZnRlckNyZWF0ZVJvdyA9IGZ1bmN0aW9uIChyb3csIGFtb3VudCwgc291cmNlKSB7XG4gICAgdGhpcy5zaGVldC5hbHRlck1hbmFnZXIuaW5zZXJ0Um93KHJvdywgYW1vdW50LCBzb3VyY2UgIT09ICdVbmRvUmVkby51bmRvJyk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQmVmb3JlUmVtb3ZlUm93ID0gZnVuY3Rpb24gKHJvdywgYW1vdW50KSB7XG4gICAgLy8gVE9ETyBTdG9yYWdlLnNhdmUoJ3JvdycsIHJvdywgYW1vdW50KTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25BZnRlclJlbW92ZVJvdyA9IGZ1bmN0aW9uIChyb3csIGFtb3VudCkge1xuICAgIHRoaXMuc2hlZXQuYWx0ZXJNYW5hZ2VyLnJlbW92ZVJvdyhyb3csIGFtb3VudCk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQmVmb3JlQ3JlYXRlQ29sID0gZnVuY3Rpb24gKGNvbHVtbiwgYW1vdW50LCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAnVW5kb1JlZG8udW5kbycpIHtcbiAgICAgICAgdGhpcy51bmRvUmVkb1NuYXBzaG90LnJlc3RvcmUoKTtcbiAgICB9XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQWZ0ZXJDcmVhdGVDb2wgPSBmdW5jdGlvbiAoY29sdW1uLCBhbW91bnQsIHNvdXJjZSkge1xuICAgIHRoaXMuc2hlZXQuYWx0ZXJNYW5hZ2VyLmluc2VydENvbHVtbihjb2x1bW4sIGFtb3VudCwgc291cmNlICE9PSAnVW5kb1JlZG8udW5kbycpO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkJlZm9yZVJlbW92ZUNvbCA9IGZ1bmN0aW9uIChjb2x1bW4sIGFtb3VudCkge1xuICAgIC8vIFRPRE8gU3RvcmFnZS5zYXZlKCdjb2x1bW4nLCBjb2x1bW4sIGFtb3VudCk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQWZ0ZXJSZW1vdmVDb2wgPSBmdW5jdGlvbiAoY29sdW1uLCBhbW91bnQpIHtcbiAgICB0aGlzLnNoZWV0LmFsdGVyTWFuYWdlci5yZW1vdmVDb2x1bW4oY29sdW1uLCBhbW91bnQpO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkFmdGVyTG9hZERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc2tpcFJlbmRlcmluZyA9IHRydWU7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUZ1bGwoKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVtlbmRdIEhvb2tzXG5cblhGb3JtdWxhcy5wcm90b3R5cGUuZ2V0Q2VsbFZhbHVlID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuc2hlZXQuZ2V0Q2VsbEF0KHJvdywgY29sdW1uKTtcbiAgICByZXR1cm4gY2VsbCA/IChjZWxsLmdldEVycm9yKCkgfHwgY2VsbC5nZXRWYWx1ZSgpKSA6IHZvaWQgMDtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUuaGFzQ29tcHV0ZWRDZWxsVmFsdWUgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICByZXR1cm4gISF0aGlzLnNoZWV0LmdldENlbGxBdChyb3csIGNvbHVtbik7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hlZXQucmVjYWxjdWxhdGUoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUucmVjYWxjdWxhdGVGdWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hlZXQucmVjYWxjdWxhdGVGdWxsKCk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLnJlY2FsY3VsYXRlT3B0aW1pemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hlZXQucmVjYWxjdWxhdGVPcHRpbWl6ZWQoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUuc2V0VmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLnNoZWV0LnNldFZhcmlhYmxlKG5hbWUsIHZhbHVlKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUuZ2V0VmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNoZWV0LmdldFZhcmlhYmxlKG5hbWUpO1xufTtcblxuSGFuZHNvbnRhYmxlLnBsdWdpbnMucmVnaXN0ZXJQbHVnaW4oJ3hGb3JtdWxhcycsIFhGb3JtdWxhcyk7XG5cbmV4cG9ydCB7WEZvcm11bGFzfTsiLCJpbXBvcnQge3RvVXBwZXJDYXNlRm9ybXVsYX0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge3RvTGFiZWwsIGV4dHJhY3RMYWJlbH0gZnJvbSAnLi9wYXJzZXIvdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGVycm9yLCBFUlJPUl9SRUZ9IGZyb20gJy4vcGFyc2VyL2Vycm9yJztcbmltcG9ydCBsb2NhbEhvb2tzIGZyb20gJy4uLy4uL3V0aWxzL2xvY2FsSG9va3MnO1xuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgYXJyYXlGaWx0ZXIgPSBIYW5kc29udGFibGUuaGVscGVyLmFycmF5RmlsdGVyO1xudmFyIG1peGluID0gSGFuZHNvbnRhYmxlLmhlbHBlci5taXhpbjtcblxuY29uc3QgQkFSRV9DRUxMX1NUUklDVF9SRUdFWCA9IC9eXFwkP1tBLVpdK1xcJD9cXGQrJC87XG5jb25zdCBCQVJFX0NFTExfUkVHRVggPSAvXFwkP1tBLVpdK1xcJD9cXGQrLztcbmNvbnN0IENFTExfUkVHRVggPSAvKD86W14wLTlBLVokOiBdfF4pXFxzKihcXCQ/W0EtWl0rXFwkP1xcZCspXFxzKig/IVswLTlBLVpfOiBdKS9nO1xuY29uc3QgUkFOR0VfUkVHRVggPSAvXFwkP1tBLVpdK1xcJD9cXGQrXFxzKjpcXHMqXFwkP1tBLVpdK1xcJD9cXGQrL2c7XG5jb25zdCBDRUxMX0FORF9SQU5HRV9SRUdFWCA9IC8oKD86W14wLTlBLVokOiBdfF4pXFxzKihcXCQ/W0EtWl0rXFwkP1xcZCspXFxzKig/IVswLTlBLVpfOiBdKSl8KFxcJD9bQS1aXStcXCQ/XFxkK1xccyo6XFxzKlxcJD9bQS1aXStcXCQ/XFxkKykvZztcblxuXG5jbGFzcyBFeHByZXNzaW9uTW9kaWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb24pIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5b6F5L+u5pS555qE6KGo6L6+5byPXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSAnJztcblxuICAgICAgICB0aGlzLmNlbGxzID0gW107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5zZXRFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0RXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuY2VsbHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gdG9VcHBlckNhc2VGb3JtdWxhKGV4cHJlc3Npb24pO1xuXG4gICAgICAgIHRoaXMuX2V4dHJhY3RDZWxscygpO1xuICAgICAgICB0aGlzLl9leHRyYWN0Q2VsbHNSYW5nZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRyYW5zbGF0ZSh7cm93OiBiYXNlUm93LCBjb2x1bW46IGJhc2VDb2x1bW59LCB7cm93OiBkZWx0YVJvdywgY29sdW1uOiBkZWx0YUNvbHVtbn0pIHtcbiAgICAgICAgYXJyYXlFYWNoKHRoaXMuY2VsbHMsIChjZWxsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGVsdGFSb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIEV4cHJlc3Npb25Nb2RpZmllci5fdHJhbnNsYXRlQ2VsbChjZWxsLCAncm93JywgYmFzZVJvdywgZGVsdGFSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhQ29sdW1uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uTW9kaWZpZXIuX3RyYW5zbGF0ZUNlbGwoY2VsbCwgJ2NvbHVtbicsIGJhc2VDb2x1bW4sIGRlbHRhQ29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uLnJlcGxhY2UoQ0VMTF9BTkRfUkFOR0VfUkVHRVgsIChtYXRjaCwgcDEsIHAyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1NpbmdsZUNlbGwgPSBtYXRjaC5pbmRleE9mKCc6JykgPT09IC0xO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoO1xuICAgICAgICAgICAgbGV0IGNlbGxMYWJlbCA9IG1hdGNoO1xuICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZWRDZWxsTGFiZWwgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoaXNTaW5nbGVDZWxsKSB7XG4gICAgICAgICAgICAgICAgY2VsbExhYmVsID0gQkFSRV9DRUxMX1NUUklDVF9SRUdFWC50ZXN0KHAxKSA/IHAxIDogcDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5fc2VhcmNoQ2VsbChjZWxsTGFiZWwpO1xuXG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRDZWxsTGFiZWwgPSBjZWxsLnJlZkVycm9yID8gZXJyb3IoRVJST1JfUkVGKSA6IGNlbGwudG9MYWJlbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2luZ2xlQ2VsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRjaC5yZXBsYWNlKGNlbGxMYWJlbCwgdHJhbnNsYXRlZENlbGxMYWJlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJhbnNsYXRlZENlbGxMYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZXhwcmVzc2lvbi5zdGFydHNXaXRoKCc9JykpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSAnPScgKyBleHByZXNzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgc3RhdGljIF90cmFuc2xhdGVDZWxsKGNlbGwsIHByb3BlcnR5LCBiYXNlSW5kZXggPSAwLCBkZWx0YSA9IDApIHtcbiAgICAgICAgY29uc3Qge3R5cGUsIHN0YXJ0LCBlbmR9ID0gY2VsbDtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydFtwcm9wZXJ0eV0uaW5kZXg7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IGVuZFtwcm9wZXJ0eV0uaW5kZXg7XG4gICAgICAgIGxldCBkZWx0YVN0YXJ0ID0gZGVsdGE7XG4gICAgICAgIGxldCBkZWx0YUVuZCA9IGRlbHRhO1xuICAgICAgICBsZXQgcmVmRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaW5kZXhPZmZzZXQgPSBNYXRoLmFicyhkZWx0YSkgLSAxO1xuXG4gICAgICAgIC8vIOWinuWKoFxuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBpZiAoYmFzZUluZGV4ID4gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGRlbHRhU3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhc2VJbmRleCA+IGVuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgZGVsdGFFbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyDliKDpmaRcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID49IGJhc2VJbmRleCAmJiBlbmRJbmRleCA8PSBiYXNlSW5kZXggKyBpbmRleE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJlZkVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVmRXJyb3IgJiYgdHlwZSA9PT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VJbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YUVuZCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWZFcnJvciAmJiB0eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VJbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmFzZUluZGV4ID4gZW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFFbmQgPSAwO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRJbmRleCA8PSBiYXNlSW5kZXggKyBpbmRleE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YUVuZCAtPSBNYXRoLm1pbihlbmRJbmRleCAtIChiYXNlSW5kZXggKyBpbmRleE9mZnNldCksIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWx0YVN0YXJ0ICYmICFyZWZFcnJvcikge1xuICAgICAgICAgICAgc3RhcnRbcHJvcGVydHldLmluZGV4ID0gTWF0aC5tYXgoc3RhcnRJbmRleCArIGRlbHRhU3RhcnQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YUVuZCAmJiAhcmVmRXJyb3IpIHtcbiAgICAgICAgICAgIGVuZFtwcm9wZXJ0eV0uaW5kZXggPSBNYXRoLm1heChlbmRJbmRleCArIGRlbHRhRW5kLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmRXJyb3IpIHtcbiAgICAgICAgICAgIGNlbGwucmVmRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2V4dHJhY3RDZWxscygpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuZXhwcmVzc2lvbi5tYXRjaChDRUxMX1JFR0VYKTtcblxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhcnJheUVhY2gobWF0Y2hlcywgKGNvb3JkKSA9PiB7XG4gICAgICAgICAgICBjb29yZCA9IGNvb3JkLm1hdGNoKEJBUkVfQ0VMTF9SRUdFWCk7XG5cbiAgICAgICAgICAgIGlmICghY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbcm93LCBjb2x1bW5dID0gZXh0cmFjdExhYmVsKGNvb3JkWzBdKTtcblxuICAgICAgICAgICAgdGhpcy5jZWxscy5wdXNoKHRoaXMuX2NyZWF0ZUNlbGwoe3JvdywgY29sdW1ufSwge3JvdywgY29sdW1ufSwgY29vcmRbMF0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2V4dHJhY3RDZWxsc1JhbmdlKCkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKFJBTkdFX1JFR0VYKTtcblxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhcnJheUVhY2gobWF0Y2hlcywgKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBtYXRjaC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgY29uc3QgW3N0YXJ0Um93LCBzdGFydENvbHVtbl0gPSBleHRyYWN0TGFiZWwoc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgW2VuZFJvdywgZW5kQ29sdW1uXSA9IGV4dHJhY3RMYWJlbChlbmQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0ge1xuICAgICAgICAgICAgICAgIHJvdzogc3RhcnRSb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydENvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGVuZENlbGwgPSB7XG4gICAgICAgICAgICAgICAgcm93OiBlbmRSb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuY2VsbHMucHVzaCh0aGlzLl9jcmVhdGVDZWxsKHN0YXJ0Q2VsbCwgZW5kQ2VsbCwgbWF0Y2gpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBfc2VhcmNoQ2VsbChsYWJlbCkge1xuICAgICAgICBjb25zdCBbY2VsbF0gPSBhcnJheUZpbHRlcih0aGlzLmNlbGxzLCAoY2VsbCkgPT4gY2VsbC5vcmlnTGFiZWwgPT09IGxhYmVsKTtcblxuICAgICAgICByZXR1cm4gY2VsbCB8fCBudWxsO1xuICAgIH1cblxuICAgIF9jcmVhdGVDZWxsKHN0YXJ0LCBlbmQsIGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIG9yaWdMYWJlbDogbGFiZWwsXG4gICAgICAgICAgICB0eXBlOiBsYWJlbC5pbmRleE9mKCc6JykgPT09IC0xID8gJ2NlbGwnIDogJ3JhbmdlJyxcbiAgICAgICAgICAgIHJlZkVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIHRvTGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSB0b0xhYmVsKHRoaXMuc3RhcnQucm93LCB0aGlzLnN0YXJ0LmNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsICs9ICc6JyArIHRvTGFiZWwodGhpcy5lbmQucm93LCB0aGlzLmVuZC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbm1peGluKEV4cHJlc3Npb25Nb2RpZmllciwgbG9jYWxIb29rcyk7XG5cbmV4cG9ydCB7RXhwcmVzc2lvbk1vZGlmaWVyfTsiLCJleHBvcnQgY29uc3QgRVJST1IgPSAnRVJST1InO1xuZXhwb3J0IGNvbnN0IEVSUk9SX0RJVl9aRVJPID0gJ0RJVi8wJztcbmV4cG9ydCBjb25zdCBFUlJPUl9OQU1FID0gJ05BTUUnO1xuZXhwb3J0IGNvbnN0IEVSUk9SX05FRURfVVBEQVRFID0gJ05FRURfVVBEQVRFJztcbmV4cG9ydCBjb25zdCBFUlJPUl9OT1RfQVZBSUxBQkxFID0gJ04vQSc7XG5leHBvcnQgY29uc3QgRVJST1JfTlVMTCA9ICdOVUxMJztcbmV4cG9ydCBjb25zdCBFUlJPUl9OVU0gPSAnTlVNJztcbmV4cG9ydCBjb25zdCBFUlJPUl9SRUYgPSAnUkVGJztcbmV4cG9ydCBjb25zdCBFUlJPUl9WQUxVRSA9ICdWQUxVRSc7XG5cbmNvbnN0IGVycm9ycyA9IHtcbiAgW0VSUk9SXTogJyNFUlJPUiEnLFxuICBbRVJST1JfRElWX1pFUk9dOiAnI0RJVi8wIScsXG4gIFtFUlJPUl9OQU1FXTogJyNOQU1FPycsXG4gIFtFUlJPUl9ORUVEX1VQREFURV06ICcjTkVFRF9VUERBVEUhJyxcbiAgW0VSUk9SX05PVF9BVkFJTEFCTEVdOiAnI04vQScsXG4gIFtFUlJPUl9OVUxMXTogJyNOVUxMIScsXG4gIFtFUlJPUl9OVU1dOiAnI05VTSEnLFxuICBbRVJST1JfUkVGXTogJyNSRUYhJyxcbiAgW0VSUk9SX1ZBTFVFXTogJyNWQUxVRSEnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG4gIGxldCBlcnJvcjtcbiAgdHlwZSA9ICh0eXBlICsgJycpLnJlcGxhY2UoLyN8IXxcXD8vZywgJycpO1xuXG4gIGlmIChlcnJvcnNbdHlwZV0pIHtcbiAgICBlcnJvciA9IGVycm9yc1t0eXBlXTtcbiAgfVxuICByZXR1cm4gZXJyb3IgPyBlcnJvciA6IG51bGw7XG59XG4iLCIvKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNC4xNyAqL1xuLypcbiAgUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5cbiAgUGFyc2VyOiB7XG4gICAgeXk6IHt9XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlOiB7XG4gICAgeXk6IHt9LFxuICAgIHRyYWNlOiBmdW5jdGlvbigpLFxuICAgIHN5bWJvbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gbnVtYmVyfSxcbiAgICB0ZXJtaW5hbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbnVtYmVyID09PiBuYW1lfSxcbiAgICBwcm9kdWN0aW9uc186IFsuLi5dLFxuICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlLCAkJCwgXyQpLFxuICAgIHRhYmxlOiBbLi4uXSxcbiAgICBkZWZhdWx0QWN0aW9uczogey4uLn0sXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQpLFxuXG4gICAgbGV4ZXI6IHtcbiAgICAgICAgRU9GOiAxLFxuICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24oaW5wdXQpLFxuICAgICAgICBpbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgdW5wdXQ6IGZ1bmN0aW9uKHN0ciksXG4gICAgICAgIG1vcmU6IGZ1bmN0aW9uKCksXG4gICAgICAgIGxlc3M6IGZ1bmN0aW9uKG4pLFxuICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAgICAgICAgdGVzdF9tYXRjaDogZnVuY3Rpb24ocmVnZXhfbWF0Y2hfYXJyYXksIHJ1bGVfaW5kZXgpLFxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpLFxuICAgICAgICBsZXg6IGZ1bmN0aW9uKCksXG4gICAgICAgIGJlZ2luOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24oY29uZGl0aW9uKSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICByYW5nZXM6IGJvb2xlYW4gICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIpXG4gICAgICAgICAgICBmbGV4OiBib29sZWFuICAgICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWQgZXhoYXVzdGl2ZWx5IHRvIGZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gpXG4gICAgICAgICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW4gIChvcHRpb25hbDogdHJ1ZSA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgZWFjaCBtYXRjaGluZyByZWdleCB0aGUgYWN0aW9uIGNvZGUgaXMgaW52b2tlZDsgdGhlIGxleGVyIHRlcm1pbmF0ZXMgdGhlIHNjYW4gd2hlbiBhIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24gY29kZSlcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbih5eSwgeXlfLCAkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLCBZWV9TVEFSVCksXG4gICAgICAgIHJ1bGVzOiBbLi4uXSxcbiAgICAgICAgY29uZGl0aW9uczoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IHNldH0sXG4gICAgfVxuICB9XG5cblxuICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7XG4gICAgZmlyc3RfbGluZTogbixcbiAgICBsYXN0X2xpbmU6IG4sXG4gICAgZmlyc3RfY29sdW1uOiBuLFxuICAgIGxhc3RfY29sdW1uOiBuLFxuICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXSAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCByZWd1bGFyIHplcm8tYmFzZWQpXG4gIH1cblxuXG4gIHRoZSBwYXJzZUVycm9yIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGFuZCBwYXJzZXIgZXJyb3JzOiB7XG4gICAgdGV4dDogICAgICAgIChtYXRjaGVkIHRleHQpXG4gICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAgICBsaW5lOiAgICAgICAgKHl5bGluZW5vKVxuICB9XG4gIHdoaWxlIHBhcnNlciAoZ3JhbW1hcikgZXJyb3JzIHdpbGwgYWxzbyBwcm92aWRlIHRoZXNlIG1lbWJlcnMsIGkuZS4gcGFyc2VyIGVycm9ycyBkZWxpdmVyIGEgc3VwZXJzZXQgb2YgYXR0cmlidXRlczoge1xuICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICAgIGV4cGVjdGVkOiAgICAoc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnMpXG4gICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBoYXMgYSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICB9XG4qL1xudmFyIGdyYW1tYXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSw1XSwkVjE9WzEsOF0sJFYyPVsxLDZdLCRWMz1bMSw3XSwkVjQ9WzEsOV0sJFY1PVsxLDE1XSwkVjY9WzEsMTZdLCRWNz1bMSwxN10sJFY4PVsxLDE4XSwkVjk9WzEsMTNdLCRWYT1bMSwxNF0sJFZiPVsxLDE5XSwkVmM9WzEsMjFdLCRWZD1bMSwyMl0sJFZlPVsxLDIzXSwkVmY9WzEsMjRdLCRWZz1bMSwyNV0sJFZoPVsxLDI2XSwkVmk9WzEsMjddLCRWaj1bMSwyOF0sJFZrPVsxLDI5XSwkVmw9WzEsMzBdLCRWbT1bNSw5LDEwLDExLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDMyLDMzXSwkVm49WzUsOSwxMCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwzMiwzMywzNV0sJFZvPVsxLDM5XSwkVnA9WzUsOSwxMCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwzMiwzMywzN10sJFZxPVs1LDEwLDExLDEzLDE0LDE1LDE2LDE3LDMyLDMzXSwkVnI9WzUsMTAsMTMsMTQsMTUsMTYsMzIsMzNdLCRWcz1bNSwxMCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwzMiwzM10sJFZ0PVsxMywzMiwzM10sJFZ1PVs1LDksMTAsMTEsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMzIsMzMsMzQsMzhdO1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiZXJyb3JcIjoyLFwiZXhwcmVzc2lvbnNcIjozLFwiZXhwcmVzc2lvblwiOjQsXCJFT0ZcIjo1LFwidmFyaWFibGVTZXF1ZW5jZVwiOjYsXCJudW1iZXJcIjo3LFwiU1RSSU5HXCI6OCxcIiZcIjo5LFwiPVwiOjEwLFwiK1wiOjExLFwiKFwiOjEyLFwiKVwiOjEzLFwiPFwiOjE0LFwiPlwiOjE1LFwiTk9UXCI6MTYsXCItXCI6MTcsXCIqXCI6MTgsXCIvXCI6MTksXCJeXCI6MjAsXCJGVU5DVElPTlwiOjIxLFwiZXhwc2VxXCI6MjIsXCJzaGVldFwiOjIzLFwiY2VsbFwiOjI0LFwiU0hFRVRfTkFNRVwiOjI1LFwiIVwiOjI2LFwiQUJTT0xVVEVfQ0VMTFwiOjI3LFwiUkVMQVRJVkVfQ0VMTFwiOjI4LFwiTUlYRURfQ0VMTFwiOjI5LFwiOlwiOjMwLFwiQVJSQVlcIjozMSxcIjtcIjozMixcIixcIjozMyxcIlZBUklBQkxFXCI6MzQsXCJERUNJTUFMXCI6MzUsXCJOVU1CRVJcIjozNixcIiVcIjozNyxcIiNcIjozOCxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezU6XCJFT0ZcIiw4OlwiU1RSSU5HXCIsOTpcIiZcIiwxMDpcIj1cIiwxMTpcIitcIiwxMjpcIihcIiwxMzpcIilcIiwxNDpcIjxcIiwxNTpcIj5cIiwxNjpcIk5PVFwiLDE3OlwiLVwiLDE4OlwiKlwiLDE5OlwiL1wiLDIwOlwiXlwiLDIxOlwiRlVOQ1RJT05cIiwyNTpcIlNIRUVUX05BTUVcIiwyNjpcIiFcIiwyNzpcIkFCU09MVVRFX0NFTExcIiwyODpcIlJFTEFUSVZFX0NFTExcIiwyOTpcIk1JWEVEX0NFTExcIiwzMDpcIjpcIiwzMTpcIkFSUkFZXCIsMzI6XCI7XCIsMzM6XCIsXCIsMzQ6XCJWQVJJQUJMRVwiLDM1OlwiREVDSU1BTFwiLDM2OlwiTlVNQkVSXCIsMzc6XCIlXCIsMzg6XCIjXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywyXSxbNCwxXSxbNCwxXSxbNCwxXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCw0XSxbNCw0XSxbNCw0XSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwyXSxbNCwyXSxbNCwzXSxbNCw0XSxbNCwxXSxbNCwxXSxbNCwxXSxbNCwyXSxbMjMsM10sWzIzLDNdLFsyMywzXSxbMjMsNV0sWzIzLDVdLFsyMyw1XSxbMjMsNV0sWzIzLDVdLFsyMyw1XSxbMjMsNV0sWzIzLDVdLFsyMyw1XSxbMjQsMV0sWzI0LDFdLFsyNCwxXSxbMjQsM10sWzI0LDNdLFsyNCwzXSxbMjQsM10sWzI0LDNdLFsyNCwzXSxbMjQsM10sWzI0LDNdLFsyNCwzXSxbMjIsMV0sWzIyLDFdLFsyMiwzXSxbMjIsM10sWzYsMV0sWzYsM10sWzcsMV0sWzcsM10sWzcsMl0sWzIsM10sWzIsNF1dLFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCAkJCAvKiB2c3RhY2sgKi8sIF8kIC8qIGxzdGFjayAqLykge1xuLyogdGhpcyA9PSB5eXZhbCAqL1xuXG52YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDE6XG5cbiAgICAgICAgcmV0dXJuICQkWyQwLTFdO1xuICAgIFxuYnJlYWs7XG5jYXNlIDI6XG5cbiAgICAgICAgdGhpcy4kID0geXkuY2FsbFZhcmlhYmxlKCQkWyQwXVswXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAzOlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LnRvTnVtYmVyKCQkWyQwXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSA0OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LnRyaW1FZGdlcygkJFskMF0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgNTpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJyYnLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgNjpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJz0nLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgNzpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJysnLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgODpcblxuICAgICAgICB0aGlzLiQgPSB5eS50b051bWJlcigkJFskMC0xXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSA5OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignPD0nLCBbJCRbJDAtM10sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTA6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCc+PScsIFskJFskMC0zXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAxMTpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJzw+JywgWyQkWyQwLTNdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDEyOlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignTk9UJywgWyQkWyQwLTJdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDEzOlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignPicsIFskJFskMC0yXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAxNDpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJzwnLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTU6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCctJywgWyQkWyQwLTJdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDE2OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignKicsIFskJFskMC0yXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAxNzpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJy8nLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTg6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCdeJywgWyQkWyQwLTJdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDE5OlxuXG4gICAgICAgIHZhciBuMSA9IHl5LmludmVydE51bWJlcigkJFskMF0pO1xuICAgICAgICB0aGlzLiQgPSBuMTtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuJCkpIHtcbiAgICAgICAgICAgIHRoaXMuJCA9IDA7XG4gICAgICAgIH1cbiAgICAgIFxuYnJlYWs7XG5jYXNlIDIwOlxuXG4gICAgICAgIHZhciBuMSA9IHl5LnRvTnVtYmVyKCQkWyQwXSk7XG4gICAgICAgIHRoaXMuJCA9IG4xO1xuICAgICAgICBpZiAoaXNOYU4odGhpcy4kKSkge1xuICAgICAgICAgICAgdGhpcy4kID0gMDtcbiAgICAgICAgfVxuICAgICAgXG5icmVhaztcbmNhc2UgMjE6XG5cbiAgICAgICAgdGhpcy4kID0geXkuY2FsbEZ1bmN0aW9uKCQkWyQwLTJdKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDIyOlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmNhbGxGdW5jdGlvbigkJFskMC0zXSwgJCRbJDAtMV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMjc6IGNhc2UgMjg6IGNhc2UgMjk6XG5cbiAgICAgIHRoaXMuJCA9IHl5LmNlbGxWYWx1ZUluU2hlZXQoJCRbJDAtMl0sICQkWyQwXSk7XG4gICAgXG5icmVhaztcbmNhc2UgMzA6IGNhc2UgMzE6IGNhc2UgMzI6IGNhc2UgMzM6IGNhc2UgMzQ6IGNhc2UgMzU6IGNhc2UgMzY6IGNhc2UgMzc6IGNhc2UgMzg6XG5cbiAgICAgIHRoaXMuJCA9IHl5LnJhbmdlVmFsdWVJblNoZWV0KCQkWyQwLTRdLCAkJFskMC0yXSwgJCRbJDBdKTtcbiAgICBcbmJyZWFrO1xuY2FzZSAzOTogY2FzZSA0MDogY2FzZSA0MTpcblxuICAgICAgdGhpcy4kID0geXkuY2VsbFZhbHVlKCQkWyQwXSk7XG4gICAgXG5icmVhaztcbmNhc2UgNDI6IGNhc2UgNDM6IGNhc2UgNDQ6IGNhc2UgNDU6IGNhc2UgNDY6IGNhc2UgNDc6IGNhc2UgNDg6IGNhc2UgNDk6IGNhc2UgNTA6XG5cbiAgICAgIHRoaXMuJCA9IHl5LnJhbmdlVmFsdWUoJCRbJDAtMl0sICQkWyQwXSk7XG4gICAgXG5icmVhaztcbmNhc2UgNTE6IGNhc2UgNTU6XG5cbiAgICAgIHRoaXMuJCA9IFskJFskMF1dO1xuICAgIFxuYnJlYWs7XG5jYXNlIDUyOlxuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgYXJyID0gZXZhbChcIltcIiArIHl5dGV4dCArIFwiXVwiKTtcblxuICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiQgPSByZXN1bHQ7XG4gICAgXG5icmVhaztcbmNhc2UgNTM6IGNhc2UgNTQ6XG5cbiAgICAgICQkWyQwLTJdLnB1c2goJCRbJDBdKTtcbiAgICAgIHRoaXMuJCA9ICQkWyQwLTJdO1xuICAgIFxuYnJlYWs7XG5jYXNlIDU2OlxuXG4gICAgICB0aGlzLiQgPSAoQXJyYXkuaXNBcnJheSgkJFskMC0yXSkgPyAkJFskMC0yXSA6IFskJFskMC0yXV0pO1xuICAgICAgdGhpcy4kLnB1c2goJCRbJDBdKTtcbiAgICBcbmJyZWFrO1xuY2FzZSA1NzpcblxuICAgICAgdGhpcy4kID0gJCRbJDBdO1xuICAgIFxuYnJlYWs7XG5jYXNlIDU4OlxuXG4gICAgICB0aGlzLiQgPSAoJCRbJDAtMl0gKyAnLicgKyAkJFskMF0pICogMTtcbiAgICBcbmJyZWFrO1xuY2FzZSA1OTpcblxuICAgICAgdGhpcy4kID0gJCRbJDAtMV0gKiAwLjAxO1xuICAgIFxuYnJlYWs7XG5jYXNlIDYwOiBjYXNlIDYxOlxuXG4gICAgICB0aGlzLiQgPSB5eS50aHJvd0Vycm9yKCQkWyQwLTJdICsgJCRbJDAtMV0gKyAkJFskMF0pO1xuICAgIFxuYnJlYWs7XG59XG59LFxudGFibGU6IFt7MjoxMiwzOjEsNDoyLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezE6WzNdfSx7NTpbMSwyMF0sOTokVmMsMTA6JFZkLDExOiRWZSwxNDokVmYsMTU6JFZnLDE2OiRWaCwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9LG8oJFZtLFsyLDJdLHszNTpbMSwzMV19KSxvKCRWbSxbMiwzXSx7Mzc6WzEsMzJdfSksbygkVm0sWzIsNF0pLHsyOjEyLDQ6MzMsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjM0LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDozNSw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsxMjpbMSwzNl19LG8oJFZtLFsyLDIzXSksbygkVm0sWzIsMjRdKSxvKCRWbSxbMiwyNV0sezI6MzcsMzQ6WzEsMzhdLDM4OiRWYn0pLG8oJFZuLFsyLDU1XSx7Mzg6JFZvfSksbygkVnAsWzIsNTddLHszNTpbMSw0MF19KSx7MjY6WzEsNDFdfSxvKCRWbSxbMiwzOV0sezMwOlsxLDQyXX0pLG8oJFZtLFsyLDQwXSx7MzA6WzEsNDNdfSksbygkVm0sWzIsNDFdLHszMDpbMSw0NF19KSx7MzQ6WzEsNDVdfSx7MTpbMiwxXX0sezI6MTIsNDo0Niw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6NDcsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjQ4LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo1MSw2OjMsNzo0LDg6JFYwLDEwOlsxLDQ5XSwxMTokVjEsMTI6JFYyLDE1OlsxLDUwXSwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo1Myw2OjMsNzo0LDg6JFYwLDEwOlsxLDUyXSwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjU0LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo1NSw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6NTYsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjU3LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo1OCw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHszNDpbMSw1OV19LG8oJFZwLFsyLDU5XSksezk6JFZjLDEwOiRWZCwxMTokVmUsMTM6WzEsNjBdLDE0OiRWZiwxNTokVmcsMTY6JFZoLDE3OiRWaSwxODokVmosMTk6JFZrLDIwOiRWbH0sbygkVnEsWzIsMTldLHs5OiRWYywxODokVmosMTk6JFZrLDIwOiRWbH0pLG8oJFZxLFsyLDIwXSx7OTokVmMsMTg6JFZqLDE5OiRWaywyMDokVmx9KSx7MjoxMiw0OjYzLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxMzpbMSw2MV0sMTc6JFYzLDIxOiRWNCwyMjo2MiwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzE6WzEsNjRdLDM0OiRWOSwzNjokVmEsMzg6JFZifSxvKCRWbSxbMiwyNl0pLHszODokVm99LHszNDpbMSw2NV19LHszNjpbMSw2Nl19LHsyNzpbMSw2N10sMjg6WzEsNjhdLDI5OlsxLDY5XX0sezI3OlsxLDcwXSwyODpbMSw3MV0sMjk6WzEsNzJdfSx7Mjc6WzEsNzNdLDI4OlsxLDc0XSwyOTpbMSw3NV19LHsyNzpbMSw3Nl0sMjg6WzEsNzddLDI5OlsxLDc4XX0sezI2OlsxLDc5XX0sbygkVm0sWzIsNV0pLG8oWzUsMTAsMTMsMzIsMzNdLFsyLDZdLHs5OiRWYywxMTokVmUsMTQ6JFZmLDE1OiRWZywxNjokVmgsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnEsWzIsN10sezk6JFZjLDE4OiRWaiwxOTokVmssMjA6JFZsfSksezI6MTIsNDo4MCw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6ODEsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSxvKCRWcixbMiwxNF0sezk6JFZjLDExOiRWZSwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSx7MjoxMiw0OjgyLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sbygkVnIsWzIsMTNdLHs5OiRWYywxMTokVmUsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbyhbNSwxMCwxMywxNiwzMiwzM10sWzIsMTJdLHs5OiRWYywxMTokVmUsMTQ6JFZmLDE1OiRWZywxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWcSxbMiwxNV0sezk6JFZjLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnMsWzIsMTZdLHs5OiRWYywyMDokVmx9KSxvKCRWcyxbMiwxN10sezk6JFZjLDIwOiRWbH0pLG8oWzUsMTAsMTEsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMzIsMzNdLFsyLDE4XSx7OTokVmN9KSxvKCRWbixbMiw1Nl0pLG8oJFZtLFsyLDhdKSxvKCRWbSxbMiwyMV0pLHsxMzpbMSw4M10sMzI6WzEsODRdLDMzOlsxLDg1XX0sbygkVnQsWzIsNTFdLHs5OiRWYywxMDokVmQsMTE6JFZlLDE0OiRWZiwxNTokVmcsMTY6JFZoLDE3OiRWaSwxODokVmosMTk6JFZrLDIwOiRWbH0pLG8oJFZ0LFsyLDUyXSksezI2OlsxLDg2XX0sbygkVnAsWzIsNThdKSxvKCRWbSxbMiwyN10sezMwOlsxLDg3XX0pLG8oJFZtLFsyLDI4XSx7MzA6WzEsODhdfSksbygkVm0sWzIsMjldLHszMDpbMSw4OV19KSxvKCRWbSxbMiw0Ml0pLG8oJFZtLFsyLDQzXSksbygkVm0sWzIsNDRdKSxvKCRWbSxbMiw0NV0pLG8oJFZtLFsyLDQ2XSksbygkVm0sWzIsNDddKSxvKCRWbSxbMiw0OF0pLG8oJFZtLFsyLDQ5XSksbygkVm0sWzIsNTBdKSxvKCRWdSxbMiw2MF0pLG8oJFZyLFsyLDldLHs5OiRWYywxMTokVmUsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnIsWzIsMTFdLHs5OiRWYywxMTokVmUsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnIsWzIsMTBdLHs5OiRWYywxMTokVmUsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVm0sWzIsMjJdKSx7MjoxMiw0OjkwLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo5MSw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LG8oJFZ1LFsyLDYxXSksezI3OlsxLDkyXSwyODpbMSw5M10sMjk6WzEsOTRdfSx7Mjc6WzEsOTVdLDI4OlsxLDk2XSwyOTpbMSw5N119LHsyNzpbMSw5OF0sMjg6WzEsOTldLDI5OlsxLDEwMF19LG8oJFZ0LFsyLDUzXSx7OTokVmMsMTA6JFZkLDExOiRWZSwxNDokVmYsMTU6JFZnLDE2OiRWaCwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWdCxbMiw1NF0sezk6JFZjLDEwOiRWZCwxMTokVmUsMTQ6JFZmLDE1OiRWZywxNjokVmgsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVm0sWzIsMzBdKSxvKCRWbSxbMiwzMV0pLG8oJFZtLFsyLDMyXSksbygkVm0sWzIsMzNdKSxvKCRWbSxbMiwzNF0pLG8oJFZtLFsyLDM1XSksbygkVm0sWzIsMzZdKSxvKCRWbSxbMiwzN10pLG8oJFZtLFsyLDM4XSldLFxuZGVmYXVsdEFjdGlvbnM6IHsyMDpbMiwxXX0sXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jdGlvbiBfcGFyc2VFcnJvciAobXNnLCBoYXNoKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB9XG4gICAgICAgIF9wYXJzZUVycm9yLnByb3RvdHlwZSA9IEVycm9yO1xuXG4gICAgICAgIHRocm93IG5ldyBfcGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHN0YWNrID0gWzBdLFxuICAgICAgICB0c3RhY2sgPSBbXSwgLy8gdG9rZW4gc3RhY2tcbiAgICAgICAgdnN0YWNrID0gW251bGxdLCAvLyBzZW1hbnRpYyB2YWx1ZSBzdGFja1xuICAgICAgICBsc3RhY2sgPSBbXSwgLy8gbG9jYXRpb24gc3RhY2tcbiAgICAgICAgdGFibGUgPSB0aGlzLnRhYmxlLFxuICAgICAgICB5eXRleHQgPSAnJyxcbiAgICAgICAgeXlsaW5lbm8gPSAwLFxuICAgICAgICB5eWxlbmcgPSAwLFxuICAgICAgICByZWNvdmVyaW5nID0gMCxcbiAgICAgICAgVEVSUk9SID0gMixcbiAgICAgICAgRU9GID0gMTtcblxuICAgIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIC8vdGhpcy5yZWR1Y3Rpb25Db3VudCA9IHRoaXMuc2hpZnRDb3VudCA9IDA7XG5cbiAgICB2YXIgbGV4ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIHZhciBzaGFyZWRTdGF0ZSA9IHsgeXk6IHt9IH07XG4gICAgLy8gY29weSBzdGF0ZVxuICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnl5LCBrKSkge1xuICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV4ZXIueXlsbG9jID0ge307XG4gICAgfVxuICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG5cbiAgICB2YXIgcmFuZ2VzID0gbGV4ZXIub3B0aW9ucyAmJiBsZXhlci5vcHRpb25zLnJhbmdlcztcblxuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZUVycm9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvcFN0YWNrIChuKSB7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIgKiBuO1xuICAgICAgICB2c3RhY2subGVuZ3RoID0gdnN0YWNrLmxlbmd0aCAtIG47XG4gICAgICAgIGxzdGFjay5sZW5ndGggPSBsc3RhY2subGVuZ3RoIC0gbjtcbiAgICB9XG5cbl90b2tlbl9zdGFjazpcbiAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHRva2VuID0gbGV4ZXIubGV4KCkgfHwgRU9GO1xuICAgICAgICAvLyBpZiB0b2tlbiBpc24ndCBpdHMgbnVtZXJpYyB2YWx1ZSwgY29udmVydFxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbCwgcHJlRXJyb3JTeW1ib2wsIHN0YXRlLCBhY3Rpb24sIGEsIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIHJldHJlaXZlIHN0YXRlIG51bWJlciBmcm9tIHRvcCBvZiBzdGFja1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIC8vIHVzZSBkZWZhdWx0IGFjdGlvbnMgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlYWQgYWN0aW9uIGZvciBjdXJyZW50IHN0YXRlIGFuZCBmaXJzdCBpbnB1dFxuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuICAgICAgICB9XG5cbl9oYW5kbGVfZXJyb3I6XG4gICAgICAgIC8vIGhhbmRsZSBwYXJzZSBlcnJvclxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgdmFyIGVycm9yX3J1bGVfZGVwdGg7XG4gICAgICAgICAgICB2YXIgZXJyU3RyID0gJyc7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgcnVsZSBzdGFjayBkZXB0aCB3aGVyZSB0aGUgbmVhcmVzdCBlcnJvciBydWxlIGNhbiBiZSBmb3VuZC5cbiAgICAgICAgICAgIC8vIFJldHVybiBGQUxTRSB3aGVuIG5vIGVycm9yIHJlY292ZXJ5IHJ1bGUgd2FzIGZvdW5kLlxuICAgICAgICAgICAgZnVuY3Rpb24gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrX3Byb2JlID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgZGVwdGggPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHJlY292ZXIgZnJvbSBlcnJvclxuICAgICAgICAgICAgICAgIGZvcig7Oykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3IgcmVjb3ZlcnkgcnVsZSBpbiB0aGlzIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmICgoVEVSUk9SLnRvU3RyaW5nKCkpIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCB8fCBzdGFja19wcm9iZSA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gc3VpdGFibGUgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhY2tfcHJvYmUgLT0gMjsgLy8gcG9wU3RhY2soMSk6IFtzeW1ib2wsIGFjdGlvbl1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFja19wcm9iZV07XG4gICAgICAgICAgICAgICAgICAgICsrZGVwdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBzZWUgaWYgdGhlcmUncyBhbnkgY2hhbmNlIGF0IGhpdHRpbmcgYW4gZXJyb3IgcmVjb3ZlcnkgcnVsZTpcbiAgICAgICAgICAgICAgICBlcnJvcl9ydWxlX2RlcHRoID0gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBlcnJvclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiBURVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goXCInXCIrdGhpcy50ZXJtaW5hbHNfW3BdK1wiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcrKHl5bGluZW5vKzEpK1wiOlxcblwiK2xleGVyLnNob3dQb3NpdGlvbigpK1wiXFxuRXhwZWN0aW5nIFwiK2V4cGVjdGVkLmpvaW4oJywgJykgKyBcIiwgZ290ICdcIiArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpKyBcIidcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnKyh5eWxpbmVubysxKStcIjogVW5leHBlY3RlZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN5bWJvbCA9PSBFT0YgPyBcImVuZCBvZiBpbnB1dFwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCInXCIrKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkrXCInXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgICAgIGxvYzogeXlsb2MsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmFibGU6IChlcnJvcl9ydWxlX2RlcHRoICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlRXJyb3JTeW1ib2wgIT09IEVPRikge1xuICAgICAgICAgICAgICAgIGVycm9yX3J1bGVfZGVwdGggPSBsb2NhdGVOZWFyZXN0RXJyb3JSZWNvdmVyeVJ1bGUoc3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBqdXN0IHJlY292ZXJlZCBmcm9tIGFub3RoZXIgZXJyb3JcbiAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sID09PSBFT0YgfHwgcHJlRXJyb3JTeW1ib2wgPT09IEVPRikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyIHx8ICdQYXJzaW5nIGhhbHRlZCB3aGlsZSBzdGFydGluZyB0byByZWNvdmVyIGZyb20gYW5vdGhlciBlcnJvci4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIGN1cnJlbnQgbG9va2FoZWFkIGFuZCBncmFiIGFub3RoZXJcbiAgICAgICAgICAgICAgICB5eWxlbmcgPSBsZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIueXlsaW5lbm87XG4gICAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyeSB0byByZWNvdmVyIGZyb20gZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnJvcl9ydWxlX2RlcHRoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJTdHIgfHwgJ1BhcnNpbmcgaGFsdGVkLiBObyBzdWl0YWJsZSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcFN0YWNrKGVycm9yX3J1bGVfZGVwdGgpO1xuXG4gICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IChzeW1ib2wgPT0gVEVSUk9SID8gbnVsbCA6IHN5bWJvbCk7IC8vIHNhdmUgdGhlIGxvb2thaGVhZCB0b2tlblxuICAgICAgICAgICAgc3ltYm9sID0gVEVSUk9SOyAgICAgICAgIC8vIGluc2VydCBnZW5lcmljIGVycm9yIHN5bWJvbCBhcyBuZXcgbG9va2FoZWFkXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXTtcbiAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bVEVSUk9SXTtcbiAgICAgICAgICAgIHJlY292ZXJpbmcgPSAzOyAvLyBhbGxvdyAzIHJlYWwgc3ltYm9scyB0byBiZSBzaGlmdGVkIGJlZm9yZSByZXBvcnRpbmcgYSBuZXcgZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgdW5sZXNzIHJlc29sdmUgZGVmYXVsdHMgYXJlIG9mZlxuICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcrc3RhdGUrJywgdG9rZW46ICcrc3ltYm9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIHNoaWZ0XG4gICAgICAgICAgICAgICAgLy90aGlzLnNoaWZ0Q291bnQrKztcblxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sucHVzaChsZXhlci55eXRleHQpO1xuICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKGxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pOyAvLyBwdXNoIHN0YXRlXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7IC8vIG5vcm1hbCBleGVjdXRpb24vbm8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIueXlsZW5nO1xuICAgICAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIueXlsaW5lbm87XG4gICAgICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY292ZXJpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIGp1c3Qgb2NjdXJyZWQsIHJlc3VtZSBvbGQgbG9va2FoZWFkIGYvIGJlZm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIC8vIHJlZHVjZVxuICAgICAgICAgICAgICAgIC8vdGhpcy5yZWR1Y3Rpb25Db3VudCsrO1xuXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcblxuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gc2VtYW50aWMgYWN0aW9uXG4gICAgICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoLWxlbl07IC8vIGRlZmF1bHQgdG8gJCQgPSAkMVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgbG9jYXRpb24sIHVzZXMgZmlyc3QgdG9rZW4gZm9yIGZpcnN0cywgbGFzdCBmb3IgbGFzdHNcbiAgICAgICAgICAgICAgICB5eXZhbC5fJCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGgtKGxlbnx8MSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGgtMV0ubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoLShsZW58fDEpXS5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aC0xXS5sYXN0X2NvbHVtblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgeXl2YWwuXyQucmFuZ2UgPSBbbHN0YWNrW2xzdGFjay5sZW5ndGgtKGxlbnx8MSldLnJhbmdlWzBdLCBsc3RhY2tbbHN0YWNrLmxlbmd0aC0xXS5yYW5nZVsxXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uYXBwbHkoeXl2YWwsIFt5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHNoYXJlZFN0YXRlLnl5LCBhY3Rpb25bMV0sIHZzdGFjaywgbHN0YWNrXS5jb25jYXQoYXJncykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwb3Agb2ZmIHN0YWNrXG4gICAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsLTEqbGVuKjIpO1xuICAgICAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEqbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xKmxlbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzBdKTsgICAgLy8gcHVzaCBub250ZXJtaW5hbCAocmVkdWNlKVxuICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xuICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTtcbiAgICAgICAgICAgICAgICAvLyBnb3RvIG5ldyBzdGF0ZSA9IHRhYmxlW1NUQVRFXVtOT05URVJNSU5BTF1cbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aC0yXV1bc3RhY2tbc3RhY2subGVuZ3RoLTFdXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIC8vIGFjY2VwdFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn19O1xuXG4vKiBnZW5lcmF0ZWQgYnkgamlzb24tbGV4IDAuMy40ICovXG52YXIgbGV4ZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBsZXhlciA9ICh7XG5cbkVPRjoxLFxuXG5wYXJzZUVycm9yOmZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICAgIGlmICh0aGlzLnl5LnBhcnNlcikge1xuICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuc2V0SW5wdXQ6ZnVuY3Rpb24gKGlucHV0LCB5eSkge1xuICAgICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2JhY2t0cmFjayA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IDAsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwwXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG5pbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG5cbi8vIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhIHN0cmluZykgaW50byB0aGUgaW5wdXRcbnVucHV0OmZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47XG4gICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgICAgdmFyIG9sZExpbmVzID0gdGhpcy5tYXRjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IHRoaXMueXlsbG9jLnJhbmdlO1xuXG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMClcbiAgICAgICAgICAgICAgICAgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgY2FjaGVzIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kcyBpdCBvbiBuZXh0IGFjdGlvblxubW9yZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgc2lnbmFscyB0aGUgbGV4ZXIgdGhhdCB0aGlzIHJ1bGUgZmFpbHMgdG8gbWF0Y2ggdGhlIGlucHV0LCBzbyB0aGUgbmV4dCBtYXRjaGluZyBydWxlIChyZWdleCkgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxucmVqZWN0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbmxlc3M6ZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5wYXN0SW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLic6JycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGUgbGV4aW5nIGVycm9yIG9jY3VycmVkLCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMgKyBcIl5cIjtcbiAgICB9LFxuXG4vLyB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW5cbnRlc3RfbWF0Y2g6ZnVuY3Rpb24gKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICBiYWNrdXA7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgY29udGV4dFxuICAgICAgICAgICAgYmFja3VwID0ge1xuICAgICAgICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHl5bGxvYzoge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgICAgICAgIG1hdGNoOiB0aGlzLm1hdGNoLFxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IHRoaXMubWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgICAgICAgeXlsZW5nOiB0aGlzLnl5bGVuZyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgICAgICAgIF9pbnB1dDogdGhpcy5faW5wdXQsXG4gICAgICAgICAgICAgICAgeXk6IHRoaXMueXksXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgICAgICAgZG9uZTogdGhpcy5kb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBiYWNrdXAueXlsbG9jLnJhbmdlID0gdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IG1hdGNoWzBdLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggLSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5tYXRjaCgvXFxyP1xcbj8vKVswXS5sZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIGluZGV4ZWRfcnVsZSwgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAvLyByZWNvdmVyIGNvbnRleHRcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYmFja3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIHRoZSBuZXh0IHJ1bGUgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxubmV4dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICB0ZW1wTWF0Y2gsXG4gICAgICAgICAgICBpbmRleDtcbiAgICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgICAgICB0aGlzLnl5dGV4dCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLnJ1bGVzW3J1bGVzW2ldXSk7XG4gICAgICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2godGVtcE1hdGNoLCBydWxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIGEgcnVsZSBNSVNtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFVucmVjb2duaXplZCB0ZXh0LlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW5cbmxleDpmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbmJlZ2luOmZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvbiBzdGFja1xucG9wU3RhdGU6ZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbMF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBwcm9kdWNlIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZVxuX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV0ucnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW1wiSU5JVElBTFwiXS5ydWxlcztcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXggYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLCBpZiBhdmFpbGFibGVcbnRvcFN0YXRlOmZ1bmN0aW9uIHRvcFN0YXRlKG4pIHtcbiAgICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7XG4gICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiSU5JVElBTFwiO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWxpYXMgZm9yIGJlZ2luKGNvbmRpdGlvbilcbnB1c2hTdGF0ZTpmdW5jdGlvbiBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFja1xuc3RhdGVTdGFja1NpemU6ZnVuY3Rpb24gc3RhdGVTdGFja1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aDtcbiAgICB9LFxub3B0aW9uczoge30sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXkseXlfLCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsWVlfU1RBUlQpIHtcbnZhciBZWVNUQVRFPVlZX1NUQVJUO1xuc3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcbmNhc2UgMDovKiDot7Pov4fnqbrnmb3nrKYgKi9cbmJyZWFrO1xuY2FzZSAxOnJldHVybiAyNTtcbmJyZWFrO1xuY2FzZSAyOnJldHVybiA4O1xuYnJlYWs7XG5jYXNlIDM6cmV0dXJuIDg7XG5icmVhaztcbmNhc2UgNDpyZXR1cm4gMjE7XG5icmVhaztcbmNhc2UgNTpyZXR1cm4gMjU7XG5icmVhaztcbmNhc2UgNjpyZXR1cm4gMjc7XG5icmVhaztcbmNhc2UgNzpyZXR1cm4gMjk7XG5icmVhaztcbmNhc2UgODpyZXR1cm4gMjk7XG5icmVhaztcbmNhc2UgOTpyZXR1cm4gMjg7XG5icmVhaztcbmNhc2UgMTA6cmV0dXJuIDIxO1xuYnJlYWs7XG5jYXNlIDExOnJldHVybiAzNDtcbmJyZWFrO1xuY2FzZSAxMjpyZXR1cm4gMzQ7XG5icmVhaztcbmNhc2UgMTM6cmV0dXJuIDM2O1xuYnJlYWs7XG5jYXNlIDE0OnJldHVybiAzMTtcbmJyZWFrO1xuY2FzZSAxNTpcbmJyZWFrO1xuY2FzZSAxNjpyZXR1cm4gOTtcbmJyZWFrO1xuY2FzZSAxNzpyZXR1cm4gJyAnO1xuYnJlYWs7XG5jYXNlIDE4OnJldHVybiAzNTtcbmJyZWFrO1xuY2FzZSAxOTpyZXR1cm4gMzA7XG5icmVhaztcbmNhc2UgMjA6cmV0dXJuIDMyO1xuYnJlYWs7XG5jYXNlIDIxOnJldHVybiAzMztcbmJyZWFrO1xuY2FzZSAyMjpyZXR1cm4gMTg7XG5icmVhaztcbmNhc2UgMjM6cmV0dXJuIDE5O1xuYnJlYWs7XG5jYXNlIDI0OnJldHVybiAxNztcbmJyZWFrO1xuY2FzZSAyNTpyZXR1cm4gMTE7XG5icmVhaztcbmNhc2UgMjY6cmV0dXJuIDIwO1xuYnJlYWs7XG5jYXNlIDI3OnJldHVybiAxMjtcbmJyZWFrO1xuY2FzZSAyODpyZXR1cm4gMTM7XG5icmVhaztcbmNhc2UgMjk6cmV0dXJuIDE1O1xuYnJlYWs7XG5jYXNlIDMwOnJldHVybiAxNDtcbmJyZWFrO1xuY2FzZSAzMTpyZXR1cm4gMTY7XG5icmVhaztcbmNhc2UgMzI6cmV0dXJuICdcIic7XG5icmVhaztcbmNhc2UgMzM6cmV0dXJuIFwiJ1wiO1xuYnJlYWs7XG5jYXNlIDM0OnJldHVybiBcIiFcIjtcbmJyZWFrO1xuY2FzZSAzNTpyZXR1cm4gMTA7XG5icmVhaztcbmNhc2UgMzY6cmV0dXJuIDM3O1xuYnJlYWs7XG5jYXNlIDM3OnJldHVybiAzODtcbmJyZWFrO1xuY2FzZSAzODpyZXR1cm4gNTtcbmJyZWFrO1xufVxufSxcbnJ1bGVzOiBbL14oPzpcXHMrKS8sL14oPzonKFteXFxcXC9cXD9cXCpcXFtcXF1cXCEnXCJdKyknKD89WyFdKSkvLC9eKD86XCIoXFxcXFtcIl18W15cIl0pKlwiKS8sL14oPzonKFxcXFxbJ118W14nXSkqJykvLC9eKD86W0EtWmEtel17MSx9W0EtWmEtel8wLTlcXC5dKyg/PVsoXSkpLywvXig/OlteXFxcXC9cXD9cXCpcXFtcXF0nXCJcXCEsXFwpXSsoPz1bIV0pKS8sL14oPzpcXCRbQS1aYS16XStcXCRbMC05XSspLywvXig/OlxcJFtBLVphLXpdK1swLTldKykvLC9eKD86W0EtWmEtel0rXFwkWzAtOV0rKS8sL14oPzpbQS1aYS16XStbMC05XSspLywvXig/OltBLVphLXpcXC5dKyg/PVsoXSkpLywvXig/OltBLVphLXpdezEsfVtBLVphLXpfMC05XSspLywvXig/OltBLVphLXpfXSspLywvXig/OlswLTldKykvLC9eKD86XFxbKC4qKT9cXF0pLywvXig/OlxcJCkvLC9eKD86JikvLC9eKD86ICkvLC9eKD86Wy5dKS8sL14oPzo6KS8sL14oPzo7KS8sL14oPzosKS8sL14oPzpcXCopLywvXig/OlxcLykvLC9eKD86LSkvLC9eKD86XFwrKS8sL14oPzpcXF4pLywvXig/OlxcKCkvLC9eKD86XFwpKS8sL14oPzo+KS8sL14oPzo8KS8sL14oPzpOT1RcXGIpLywvXig/OlwiKS8sL14oPzonKS8sL14oPzohKS8sL14oPzo9KS8sL14oPzolKS8sL14oPzpbI10pLywvXig/OiQpL10sXG5jb25kaXRpb25zOiB7XCJJTklUSUFMXCI6e1wicnVsZXNcIjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOF0sXCJpbmNsdXNpdmVcIjp0cnVlfX1cbn0pO1xucmV0dXJuIGxleGVyO1xufSkoKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuZnVuY3Rpb24gUGFyc2VyICgpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xucmV0dXJuIG5ldyBQYXJzZXI7XG59KSgpO1xuXG5leHBvcnQgdmFyIFBhcnNlciA9IGdyYW1tYXIuUGFyc2VyO1xuIiwiaW1wb3J0IHt0b051bWJlcn0gZnJvbSAnLi8uLi91dGlscyc7XG5pbXBvcnQge0VSUk9SX1ZBTFVFfSBmcm9tICcuLy4uL2Vycm9yJztcblxuZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICcrJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyhmaXJzdCwgLi4ucmVzdCkge1xuICBjb25zdCByZXN1bHQgPSByZXN0LnJlZHVjZSgoYWNjLCB2YWx1ZSkgPT4gYWNjICsgdG9OdW1iZXIodmFsdWUpLCB0b051bWJlcihmaXJzdCkpO1xuXG4gIGlmIChOdW1iZXIuaXNOYU4ocmVzdWx0KSkge1xuICAgIHRocm93IEVycm9yKEVSUk9SX1ZBTFVFKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImV4cG9ydCBjb25zdCBTWU1CT0wgPSAnJic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoLi4ucGFyYW1zKSB7XG4gIHJldHVybiBwYXJhbXMucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgKyB2YWx1ZS50b1N0cmluZygpLCAnJyk7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImltcG9ydCB7dG9OdW1iZXJ9IGZyb20gJy4vLi4vdXRpbHMnO1xuaW1wb3J0IHtFUlJPUl9ESVZfWkVSTywgRVJST1JfVkFMVUV9IGZyb20gJy4vLi4vZXJyb3InO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gJy8nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGZpcnN0LCAuLi5yZXN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlc3QucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgLyB0b051bWJlcih2YWx1ZSksIHRvTnVtYmVyKGZpcnN0KSk7XG5cbiAgaWYgKHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICB0aHJvdyBFcnJvcihFUlJPUl9ESVZfWkVSTyk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihyZXN1bHQpKSB7XG4gICAgdGhyb3cgRXJyb3IoRVJST1JfVkFMVUUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmMuU1lNQk9MID0gU1lNQk9MO1xuIiwiZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICc9JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyhleHAxLCBleHAyKSB7XG4gIHJldHVybiBleHAxID09PSBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCIvKipcbiAqIEV4Y2VsIOWFrOW8j+S4reeahOWHveaVsO+8jOeUsSBmb3JtdWxhanMg5a6e546w44CCXG4gKlxuICovXG5cbmltcG9ydCBTVVBQT1JURURfRk9STVVMQVMgZnJvbSAnLi8uLi9zdXBwb3J0ZWQtZm9ybXVsYXMnO1xuaW1wb3J0IHtFUlJPUl9OQU1FfSBmcm9tICcuLy4uL2Vycm9yJztcbmltcG9ydCAqIGFzIGZvcm11bGFqcyBmcm9tICdmb3JtdWxhanMnO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gU1VQUE9SVEVEX0ZPUk1VTEFTO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKHN5bWJvbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4ucGFyYW1zKSB7XG4gICAgICAgIHN5bWJvbCA9IHN5bWJvbC50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGNvbnN0IHN5bWJvbFBhcnRzID0gc3ltYm9sLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBmb3VuZEZvcm11bGEgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICBpZiAoc3ltYm9sUGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoZm9ybXVsYWpzW3N5bWJvbFBhcnRzWzBdXSkge1xuICAgICAgICAgICAgICAgIGZvdW5kRm9ybXVsYSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm9ybXVsYWpzW3N5bWJvbFBhcnRzWzBdXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gc3ltYm9sUGFydHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBuZXN0ZWRGb3JtdWxhID0gZm9ybXVsYWpzO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRGb3JtdWxhID0gbmVzdGVkRm9ybXVsYVtzeW1ib2xQYXJ0c1tpbmRleF1dO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5lc3RlZEZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkRm9ybXVsYSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXN0ZWRGb3JtdWxhKSB7XG4gICAgICAgICAgICAgICAgZm91bmRGb3JtdWxhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXN0ZWRGb3JtdWxhKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvdW5kRm9ybXVsYSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoRVJST1JfTkFNRSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5mdW5jLmlzRmFjdG9yeSA9IHRydWU7XG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImV4cG9ydCBjb25zdCBTWU1CT0wgPSAnPj0nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGV4cDEsIGV4cDIpIHtcbiAgcmV0dXJuIGV4cDEgPj0gZXhwMjtcbn07XG5cbmZ1bmMuU1lNQk9MID0gU1lNQk9MO1xuIiwiZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICc+JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyhleHAxLCBleHAyKSB7XG4gIHJldHVybiBleHAxID4gZXhwMjtcbn07XG5cbmZ1bmMuU1lNQk9MID0gU1lNQk9MO1xuIiwiZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICc8PSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoZXhwMSwgZXhwMikge1xuICByZXR1cm4gZXhwMSA8PSBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJleHBvcnQgY29uc3QgU1lNQk9MID0gJzwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGV4cDEsIGV4cDIpIHtcbiAgcmV0dXJuIGV4cDEgPCBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJpbXBvcnQge3RvTnVtYmVyfSBmcm9tICcuLy4uL3V0aWxzJztcbmltcG9ydCB7RVJST1JfVkFMVUV9IGZyb20gJy4vLi4vZXJyb3InO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gJy0nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGZpcnN0LCAuLi5yZXN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlc3QucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgLSB0b051bWJlcih2YWx1ZSksIHRvTnVtYmVyKGZpcnN0KSk7XG5cbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBFcnJvcihFUlJPUl9WQUxVRSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJpbXBvcnQge3RvTnVtYmVyfSBmcm9tICcuLy4uL3V0aWxzJztcbmltcG9ydCB7RVJST1JfVkFMVUV9IGZyb20gJy4vLi4vZXJyb3InO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gJyonO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGZpcnN0LCAuLi5yZXN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlc3QucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgKiB0b051bWJlcih2YWx1ZSksIHRvTnVtYmVyKGZpcnN0KSk7XG5cbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBFcnJvcihFUlJPUl9WQUxVRSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJleHBvcnQgY29uc3QgU1lNQk9MID0gJzw+JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyhleHAxLCBleHAyKSB7XG4gIHJldHVybiBleHAxICE9PSBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJpbXBvcnQge3RvTnVtYmVyfSBmcm9tICcuLy4uL3V0aWxzJztcbmltcG9ydCB7RVJST1JfVkFMVUV9IGZyb20gJy4vLi4vZXJyb3InO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gJ14nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGV4cDEsIGV4cDIpIHtcbiAgY29uc3QgcmVzdWx0ID0gTWF0aC5wb3codG9OdW1iZXIoZXhwMSksIHRvTnVtYmVyKGV4cDIpKTtcblxuICBpZiAoTnVtYmVyLmlzTmFOKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBFcnJvcihFUlJPUl9WQUxVRSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJpbXBvcnQge2RlZmF1bHQgYXMgYWRkfSBmcm9tICcuL29wZXJhdG9yL2FkZCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgYW1wZXJzYW5kfSBmcm9tICcuL29wZXJhdG9yL2FtcGVyc2FuZCc7XG4vLyBpbXBvcnQge2RlZmF1bHQgYXMgY3Jvc3NTaGVldH0gZnJvbSAnLi9vcGVyYXRvci9jcm9zcy1zaGVldCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgZGl2aWRlfSBmcm9tICcuL29wZXJhdG9yL2RpdmlkZSc7XG5pbXBvcnQge2RlZmF1bHQgYXMgZXF1YWx9IGZyb20gJy4vb3BlcmF0b3IvZXF1YWwnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGZvcm11bGFGdW5jdGlvbn0gZnJvbSAnLi9vcGVyYXRvci9mb3JtdWxhLWZ1bmN0aW9uJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBncmVhdGVyVGhhbn0gZnJvbSAnLi9vcGVyYXRvci9ncmVhdGVyLXRoYW4nO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGdyZWF0ZXJUaGFuT3JFcXVhbH0gZnJvbSAnLi9vcGVyYXRvci9ncmVhdGVyLXRoYW4tb3ItZXF1YWwnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGxlc3NUaGFufSBmcm9tICcuL29wZXJhdG9yL2xlc3MtdGhhbic7XG5pbXBvcnQge2RlZmF1bHQgYXMgbGVzc1RoYW5PckVxdWFsfSBmcm9tICcuL29wZXJhdG9yL2xlc3MtdGhhbi1vci1lcXVhbCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgbWludXN9IGZyb20gJy4vb3BlcmF0b3IvbWludXMnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIG11bHRpcGx5fSBmcm9tICcuL29wZXJhdG9yL211bHRpcGx5JztcbmltcG9ydCB7ZGVmYXVsdCBhcyBub3RFcXVhbH0gZnJvbSAnLi9vcGVyYXRvci9ub3QtZXF1YWwnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIHBvd2VyfSBmcm9tICcuL29wZXJhdG9yL3Bvd2VyJztcbmltcG9ydCB7RVJST1JfTkFNRX0gZnJvbSAnLi9lcnJvcic7XG5cbmNvbnN0IGF2YWlsYWJsZU9wZXJhdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnJlZ2lzdGVyT3BlcmF0aW9uKGFkZC5TWU1CT0wsIGFkZCk7XG5yZWdpc3Rlck9wZXJhdGlvbihhbXBlcnNhbmQuU1lNQk9MLCBhbXBlcnNhbmQpO1xuLy8gcmVnaXN0ZXJPcGVyYXRpb24oY3Jvc3NTaGVldC5TWU1CT0wsIGNyb3NzU2hlZXQpO1xucmVnaXN0ZXJPcGVyYXRpb24oZGl2aWRlLlNZTUJPTCwgZGl2aWRlKTtcbnJlZ2lzdGVyT3BlcmF0aW9uKGVxdWFsLlNZTUJPTCwgZXF1YWwpO1xucmVnaXN0ZXJPcGVyYXRpb24ocG93ZXIuU1lNQk9MLCBwb3dlcik7XG5yZWdpc3Rlck9wZXJhdGlvbihmb3JtdWxhRnVuY3Rpb24uU1lNQk9MLCBmb3JtdWxhRnVuY3Rpb24pO1xucmVnaXN0ZXJPcGVyYXRpb24oZ3JlYXRlclRoYW4uU1lNQk9MLCBncmVhdGVyVGhhbik7XG5yZWdpc3Rlck9wZXJhdGlvbihncmVhdGVyVGhhbk9yRXF1YWwuU1lNQk9MLCBncmVhdGVyVGhhbk9yRXF1YWwpO1xucmVnaXN0ZXJPcGVyYXRpb24obGVzc1RoYW4uU1lNQk9MLCBsZXNzVGhhbik7XG5yZWdpc3Rlck9wZXJhdGlvbihsZXNzVGhhbk9yRXF1YWwuU1lNQk9MLCBsZXNzVGhhbk9yRXF1YWwpO1xucmVnaXN0ZXJPcGVyYXRpb24obXVsdGlwbHkuU1lNQk9MLCBtdWx0aXBseSk7XG5yZWdpc3Rlck9wZXJhdGlvbihub3RFcXVhbC5TWU1CT0wsIG5vdEVxdWFsKTtcbnJlZ2lzdGVyT3BlcmF0aW9uKG1pbnVzLlNZTUJPTCwgbWludXMpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBldmFsdWF0ZUJ5T3BlcmF0b3Iob3BlcmF0b3IsIHBhcmFtcyA9IFtdKSB7XG4gICAgb3BlcmF0b3IgPSBvcGVyYXRvci50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKCFhdmFpbGFibGVPcGVyYXRvcnNbb3BlcmF0b3JdKSB7XG4gICAgICAgIHRocm93IEVycm9yKEVSUk9SX05BTUUpO1xuICAgIH1cbiAgICByZXR1cm4gYXZhaWxhYmxlT3BlcmF0b3JzW29wZXJhdG9yXSguLi5wYXJhbXMpO1xufVxuXG4vKipcbiAqIOazqOWGjFxuICogQHBhcmFtIHN5bWJvbFxuICogQHBhcmFtIGZ1bmNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyT3BlcmF0aW9uKHN5bWJvbCwgZnVuYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzeW1ib2wpKSB7XG4gICAgICAgIHN5bWJvbCA9IFtzeW1ib2wudG9VcHBlckNhc2UoKV07XG4gICAgfVxuICAgIHN5bWJvbC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIGlmIChmdW5jLmlzRmFjdG9yeSkge1xuICAgICAgICAgICAgYXZhaWxhYmxlT3BlcmF0b3JzW3NdID0gZnVuYyhzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF2YWlsYWJsZU9wZXJhdG9yc1tzXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsIi8qKlxuICog5YWs5byP6Kej5p6Q5Zmo44CCXG4gKiDlupXlsYLnmoTor63ms5Xop6PmnpDlmajkvb/nlKggamlzb24g55Sf5oiQ77yM5Y+C6KeBIGh0dHA6Ly96YWEuY2gvamlzb24vXG4gKlxuICog5rOo5oSPOiBqaXNvbiDnlJ/miJDnmoTku6PnoIHkvb/nlKggQU1EIOaWueW8j+WvvOWHuuWPmOmHj++8jOmHjeaWsOeUn+aIkOWQjuiusOW+l+aUueaIkCBFUzYg55qE5pa55byPOlxuICogICAgICBgZXhwb3J0IHZhciBQYXJzZXIgPSBncmFtbWFyLlBhcnNlcjtgXG4gKlxuICogQGNsYXNzIFBhcnNlclxuICogQGZpcmVzIFBhcnNlciNjYWxsVmFyaWFibGVcbiAqIEBmaXJlcyBQYXJzZXIjY2FsbENlbGxWYWx1ZVxuICogQGZpcmVzIFBhcnNlciNjYWxsUmFuZ2VWYWx1ZVxuICovXG5cbmltcG9ydCBFbWl0dGVyIGZyb20gJy4uLy4uLy4uL3V0aWxzL0VtaXR0ZXInO1xuaW1wb3J0IGV2YWx1YXRlQnlPcGVyYXRvciBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQge1BhcnNlciBhcyBHcmFtbWFyUGFyc2VyfSBmcm9tICcuL2dyYW1tYXInO1xuaW1wb3J0IHt0cmltRWRnZXMsIHRvTnVtYmVyLCBpbnZlcnROdW1iZXIsIGV4dHJhY3RMYWJlbCwgdG9MYWJlbH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2RlZmF1bHQgYXMgZXJyb3JQYXJzZXIsIEVSUk9SLCBFUlJPUl9OQU1FfSBmcm9tICcuL2Vycm9yJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTVVBQT1JURURfRk9STVVMQVN9IGZyb20gJy4vc3VwcG9ydGVkLWZvcm11bGFzJztcblxuY2xhc3MgUGFyc2VyIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IEdyYW1tYXJQYXJzZXIoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIueXkgPSB7XG4gICAgICAgICAgICB0b051bWJlcixcbiAgICAgICAgICAgIHRyaW1FZGdlcyxcbiAgICAgICAgICAgIGludmVydE51bWJlcixcbiAgICAgICAgICAgIHRocm93RXJyb3I6IChlcnJvck5hbWUpID0+IFBhcnNlci5fdGhyb3dFcnJvcihlcnJvck5hbWUpLFxuICAgICAgICAgICAgY2FsbFZhcmlhYmxlOiAodmFyaWFibGUpID0+IHRoaXMuX2NhbGxWYXJpYWJsZSh2YXJpYWJsZSksXG4gICAgICAgICAgICBldmFsdWF0ZUJ5T3BlcmF0b3IsXG4gICAgICAgICAgICBjYWxsRnVuY3Rpb246IGV2YWx1YXRlQnlPcGVyYXRvcixcbiAgICAgICAgICAgIGNlbGxWYWx1ZTogKHZhbHVlKSA9PiB0aGlzLl9jYWxsQ2VsbFZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgIHJhbmdlVmFsdWU6IChzdGFydCwgZW5kKSA9PiB0aGlzLl9jYWxsUmFuZ2VWYWx1ZShzdGFydCwgZW5kKSxcbiAgICAgICAgICAgIGNlbGxWYWx1ZUluU2hlZXQ6IChzaGVldE5hbWUsIHZhbHVlKSA9PiB0aGlzLl9jYWxsQ2VsbFZhbHVlSW5TaGVldChzaGVldE5hbWUsIHZhbHVlKSxcbiAgICAgICAgICAgIHJhbmdlVmFsdWVJblNoZWV0OiAoc2hlZXROYW1lLCBzdGFydCwgZW5kKSA9PiB0aGlzLl9jYWxsUmFuZ2VWYWx1ZUluU2hlZXQoc2hlZXROYW1lLCBzdGFydCwgZW5kKSxcbiAgICAgICAgICAgIHBhcnNlRXJyb3I6ICguLi5hcmdzKSA9PiBQYXJzZXIuX3BhcnNlRXJyb3IoLi4uYXJncylcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIHRoaXMuc2V0VmFyaWFibGUoJ1RSVUUnLCB0cnVlKVxuICAgICAgICAgICAgLnNldFZhcmlhYmxlKCdGQUxTRScsIGZhbHNlKVxuICAgICAgICAgICAgLnNldFZhcmlhYmxlKCdOVUxMJywgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6Kej5p6Q6KGo6L6+5byPXG4gICAgICogQHBhcmFtIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJucyB7e2Vycm9yOiAqLCByZXN1bHQ6ICp9fVxuICAgICAqL1xuICAgIHBhcnNlKGV4cHJlc3Npb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGxldCBlcnJvciA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VyLnBhcnNlKGV4cHJlc3Npb24pO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yUGFyc2VyKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyb3JQYXJzZXIoRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yUGFyc2VyKHJlc3VsdC5tZXNzYWdlKSB8fCBlcnJvclBhcnNlcihFUlJPUik7XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u5Y+Y6YePXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7UGFyc2VyfVxuICAgICAqL1xuICAgIHNldFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFyaWFibGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiwg+eUqOWPmOmHj+WAvFxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsbFZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRWYXJpYWJsZShuYW1lKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ2NhbGxWYXJpYWJsZScsIG5hbWUsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoRVJST1JfTkFNRSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6LCD55So5Y2V5YWD5qC855qE5YC8XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0g5L6L5aaCIGBCM2AsIGBCJDNgLCBgQiQzYCwgYCRCJDNgXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsbENlbGxWYWx1ZShsYWJlbCkge1xuICAgICAgICBjb25zdCBbcm93LCBjb2x1bW5dID0gZXh0cmFjdExhYmVsKGxhYmVsKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdm9pZCAwO1xuXG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbENlbGxWYWx1ZScsIHtsYWJlbCwgcm93LCBjb2x1bW59LCAoX3ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiwg+eUqOaMh+WumiBzaGVldCDkuK3ljZXlhYPmoLznmoTlgLxcbiAgICAgKiBAcGFyYW0gc2hlZXROYW1lXG4gICAgICogQHBhcmFtIGxhYmVsXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsbENlbGxWYWx1ZUluU2hlZXQoc2hlZXROYW1lLCBsYWJlbCkge1xuICAgICAgICBjb25zdCBbcm93LCBjb2x1bW5dID0gZXh0cmFjdExhYmVsKGxhYmVsKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdm9pZCAwO1xuXG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbENlbGxWYWx1ZUluU2hlZXQnLCB7c2hlZXROYW1lLCBsYWJlbCwgcm93LCBjb2x1bW59LCAoX3ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2V4cGxhaW5DZWxsKHN0YXJ0TGFiZWwsIGVuZExhYmVsKSB7XG4gICAgICAgIGNvbnN0IFtzdGFydFJvdywgc3RhcnRDb2x1bW5dID0gZXh0cmFjdExhYmVsKHN0YXJ0TGFiZWwpO1xuICAgICAgICBjb25zdCBbZW5kUm93LCBlbmRDb2x1bW5dID0gZXh0cmFjdExhYmVsKGVuZExhYmVsKTtcbiAgICAgICAgbGV0IHN0YXJ0Q2VsbCA9IHt9O1xuICAgICAgICBsZXQgZW5kQ2VsbCA9IHt9O1xuXG4gICAgICAgIGlmIChzdGFydFJvdy5pbmRleCA8PSBlbmRSb3cuaW5kZXgpIHtcbiAgICAgICAgICAgIHN0YXJ0Q2VsbC5yb3cgPSBzdGFydFJvdztcbiAgICAgICAgICAgIGVuZENlbGwucm93ID0gZW5kUm93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDZWxsLnJvdyA9IGVuZFJvdztcbiAgICAgICAgICAgIGVuZENlbGwucm93ID0gc3RhcnRSb3c7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRDb2x1bW4uaW5kZXggPD0gZW5kQ29sdW1uLmluZGV4KSB7XG4gICAgICAgICAgICBzdGFydENlbGwuY29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgICAgICBlbmRDZWxsLmNvbHVtbiA9IGVuZENvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0Q2VsbC5jb2x1bW4gPSBlbmRDb2x1bW47XG4gICAgICAgICAgICBlbmRDZWxsLmNvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRDZWxsLmxhYmVsID0gdG9MYWJlbChzdGFydENlbGwucm93LCBzdGFydENlbGwuY29sdW1uKTtcbiAgICAgICAgZW5kQ2VsbC5sYWJlbCA9IHRvTGFiZWwoZW5kQ2VsbC5yb3csIGVuZENlbGwuY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIHtzdGFydENlbGwsIGVuZENlbGx9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiwg+eUqOafkOiMg+WbtOeahOWNleWFg+agvOWAvO+8jOWmgiBgQjM6QTFgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0TGFiZWwgLSDotbflp4vmoIfnrb7vvIzlpoIgYEIzYFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRMYWJlbCAtIOe7k+adn+agh+etvu+8jOWmgiBgQTFgXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGxSYW5nZVZhbHVlKHN0YXJ0TGFiZWwsIGVuZExhYmVsKSB7XG4gICAgICAgIHZhciB7c3RhcnRDZWxsLCBlbmRDZWxsfSA9IFBhcnNlci5fZXhwbGFpbkNlbGwoc3RhcnRMYWJlbCwgZW5kTGFiZWwpO1xuICAgICAgICBsZXQgdmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5lbWl0KCdjYWxsUmFuZ2VWYWx1ZScsIHN0YXJ0Q2VsbCwgZW5kQ2VsbCwgKF92YWx1ZSA9IFtdKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDosIPnlKjmjIflrpogc2hlZXQg5Lit5p+Q6IyD5Zu055qE5Y2V5YWD5qC85YC877yM5aaCIGDlt6XkvZzooagxIUIzOkExYFxuICAgICAqIEBwYXJhbSBzaGVldE5hbWVcbiAgICAgKiBAcGFyYW0gc3RhcnRMYWJlbFxuICAgICAqIEBwYXJhbSBlbmRMYWJlbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxsUmFuZ2VWYWx1ZUluU2hlZXQoc2hlZXROYW1lLCBzdGFydExhYmVsLCBlbmRMYWJlbCkge1xuICAgICAgICB2YXIge3N0YXJ0Q2VsbCwgZW5kQ2VsbH0gPSBQYXJzZXIuX2V4cGxhaW5DZWxsKHN0YXJ0TGFiZWwsIGVuZExhYmVsKTtcbiAgICAgICAgbGV0IHZhbHVlID0gW107XG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbFJhbmdlVmFsdWVJblNoZWV0Jywgc2hlZXROYW1lLCBzdGFydENlbGwsIGVuZENlbGwsIChfdmFsdWUgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JOYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3Rocm93RXJyb3IoZXJyb3JOYW1lKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEVycm9yID0gZXJyb3JQYXJzZXIoZXJyb3JOYW1lKTtcbiAgICAgICAgaWYgKHBhcnNlZEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihwYXJzZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yTmFtZTtcbiAgICB9XG5cblxuICAgIC8vIFRPRE8g6Kej5p6Q5aSx6LSl5pe277yM57uZ55So5oi35o+Q5L6b5ZCI6YCC55qE6ZSZ6K+v5L+h5oGv44CCXG4gICAgc3RhdGljIF9wYXJzZUVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coYXJncyk7XG4gICAgfVxufVxuXG5leHBvcnQge1BhcnNlcn07XG4iLCJjb25zdCBTVVBQT1JURURfRk9STVVMQVMgPSBbXG4gICdBQlMnLFxuICAnQUNDUklOVCcsXG4gICdBQ09TJyxcbiAgJ0FDT1NIJyxcbiAgJ0FDT1QnLFxuICAnQUNPVEgnLFxuICAnQUREJyxcbiAgJ0FHR1JFR0FURScsXG4gICdBTkQnLFxuICAnQVJBQklDJyxcbiAgJ0FSR1MyQVJSQVknLFxuICAnQVNJTicsXG4gICdBU0lOSCcsXG4gICdBVEFOJyxcbiAgJ0FUQU4yJyxcbiAgJ0FUQU5IJyxcbiAgJ0FWRURFVicsXG4gICdBVkVSQUdFJyxcbiAgJ0FWRVJBR0VBJyxcbiAgJ0FWRVJBR0VJRicsXG4gICdBVkVSQUdFSUZTJyxcbiAgJ0JBU0UnLFxuICAnQkVTU0VMSScsXG4gICdCRVNTRUxKJyxcbiAgJ0JFU1NFTEsnLFxuICAnQkVTU0VMWScsXG4gICdCRVRBLkRJU1QnLFxuICAnQkVUQS5JTlYnLFxuICAnQkVUQURJU1QnLFxuICAnQkVUQUlOVicsXG4gICdCSU4yREVDJyxcbiAgJ0JJTjJIRVgnLFxuICAnQklOMk9DVCcsXG4gICdCSU5PTS5ESVNUJyxcbiAgJ0JJTk9NLkRJU1QuUkFOR0UnLFxuICAnQklOT00uSU5WJyxcbiAgJ0JJTk9NRElTVCcsXG4gICdCSVRBTkQnLFxuICAnQklUTFNISUZUJyxcbiAgJ0JJVE9SJyxcbiAgJ0JJVFJTSElGVCcsXG4gICdCSVRYT1InLFxuICAnQ0VJTElORycsXG4gICdDRUlMSU5HTUFUSCcsXG4gICdDRUlMSU5HUFJFQ0lTRScsXG4gICdDSEFSJyxcbiAgJ0NISVNRLkRJU1QnLFxuICAnQ0hJU1EuRElTVC5SVCcsXG4gICdDSElTUS5JTlYnLFxuICAnQ0hJU1EuSU5WLlJUJyxcbiAgJ0NIT09TRScsXG4gICdDSE9PU0UnLFxuICAnQ0xFQU4nLFxuICAnQ09ERScsXG4gICdDT0xVTU4nLFxuICAnQ09MVU1OUycsXG4gICdDT01CSU4nLFxuICAnQ09NQklOQScsXG4gICdDT01QTEVYJyxcbiAgJ0NPTkNBVEVOQVRFJyxcbiAgJ0NPTkZJREVOQ0UnLFxuICAnQ09ORklERU5DRS5OT1JNJyxcbiAgJ0NPTkZJREVOQ0UuVCcsXG4gICdDT05WRVJUJyxcbiAgJ0NPUlJFTCcsXG4gICdDT1MnLFxuICAnQ09TSCcsXG4gICdDT1QnLFxuICAnQ09USCcsXG4gICdDT1VOVCcsXG4gICdDT1VOVEEnLFxuICAnQ09VTlRCTEFOSycsXG4gICdDT1VOVElGJyxcbiAgJ0NPVU5USUZTJyxcbiAgJ0NPVU5USU4nLFxuICAnQ09VTlRVTklRVUUnLFxuICAnQ09WQVJJQU5DRS5QJyxcbiAgJ0NPVkFSSUFOQ0UuUycsXG4gICdDU0MnLFxuICAnQ1NDSCcsXG4gICdDVU1JUE1UJyxcbiAgJ0NVTVBSSU5DJyxcbiAgJ0RBVEUnLFxuICAnREFURVZBTFVFJyxcbiAgJ0RBWScsXG4gICdEQVlTJyxcbiAgJ0RBWVMzNjAnLFxuICAnREInLFxuICAnRERCJyxcbiAgJ0RFQzJCSU4nLFxuICAnREVDMkhFWCcsXG4gICdERUMyT0NUJyxcbiAgJ0RFQ0lNQUwnLFxuICAnREVHUkVFUycsXG4gICdERUxUQScsXG4gICdERVZTUScsXG4gICdESVZJREUnLFxuICAnRE9MTEFSJyxcbiAgJ0RPTExBUkRFJyxcbiAgJ0RPTExBUkZSJyxcbiAgJ0UnLFxuICAnRURBVEUnLFxuICAnRUZGRUNUJyxcbiAgJ0VPTU9OVEgnLFxuICAnRVEnLFxuICAnRVJGJyxcbiAgJ0VSRkMnLFxuICAnRVZFTicsXG4gICdFWEFDVCcsXG4gICdFWFBPTi5ESVNUJyxcbiAgJ0VYUE9ORElTVCcsXG4gICdGLkRJU1QnLFxuICAnRi5ESVNULlJUJyxcbiAgJ0YuSU5WJyxcbiAgJ0YuSU5WLlJUJyxcbiAgJ0ZBQ1QnLFxuICAnRkFDVERPVUJMRScsXG4gICdGQUxTRScsXG4gICdGRElTVCcsXG4gICdGRElTVFJUJyxcbiAgJ0ZJTkQnLFxuICAnRklOVicsXG4gICdGSU5WUlQnLFxuICAnRklTSEVSJyxcbiAgJ0ZJU0hFUklOVicsXG4gICdGSVhFRCcsXG4gICdGTEFUVEVOJyxcbiAgJ0ZMT09SJyxcbiAgJ0ZPUkVDQVNUJyxcbiAgJ0ZSRVFVRU5DWScsXG4gICdGVicsXG4gICdGVlNDSEVEVUxFJyxcbiAgJ0dBTU1BJyxcbiAgJ0dBTU1BLkRJU1QnLFxuICAnR0FNTUEuSU5WJyxcbiAgJ0dBTU1BRElTVCcsXG4gICdHQU1NQUlOVicsXG4gICdHQU1NQUxOJyxcbiAgJ0dBTU1BTE4uUFJFQ0lTRScsXG4gICdHQVVTUycsXG4gICdHQ0QnLFxuICAnR0VPTUVBTicsXG4gICdHRVNURVAnLFxuICAnR1JPV1RIJyxcbiAgJ0dURScsXG4gICdIQVJNRUFOJyxcbiAgJ0hFWDJCSU4nLFxuICAnSEVYMkRFQycsXG4gICdIRVgyT0NUJyxcbiAgJ0hPVVInLFxuICAnSFRNTDJURVhUJyxcbiAgJ0hZUEdFT00uRElTVCcsXG4gICdIWVBHRU9NRElTVCcsXG4gICdJRicsXG4gICdJTUFCUycsXG4gICdJTUFHSU5BUlknLFxuICAnSU1BUkdVTUVOVCcsXG4gICdJTUNPTkpVR0FURScsXG4gICdJTUNPUycsXG4gICdJTUNPU0gnLFxuICAnSU1DT1QnLFxuICAnSU1DU0MnLFxuICAnSU1DU0NIJyxcbiAgJ0lNRElWJyxcbiAgJ0lNRVhQJyxcbiAgJ0lNTE4nLFxuICAnSU1MT0cxMCcsXG4gICdJTUxPRzInLFxuICAnSU1QT1dFUicsXG4gICdJTVBST0RVQ1QnLFxuICAnSU1SRUFMJyxcbiAgJ0lNU0VDJyxcbiAgJ0lNU0VDSCcsXG4gICdJTVNJTicsXG4gICdJTVNJTkgnLFxuICAnSU1TUVJUJyxcbiAgJ0lNU1VCJyxcbiAgJ0lNU1VNJyxcbiAgJ0lNVEFOJyxcbiAgJ0lOVCcsXG4gICdJTlRFUkNFUFQnLFxuICAnSU5URVJWQUwnLFxuICAnSVBNVCcsXG4gICdJUlInLFxuICAnSVNCSU5BUlknLFxuICAnSVNCTEFOSycsXG4gICdJU0VWRU4nLFxuICAnSVNMT0dJQ0FMJyxcbiAgJ0lTTk9OVEVYVCcsXG4gICdJU05VTUJFUicsXG4gICdJU09ERCcsXG4gICdJU09ERCcsXG4gICdJU09XRUVLTlVNJyxcbiAgJ0lTUE1UJyxcbiAgJ0lTVEVYVCcsXG4gICdKT0lOJyxcbiAgJ0tVUlQnLFxuICAnTEFSR0UnLFxuICAnTENNJyxcbiAgJ0xFRlQnLFxuICAnTEVOJyxcbiAgJ0xJTkVTVCcsXG4gICdMTicsXG4gICdMT0cnLFxuICAnTE9HMTAnLFxuICAnTE9HRVNUJyxcbiAgJ0xPR05PUk0uRElTVCcsXG4gICdMT0dOT1JNLklOVicsXG4gICdMT0dOT1JNRElTVCcsXG4gICdMT0dOT1JNSU5WJyxcbiAgJ0xPV0VSJyxcbiAgJ0xUJyxcbiAgJ0xURScsXG4gICdNQVRDSCcsXG4gICdNQVgnLFxuICAnTUFYQScsXG4gICdNRURJQU4nLFxuICAnTUlEJyxcbiAgJ01JTicsXG4gICdNSU5BJyxcbiAgJ01JTlVTJyxcbiAgJ01JTlVURScsXG4gICdNSVJSJyxcbiAgJ01PRCcsXG4gICdNT0RFLk1VTFQnLFxuICAnTU9ERS5TTkdMJyxcbiAgJ01PREVNVUxUJyxcbiAgJ01PREVTTkdMJyxcbiAgJ01PTlRIJyxcbiAgJ01ST1VORCcsXG4gICdNVUxUSU5PTUlBTCcsXG4gICdNVUxUSVBMWScsXG4gICdORScsXG4gICdORUdCSU5PTS5ESVNUJyxcbiAgJ05FR0JJTk9NRElTVCcsXG4gICdORVRXT1JLREFZUycsXG4gICdOT01JTkFMJyxcbiAgJ05PUk0uRElTVCcsXG4gICdOT1JNLklOVicsXG4gICdOT1JNLlMuRElTVCcsXG4gICdOT1JNLlMuSU5WJyxcbiAgJ05PUk1ESVNUJyxcbiAgJ05PUk1JTlYnLFxuICAnTk9STVNESVNUJyxcbiAgJ05PUk1TSU5WJyxcbiAgJ05PVCcsXG4gICdOT1cnLFxuICAnTlBFUicsXG4gICdOUFYnLFxuICAnTlVNQkVSUycsXG4gICdOVU1FUkFMJyxcbiAgJ09DVDJCSU4nLFxuICAnT0NUMkRFQycsXG4gICdPQ1QySEVYJyxcbiAgJ09ERCcsXG4gICdPUicsXG4gICdQRFVSQVRJT04nLFxuICAnUEVBUlNPTicsXG4gICdQRVJDRU5USUxFRVhDJyxcbiAgJ1BFUkNFTlRJTEVJTkMnLFxuICAnUEVSQ0VOVFJBTktFWEMnLFxuICAnUEVSQ0VOVFJBTktJTkMnLFxuICAnUEVSTVVUJyxcbiAgJ1BFUk1VVEFUSU9OQScsXG4gICdQSEknLFxuICAnUEknLFxuICAnUE1UJyxcbiAgJ1BPSVNTT04uRElTVCcsXG4gICdQT0lTU09ORElTVCcsXG4gICdQT1cnLFxuICAnUE9XRVInLFxuICAnUFBNVCcsXG4gICdQUk9CJyxcbiAgJ1BST0RVQ1QnLFxuICAnUFJPUEVSJyxcbiAgJ1BWJyxcbiAgJ1FVQVJUSUxFLkVYQycsXG4gICdRVUFSVElMRS5JTkMnLFxuICAnUVVBUlRJTEVFWEMnLFxuICAnUVVBUlRJTEVJTkMnLFxuICAnUVVPVElFTlQnLFxuICAnUkFESUFOUycsXG4gICdSQU5EJyxcbiAgJ1JBTkRCRVRXRUVOJyxcbiAgJ1JBTksuQVZHJyxcbiAgJ1JBTksuRVEnLFxuICAnUkFOS0FWRycsXG4gICdSQU5LRVEnLFxuICAnUkFURScsXG4gICdSRUZFUkVOQ0UnLFxuICAnUkVHRVhFWFRSQUNUJyxcbiAgJ1JFR0VYTUFUQ0gnLFxuICAnUkVHRVhSRVBMQUNFJyxcbiAgJ1JFUExBQ0UnLFxuICAnUkVQVCcsXG4gICdSSUdIVCcsXG4gICdST01BTicsXG4gICdST1VORCcsXG4gICdST1VORERPV04nLFxuICAnUk9VTkRVUCcsXG4gICdST1cnLFxuICAnUk9XUycsXG4gICdSUkknLFxuICAnUlNRJyxcbiAgJ1NFQVJDSCcsXG4gICdTRUMnLFxuICAnU0VDSCcsXG4gICdTRUNPTkQnLFxuICAnU0VSSUVTU1VNJyxcbiAgJ1NJR04nLFxuICAnU0lOJyxcbiAgJ1NJTkgnLFxuICAnU0tFVycsXG4gICdTS0VXLlAnLFxuICAnU0tFV1AnLFxuICAnU0xOJyxcbiAgJ1NMT1BFJyxcbiAgJ1NNQUxMJyxcbiAgJ1NQTElUJyxcbiAgJ1NQTElUJyxcbiAgJ1NRUlQnLFxuICAnU1FSVFBJJyxcbiAgJ1NUQU5EQVJESVpFJyxcbiAgJ1NUREVWLlAnLFxuICAnU1RERVYuUycsXG4gICdTVERFVkEnLFxuICAnU1RERVZQJyxcbiAgJ1NUREVWUEEnLFxuICAnU1RERVZTJyxcbiAgJ1NURVlYJyxcbiAgJ1NVQlNUSVRVVEUnLFxuICAnU1VCVE9UQUwnLFxuICAnU1VNJyxcbiAgJ1NVTUlGJyxcbiAgJ1NVTUlGUycsXG4gICdTVU1QUk9EVUNUJyxcbiAgJ1NVTVNRJyxcbiAgJ1NVTVgyTVkyJyxcbiAgJ1NVTVgyUFkyJyxcbiAgJ1NVTVhNWTInLFxuICAnU1dJVENIJyxcbiAgJ1NZRCcsXG4gICdUJyxcbiAgJ1QuRElTVCcsXG4gICdULkRJU1QuMlQnLFxuICAnVC5ESVNULlJUJyxcbiAgJ1QuSU5WJyxcbiAgJ1QuSU5WLjJUJyxcbiAgJ1RBTicsXG4gICdUQU5IJyxcbiAgJ1RCSUxMRVEnLFxuICAnVEJJTExQUklDRScsXG4gICdUQklMTFlJRUxEJyxcbiAgJ1RESVNUJyxcbiAgJ1RESVNUMlQnLFxuICAnVERJU1RSVCcsXG4gICdURVhUJyxcbiAgJ1RJTUUnLFxuICAnVElNRVZBTFVFJyxcbiAgJ1RJTlYnLFxuICAnVElOVjJUJyxcbiAgJ1RPREFZJyxcbiAgJ1RSQU5TUE9TRScsXG4gICdUUkVORCcsXG4gICdUUklNJyxcbiAgJ1RSSU1NRUFOJyxcbiAgJ1RSVUUnLFxuICAnVFJVTkMnLFxuICAnVU5JQ0hBUicsXG4gICdVTklDT0RFJyxcbiAgJ1VOSVFVRScsXG4gICdVUFBFUicsXG4gICdWQUxVRScsXG4gICdWQVIuUCcsXG4gICdWQVIuUycsXG4gICdWQVJBJyxcbiAgJ1ZBUlAnLFxuICAnVkFSUEEnLFxuICAnVkFSUycsXG4gICdXRUVLREFZJyxcbiAgJ1dFRUtOVU0nLFxuICAnV0VJQlVMTC5ESVNUJyxcbiAgJ1dFSUJVTExESVNUJyxcbiAgJ1dPUktEQVknLFxuICAnWElSUicsXG4gICdYTlBWJyxcbiAgJ1hPUicsXG4gICdZRUFSJyxcbiAgJ1lFQVJGUkFDJ1xuXTtcblxuZXhwb3J0IHtTVVBQT1JURURfRk9STVVMQVMgYXMgZGVmYXVsdH07XG4iLCIvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKlxcXG4gKiAgICAgICAgICAgICAgICAgIOWNleWFg+agvOebuOWFs1xuICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbmNvbnN0IExBQkVMX0VYVFJBQ1RfUkVHRVhQID0gL14oWyRdKT8oW0EtWmEtel0rKShbJF0pPyhbMC05XSspJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0TGFiZWwobGFiZWwpIHtcbiAgICBpZiAoIUxBQkVMX0VYVFJBQ1RfUkVHRVhQLnRlc3QobGFiZWwpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgWywgY29sdW1uQWJzLCBjb2x1bW4sIHJvd0Ficywgcm93XSA9IGxhYmVsLm1hdGNoKExBQkVMX0VYVFJBQ1RfUkVHRVhQKTtcblxuICAgIHJldHVybiBbe1xuICAgICAgICBpbmRleDogcm93TGFiZWxUb0luZGV4KHJvdyksXG4gICAgICAgIGxhYmVsOiByb3csXG4gICAgICAgIGlzQWJzb2x1dGU6IHJvd0FicyA9PT0gJyQnXG4gICAgfSwge1xuICAgICAgICBpbmRleDogY29sdW1uTGFiZWxUb0luZGV4KGNvbHVtbiksXG4gICAgICAgIGxhYmVsOiBjb2x1bW4sXG4gICAgICAgIGlzQWJzb2x1dGU6IGNvbHVtbkFicyA9PT0gJyQnXG4gICAgfV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0xhYmVsKHJvdywgY29sdW1uKSB7XG4gICAgY29uc3Qgcm93TGFiZWwgPSAocm93LmlzQWJzb2x1dGUgPyAnJCcgOiAnJykgKyByb3dJbmRleFRvTGFiZWwocm93LmluZGV4KTtcbiAgICBjb25zdCBjb2x1bW5MYWJlbCA9IChjb2x1bW4uaXNBYnNvbHV0ZSA/ICckJyA6ICcnKSArIGNvbHVtbkluZGV4VG9MYWJlbChjb2x1bW4uaW5kZXgpO1xuICAgIHJldHVybiBjb2x1bW5MYWJlbCArIHJvd0xhYmVsO1xufVxuXG5jb25zdCBDT0xVTU5fTEFCRUxfQkFTRSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7XG5jb25zdCBDT0xVTU5fTEFCRUxfQkFTRV9MRU5HVEggPSBDT0xVTU5fTEFCRUxfQkFTRS5sZW5ndGg7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2x1bW5MYWJlbFRvSW5kZXgobGFiZWwpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxhYmVsLmxlbmd0aCAtIDE7IGkgPCBsYWJlbC5sZW5ndGg7IGkgKz0gMSwgaiAtPSAxKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5wb3coQ09MVU1OX0xBQkVMX0JBU0VfTEVOR1RILCBqKSAqIChDT0xVTU5fTEFCRUxfQkFTRS5pbmRleE9mKGxhYmVsW2ldKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC0tcmVzdWx0O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY29sdW1uSW5kZXhUb0xhYmVsKGNvbHVtbikge1xuICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgIHdoaWxlIChjb2x1bW4gPj0gMCkge1xuICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvbHVtbiAlIENPTFVNTl9MQUJFTF9CQVNFX0xFTkdUSCArIDk3KSArIHJlc3VsdDtcbiAgICAgICAgY29sdW1uID0gTWF0aC5mbG9vcihjb2x1bW4gLyBDT0xVTU5fTEFCRUxfQkFTRV9MRU5HVEgpIC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJvd0xhYmVsVG9JbmRleChsYWJlbCkge1xuICAgIGxldCByZXN1bHQgPSBwYXJzZUludChsYWJlbCwgMTApO1xuXG4gICAgaWYgKE51bWJlci5pc05hTihyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgubWF4KHJlc3VsdCAtIDEsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvd0luZGV4VG9MYWJlbChyb3cpIHtcbiAgICByZXR1cm4gcm93ID49IDAgPyBgJHtyb3cgKyAxfWAgOiAnJztcbn1cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKlxcXG4gKiAgICAgICAgICAgICAgICAgIG51bWJlclxuICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcihudW1iZXIpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSBudW1iZXI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbnVtYmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXN1bHQgPSBudW1iZXIuaW5kZXhPZignLicpID4gLTEgPyBwYXJzZUZsb2F0KG51bWJlcikgOiBwYXJzZUludChudW1iZXIsIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiDlj5botJ/mlbBcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnROdW1iZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIC0xICogdG9OdW1iZXIobnVtYmVyKTtcbn1cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKlxcXG4gKiAgICAgICAgICAgICAgICAgIHN0cmluZ1xuICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmltRWRnZXMoc3RyaW5nLCBtYXJnaW4gPSAxKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZyhtYXJnaW4sIHN0cmluZy5sZW5ndGggLSBtYXJnaW4pO1xuICAgIHJldHVybiBzdHJpbmc7XG59IiwiXG4vKipcbiAqIENoZWNrIGlmIHByb3ZpZGVkIGV4cHJlc3Npb24gaXMgdmFsaWQgZm9ybXVsYSBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7Kn0gZXhwcmVzc2lvbiBFeHByZXNzaW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Zvcm11bGFFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbiAmJiAoZXhwcmVzc2lvbiArICcnKS5jaGFyQXQoMCkgPT09ICc9JyA/IHRydWUgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBwcm92aWRlZCBmb3JtdWxhIGV4cHJlc3Npb24gaXMgZXNjYXBlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV4cHJlc3Npb24gRXhwcmVzc2lvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGb3JtdWxhRXhwcmVzc2lvbkVzY2FwZWQoZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uICYmICgoZXhwcmVzc2lvbiArICcnKS5jaGFyQXQoMCkgPT09ICdcXCcnICYmICgoZXhwcmVzc2lvbiArICcnKS5jaGFyQXQoMSkgPT09ICc9JykpID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgZXNjYXBlZCBmb3JtdWxhIGV4cHJlc3Npb24gaW50byB2YWxpZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb24gRXhwcmVzc2lvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlRm9ybXVsYUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBpc0Zvcm11bGFFeHByZXNzaW9uRXNjYXBlZChleHByZXNzaW9uKSA/IGV4cHJlc3Npb24uc3Vic3RyKDEpIDogZXhwcmVzc2lvbjtcbn1cblxuLyoqXG4gKiBVcHBlciBjYXNlIGZvcm11bGEgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBGb3JtdWxhIGV4cHJlc3Npb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VcHBlckNhc2VGb3JtdWxhKGV4cHJlc3Npb24pIHtcbiAgICBjb25zdCBQQVRURVJOID0gLyhcXFxcXCJ8XCIoPzpcXFxcXCJ8W15cIl0pKlwifChcXCspKXwoXFxcXCd8Jyg/OlxcXFwnfFteJ10pKid8KFxcKykpL2c7XG4gICAgY29uc3Qgc3RyaW5ncyA9IGV4cHJlc3Npb24ubWF0Y2goUEFUVEVSTikgfHwgW107XG4gICAgbGV0IGluZGV4ID0gLTE7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbi50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoUEFUVEVSTiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICsraW5kZXg7XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZ3NbaW5kZXhdO1xuICAgIH0pO1xufVxuIiwiLyoqXG4gKlxuICogQHBhcmFtIF9nIOWFqOWxgOWPmOmHj++8iOWNs+a1j+iniOWZqOeOr+Wig+S4i+eahCB3aW5kb3cg5a+56LGh77yJXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvbHlmaWxsKF9nKSB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZXM2IHBvbHlmaWxsXG5cbiAgICAvLyBOdW1iZXIuaXNOYU4oKVxuICAgIGlmICghX2cuTnVtYmVyLmlzTmFOKSB7XG4gICAgICAgIF9nLk51bWJlci5pc05hTiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCAhPT0geDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0cmluZy5jb250YWlucygpXG4gICAgaWYgKHR5cGVvZiBfZy5TdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZy5TdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuICEhfnRoaXMuaW5kZXhPZihzdHIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RyaW5nLnN0YXJ0c1dpdGgoKVxuICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKSB7XG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJzdHIocG9zaXRpb24sIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSUUgcG9seWZpbGxcblxuICAgIC8vIEhUTUxFbGVtZW50LmNsYXNzTGlzdFxuICAgIGlmICghKCdjbGFzc0xpc3QnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2NsYXNzTGlzdCcsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNlbGYuY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm4oY2xhc3NlcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhZGQ6IHVwZGF0ZShmdW5jdGlvbiAoY2xhc3NlcywgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIX5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZTogdXBkYXRlKGZ1bmN0aW9uIChjbGFzc2VzLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlOiB1cGRhdGUoZnVuY3Rpb24gKGNsYXNzZXMsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhfnNlbGYuY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jbGFzc05hbWUuc3BsaXQoL1xccysvZylbaV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5cblxuXG5cbiIsIi8qKlxuICog5YWo5bGA6YWN572u44CCXG4gKi9cbnZhciBnbG9iYWxTZXR0aW5ncyA9IHtcbiAgICBpZFByZWZpeDogJ2JyaWNrLXNzZC0nLFxuICAgIGlkU3VmZml4NFdvcmtib29rOiAnLXdvcmtib29rJyxcblxuICAgIHNoZWV0OiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWKqOeUn+aIkOW3peS9nOihqOWQjeensOaXtueahOWJjee8gCjlt6XkvZzooagxLCDlt6XkvZzooagyLi4uKVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1ByZWZpeDogJ+W3peS9nOihqCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNoZWV0IOWQjeensOS4reeahOmdnuazleWtl+espuOAguW+rui9r+ayoeacieebuOWFs+aWh+aho++8jOS7peS4i+aYryBBcGFjaGUgUE9JIOeahOivtOaYju+8mlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgc2hlZXQgbmFtZSBpbiBFeGNlbCBtdXN0IG5vdCBleGNlZWQgMzEgY2hhcmFjdGVyc1xuICAgICAgICAgKiBhbmQgbXVzdCBub3QgY29udGFpbiBhbnkgb2YgdGhlIGFueSBvZiB0aGUgZm9sbG93aW5nIGNoYXJhY3RlcnM6XG4gICAgICAgICAqICAgIC0gMHgwMDAwXG4gICAgICAgICAqICAgIC0gMHgwMDAzXG4gICAgICAgICAqICAgIC0gY29sb24gKDopXG4gICAgICAgICAqICAgIC0gYmFja3NsYXNoIChcXClcbiAgICAgICAgICogICAgLSBhc3RlcmlzayAoKilcbiAgICAgICAgICogICAgLSBxdWVzdGlvbiBtYXJrICg/KVxuICAgICAgICAgKiAgICAtIGZvcndhcmQgc2xhc2ggKC8pXG4gICAgICAgICAqICAgIC0gb3BlbmluZyBzcXVhcmUgYnJhY2tldCAoWylcbiAgICAgICAgICogICAgLSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IChdKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc2hlZXROYW1lOiAvW1xcXFwvXFw/XFwqOlxcW1xcXSdcIl0vLFxuXG4gICAgICAgIGFuaW1hdGVkOiBmYWxzZVxuICAgIH1cblxufTtcblxuXG4vKipcbiAqIOm7mOiupOmFjee9rlxuICovXG52YXIgZGVmYXVsdFNldHRpbmdzID0ge1xuXG4gICAgd29ya2Jvb2s6IHtcbiAgICAgICAgYWN0aXZlU2hlZXQ6ICflt6XkvZzooagxJyxcbiAgICAgICAgc2hlZXRzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ+W3peS9nOihqDEnXG4gICAgICAgIH1dXG4gICAgfSxcblxuICAgIHBlcnNpc3RlbnQ6IHRydWVcblxufTtcblxuZXhwb3J0IHtnbG9iYWxTZXR0aW5ncywgZGVmYXVsdFNldHRpbmdzfTsiLCIvKipcbiAqIOS6i+S7tuWPkeWwhOWZqFxuICpcbiAqIFBTOiBub2RlanMg55qE57O757uf57G75bqTIEVtaXR0ZXIg6L+H5aSn77yM5LiN6YCC5ZCI5Zyo5rWP6KeI5Zmo546v5aKD5L2/55So44CC5pWF5byV5YWl5LiA5Liq566A5piT5a6e546w44CCXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICAvLyDkv53mjIHmraTlh73mlbDkuLrnqbrvvIzku6Xkvr/kuo7nu6fmib9cbn1cblxuRW1pdHRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiDorqLpmIXkuovku7ZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOS6i+S7tuWQjVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0g5LqL5Lu25Zue6LCD5Ye95pWwXG4gICAgICogQHBhcmFtIFtjdHhdIC0g6K6+572u6LCD55SoIGNhbGxiYWNrIOaXtueahOS4iuS4i+aWh1xuICAgICAqIEByZXR1cm5zIHtFbWl0dGVyfVxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuZSB8fCAodGhpcy5lID0ge30pO1xuXG4gICAgICAgIChlW25hbWVdIHx8IChlW25hbWVdID0gW10pKS5wdXNoKHtcbiAgICAgICAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDorqLpmIXkuIDmrKHmgKfkuovku7ZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOS6i+S7tuWQjVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0g5LqL5Lu25Zue6LCD5Ye95pWwXG4gICAgICogQHBhcmFtIGN0eCAtIOiuvue9ruiwg+eUqCBjYWxsYmFjayDml7bnmoTkuIrkuIvmlodcbiAgICAgKiBAcmV0dXJucyB7KnxFbWl0dGVyfVxuICAgICAqL1xuICAgIG9uY2U6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHNlbGYub2ZmKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVyLl8gPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgbGlzdGVuZXIsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOWPkeWwhOaMh+WumuS6i+S7tlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCNXG4gICAgICogQHJldHVybnMge0VtaXR0ZXJ9XG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHZhciBldnRBcnIgPSAoKHRoaXMuZSB8fCAodGhpcy5lID0ge30pKVtuYW1lXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gZXZ0QXJyLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZXZ0QXJyW2ldLmZuLmFwcGx5KGV2dEFycltpXS5jdHgsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOazqOmUgOS6i+S7tlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCNXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSAtIOe7keWumuS6i+S7tuaXtueahOWbnuiwg+WHveaVsO+8jOWmguaenOS4jeaMh+WumuWImeazqOmUgOaJgOaciSBgbmFtZWAg5LqL5Lu2XG4gICAgICogQHJldHVybnMge0VtaXR0ZXJ9XG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcbiAgICAgICAgdmFyIGV2dHMgPSBlW25hbWVdO1xuICAgICAgICB2YXIgbGl2ZUV2ZW50cyA9IFtdO1xuXG4gICAgICAgIGlmIChldnRzICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChldnRzW2ldLmZuICE9PSBjYWxsYmFjayAmJiBldnRzW2ldLmZuLl8gIT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpdmVFdmVudHMucHVzaChldnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDpmLLmraLlhoXlrZjmuqLlh7pcbiAgICAgICAgKGxpdmVFdmVudHMubGVuZ3RoKVxuICAgICAgICAgICAgPyBlW25hbWVdID0gbGl2ZUV2ZW50c1xuICAgICAgICAgICAgOiBkZWxldGUgZVtuYW1lXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5YWo5bGA5ZSv5LiA5LqL5Lu25Y+R5bCE5ZmoXG4gICAgICovXG4gICAgZ2V0R2xvYmFsRW1pdHRlcjogIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBpbnN0YW5jZTtcbiAgICB9KCkpXG59O1xuXG5leHBvcnQgZGVmYXVsdCBFbWl0dGVyO1xuXG4vKipcbiAqIOWFqOWxgOWUr+S4gOS6i+S7tuWPkeWwhOWZqFxuICovXG5leHBvcnQgY29uc3QgR2xvYmFsRW1pdHRlciA9IEVtaXR0ZXIucHJvdG90eXBlLmdldEdsb2JhbEVtaXR0ZXIoKTsiLCJcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBvYmplY3RcblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIGV4dGVuc2lvbikge1xuICAgIG9iamVjdEVhY2goZXh0ZW5zaW9uLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RFYWNoKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmICghb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IChvYmplY3QuaGFzT3duUHJvcGVydHkgJiYgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0ZWUob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGZ1bmN0aW9uXG5cbnZhciBfZW1wdHlGbiA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbi8qKlxuICog6I635Y+W56m65Ye95pWw44CCXG4gKiBAcGFyYW0gbmV3T25lIOm7mOiupCBgZmFsc2Vg77yM5b2T5Li6IGB0cnVlYCDml7blsIbov5Tlm57kuIDkuKrmlrDnmoTnqbrlh73mlbDjgIJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24obmV3T25lID0gZmFsc2UpIHtcbiAgICBpZiAobmV3T25lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZW1wdHlGbjtcbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHN0cmluZ1xuXG5cbmV4cG9ydCBmdW5jdGlvbiB1cHBlckNhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1cHBlckNhc2VGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXFMvZywgZiA9PiB1cHBlckNhc2UoZikpO1xufVxuXG5cblxuXG4vKipcbiAqIOeUn+aIkOS4gOS4qumVv+W6puS4uiAxNiDnmoTpmo/mnLrlrZfnrKbkuLJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RyaW5nKCkge1xuICAgIGZ1bmN0aW9uIHM0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiBzNCgpICsgczQoKSArIHM0KCkgKyBzNCgpO1xufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gbWl4ZWRcblxuLyoqXG4gKiDliKTmlq3mmK/lkKbkuLpg56m6YOWAvOOAglxuICogUFPvvJrmraTmlrnms5XnmoTliKTmlq3pgLvovpHkvZzkuLrljZXlhYPmoLzmmK/lkKbkuLrnqbrnmoTkvp3mja7jgIJcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKTtcbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGNvb3JkaW5hdGVcblxuXG52YXIgY19pc0VxdWFsID0gZnVuY3Rpb24gKHIxLCByMikge1xuICAgIHJldHVybiByMVswXSA9PT0gcjJbMF0gJiYgcjFbMV0gPT09IHIyWzFdICYmIHIxWzJdID09PSByMlsyXSAmJiByMVszXSA9PT0gcjJbM107XG59O1xuXG52YXIgY19pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgdmFyIHgxID0gTWF0aC5tYXgocjFbMF0sIHIyWzBdKTtcbiAgICB2YXIgeTEgPSBNYXRoLm1heChyMVsxXSwgcjJbMV0pO1xuICAgIHZhciB4MiA9IE1hdGgubWluKHIxWzJdLCByMlsyXSk7XG4gICAgdmFyIHkyID0gTWF0aC5taW4ocjFbM10sIHIyWzNdKTtcblxuICAgIGlmICh4MSA8PSB4MiAmJiB5MSA8PSB5Mikge1xuICAgICAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGNfc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHIxLCByMikge1xuICAgICAgICB2YXIgaW5zID0gY19pbnRlcnNlY3Rpb24ocjEsIHIyKTtcbiAgICAgICAgaWYgKGlucykge1xuICAgICAgICAgICAgcmV0dXJuIGNfaXNFcXVhbChpbnMsIHQgPT09ICdzdWInID8gcjEgOiByMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59O1xuXG5leHBvcnQgdmFyIENvb3JkaW5hdGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiDliKTmlq3lnZDmoIfojIPlm7QgcjEg5piv5ZCm5LiOIHIyIOebuOetieOAglxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHIxXG4gICAgICogQHBhcmFtIHtpbnR9IHIxWzBdIC0g5Z2Q5qCH6IyD5Zu0IHIxIOeahOi1t+Wni+ihjOWdkOagh1xuICAgICAqIEBwYXJhbSB7aW50fSByMVsxXSAtIOWdkOagh+iMg+WbtCByMSDnmoTotbflp4vliJflnZDmoIdcbiAgICAgKiBAcGFyYW0ge2ludH0gcjFbMl0gLSDlnZDmoIfojIPlm7QgcjEg55qE57uI5q2i6KGM5Z2Q5qCHXG4gICAgICogQHBhcmFtIHtpbnR9IHIxWzNdIC0g5Z2Q5qCH6IyD5Zu0IHIxIOeahOe7iOatouWIl+WdkOagh1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHIyXG4gICAgICogQHBhcmFtIHtpbnR9IHIyWzBdIC0g5Z2Q5qCH6IyD5Zu0IHIyIOeahOi1t+Wni+ihjOWdkOagh1xuICAgICAqIEBwYXJhbSB7aW50fSByMlsxXSAtIOWdkOagh+iMg+WbtCByMiDnmoTotbflp4vliJflnZDmoIdcbiAgICAgKiBAcGFyYW0ge2ludH0gcjJbMl0gLSDlnZDmoIfojIPlm7QgcjIg55qE57uI5q2i6KGM5Z2Q5qCHXG4gICAgICogQHBhcmFtIHtpbnR9IHIyWzNdIC0g5Z2Q5qCH6IyD5Zu0IHIyIOeahOe7iOatouWIl+WdkOagh1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRXF1YWw6IGNfaXNFcXVhbCxcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreWdkOagh+iMg+WbtCByMSDmmK/lkKbkuI4gcjIg5a2Y5Zyo5Lqk6ZuG44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaW50ZXJzZWN0aW9uOiBjX2ludGVyc2VjdGlvbixcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreWdkOagh+iMg+WbtCByMSDmmK/lkKbmmK8gcjIg55qE5a2Q6ZuG44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdWJzZXQ6IGNfc2V0KCdzdWInKSxcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreWdkOagh+iMg+WbtCByMSDmmK/lkKbmmK8gcjIg55qE6LaF6ZuG44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdXBlcnNldDogY19zZXQoJ3N1cCcpXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIiwiaW1wb3J0IHt1cHBlckNhc2V9IGZyb20gJy4vY29tbW9uLmpzJ1xuXG4vKipcbiAqIOWkp+Wwj+WGmeS4jeaVj+aEn+eahCBNYXBcbiAqL1xuY2xhc3MgQ2FzZUluc2Vuc2l0aXZlTWFwIHtcblxuICAgIGNvbnN0cnVjdG9yKGl0ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoaXRlcmFibGUpO1xuICAgICAgICB0aGlzLl9rZXlzID0ge307XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICB2YXIgYWNLZXkgPSB0aGlzLl9rZXlzW3VwcGVyQ2FzZShrZXkpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoYWNLZXkpO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2tleXNbdXBwZXJDYXNlKGtleSldID0ga2V5O1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzW3VwcGVyQ2FzZShrZXkpXTtcbiAgICB9XG5cbiAgICBoYXNFeGFjdChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fa2V5cyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICB2YXIgYWNLZXkgPSB0aGlzLl9rZXlzW3VwcGVyQ2FzZShrZXkpXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2tleXNbdXBwZXJDYXNlKGtleSldO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmRlbGV0ZShhY0tleSk7XG4gICAgfVxuXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgfVxuXG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtJdGVyYXRvci48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgICB9XG5cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudmFsdWVzKCk7XG4gICAgfVxuXG4gICAgdG9NYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXA7XG4gICAgfVxuXG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFN0YWNrXG4gKi9cbmNsYXNzIFN0YWNrIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsID0gW10pIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGluaXRpYWw7XG4gICAgfVxuXG4gICAgcHVzaCguLi5pdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgfVxuXG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdm9pZCAwIDogdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5zaXplKCk7XG4gICAgfVxuXG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cblxufVxuXG5leHBvcnQge0Nhc2VJbnNlbnNpdGl2ZU1hcCwgU3RhY2t9O1xuXG4iLCJ2YXIgdGV4dENvbnRleHRTdXBwb3J0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3Rlc3QnKS50ZXh0Q29udGVudCA/IHRydWUgOiBmYWxzZTtcblxudmFyIFJFR19IVE1MX0NIQVJBQ1RFUlMgPSAvKDwoLiopPnwmKC4qKTspLztcblxuLyoqXG4gKiDog73lkIzml7blhbzlrrnmlofmnKzoioLngrnnmoQgaW5uZXJIVE1MIOaWueazleOAglxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5uZXJIVE1MKGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgICBpZiAoUkVHX0hUTUxfQ0hBUkFDVEVSUy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiBjaGlsZC5uZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRleHRDb250ZXh0U3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGF0YSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbXB0eShlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIOWcqOaMh+WumuiKgueCueWQjuaPkuWFpeiKgueCuVxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEBwYXJhbSBjb250ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRBZnRlcihlbGVtZW50LCBjb250ZW50KSB7XG4gICAgaWYgKFJFR19IVE1MX0NIQVJBQ1RFUlMudGVzdChjb250ZW50KSkge1xuICAgICAgICBlbGVtZW50Lmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJlbmQnLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29udGVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0O1xuICAgIGRvIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgKHJldCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiDmuIXnqbrmjIflrprlhYPntKDnmoTmiYDmnInlrZDoioLngrnjgIJcbiAqXG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbGVtZW50KSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCA9IGVsZW1lbnQubGFzdENoaWxkKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8g5pqC5pe26L+Z5qC35aSE55CGIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU1OTU2MVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIOi/lOWbnuaMh+WumuWFg+e0oOeahOWklumrmOW6pu+8iOWMheaLrCBwYWRkaW5n44CBYm9yZGVyIOWPiuWPr+mAieeahCBtYXJnaW4g5YC877yJ44CCXG4gKlxuICogQHBhcmFtIGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhNYXJnaW4gLSDpq5jluqbkuK3mmK/lkKbljIXmi6wgbWFyZ2luIOWAvFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dGVySGVpZ2h0KGVsLCB3aXRoTWFyZ2luID0gdHJ1ZSkge1xuICAgIHZhciBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIHN0eWxlO1xuXG4gICAgaWYgKHdpdGhNYXJnaW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICAgIHJldHVybiBoZWlnaHQ7XG59XG5cblxuLyoqXG4gKiDov5Tlm57mjIflrprlhYPntKDnmoTlpJblrr3luqbvvIjljIXmi6wgcGFkZGluZ+OAgWJvcmRlciDlj4rlj6/pgInnmoQgbWFyZ2luIOWAvO+8ieOAglxuICpcbiAqIEBwYXJhbSBlbFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoTWFyZ2luIC0g5a695bqm5Lit5piv5ZCm5YyF5ousIG1hcmdpbiDlgLxcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlcldpZHRoKGVsLCB3aXRoTWFyZ2luID0gdHJ1ZSkge1xuICAgIHZhciB3aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICAgIHZhciBzdHlsZTtcblxuICAgIGlmICh3aXRoTWFyZ2luID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgd2lkdGggKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCk7XG4gICAgcmV0dXJuIHdpZHRoO1xufVxuXG4iLCIvKipcbiAqIOmYu+atouWFtuWug+ebkeWQrOiiq+iwg+eUqOOAglxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihldmVudCkge1xuICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiDpmLvmraLkuovku7blhpLms6HjgIJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cbn0iLCJ2YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgZGVmaW5lR2V0dGVyID0gSGFuZHNvbnRhYmxlLmhlbHBlci5kZWZpbmVHZXR0ZXI7XG5cbmNvbnN0IE1JWElOX05BTUUgPSAnbG9jYWxIb29rcyc7XG5cbi8qKlxuICog55So5p2l5YGa5a+56LGh5o665ZKM55qEIGhvb2tzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IGxvY2FsSG9va3MgPSB7XG5cbiAgICBfbG9jYWxIb29rczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgIC8qKlxuICAgICAqIOWinuWKoCBob29rXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gaG9vayDlkI1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIOWbnuiwg1xuICAgICAqL1xuICAgIGFkZExvY2FsSG9vazogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEhvb2tzW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsSG9va3Nba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvY2FsSG9va3Nba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog5omn6KGMIGhvb2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gaG9vayDlkI1cbiAgICAgKiBAcGFyYW0geyp9IHBhcmFtc1xuICAgICAqL1xuICAgIHJ1bkxvY2FsSG9va3M6IGZ1bmN0aW9uIChrZXksIC4uLnBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxIb29rc1trZXldKSB7XG4gICAgICAgICAgICBhcnJheUVhY2godGhpcy5fbG9jYWxIb29rc1trZXldLCAoY2FsbGJhY2spID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa4heepuiBob29rc1xuICAgICAqL1xuICAgIGNsZWFyTG9jYWxIb29rczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2NhbEhvb2tzID0ge307XG4gICAgfVxufTtcblxuZGVmaW5lR2V0dGVyKGxvY2FsSG9va3MsICdNSVhJTl9OQU1FJywgTUlYSU5fTkFNRSwge1xuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGxvY2FsSG9va3M7Il19
